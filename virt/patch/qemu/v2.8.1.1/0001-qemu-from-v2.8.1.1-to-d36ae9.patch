diff --git a/.gitignore b/.gitignore
index 3d7848c..5920428 100644
--- a/.gitignore
+++ b/.gitignore
@@ -109,9 +109,11 @@
 /pc-bios/optionrom/kvmvapic.img
 /pc-bios/s390-ccw/s390-ccw.elf
 /pc-bios/s390-ccw/s390-ccw.img
+/tests/csky/ck803s-dsp/case/*.elf
 .stgit-*
 cscope.*
 tags
 TAGS
 docker-src.*
 *~
+/build
diff --git a/Makefile b/Makefile
index 474cc5e..e6d4caa 100644
--- a/Makefile
+++ b/Makefile
@@ -157,6 +157,7 @@ dummy := $(call unnest-vars,, \
                 qom-obj-y \
                 io-obj-y \
                 common-obj-y \
+                obj-m \
                 common-obj-m)
 
 ifneq ($(wildcard config-host.mak),)
diff --git a/Makefile.objs b/Makefile.objs
index 06f74b8..d05122e 100644
--- a/Makefile.objs
+++ b/Makefile.objs
@@ -18,6 +18,9 @@ block-obj-y += qemu-io-cmds.o
 block-obj-$(CONFIG_REPLICATION) += replication.o
 
 block-obj-m = block/
+common-obj-m = hw/char/
+obj-m = hw/csky/
+obj-m += hw/timer/
 
 #######################################################################
 # crypto-obj-y is code used by both qemu system emulation and qemu-img
diff --git a/Makefile.target b/Makefile.target
index 7a5080e..1be5ca2 100644
--- a/Makefile.target
+++ b/Makefile.target
@@ -180,6 +180,7 @@ dummy := $(call unnest-vars,.., \
                crypto-aes-obj-y \
                qom-obj-y \
                io-obj-y \
+               obj-m \
                common-obj-y \
                common-obj-m)
 target-obj-y := $(target-obj-y-save)
diff --git a/README b/README
index bd8060a..6eb0e9e 100644
--- a/README
+++ b/README
@@ -1,3 +1,31 @@
+C-SKY on QEMU
+===========
+这是以QEMU项目为基础，添加了C-SKY体系结构支持的项目。
+
+暂时以2.8版本为主，之后会支持更多版本。
+
+
+
+编译
+===========
+
+mkdir build
+../configure --target-list=cskyv2-softmmu
+make
+
+推荐编译环境
+===============
+
+ubuntu 16.04下执行下面的命令，获取完整开发环境
+
+sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev git-email \
+libaio-dev libbluetooth-dev libbrlapi-dev libbz2-dev libcap-dev libcap-ng-dev \
+libcurl4-gnutls-dev libgtk-3-dev libibverbs-dev libjpeg8-dev libncurses5-dev \
+libnuma-dev librbd-dev librdmacm-dev libsasl2-dev libsdl2-dev libseccomp-dev \
+libsnappy-dev libssh2-1-dev libvde-dev libvdeplug-dev liblzo2-dev xfslibs-dev
+
+
+===============================================
          QEMU README
          ===========
 
diff --git a/arch_init.c b/arch_init.c
index 5cc58b2..9165bf6 100644
--- a/arch_init.c
+++ b/arch_init.c
@@ -80,6 +80,8 @@ int graphic_depth = 32;
 #define QEMU_ARCH QEMU_ARCH_UNICORE32
 #elif defined(TARGET_TRICORE)
 #define QEMU_ARCH QEMU_ARCH_TRICORE
+#elif defined(TARGET_CSKY)
+#define QEMU_ARCH QEMU_ARCH_CSKY
 #endif
 
 const uint32_t arch_type = QEMU_ARCH;
diff --git a/configure b/configure
index 3770d7c..78ed419 100755
--- a/configure
+++ b/configure
@@ -322,6 +322,8 @@ numa=""
 tcmalloc="no"
 jemalloc="no"
 replication="yes"
+csky_dynsoc="no"
+csky_osver=""
 
 # parse CC options first
 for opt do
@@ -347,6 +349,8 @@ for opt do
   ;;
   --disable-debug-info) debug_info="no"
   ;;
+  --enable-dynsoc) csky_dynsoc="yes"
+  ;;
   esac
 done
 # OS specific
@@ -399,6 +403,10 @@ QEMU_CFLAGS="-Wall -Wundef -Wwrite-strings -Wmissing-prototypes $QEMU_CFLAGS"
 QEMU_CFLAGS="-Wstrict-prototypes -Wredundant-decls $QEMU_CFLAGS"
 QEMU_CFLAGS="-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE $QEMU_CFLAGS"
 QEMU_INCLUDES="-I. -I\$(SRC_PATH) -I\$(SRC_PATH)/include"
+if test "$csky_dynsoc" = "yes"; then
+    QEMU_CFLAGS="-I./\$(TARGET_DIRS)/ $QEMU_CFLAGS"
+fi
+
 if test "$debug_info" = "yes"; then
     CFLAGS="-g $CFLAGS"
     LDFLAGS="-g $LDFLAGS"
@@ -528,6 +536,12 @@ case "$cpu" in
   x86_64|amd64)
     cpu="x86_64"
   ;;
+  cskyv1)
+    cpu="cskyv1"
+  ;;
+  cskyv2)
+    cpu="cskyv2"
+  ;;
   armv*b|armv*l|arm)
     cpu="arm"
   ;;
@@ -545,6 +559,7 @@ case "$cpu" in
     ARCH=unknown
   ;;
 esac
+
 if test -z "$ARCH"; then
   ARCH="$cpu"
 fi
@@ -673,7 +688,11 @@ Haiku)
   LIBS="-lposix_error_mapper -lnetwork $LIBS"
 ;;
 *)
-  audio_drv_list="oss"
+  if [ "$cpu" = "cskyv1" -o "$cpu" = "cskyv2" ] ; then
+    audio_drv_list="alsa"
+  else
+    audio_drv_list="oss"
+  fi
   audio_possible_drivers="oss alsa sdl pa"
   linux="yes"
   linux_user="yes"
@@ -772,6 +791,8 @@ for opt do
   ;;
   --disable-debug-info)
   ;;
+  --enable-dynsoc)
+  ;;
   --enable-modules)
       modules="yes"
   ;;
@@ -1169,6 +1190,8 @@ for opt do
   ;;
   --enable-replication) replication="yes"
   ;;
+  --osver=*) csky_osver="$optarg"
+  ;;
   *)
       echo "ERROR: unknown option $opt"
       echo "Try '$0 --help' for more information"
@@ -2576,6 +2599,10 @@ EOF
   else
     sdl_libs=$($sdlconfig --libs 2>/dev/null)
   fi
+  if test "$mingw32" = "yes" ; then
+    sdl_libs="-lmingw32 -lSDLmain -lSDL -lmingw32 -lSDLmain -lSDL -liconv -lm -luser32 -lgdi32 -lwinmm -ldxguid"
+    echo $sdl_libs
+  fi
   if compile_prog "$sdl_cflags" "$sdl_libs" ; then
     if test $(echo $sdlversion | sed 's/[^0-9]//g') -lt 121 ; then
       sdl_too_old=yes
@@ -5164,7 +5191,7 @@ if test "$mingw32" = "yes" ; then
     echo "CONFIG_QGA_NTDDDISK=y" >> $config_host_mak
   fi
   if test "$guest_agent_msi" = "yes"; then
-    echo "QEMU_GA_MSI_ENABLED=yes" >> $config_host_mak  
+    echo "QEMU_GA_MSI_ENABLED=yes" >> $config_host_mak
     echo "QEMU_GA_MSI_MINGW_DLL_PATH=${QEMU_GA_MSI_MINGW_DLL_PATH}" >> $config_host_mak
     echo "QEMU_GA_MSI_WITH_VSS=${QEMU_GA_MSI_WITH_VSS}" >> $config_host_mak
     echo "QEMU_GA_MSI_ARCH=${QEMU_GA_MSI_ARCH}" >> $config_host_mak
@@ -5262,7 +5289,11 @@ fi
 if test "$modules" = "yes"; then
   # $shacmd can generate a hash started with digit, which the compiler doesn't
   # like as an symbol. So prefix it with an underscore
-  echo "CONFIG_STAMP=_$( (echo $qemu_version; echo $pkgversion; cat $0) | $shacmd - | cut -f1 -d\ )" >> $config_host_mak
+  if test "$csky_dynsoc" = "yes"; then
+    echo "CONFIG_STAMP=y" >> $config_host_mak
+  else
+    echo "CONFIG_STAMP=_$( (echo $qemu_version; echo $pkgversion; cat $0) | $shacmd - | cut -f1 -d\ )" >> $config_host_mak
+  fi
   echo "CONFIG_MODULES=y" >> $config_host_mak
 fi
 if test "$sdl" = "yes" ; then
@@ -5830,7 +5861,7 @@ target_name=$(echo $target | cut -d '-' -f 1)
 target_bigendian="no"
 
 case "$target_name" in
-  armeb|lm32|m68k|microblaze|mips|mipsn32|mips64|moxie|or32|ppc|ppcemb|ppc64|ppc64abi32|s390x|sh4eb|sparc|sparc64|sparc32plus|xtensaeb)
+  armeb|lm32|m68k|microblaze|mips|mipsn32|mips64|moxie|or32|ppc|ppcemb|ppc64|ppc64abi32|s390x|sh4eb|sparc|sparc64|sparc32plus|xtensaeb|cskyv1eb|cskyv2eb)
   target_bigendian=yes
   ;;
 esac
@@ -5891,6 +5922,24 @@ case "$target_name" in
     bflt="yes"
     gdb_xml_files="aarch64-core.xml aarch64-fpu.xml arm-core.xml arm-vfp.xml arm-vfp3.xml arm-neon.xml"
   ;;
+  cskyv1|cskyv1eb)
+    TARGET_ARCH=cskyv1
+    TARGET_BASE_ARCH=csky
+    TARGET_ABI_DIR=csky
+    bflt="yes"
+    echo "TARGET_CSKYV1=y" >> $config_target_mak
+    cskyversion="CSKY QEMU V2.8.01 Beta1 Build on `date +%Y%m%d`"
+    echo "CSKY_VERSION=$cskyversion" >> $config_host_mak
+  ;;
+  cskyv2|cskyv2eb)
+    TARGET_ARCH=cskyv2
+    TARGET_BASE_ARCH=csky
+    TARGET_ABI_DIR=csky
+    bflt="yes"
+    echo "TARGET_CSKYV2=y" >> $config_target_mak
+    cskyversion="CSKY QEMU V2.8.01 Beta1 Build on `date +%Y%m%d`"
+    echo "CSKY_VERSION=$cskyversion" >> $config_host_mak
+  ;;
   cris)
   ;;
   lm32)
@@ -6048,6 +6097,23 @@ fi
 if test "$target_linux_user" = "yes" ; then
   echo "CONFIG_LINUX_USER=y" >> $config_target_mak
 fi
+case "$csky_osver" in
+  4*)
+    if test "$target_linux_user" = "yes" -a "$TARGET_BASE_ARCH" = "csky" ; then
+      echo "CONFIG_CSKY_KERNEL_4X=y" >> $config_target_mak
+    fi
+    ;;
+  3*)
+    if test "$target_linux_user" = "yes" -a "$TARGET_BASE_ARCH" = "csky" ; then
+      echo "CONFIG_CSKY_KERNEL_3X=y" >> $config_target_mak
+    fi
+    ;;
+  *)
+    if test "$target_linux_user" = "yes" -a "$TARGET_BASE_ARCH" = "csky" ; then
+      echo "CONFIG_CSKY_KERNEL_4X=y" >> $config_target_mak
+    fi
+esac
+
 list=""
 if test ! -z "$gdb_xml_files" ; then
   for x in $gdb_xml_files; do
@@ -6089,6 +6155,9 @@ for i in $ARCH $TARGET_BASE_ARCH ; do
       disas_config "ARM_A64"
     fi
   ;;
+  csky)
+    disas_config "CSKY"
+  ;;
   cris)
     disas_config "CRIS"
   ;;
diff --git a/default-configs/arm-softmmu.mak b/default-configs/arm-softmmu.mak
index 6de3e16..f0f94a7 100644
--- a/default-configs/arm-softmmu.mak
+++ b/default-configs/arm-softmmu.mak
@@ -115,3 +115,6 @@ CONFIG_ACPI=y
 CONFIG_SMBIOS=y
 CONFIG_ASPEED_SOC=y
 CONFIG_GPIO_KEY=y
+
+CONFIG_CSKY_EXIT=y
+CONFIG_CSKY_UART=y
diff --git a/default-configs/cskyv1-linux-user.mak b/default-configs/cskyv1-linux-user.mak
new file mode 100644
index 0000000..0c16d8a
--- /dev/null
+++ b/default-configs/cskyv1-linux-user.mak
@@ -0,0 +1,3 @@
+# Default configuration for csky-linux-user
+
+CONFIG_CSKY_KERNEL_4X=y
diff --git a/default-configs/cskyv1-softmmu.mak b/default-configs/cskyv1-softmmu.mak
new file mode 100644
index 0000000..202c3a4
--- /dev/null
+++ b/default-configs/cskyv1-softmmu.mak
@@ -0,0 +1,23 @@
+#Default configuration for cskyv1-softmmu
+
+CONFIG_CSKY_MAC=y
+CONFIG_CSKY_MAC2=y
+CONFIG_SERIAL=y
+CONFIG_PTIMER=y
+CONFIG_PCKBD=y
+CONFIG_NAND=y
+CONFIG_FRAMEBUFFER=y
+CONFIG_SD=y
+CONFIG_CSKY_IIS=y
+CONFIG_CSKY_NFC=y
+CONFIG_CSKY_UART=y
+CONFIG_CSKY_LCDC=y
+CONFIG_CSKY_DMA=y
+CONFIG_CSKY_INTC=y
+CONFIG_CSKY_TCIP=y
+CONFIG_CSKY_EXIT=y
+CONFIG_CSKY_MEMLOG=y
+CONFIG_CSKY_SDHC=y
+CONFIG_CSKY_TIMER=y
+CONFIG_SMARTL=y
+CONFIG_SMARTH=y
diff --git a/default-configs/cskyv1eb-linux-user.mak b/default-configs/cskyv1eb-linux-user.mak
new file mode 100644
index 0000000..0c16d8a
--- /dev/null
+++ b/default-configs/cskyv1eb-linux-user.mak
@@ -0,0 +1,3 @@
+# Default configuration for csky-linux-user
+
+CONFIG_CSKY_KERNEL_4X=y
diff --git a/default-configs/cskyv1eb-softmmu.mak b/default-configs/cskyv1eb-softmmu.mak
new file mode 100644
index 0000000..fe31962
--- /dev/null
+++ b/default-configs/cskyv1eb-softmmu.mak
@@ -0,0 +1,23 @@
+#Default configuration for cskyv1eb-softmmu
+
+CONFIG_CSKY_MAC=y
+CONFIG_CSKY_MAC2=y
+CONFIG_SERIAL=y
+CONFIG_PTIMER=y
+CONFIG_PCKBD=y
+CONFIG_NAND=y
+CONFIG_FRAMEBUFFER=y
+CONFIG_SD=y
+CONFIG_CSKY_IIS=y
+CONFIG_CSKY_NFC=y
+CONFIG_CSKY_UART=y
+CONFIG_CSKY_LCDC=y
+CONFIG_CSKY_DMA=y
+CONFIG_CSKY_INTC=y
+CONFIG_CSKY_TCIP=y
+CONFIG_CSKY_EXIT=y
+CONFIG_CSKY_MEMLOG=y
+CONFIG_CSKY_SDHC=y
+CONFIG_CSKY_TIMER=y
+CONFIG_SMARTL=y
+CONFIG_SMARTH=y
diff --git a/default-configs/cskyv2-linux-user.mak b/default-configs/cskyv2-linux-user.mak
new file mode 100644
index 0000000..0c16d8a
--- /dev/null
+++ b/default-configs/cskyv2-linux-user.mak
@@ -0,0 +1,3 @@
+# Default configuration for csky-linux-user
+
+CONFIG_CSKY_KERNEL_4X=y
diff --git a/default-configs/cskyv2-softmmu.mak b/default-configs/cskyv2-softmmu.mak
new file mode 100644
index 0000000..e7e700b
--- /dev/null
+++ b/default-configs/cskyv2-softmmu.mak
@@ -0,0 +1,24 @@
+#Default configuration for cskyv2-softmmu
+
+CONFIG_CSKY_MAC=y
+CONFIG_CSKY_MAC2=y
+CONFIG_SERIAL=y
+CONFIG_PTIMER=y
+CONFIG_PCKBD=y
+CONFIG_NAND=y
+CONFIG_FRAMEBUFFER=y
+CONFIG_SD=y
+CONFIG_CSKY_IIS=y
+CONFIG_CSKY_NFC=y
+CONFIG_CSKY_UART=y
+CONFIG_CSKY_LCDC=y
+CONFIG_CSKY_DMA=y
+CONFIG_CSKY_INTC=y
+CONFIG_CSKY_TCIP=y
+CONFIG_CSKY_EXIT=y
+CONFIG_CSKY_MEMLOG=y
+CONFIG_CSKY_SDHC=y
+CONFIG_CSKY_TIMER=y
+CONFIG_SMARTL=y
+CONFIG_SMARTH=y
+CONFIG_SMART_CARD=y
diff --git a/default-configs/cskyv2eb-linux-user.mak b/default-configs/cskyv2eb-linux-user.mak
new file mode 100644
index 0000000..0c16d8a
--- /dev/null
+++ b/default-configs/cskyv2eb-linux-user.mak
@@ -0,0 +1,3 @@
+# Default configuration for csky-linux-user
+
+CONFIG_CSKY_KERNEL_4X=y
diff --git a/default-configs/cskyv2eb-softmmu.mak b/default-configs/cskyv2eb-softmmu.mak
new file mode 100644
index 0000000..82e5f73
--- /dev/null
+++ b/default-configs/cskyv2eb-softmmu.mak
@@ -0,0 +1,23 @@
+#Default configuration for cskyv2eb-softmmu
+
+CONFIG_CSKY_MAC=y
+CONFIG_CSKY_MAC2=y
+CONFIG_SERIAL=y
+CONFIG_PTIMER=y
+CONFIG_PCKBD=y
+CONFIG_NAND=y
+CONFIG_FRAMEBUFFER=y
+CONFIG_SD=y
+CONFIG_CSKY_IIS=y
+CONFIG_CSKY_NFC=y
+CONFIG_CSKY_UART=y
+CONFIG_CSKY_LCDC=y
+CONFIG_CSKY_DMA=y
+CONFIG_CSKY_INTC=y
+CONFIG_CSKY_TCIP=y
+CONFIG_CSKY_EXIT=y
+CONFIG_CSKY_MEMLOG=y
+CONFIG_CSKY_SDHC=y
+CONFIG_CSKY_TIMER=y
+CONFIG_SMARTL=y
+CONFIG_SMARTH=y
diff --git a/disas.c b/disas.c
index 67f116a..b7fd4fb 100644
--- a/disas.c
+++ b/disas.c
@@ -87,61 +87,6 @@ generic_symbol_at_address (bfd_vma addr, struct disassemble_info *info)
   return 1;
 }
 
-bfd_vma bfd_getl64 (const bfd_byte *addr)
-{
-  unsigned long long v;
-
-  v = (unsigned long long) addr[0];
-  v |= (unsigned long long) addr[1] << 8;
-  v |= (unsigned long long) addr[2] << 16;
-  v |= (unsigned long long) addr[3] << 24;
-  v |= (unsigned long long) addr[4] << 32;
-  v |= (unsigned long long) addr[5] << 40;
-  v |= (unsigned long long) addr[6] << 48;
-  v |= (unsigned long long) addr[7] << 56;
-  return (bfd_vma) v;
-}
-
-bfd_vma bfd_getl32 (const bfd_byte *addr)
-{
-  unsigned long v;
-
-  v = (unsigned long) addr[0];
-  v |= (unsigned long) addr[1] << 8;
-  v |= (unsigned long) addr[2] << 16;
-  v |= (unsigned long) addr[3] << 24;
-  return (bfd_vma) v;
-}
-
-bfd_vma bfd_getb32 (const bfd_byte *addr)
-{
-  unsigned long v;
-
-  v = (unsigned long) addr[0] << 24;
-  v |= (unsigned long) addr[1] << 16;
-  v |= (unsigned long) addr[2] << 8;
-  v |= (unsigned long) addr[3];
-  return (bfd_vma) v;
-}
-
-bfd_vma bfd_getl16 (const bfd_byte *addr)
-{
-  unsigned long v;
-
-  v = (unsigned long) addr[0];
-  v |= (unsigned long) addr[1] << 8;
-  return (bfd_vma) v;
-}
-
-bfd_vma bfd_getb16 (const bfd_byte *addr)
-{
-  unsigned long v;
-
-  v = (unsigned long) addr[0] << 24;
-  v |= (unsigned long) addr[1] << 16;
-  return (bfd_vma) v;
-}
-
 static int print_insn_objdump(bfd_vma pc, disassemble_info *info,
                               const char *prefix)
 {
@@ -213,6 +158,12 @@ void target_disas(FILE *out, CPUState *cpu, target_ulong code,
         s.info.mach = bfd_mach_i386_i386;
     }
     s.info.print_insn = print_insn_i386;
+#elif defined(TARGET_CSKYV1)
+    s.info.mach = bfd_mach_csky_v1;
+    s.info.print_insn = print_insn_csky_v1;
+#elif defined(TARGET_CSKYV2)
+    s.info.mach = bfd_mach_csky_v2;
+    s.info.print_insn = print_insn_csky_v2;
 #elif defined(TARGET_PPC)
     if ((flags >> 16) & 1) {
         s.info.endian = BFD_ENDIAN_LITTLE;
@@ -302,6 +253,10 @@ void disas(FILE *out, void *code, unsigned long size)
     s.info.mach = bfd_mach_sparc_v9b;
 #elif defined(__arm__)
     print_insn = print_insn_arm;
+#elif defined(__cskyv1__)
+    print_insn = print_insn_csky_v1;
+#elif defined(__cskyv2__)
+    print_insn = print_insn_csky_v2;
 #elif defined(__MIPSEB__)
     print_insn = print_insn_big_mips;
 #elif defined(__MIPSEL__)
diff --git a/disas/Makefile.objs b/disas/Makefile.objs
index 09bc992..e07358e 100644
--- a/disas/Makefile.objs
+++ b/disas/Makefile.objs
@@ -9,6 +9,9 @@ libvixldir = $(SRC_PATH)/disas/libvixl
 # versions do not.
 arm-a64.o-cflags := -I$(libvixldir) -Wno-sign-compare
 common-obj-$(CONFIG_CRIS_DIS) += cris.o
+
+common-obj-$(CONFIG_CSKY_DIS) += csky.o
+
 common-obj-$(CONFIG_I386_DIS) += i386.o
 common-obj-$(CONFIG_IA64_DIS) += ia64.o
 common-obj-$(CONFIG_M68K_DIS) += m68k.o
diff --git a/disas/csky.c b/disas/csky.c
new file mode 100644
index 0000000..b76a62b
--- /dev/null
+++ b/disas/csky.c
@@ -0,0 +1,2542 @@
+/*
+ * Disassemble C-SKY instructions
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "disas/bfd.h"
+
+/* sourced by binutils-2.20/bfd/bfd-in2.h */
+/* architecture */
+#define M_CK510   (1 << 0)
+#define M_CK610   (1 << 1)
+#define M_CK803   (1 << 2)
+#define M_CK810   (1 << 3)
+/* module */
+#define M_DSP     (1 << 14)
+#define M_MAC     (1 << 15)  /* security */
+#define M_FLOAT   (1 << 16)
+#define M_SIMD    (1 << 17)
+#define M_CP      (1 << 18)
+#define M_MP      (1 << 19)
+#define M_CACHE   (1 << 20)
+
+#define bfd_mach_ck510     (M_CK510)
+#define bfd_mach_ck510e    (bfd_mach_ck510 | M_DSP)
+#define bfd_mach_ck520     (bfd_mach_ck510 | M_MAC)
+#define bfd_mach_ck610     (M_CK610)
+#define bfd_mach_ck610e    (bfd_mach_ck610 | M_DSP)
+#define bfd_mach_ck610f    (bfd_mach_ck610 | M_FLOAT)
+#define bfd_mach_ck610ef   (bfd_mach_ck610 | M_DSP | M_FLOAT)
+
+#define bfd_mach_ck803     (M_CK803)
+#define bfd_mach_ck803e    (M_CK803 | M_DSP)
+#define bfd_mach_ck810     (M_CK810)
+#define bfd_mach_ck810e    (M_CK810 | M_DSP)
+#define bfd_mach_ck810f    (M_CK810 | M_FLOAT)
+#define bfd_mach_ck810ef   (M_CK810 | M_SIMD | M_FLOAT)
+
+/*
+ * CKCORE Instruction Class
+ */
+typedef enum {
+    O0,    OT,   O1,   OC,   O2,    X1,    OI,    OB,
+    OMa,   SI,   I7,   LS,   BR,    BL,    LR,    LJ,
+    RM,    RQ,   JSR,  JMP,  OBRa,  OBRb,  OBRc,  OBR2,
+    O1R1,  OMb,  OMc,  SIa,
+    MULSH, OPSR,
+    O1_CP, O2_CPGR, O2_CPCR,
+    O_KWGJ1, O_KWGJ2, /* For CAA */
+    JC,    JU,   JL,   RSI,  DO21,  OB2,
+    O1_E2, O1_E, O2_E, OI_E, OB_E, O1R1_E, SIa_E
+} ckcore_opclass;
+
+/*
+ * CKCORE instruction information & opcode.
+ */
+typedef struct inst {
+    const char *name;
+    /* the instruction class */
+    ckcore_opclass  opclass;
+    unsigned char  transfer;
+    /* The instruction opcode */
+    unsigned short inst;
+    /*
+     * One bit cpu_flags for the opcode.  These are used to indicate which
+     * specific processors support the instructions.  The values are the
+     * same as those for the struct powerpc_opcode flags field.
+     */
+    unsigned long cpu_flag;
+} ckcore_opcode_info;
+
+
+static ckcore_opcode_info ckcore_table[] = {
+    { "bkpt",  O0, 0, 0x0000, M_CK510 | M_CK610 },
+    { "sync",  O0, 0, 0x0001, M_CK510 | M_CK610 },
+    { "rte",   O0, 2, 0x0002, M_CK510 | M_CK610 },
+    { "rfe",   O0, 2, 0x0002, M_CK510 | M_CK610 },
+    { "rfi",   O0, 2, 0x0003, M_CK510 | M_CK610 },
+    { "stop",  O0, 0, 0x0004, M_CK510 | M_CK610 },
+    { "wait",  O0, 0, 0x0005, M_CK510 | M_CK610 },
+    { "doze",  O0, 0, 0x0006, M_CK510 | M_CK610 },
+    { "idly4", O0, 0, 0x0007, M_CK510 | M_CK610 },
+    { "trap",  OT, 0, 0x0008, M_CK510 | M_CK610 },
+    /* DSP/Coprocessor */
+    { "mvtc", O0, 0, 0x000C, M_DSP },
+    { "cprc", O0,   0, 0x000D, M_CK610 | M_CP },
+    /* SPACE:        0x000E - 0x000F */
+    { "cpseti", O1_CP, 0, 0x0010, M_CK610 | M_CP },
+    { "mvc",  O1, 0, 0x0020, M_CK510 | M_CK610 },
+    { "mvcv", O1, 0, 0x0030, M_CK510 | M_CK610 },
+    { "ldq",  RQ, 0, 0x0040, M_CK510 | M_CK610 },
+    { "stq",  RQ, 0, 0x0050, M_CK510 | M_CK610 },
+    { "ldm",  RM, 0, 0x0060, M_CK510 | M_CK610 },
+    { "stm",  RM, 0, 0x0070, M_CK510 | M_CK610 },
+    { "dect", O1_E2, 0, 0x0080, M_CK510 | M_CK610 },
+    { "decf", O1_E2, 0, 0x0090, M_CK510 | M_CK610 },
+    { "inct", O1_E2, 0, 0x00A0, M_CK510 | M_CK610 },
+    { "incf", O1_E2, 0, 0x00B0, M_CK510 | M_CK610 },
+    { "jmp", JMP, 2, 0x00C0, M_CK510 | M_CK610 },
+#define ckcore_INST_JMP 0x00C0
+    { "jsr", JSR, 0, 0x00D0, M_CK510 | M_CK610 },
+#define ckcore_INST_JSR 0x00E0
+    { "ff1",    O1_E, 0, 0x00E0, M_CK510 | M_CK610 },
+    { "brev",   O1_E, 0, 0x00F0, M_CK510 | M_CK610 },
+    { "xtrb3",  X1,   0, 0x0100, M_CK510 | M_CK610 },
+    { "xtrb2",  X1,   0, 0x0110, M_CK510 | M_CK610 },
+    { "xtrb1",  X1,   0, 0x0120, M_CK510 | M_CK610 },
+    { "xtrb0",  X1,   0, 0x0130, M_CK510 | M_CK610 },
+    { "zextb",  O1_E, 0, 0x0140, M_CK510 | M_CK610 },
+    { "sextb",  O1_E, 0, 0x0150, M_CK510 | M_CK610 },
+    { "zexth",  O1_E, 0, 0x0160, M_CK510 | M_CK610 },
+    { "sexth",  O1_E, 0, 0x0170, M_CK510 | M_CK610 },
+    { "declt",  O1_E2, 0, 0x0180, M_CK510 | M_CK610 },
+    { "tstnbz", O1,    0, 0x0190, M_CK510 | M_CK610 },
+    { "decgt",  O1_E2, 0, 0x01A0, M_CK510 | M_CK610 },
+    { "decne",  O1_E2, 0, 0x01B0, M_CK510 | M_CK610 },
+    { "clrt",   O1,    0, 0x01C0, M_CK510 | M_CK610 },
+    { "clrf",   O1,    0, 0x01D0, M_CK510 | M_CK610 },
+    { "abs",    O1_E,  0, 0x01E0, M_CK510 | M_CK610 },
+    { "not",    O1_E,  0, 0x01F0, M_CK510 | M_CK610 },
+    { "movt",   O2,    0, 0x0200, M_CK510 | M_CK610 },
+    { "mult",   O2_E,  0, 0x0300, M_CK510 | M_CK610 },
+    { "mac",    O2,    0, 0x0400, M_MAC},
+    { "subu",   O2_E, 0, 0x0500, M_CK510 | M_CK610 },
+    { "sub",    O2_E, 0, 0x0500, M_CK510 | M_CK610 }, /* Official alias.  */
+    { "addc",   O2_E, 0, 0x0600, M_CK510 | M_CK610 },
+    { "subc",   O2_E, 0, 0x0700, M_CK510 | M_CK610 },
+    /*
+     * SPACE: 0x0800-0x09ff for a diadic operation,
+     *   Used now by "xnor/xadd" and "cprgr" overlapped,
+     *   but they are not existed in same time.
+     */
+    /* CK610 Coprocessor Instruction*/
+    { "cprgr", O2_CPGR, 0, 0x0800, M_CK610 | M_CP },
+
+    { "movf",  O2, 0, 0x0A00, M_CK510 | M_CK610 },
+    { "lsr",   O2_E, 0, 0x0B00, M_CK510 | M_CK610 },
+    { "cmphs", O2, 0, 0x0C00, M_CK510 | M_CK610 },
+    { "cmplt", O2, 0, 0x0D00, M_CK510 | M_CK610 },
+    { "tst",   O2, 0, 0x0E00, M_CK510 | M_CK610 },
+    { "cmpne", O2, 0, 0x0F00, M_CK510 | M_CK610 },
+    /*
+     *  We must search psrclr or psrset before mfcr,
+     *  becase psrclr or psrset is a subcollection.
+     *  Or we will get mfcr instruction when disassemble
+     *  psrclr or psrset.
+     *  Modified by Li Chunqiang (chunqiang_li@c-sky.com)
+     */
+    { "psrclr", OPSR, 0, 0x11F0, M_CK510 | M_CK610 },
+    { "psrset", OPSR, 0, 0x11F8, M_CK510 | M_CK610 },
+    { "mfcr",   OC,   0, 0x1000, M_CK510 | M_CK610 },
+
+    { "mov",    O2,   0, 0x1200, M_CK510 | M_CK610 },
+    { "bgenr",  O2,   0, 0x1300, M_CK510 | M_CK610 },
+    { "rsub",   O2_E,   0, 0x1400, M_CK510 | M_CK610 },
+    { "ixw",    O2_E,   0, 0x1500, M_CK510 | M_CK610 },
+    { "and",    O2_E,   0, 0x1600, M_CK510 | M_CK610 },
+    { "xor",    O2_E,   0, 0x1700, M_CK510 | M_CK610 },
+    { "mtcr",   OC,   0, 0x1800, M_CK510 | M_CK610 },
+    { "asr",    O2_E,   0, 0x1A00, M_CK510 | M_CK610 },
+    { "lsl",    O2_E,   0, 0x1B00, M_CK510 | M_CK610 },
+    { "addu",   O2_E,   0, 0x1C00, M_CK510 | M_CK610 },
+    { "add",    O2,   0, 0x1C00, M_CK510 | M_CK610 }, /* Official alias.  */
+#define ckcore_INST_ADDU    0x1C00
+    { "ixh",    O2_E,   0, 0x1D00, M_CK510 | M_CK610 },
+    { "or",     O2_E,   0, 0x1E00, M_CK510 | M_CK610 },
+    { "andn",   O2_E,   0, 0x1F00, M_CK510 | M_CK610 },
+    { "addi",   OI_E,   0, 0x2000, M_CK510 | M_CK610 },
+#define ckcore_INST_ADDI    0x2000
+    { "cmplti", OI,   0, 0x2200, M_CK510 | M_CK610 },
+    { "subi",   OI_E,   0, 0x2400, M_CK510 | M_CK610 }, /* 0x2400 ~ 0x25ff */
+#define ckcore_INST_SUBI    0x2400
+    /*
+     * SPACE: 0x2600-0x27ff,
+     *   open for a register+immediate  operation,
+     *   Used now by "perm/rxor" and "cpwgr" are overlapped,
+     *   but they are not existed in the same time.
+     */
+    /* CK610 Coprocessor instructions */
+    { "cpwgr",  O2_CPGR, 0, 0x2600, M_CK610 | M_CP },
+
+    { "rsubi",  OB_E,   0, 0x2800, M_CK510 | M_CK610 },
+    { "cmpnei", OB,   0, 0x2A00, M_CK510 | M_CK610 },
+    { "bmaski", OMa,  0, 0x2C00, M_CK510 | M_CK610 },
+    { "divu",   O1R1_E, 0, 0x2C10, M_CK510 | M_CK610 },
+
+    /*
+     * SPACE: 0x2C20-0x2C3f
+     *   Used  by DSP, but they are not existed in
+     *   the same time.
+     */
+    /* DSP instructions */
+    { "mflos",  O1,   0, 0x2C20, M_DSP },
+    { "mfhis",  O1,   0, 0x2C30, M_DSP },
+
+    { "mtlo",   O1,   0, 0x2C40, M_DSP},
+    { "mthi",   O1,   0, 0x2C50, M_DSP},
+    { "mflo",   O1,   0, 0x2C60, M_DSP},
+    { "mfhi",   O1,   0, 0x2C70, M_DSP},
+
+    { "bmaski", OMb,  0, 0x2C80, M_CK510 | M_CK610 },
+    { "bmaski", OMc,  0, 0x2D00, M_CK510 | M_CK610 },
+    { "andi",   OB_E,   0, 0x2E00, M_CK510 | M_CK610 },
+    { "bclri",  OB_E,   0, 0x3000, M_CK510 | M_CK610 },
+
+    /*
+     * SPACE: 0x3200-0x320f
+     *   Used  by Coprocessor, but they are not existed in
+     *   the same time.
+     */
+    /* CK610 Coprocessor instructions */
+    { "cpwir",  O1,   0, 0x3200, M_CK610 | M_CP },
+
+    { "divs",   O1R1_E, 0, 0x3210, M_CK510 | M_CK610 },
+    /*
+     * SPACE: 0x3200-0x320f
+     *   Used  by Coprocessor, but they are not existed in
+     *   the same time.
+     */
+    /* SPACE:           0x3260 - 0x326f */
+    /* CK610 Coprocessor instructions */
+    { "cprsr",  O1,   0, 0x3220, M_CK610 | M_CP },
+    { "cpwsr",  O1,   0, 0x3230, M_CK610 | M_CP },
+    /* SPACE:            0x3240 - 0x326f */
+
+    { "bgeni",  OBRa,  0, 0x3270, M_CK510 | M_CK610 },
+    { "bgeni",  OBRb,  0, 0x3280, M_CK510 | M_CK610 },
+    { "bgeni",  OBRc,  0, 0x3300, M_CK510 | M_CK610 },
+    { "bseti",  OB_E,  0, 0x3400, M_CK510 | M_CK610 },
+    { "btsti",  OB,    0, 0x3600, M_CK510 | M_CK610 },
+    { "xsr",    O1_E2, 0, 0x3800, M_CK510 | M_CK610 },
+    { "rotli",  SIa_E, 0, 0x3800, M_CK510 | M_CK610 },
+    { "asrc",   O1_E2, 0, 0x3A00, M_CK510 | M_CK610 },
+    { "asri",   SIa_E, 0, 0x3A00, M_CK510 | M_CK610 },
+    { "lslc",   O1_E2, 0, 0x3C00, M_CK510 | M_CK610 },
+    { "lsli",   SIa_E, 0, 0x3C00, M_CK510 | M_CK610 },
+    { "lsrc",   O1_E2, 0, 0x3E00, M_CK510 | M_CK610 },
+    { "lsri",   SIa_E, 0, 0x3E00, M_CK510 | M_CK610 },
+
+    { "omflip0", O2, 0, 0x4000, M_MAC },
+    { "omflip1", O2, 0, 0x4100, M_MAC },
+    { "omflip2", O2, 0, 0x4200, M_MAC },
+    { "omflip3", O2, 0, 0x4300, M_MAC },
+    { "muls",    O2, 0, 0x5000, M_DSP },
+    { "mulsa",   O2, 0, 0x5100, M_DSP },
+    { "mulss",   O2, 0, 0x5200, M_DSP },
+    /* SPACE:           0x5300 - 0x53FF */
+    { "mulu",    O2, 0, 0x5400, M_DSP },
+    { "mulua",   O2, 0, 0x5500, M_DSP },
+    { "mulus",   O2, 0, 0x5600, M_DSP },
+    /* SPACE:           0x5700 - 0x57FF */
+    { "vmulsh",  O2, 0, 0x5800, M_DSP },
+    { "vmulsha", O2, 0, 0x5900, M_DSP },
+    { "vmulshs", O2, 0, 0x5A00, M_DSP },
+    /* SPACE:          0x5B00 - 0x5BFF */
+    { "vmulsw",  O2, 0, 0x5C00, M_DSP },
+    { "vmulswa", O2, 0, 0x5D00, M_DSP },
+    { "vmulsws", O2, 0, 0x5E00, M_DSP },
+    /* SPACE:           0x5F00 - 0x5FFF */
+    /* SPACE:           0x4000 - 0x5fff */
+    { "movi",    I7, 0, 0x6000, M_CK510 | M_CK610 },
+#define ckcore_INST_BMASKI_ALT  0x6000
+#define ckcore_INST_BGENI_ALT   0x6000
+    { "mulsh",   O2_E, 0, 0x6800, M_CK510 | M_CK610 },
+    { "muls.h",  O2_E, 0, 0x6800, M_CK510 | M_CK610 },
+
+    /*
+     * SPACE: 0x6900-0x6fff
+     *   Used  by DSP/Coprocessor, but they are not
+     *   existed in the same time.
+     */
+    /* DSP/Coprocessor Instructions */
+    { "mulsha",  O2,      0, 0x6900, M_DSP },
+    { "mulshs",  O2,      0, 0x6A00, M_DSP },
+    { "cprcr",   O2_CPCR, 0, 0x6B00, M_CK610 | M_CP },
+    { "mulsw",   O2,      0, 0x6C00, M_DSP },
+    { "mulswa",  O2,      0, 0x6D00, M_DSP },
+    { "mulsws",  O2,      0, 0x6E00, M_DSP },
+    { "cpwcr",   O2_CPCR, 0, 0x6F00, M_CK610 | M_CP },
+
+    /*
+     *  We must search jsri/jumpi before lrw,
+     *  becase jsri/jumpi is a subcollection.
+     *  Or we will get lrw instruction when disassemble
+     *  jsri/jumpi.
+     */
+    { "jmpi", LJ, 1, 0x7000, M_CK510 | M_CK610 },
+    { "jsri", LJ, 0, 0x7F00, M_CK510 | M_CK610 },
+    { "lrw",  LR, 0, 0x7000, M_CK510 | M_CK610 },
+#define ckcore_INST_JMPI    0x7000
+#define ckcore_INST_JSRI    0x7F00
+#define ckcore_INST_LRW     0x7000
+#define ckcore_INST_LDW     0x8000
+#define ckcore_INST_STW     0x9000
+    { "ld",   LS, 0, 0x8000, M_CK510 | M_CK610 },
+    { "ldw",  LS, 0, 0x8000, M_CK510 | M_CK610 },
+    { "ld.w", LS, 0, 0x8000, M_CK510 | M_CK610 },
+    { "st",   LS, 0, 0x9000, M_CK510 | M_CK610 },
+    { "stw",  LS, 0, 0x9000, M_CK510 | M_CK610 },
+    { "st.w", LS, 0, 0x9000, M_CK510 | M_CK610 },
+    { "ldb",  LS, 0, 0xA000, M_CK510 | M_CK610 },
+    { "ld.b", LS, 0, 0xA000, M_CK510 | M_CK610 },
+    { "stb",  LS, 0, 0xB000, M_CK510 | M_CK610 },
+    { "st.b", LS, 0, 0xB000, M_CK510 | M_CK610 },
+    { "ldh",  LS, 0, 0xC000, M_CK510 | M_CK610 },
+    { "ld.h", LS, 0, 0xC000, M_CK510 | M_CK610 },
+    { "sth",  LS, 0, 0xD000, M_CK510 | M_CK610 },
+    { "st.h", LS, 0, 0xD000, M_CK510 | M_CK610 },
+    { "bt",   BR, 0, 0xE000, M_CK510 | M_CK610 },
+    { "bf",   BR, 0, 0xE800, M_CK510 | M_CK610 },
+    { "br",   BR, 1, 0xF000, M_CK510 | M_CK610 },
+#define ckcore_INST_BR  0xF000
+    { "bsr",  BR, 0, 0xF800, M_CK510 | M_CK610 },
+#define ckcore_INST_BSR 0xF800
+
+    /* The following are relaxable branches */
+    { "jbt",  JC, 0, 0xE000, M_CK510 | M_CK610 },
+    { "jbf",  JC, 0, 0xE800, M_CK510 | M_CK610 },
+    { "jbr",  JU, 1, 0xF000, M_CK510 | M_CK610 },
+    { "jbsr", JL, 0, 0xF800, M_CK510 | M_CK610 },
+
+    /* The following are aliases for other instructions */
+    { "rts",   O0,   2, 0x00CF, M_CK510 | M_CK610 }, /* jmp r15 */
+    { "rolc",  DO21, 0, 0x0600, M_CK510 | M_CK610 }, /* addc rd,rd */
+    { "rotlc", DO21, 0, 0x0600, M_CK510 | M_CK610 }, /* addc rd,rd */
+    { "setc",  O0,   0, 0x0C00, M_CK510 | M_CK610 }, /* cmphs r0,r0 */
+    { "clrc",  O0,   0, 0x0F00, M_CK510 | M_CK610 }, /* cmpne r0,r0 */
+    { "tstle", O1,   0, 0x2200, M_CK510 | M_CK610 }, /* cmplti rd,1 */
+    /* cmplei rd,X -> cmplti rd,X+1 */
+    { "cmplei", OB,   0, 0x2200, M_CK510 | M_CK610 },
+    { "neg",    O1,   0, 0x2800, M_CK510 | M_CK610 }, /* rsubi rd,0 */
+    { "tstne",  O1,   0, 0x2A00, M_CK510 | M_CK610 }, /* cmpnei rd,0 */
+    { "tstlt",  O1,   0, 0x37F0, M_CK510 | M_CK610 }, /* btsti rx,31 */
+    { "mclri",  OB2,  0, 0x3000, M_CK510 | M_CK610 }, /* bclri rx,log2(imm) */
+    { "mgeni",  OBR2, 0, 0x3200, M_CK510 | M_CK610 }, /* bgeni rx,log2(imm) */
+    { "mseti",  OB2,  0, 0x3400, M_CK510 | M_CK610 }, /* bseti rx,log2(imm) */
+    { "mtsti",  OB2,  0, 0x3600, M_CK510 | M_CK610 }, /* btsti rx,log2(imm) */
+    { "rori",   RSI,  0, 0x3800, M_CK510 | M_CK610 },
+    { "rotri",  RSI,  0, 0x3800, M_CK510 | M_CK610 },
+    { "nop",    O0,   0, 0x1200, M_CK510 | M_CK610 }, /* mov r0, r0 */
+    { 0,        0,    0, 0,      0 }
+};
+
+/* Mask for each ckcore_opclass: */
+static const unsigned short v1_imsk[] = {
+    /* O0  */ 0xFFFF,
+    /* OT  */ 0xFFFC,
+    /* O1  */ 0xFFF0,
+    /* OC  */ 0xFE00,
+    /* O2  */ 0xFF00,
+    /* X1  */ 0xFFF0,
+    /* OI  */ 0xFE00,
+    /* OB  */ 0xFE00,
+
+    /* OMa */ 0xFFF0,
+    /* SI  */ 0xFE00,
+    /* I7  */ 0xF800,
+    /* LS  */ 0xF000,
+    /* BR  */ 0xF800,
+    /* BL  */ 0xFF00,
+    /* LR  */ 0xF000,
+    /* LJ  */ 0xFF00,
+
+    /* RM  */ 0xFFF0,
+    /* RQ  */ 0xFFF0,
+    /* JSR */ 0xFFF0,
+    /* JMP */ 0xFFF0,
+    /* OBRa*/ 0xFFF0,
+    /* OBRb*/ 0xFF80,
+    /* OBRc*/ 0xFF00,
+    /* OBR2*/ 0xFE00,
+
+    /* O1R1*/ 0xFFF0,
+    /* OMb */ 0xFF80,
+    /* OMc */ 0xFF00,
+    /* SIa */ 0xFE00,
+
+    /* MULSH */ 0xFF00,
+    /* OPSR  */ 0xFFF8,   /* psrset/psrclr */
+
+    /* O1_CP */   0xFFF0,
+    /* O2_CPGR */ 0xFE00,
+    /* O2_CPCR */ 0xFF00,
+    /* O_KWGJ1 */ 0xFF00,
+    /* O_KWGJ2 */ 0xFF00,
+    /* JC  */ 0,        /* JC,JU,JL don't appear in object */
+    /* JU  */ 0,
+    /* JL  */ 0,
+    /* RSI */ 0,
+    /* DO21*/ 0,
+    /* OB2 */ 0,        /* OB2 won't appear in object.  */
+
+    /* O1_E2  */ 0xFFF0,
+    /* O1_E   */ 0xFFF0,
+    /* O2_E   */ 0xFF00,
+    /* OI_E   */ 0xFE00,
+    /* OB_E   */ 0xFE00,
+    /* O1R1_E */ 0xFFF0,
+    /* SIa_E  */ 0xFE00
+
+};
+
+static const char *v1_grname[] = {
+    "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
+    "r8",  "r9", "r10", "r11", "r12", "r13", "r14", "r15"
+};
+
+static const char v1_X[] = "??";
+
+static const char *v1_crname[] = {
+    "psr",  "vbr",  "epsr", "fpsr", "epc",  "fpc",  "ss0",  "ss1",
+    "ss2",  "ss3",  "ss4",  "gcr",  "gsr",  "cr13", "cr14", "cr15",
+    "cr16", "cr17", "cr18", "cr19", "cr20", "cr21", "cr22", "cr23",
+    "cr24", "cr25", "cr26", "cr27", "cr28", "cr29", "cr30",  v1_X
+};
+
+static const char *v1_cpname[] = {
+    v1_X, "cp1", "cp2",  "cp3",  "cp4",  "cp5",  "cp6",  "cp7",
+    "cp8", "cp9", "cp10", "cp11", "cp12", "cp13", "cp14", "cp15"
+};
+
+static const char *v1_cprname[] = {
+    "cpr0",  "cpr1",  "cpr2",  "cpr3",  "cpr4",  "cpr5",  "cpr6",  "cpr7",
+    "cpr8",  "cpr9",  "cpr10", "cpr11", "cpr12", "cpr13", "cpr14", "cpr15",
+    "cpr16", "cpr17", "cpr18", "cpr19", "cpr20", "cpr21", "cpr22", "cpr23",
+    "cpr24", "cpr25", "cpr26", "cpr27", "cpr28", "cpr29", "cpr30", "cpr31",
+};
+
+static const char *v1_cpcrname[] = {
+    "cpcr0",  "cpcr1",  "cpcr2",  "cpcr3",
+    "cpcr4",  "cpcr5",  "cpcr6",  "cpcr7",
+    "cpcr8",  "cpcr9",  "cpcr10", "cpcr11",
+    "cpcr12", "cpcr13", "cpcr14", "cpcr15",
+    "cpcr16", "cpcr17", "cpcr18", "cpcr19",
+    "cpcr20", "cpcr21", "cpcr22", "cpcr23",
+    "cpcr24", "cpcr25", "cpcr26", "cpcr27",
+    "cpcr28", "cpcr29", "cpcr30", "cpcr31",
+};
+
+static const unsigned v1_isiz[] = { 2, 0, 1, 0 };
+
+int print_insn_csky_v1(bfd_vma memaddr, struct disassemble_info *info)
+{
+    unsigned char       ibytes[4];
+    fprintf_function    func = info->fprintf_func;
+    void                *stream = info->stream;
+    unsigned short      inst;
+    ckcore_opcode_info  *op;
+    int                 status;
+    unsigned long       cpu_flag = -1; /* CKCORE_INSN_CK510 */;
+
+    info->bytes_per_chunk = 2;
+
+    status = info->read_memory_func(memaddr, ibytes, 2, info);
+
+    if (status != 0) {
+        info->memory_error_func(status, memaddr, info);
+        return -1;
+    }
+
+    if (info->endian == BFD_ENDIAN_BIG) {
+        inst = (ibytes[0] << 8) | ibytes[1];
+    } else if (info->endian == BFD_ENDIAN_LITTLE) {
+        inst = (ibytes[1] << 8) | ibytes[0];
+    } else {
+        abort();
+    }
+
+    /* Just a linear search of the table.  */
+    for (op = ckcore_table; op->name != 0; op++) {
+        if (op->inst == (inst & v1_imsk[op->opclass]) &&
+            (op->cpu_flag & cpu_flag)) {
+            break;
+        }
+    }
+
+    if (op->name == 0) {
+        func(stream, ".short 0x%04x", inst);
+    } else {
+        const char *name = v1_grname[inst & 0x0F];
+
+        func(stream, "%s", op->name);
+
+        switch (op->opclass) {
+        case O0:
+            break;
+        case OT:
+            func(stream, "\t%d", inst & 0x3);
+            break;
+        case O1:
+        case JMP:
+        case JSR:
+            func(stream, "\t%s", name);
+            break;
+        case O1_E:
+            func(stream, "\t%s, %s", name, name);
+            break;
+        case O1_E2:
+            func(stream, "\t%s, %s, 1", name, name);
+            break;
+        case OC:
+            func(stream, "\t%s, %s", name, v1_crname[(inst >> 4) & 0x1F]);
+            break;
+        case O1R1:
+            func(stream, "\t%s, r1", name);
+            break;
+        case O1R1_E:
+            func(stream, "\t%s, %s, r1", name, name);
+            break;
+        case MULSH:
+        case O2:
+            func(stream, "\t%s, %s", name, v1_grname[(inst >> 4) & 0xF]);
+            break;
+        case O2_E:
+            func(stream, "\t%s, %s, %s",
+                 name, name, v1_grname[(inst >> 4) & 0xF]);
+            break;
+        case O1_CP:
+            func(stream, "\t%s", v1_cpname[inst & 0xF]);
+            break;
+        case O2_CPGR:
+            func(stream, "\t%s, %s",
+                  v1_grname[inst & 0x0F], v1_cprname[(inst >> 4) & 0x1F]);
+            break;
+        case O2_CPCR:
+            func(stream, "\t%s, %s",
+                  v1_grname[inst & 0x07], v1_cpcrname[(inst >> 3) & 0x1F]);
+            break;
+        case O_KWGJ1:
+            {
+                int bank = (inst >> 6) & 0x3;
+                int rw = ((inst >> 4) & 0x3) + 4 * bank;
+                int ru = (inst & 0x3) + 4 * bank;
+                int rv = ((inst >> 2) & 0x3) + 4 * bank;
+
+                func(stream, "\t%s, %s, %s\t// in bank %d",
+                      v1_grname[rw], v1_grname[ru], v1_grname[rv], bank);
+                break;
+            }
+        case O_KWGJ2:
+            {
+                int bank = (inst >> 6) & 0x3;
+                int rw = ((inst >> 4) & 0x3) + 4 * bank;
+                int ru = (inst & 0x3) + 4 * bank;
+                int rv = ((inst >> 2) & 0x3) + 4 * bank;
+
+                func(stream, "\t%s, (%s), @%s\t// in bank %d",
+                      v1_grname[rw], v1_grname[ru], v1_grname[rv], bank);
+                break;
+            }
+        case X1:
+            func(stream, "\tr1, %s", name);
+            break;
+        case OI:
+            func(stream, "\t%s, %d", name, ((inst >> 4) & 0x1F) + 1);
+            break;
+        case OI_E:
+            func(stream, "\t%s, %s, %d", name, name, ((inst >> 4) & 0x1F) + 1);
+            break;
+        case RM:
+            func(stream, "\t%s-r15, (r0)", name);
+            break;
+        case RQ:
+            func(stream, "\tr4-r7, (%s)", name);
+            break;
+        case OB:
+        case OBRa:
+        case OBRb:
+        case OBRc:
+        case SI:
+        case SIa:
+        case OMa:
+        case OMb:
+        case OMc:
+            func(stream, "\t%s, %d", name, (inst >> 4) & 0x1F);
+            break;
+        case OB_E:
+        case SIa_E:
+            func(stream, "\t%s, %s, %d", name, name, (inst >> 4) & 0x1F);
+            break;
+        case I7:
+            func(stream, "\t%s, %d", name, (inst >> 4) & 0x7F);
+            break;
+        case LS:
+            func(stream, "\t%s, (%s, %d)", v1_grname[(inst >> 8) & 0xF],
+                  name, ((inst >> 4) & 0xF) << v1_isiz[(inst >> 13) & 3]);
+            break;
+
+        case BR:
+            {
+                bfd_vma val = inst & 0x3FF;
+
+                if (inst & 0x400) {
+                    val |= 0xFFFFFC00;
+                }
+
+                func(stream, "\t0x%x", (unsigned)(memaddr + 2 + (val << 1)));
+
+                if (strcmp(op->name, "bsr") == 0) {
+                    /* For bsr, we'll try to get a symbol for the target.  */
+                    val = (memaddr + 2 + (val << 1)) & 0xffffffff;
+
+                    if (info->print_address_func && val != 0) {
+                        func(stream, "\t// ");
+                        info->print_address_func(val, info);
+                    }
+                }
+            }
+            break;
+
+        case BL:
+            {
+                long val;
+
+                val = (inst & 0x000F);
+                func(stream, "\t%s, 0x%x",
+                      v1_grname[(inst >> 4) & 0xF],
+                      (unsigned)(memaddr - (val << 1)));
+            }
+            break;
+
+        case LR:
+            {
+                unsigned long val;
+
+                val = (memaddr + 2 + ((inst & 0xFF) << 2)) & 0xFFFFFFFC;
+
+                status = info->read_memory_func(val, ibytes, 4, info);
+                if (status != 0) {
+                    info->memory_error_func(status, memaddr, info);
+                    break;
+                }
+
+                if (info->endian == BFD_ENDIAN_LITTLE) {
+                    val = (ibytes[3] << 24) | (ibytes[2] << 16) |
+                        (ibytes[1] <<  8) | (ibytes[0]);
+                } else {
+                    val = (ibytes[0] << 24) | (ibytes[1] << 16) |
+                        (ibytes[2] <<  8) | (ibytes[3]);
+                }
+
+                /* Removed [] around literal value to match ABI syntax 12/95. */
+                func(stream, "\t%s, 0x%X",
+                     v1_grname[(inst >> 8) & 0xF], (unsigned)val);
+
+                if (val == 0) {
+                    func(stream, "\t// from address pool at 0x%x",
+                          (unsigned)((memaddr + 2 + ((inst & 0xFF) << 2)) &
+                                     0xFFFFFFFC));
+                }
+            }
+            break;
+
+        case LJ:
+            {
+                bfd_vma val;
+
+                val = (memaddr + 2 + ((inst & 0xFF) << 2)) & 0xFFFFFFFC;
+
+                status = info->read_memory_func(val, ibytes, 4, info);
+                if (status != 0) {
+                    info->memory_error_func(status, memaddr, info);
+                    break;
+                }
+
+                if (info->endian == BFD_ENDIAN_LITTLE) {
+                    val = (ibytes[3] << 24) | (ibytes[2] << 16) |
+                        (ibytes[1] <<  8) | (ibytes[0]);
+                } else {
+                    val = (ibytes[0] << 24) | (ibytes[1] << 16) |
+                        (ibytes[2] <<  8) | (ibytes[3]);
+                }
+
+                val &= 0xffffffff;
+                /* Removed [] around literal value to match ABI syntax 12/95. */
+                func(stream, "\t0x%X", (unsigned)val);
+                /* For jmpi/jsri, we'll try to get a symbol for the target. */
+                if (info->print_address_func && val != 0) {
+                    func(stream, "\t// ");
+                    info->print_address_func(val, info);
+                } else {
+                    func(stream, "\t// from address pool at 0x%x",
+                          (unsigned)(memaddr + 2 + ((inst & 0xFF) << 2)) &
+                          0xFFFFFFFC);
+                }
+            }
+            break;
+
+        case OPSR:
+            {
+                static const char *fields[] = {
+                    "af", "ie",    "fe",    "fe,ie",
+                    "ee", "ee,ie", "ee,fe", "ee,fe,ie"
+                };
+
+                func(stream, "\t%s", fields[inst & 0x7]);
+            }
+            break;
+
+        default:
+            /* If the disassembler lags the instruction set.  */
+            func(stream, "\tundecoded operands, inst is 0x%04x", inst);
+            break;
+        }
+    }
+
+    /* Say how many bytes we consumed.  */
+    return 2;
+}
+
+#define ALIAS 0
+
+#define CSKY_INST_TYPE unsigned long
+
+typedef enum {
+    MEND, /*end of parsing operands*/
+    MREG, /*parsing operand as register, two values after 'MREG':
+            operand-mask, rightshift*/
+    MREG1,/*parsing vr resgister*/
+    MREG2,/*parsing fr resgister*/
+    MIMM, /*parsing operand as oimm, three values after 'MIMM':
+            operand-mask, rightshift, offset */
+    MIMMH, /*parsing operand as oimm, three values after 'MIMM':
+             operand-mask, rightshift, offset */
+    MSYM, /* convert offset to label name */
+    MSYMI, /* convert pool offset to lable name*/
+    MIMM0, /* parsing operand as imm, two values after 'MIMM0':
+              operand-mask, rightshift*/
+    MIMM0H, /* parsing operand as imm, two values after 'MIMM0':
+               operand-mask, rightshift*/
+    MADD, /* calculate as hex */
+    MADDD, /*calculate as decimal*/
+    MSUBD, /* calculate as decimal */
+    MSPE,   /*output a single character*/
+    MERR,  /*error*/
+    MSPE1, /* suppress nearby comma */
+    MBR,
+    MBR1,
+    MPSR,  /*specially for instruction psrclr,psrset*/
+    MLOG2, /* return clog2(x) */
+    MPOP16,
+    MPOP32,  /*srecially for instruction pop, push*/
+    MIMM1, /*specially for addi.sp instruction*/
+    MSP,   /*specially for print sp*/
+    MADDISP, /*specially for addisp, subisp*/
+    MADDISPH, /*specially for ld.wsp, st.wsp*/
+    MLDM,   /*specially for ldm,stm instruction*/
+    MVLDM , /*specially for Vldm,Vstm instruction*/
+    MLRS, /*specially for instruction lrs.b,lrs.h,lrs.w*/
+    MPRINT, /*specially for printing lrs information of  lrs instruction*/
+    MLRW16, /*specially for instruction lrw16, addi16.sp, subi16.sp*/
+    MLRW16_2, /*specially for instruction lrw16,offset 512-1016*/
+    MVSHLRI,
+    MVLDSTI,/*specially for instruction VLD&VST*/
+    MFLDSTI,/*specially for instruction FLD&VST*/
+    MVLDSTQ,/*specially for instruction VLDQ&VSTQ*/
+    MR28,   /*specially for print r28*/
+    MFLRW,  /*specially for print float and double number*/
+    MFMOVI  /*specially for print float number for fmovi*/
+} PARSE_METHOD;
+
+typedef struct {
+    CSKY_INST_TYPE mask;
+    CSKY_INST_TYPE opcode;
+    const char *name;     /*instruction name*/
+    int *data;  /*point to array for parsing operands*/
+} INST_PARSE_INFO;
+
+int CBKPT[] = {MEND };
+int CBSR[] = {
+    MSYM, 0x3FFFFFF, -1, 0x4000000, 0xFC000000,
+    MEND };
+int CSCE[] = {
+    MIMMH, 0x01E00000, 21, 0,
+    MEND };
+int CTRAP[] = {
+    MIMM0, 0xC00, 10,
+    MEND };
+int CPSRCLR[] = {
+    MPSR, 0x03E00000, 21,
+    MEND };
+int CCLRF[] = {
+    MREG, 0x03E00000, 21,
+    MEND };
+int CMFHI[] = {
+    MREG, 0x1F, 0,
+    MEND };
+int CMTHI[] = {
+    MREG, 0x1F0000, 16,
+    MEND };
+int CJMPI[] = {
+    MSYMI, 0xFFFF, -2,
+    MEND };
+int CBT[] = {
+    MSYM, 0xFFFF, -1, 0x10000, 0xFFFF0000,
+    MEND };
+int CCPOP[] = {MERR };
+int CCPRC[] = {MERR };
+int CCPRCR[] = {MERR };
+int CLDCPR[] = {MERR };
+int CBEZ[] = {
+    MREG, 0x1F0000, 16,
+    MSYM, 0xFFFF, -1, 0x10000, 0xFFFF0000,
+    MEND };
+int CCMPNEI[] = {
+    MREG, 0x1F0000, 16,
+    MIMM0, 0xFFFF, 0,
+    MEND };
+int CCMPHSI[] = {
+    MREG, 0x1F0000, 16,
+    MIMM, 0xFFFF, 0, 1,
+    MEND };
+int CPLDR[] = {
+    MSPE1, '(',
+    MREG, 0x1F0000, 16,
+    MIMM0H, 0xFFF, -2,
+    MSPE, ')',
+    MEND };
+int CBGENR[] = {
+    MREG, 0x1F, 0,
+    MREG, 0x1F0000, 16,
+    MEND };
+int CCMPNE[] = {
+    MREG, 0x1F0000, 16,
+    MREG, 0x03E00000, 21,
+    MEND };
+int CCMPLS[] = {MERR };
+int CBTSTI[] = {
+    MREG, 0x1F0000, 16,
+    MIMM0, 0x03E00000, 21,
+    MEND };
+int CBMASKI[] = {
+    MREG, 0x1F, 0,
+    MIMM, 0x03E00000, 21, 1,
+    MEND };
+int CADDI[] = {
+    MREG, 0x03E00000, 21,
+    MREG, 0x1F0000, 16,
+    MIMM, 0xFFF, 0, 1,
+    MEND };
+int CANDI[] = {
+    MREG, 0x03E00000, 21,
+    MREG, 0x1F0000, 16,
+    MIMM0, 0xFFF, 0,
+    MEND };
+int CORI[] = {
+    MREG, 0x03E00000, 21,
+    MREG, 0x1F0000, 16,
+    MIMM0, 0xFFFF, 0,
+    MEND };
+int CLDB[] = {
+    MREG, 0x03E00000, 21,
+    MSPE1, '(',
+    MREG, 0x1F0000, 16,
+    MIMM0H, 0xFFF, 0,
+    MSPE, ')',
+    MEND };
+int CLDH[] = {
+    MREG, 0x03E00000, 21,
+    MSPE1, '(',
+    MREG, 0x1F0000, 16,
+    MIMM0H, 0xFFF, -1,
+    MSPE, ')',
+    MEND };
+int CLDW[] = {
+    MREG, 0x03E00000, 21,
+    MSPE1, '(',
+    MREG, 0x1F0000, 16,
+    MIMM0H, 0xFFF, -2,
+    MSPE, ')',
+    MEND };
+int CLDD[] = {
+    MREG, 0x03E00000, 21,
+    MSPE1, '(',
+    MREG, 0x1F0000, 16,
+    MIMM0H, 0xFFF, -2,
+    MSPE, ')',
+    MEND };
+int CADDU[] = {
+    MREG, 0x01F, 0,
+    MREG, 0x1F0000, 16,
+    MREG, 0x03E00000, 21,
+    MEND };
+int CNOT[] = {MERR };
+int CRSUB[] = {MERR };
+int CBE[] = {
+    MREG, 0x1F0000, 16,
+    MREG, 0x03E00000, 21,
+    MSYM, 0xFFFF, -1, 0x10000, 0xFFFF0000,
+    MEND };
+int CINCF[] = {
+    MREG, 0x03E00000, 21,
+    MREG, 0x1F0000, 16,
+    MIMM0, 0x1F, 0,
+    MEND };
+int CDECGT[] = {
+    MREG, 0x1F, 0,
+    MREG, 0x1F0000, 16,
+    MIMM0, 0x03E00000, 21,
+    MEND };
+int CSRC[] = {
+    MREG, 0x1F, 0,
+    MREG, 0x1F0000, 16,
+    MIMM, 0x03E00000, 21, 1,
+    MEND };
+int CINS[] = {
+    MREG, 0x03E00000, 21,
+    MREG, 0x1F0000, 16,
+    MADD, 0x3E0, 5, 0x1F, 0,
+    MIMM0, 0x1F, 0,
+    MEND };
+int CSEXT[] = {
+    MREG, 0x1F, 0,
+    MREG, 0x1F0000, 16,
+    MIMM0, 0x3E0, 5,
+    MIMM0, 0x03E00000, 21,
+    MEND };
+int CLDM[] = {
+    MREG, 0x03E00000, 21,
+    MSPE, '-',
+    MLDM, 0x1f, 0,
+    MSPE1, '(',
+    MREG, 0x1F0000, 16,
+    MSPE, ')',
+    MEND };
+int CLDRH[] = {
+    MREG, 0x1F, 0,
+    MSPE1, '(',
+    MREG, 0x001F0000, 16,
+    MREG, 0x03E00000, 21,
+    MSPE, '<',
+    MSPE, '<',
+    MLOG2, 0x1E0, 5,
+    MSPE, ')',
+    MERR };
+int CMFCR[] = {
+    MREG, 0x1F, 0,
+    MSPE1, 'c',
+    MSPE, 'r',
+    MSPE, '<',
+    MADDD, 0x1F0000, 16, 0, 0,
+    MIMM0, 0x03E00000, 21,
+    MSPE, '>',
+    MEND };
+int CMTCR[] = {
+    MREG, 0x1F0000, 16,
+    MSPE1, 'c',
+    MSPE, 'r',
+    MSPE, '<',
+    MADDD, 0x1F, 0, 0, 0,
+    MIMM0, 0x03E00000, 21,
+    MSPE, '>',
+    MEND };
+int HLRW[] = {
+    MREG, 0x00e0, 5,
+    MLRW16, 0x0300, 3, 0x1f, -2,
+    MEND };
+int CLRW[] = {
+    MREG, 0x1F0000, 16,
+    MSYMI, 0xFFFF, -2,
+    MEND };
+int CGRS[] = {
+    MREG, 0x03e00000, 21,
+    MSYM, 0x3ffff, -1, 0x40000, 0xfffc0000,
+    MEND };
+int CBR3[] = {
+    MSYM, 0xffff, -1, 0x10000, 0xffff0000,
+    MEND };
+int CPOP[] = {
+    MPOP32,
+    MEND };
+int CADDI18[] = {
+    MREG, 0x03e00000, 21,
+    MR28,
+    MIMM, 0x3ffff, 0x0, 1,
+    MEND  };
+int CLRSB[] = {
+    MREG, 0x03e00000, 21,
+    MSPE1, '[',
+    MLRS, 0x3ffff, 0,
+    MSPE, ']',
+    MPRINT,
+    MEND };
+int CLRSH[] = {
+    MREG, 0x03e00000, 21,
+    MSPE1, '[',
+    MLRS, 0x3ffff, -1,
+    MSPE, ']',
+    MPRINT,
+    MEND };
+int CLRSW[] = {
+    MREG, 0x03e00000, 21,
+    MSPE1, '[',
+    MLRS, 0x3ffff, -2,
+    MSPE, ']',
+    MPRINT,
+    MEND };
+int CJMPIX[] = {
+    MREG, 0x1f0000, 16,
+    MIMM, 0x3, -3, 16,
+    MEND };
+int HBKPT[] = {
+    MEND };
+int HBR[] = {
+    MSYM, 0x3FF, -1, 0x400, 0xFFFFFC00,
+    MEND };
+int HMVCV[] = {
+    MREG, 0x03C0, 6,
+    MEND };
+int HTSTNBZ[] = {
+    MREG, 0x3c, 2,
+    MEND };
+int HNOT[] = {MERR };
+int HCMPHS[] = {
+    MREG, 0x3c, 2,
+    MREG, 0x3c0, 6,
+    MEND };
+int HCMPNEI[] = {
+    MREG, 0x0700, 8,
+    MIMM0, 0x1f, 0,
+    MEND };
+int HCMPLTI[] = {
+    MREG, 0x0700, 8,
+    MIMM, 0x1f, 0, 1,
+    MEND };
+int HMOVI[] = {
+    MREG, 0x0700, 8,
+    MIMM0H, 0xff, 0,
+    MEND };
+int HZEXTB[] = {
+    MREG, 0x03C0, 6,
+    MREG, 0x3C, 2,
+    MEND };
+int HLSLI[] = {
+    MREG, 0x00E0, 5,
+    MREG, 0x0700, 8,
+    MIMM0, 0x1F, 0,
+    MEND };
+int HLDB[] = {
+    MREG, 0x00E0, 5,
+    MSPE1, '(',
+    MREG, 0x0700, 8,
+    MIMM0H, 0x1F, 0,
+    MSPE, ')',
+    MEND };
+int HLDH[] = {
+    MREG, 0x00E0, 5,
+    MSPE1, '(',
+    MREG, 0x0700, 8,
+    MIMM0H, 0x1F, -1,
+    MSPE, ')',
+    MEND };
+int HLDW[] = {
+    MREG, 0x00E0, 5,
+    MSPE1, '(',
+    MREG, 0x0700, 8,
+    MIMM0H, 0x1F, -2,
+    MSPE, ')',
+    MEND };
+int HLDWSP[] = {
+    MREG, 0x00e0, 5,
+    MSPE1, '(',
+    MSP,
+    MADDISPH, 0x700, 3, 0x1f, -2,
+    MSPE, ')',
+    MEND };
+int HADDI8[] = {
+    MREG, 0x0700, 8,
+    MIMM, 0xFF, 0, 1,
+    MEND };
+int HADDI3[] = {
+    MREG, 0x00E0, 5,
+    MREG, 0x0700, 8,
+    MIMM, 0x1C, 2, 1,
+    MEND };
+int HADDI8SP[] = {
+    MREG, 0x0700, 8,
+    MSP,
+    MIMM1, 0xFF, 0, -2,
+    MEND };
+int HADDI7SP[] = {
+    MSP,
+    MSP,
+    MADDISP, 0x0300, 3, 0x1f, -2,
+    MEND };
+int HSUBI7SP[] = {
+    MSP,
+    MSP,
+    MADDISP, 0x0300, 3, 0x1f, -2,
+    MEND };
+int HPOP[] = {
+    MPOP16,
+    MEND};
+int HADDU2[] = {
+    MREG, 0x00E0, 5,
+    MREG, 0x0700, 8,
+    MREG, 0x001C, 2,
+    MEND };
+int HJMPIX[] = {
+    MREG, 0x0700, 8,
+    MIMM, 0x3, -3, 16,
+    MEND };
+int PSEUDO[] = {MERR };
+int CFMPZHSS[] = {
+    MREG2, 0xf0000, 16,
+    MEND};
+int CFSITOS[] = {
+    MREG2, 0xf, 0,
+    MREG2, 0xf0000, 16,
+    MEND };
+int CVCADD[] = {
+    MREG1, 0xf, 0,
+    MREG1, 0xf0000, 16,
+    MEND };
+
+int CFCMPHSS[] = {
+    MREG2, 0xf0000, 16,
+    MREG2, 0x1e00000, 21,
+    MEND };
+int CFADDS[] = {
+    MREG2, 0xf, 0,
+    MREG2, 0xf0000, 16,
+    MREG2, 0x1e00000, 21,
+    MEND };
+int CVTRCH[] = {
+    MREG1, 0xf, 0,
+    MREG1, 0xf0000, 16,
+    MREG1, 0x1e00000, 21,
+    MEND };
+int CSHLI[] = {
+    MREG1, 0xf, 0,
+    MREG1, 0xf0000, 16,
+    MIMM, 0x1e0000, 21,
+    MEND};
+int CVLDB[] = {
+    MREG1, 0x1e00000, 21,
+    MSPE1, '(',
+    MREG, 0x1f0000, 16,
+    MIMM0H, 0x1f, 0,
+    MSPE, ')',
+    MEND};
+int CVLDH[] = {
+    MREG1, 0x1e00000, 21,
+    MSPE1, '(',
+    MREG, 0x1f0000, 16,
+    MIMM0H, 0x1f, -1,
+    MSPE, ')',
+    MEND};
+int CVLDW[] = {
+    MREG1, 0x1e00000, 21,
+    MSPE1, '(',
+    MREG, 0x1f0000, 16,
+    MIMM0H, 0x1f, -2,
+    MSPE, ')',
+    MEND};
+int CVMTVR[] = {
+    MREG1, 0xf, 0,
+    MBR1, '[',
+    MIMM0, 0x1e00000, 21,
+    MBR, ']',
+    MREG, 0x1F0000, 16,
+    MEND};
+int CVMFVR[] = {
+    MREG, 0x1f, 0,
+    MREG1, 0x1F0000, 16,
+    MBR1, '[',
+    MIMM0, 0x1e00000, 21,
+    MBR, ']',
+    MEND};
+
+int CVDUP[] = {
+    MREG1, 0xf, 0,
+    MREG1, 0xf0000, 16,
+    MBR1, '[',
+    MIMM0, 0x1e00000, 21,
+    MSPE, ']',
+    MEND};
+int CVSHLRI[] = {
+    MREG1, 0XF, 0,
+    MREG1, 0xF0000, 16,
+    MVSHLRI, 0x01e00000, 21, 0x20, 1,
+    MEND };
+int CVLDST[] = {
+    MREG1, 0xF, 0,
+    MSPE1, '(',
+    MREG, 0x1f0000, 16,
+    MVLDSTI, 0x1e00000, 17, 0xf0, 4,
+    MSPE, ')',
+    MEND };
+int CFLDST[] = {
+    MREG2, 0xF, 0,
+    MSPE1, '(',
+    MREG, 0x1f0000, 16,
+    MFLDSTI, 0x1e00000, 17, 0xf0, 4,
+    MSPE, ')',
+    MEND };
+int CVLDSTQ[] = {
+    MREG1, 0xF, 0,
+    MSPE1, '(',
+    MREG, 0x1f0000, 16,
+    MVLDSTQ, 0x1e00000, 17, 0xf0, 4,
+    MSPE, ')',
+    MEND };
+
+int CVLDR[] = {
+    MREG1, 0xf, 0,
+    MSPE1, '(',
+    MREG, 0x1f0000, 16,
+    MREG, 0x03e00000, 21,
+    MSPE, '<',
+    MSPE, '<',
+    MIMM0, 0x60, 5,
+    MSPE, ')',
+    MEND };
+int CFLDRS[] = {
+    MREG2, 0xf, 0,
+    MSPE1, '(',
+    MREG, 0x1f0000, 16,
+    MREG, 0x03e00000, 21,
+    MSPE, '<',
+    MSPE, '<',
+    MIMM0, 0x60, 5,
+    MSPE, ')',
+    MEND };
+int CFMFVR[] = {
+    MREG, 0x1f, 0,
+    MREG2, 0xf0000, 16,
+    MEND };
+int CFMTVR[] = {
+    MREG2, 0xf, 0,
+    MREG, 0x1f0000, 16,
+    MEND };
+
+int CFLDM[] = {
+    MREG2, 0xf, 0,
+    MSPE, '-',
+    MVLDM, 0x1e00000, 21,
+    MSPE1, '(',
+    MREG, 0x1F0000, 16,
+    MSPE, ')',
+    MEND };
+int CVINS[] = {
+    MREG1, 0xf, 0,
+    MBR1, '[',
+    MIMM0, 0x1E0, 5,
+    MBR, ']',
+    MREG1, 0xf0000, 16,
+    MBR1, '[',
+    MIMM0, 0x1e00000, 21,
+    MSPE, ']',
+    MEND};
+int FLRW[] = {
+    MREG2, 0xF, 0,
+    MFLRW, 0x01e00000, 13, 0xf0, 2,
+    MEND };
+int FMOVI[] = {
+    MREG2, 0xF, 0,
+    MFMOVI, 0x1e00000, 17, 0xf0, 4, 0x000f0000, 16, 0x00100000, 20,
+    MEND };
+int BPOP[] = {
+    MREG, 0X1C, 2,
+    MEND };
+
+
+INST_PARSE_INFO *csky_find_inst_info(CSKY_INST_TYPE inst, int length);
+static inline int clog2(int s);
+
+INST_PARSE_INFO csky_inst_info_32[] = {
+    { 0xffffffff, 0xe8cf0000, "rts", CBKPT },
+    { 0xffffffff, 0xc0005020, "doze", CBKPT },
+    { 0xffffffff, 0xc0004420, "rfi", CBKPT },
+    { 0xffffffff, 0xc0004020, "rte", CBKPT },
+    { 0xffffffff, 0xc0005820, "se", CBKPT },
+    { 0xffffffff, 0xc0004820, "stop", CBKPT },
+    { 0xffffffff, 0xc0000420, "sync", CBKPT },
+    { 0xffffffff, 0xc0004c20, "wait", CBKPT },
+    { 0xffffffff, 0xc0005420, "we", CBKPT },
+    { 0xffffffff, 0xc4009820, "mvtc", CBKPT },
+    { 0xffffffff, 0xc0001c20, "idly", CBKPT},
+    { 0xffffffff, 0xc0001020, "bmset", CBKPT},
+    { 0xffffffff, 0xc0001420, "bmclr", CBKPT},
+    { 0xffff0000, 0xe8000000, "br", CBR3 },
+    { 0xffff0000, 0xe8400000, "bf", CBR3 },
+    { 0xffff0000, 0xe8600000, "bt", CBR3 },
+    { 0xfc000000, 0xe0000000, "bsr", CBSR },
+    { 0xfe1fffff, 0xc0001820, "sce", CSCE },
+    { 0xfffff3ff, 0xc0002020, "trap", CTRAP },
+    { 0xfc1fffff, 0xc0007020, "psrclr", CPSRCLR },
+    { 0xfc1fffff, 0xc0007420, "psrset", CPSRCLR },
+    { 0xfc1fffff, 0xc4002c20, "clrf", CCLRF },
+    { 0xfc1fffff, 0xc4002c40, "clrt", CCLRF },
+    { 0xffffffe0, 0xc4009c20, "mfhi", CMFHI },
+    { 0xffffffe0, 0xc4009820, "mfhis", CMFHI },
+    { 0xffffffe0, 0xc4009880, "mflos", CMFHI },
+    { 0xffffffe0, 0xc4009c80, "mflo", CMFHI },
+    { 0xffffffe0, 0xc4000500, "mvc", CMFHI },
+    { 0xffffffe0, 0xc4000600, "mvcv", CMFHI },
+    { 0xffe0ffff, 0xc4009c40, "mthi", CMTHI },
+    { 0xffe0ffff, 0xc4009d00, "mtlo", CMTHI },
+    { 0xffe0ffff, 0xc4002100, "tstnbz", CMTHI },
+    { 0xffe0ffff, 0xe8c00000, "jmp", CMTHI },
+    { 0xffe0ffff, 0xe8e00000, "jsr", CMTHI },
+    { 0xffff0000, 0xeac00000, "jmpi", CJMPI },
+    { 0xffff0000, 0xeae00000, "jsri", CJMPI },
+    { 0xfffff000, 0xfc00c000, "cpop", CCPOP },
+    { 0xfc00f000, 0xfc004000, "cprc", CCPRC },
+    { 0xfc00f000, 0xfc002000, "cprcr", CCPRCR },
+    { 0xfc00f000, 0xfc000000, "cprgr", CCPRCR },
+    { 0xfc00f000, 0xfc003000, "cpwcr", CCPRCR },
+    { 0xfc00f000, 0xfc001000, "cpwgr", CCPRCR },
+    { 0xffe00000, 0xe8000000, "ldcpr", CLDCPR },
+    { 0xffe00000, 0xe8008000, "stcpr", CLDCPR },
+    { 0xffe00000, 0xe9000000, "bez", CBEZ },
+    { 0xffe00000, 0xe9200000, "bnez", CBEZ },
+    { 0xffe00000, 0xe9400000, "bhz", CBEZ },
+    { 0xffe00000, 0xe9600000, "blsz", CBEZ },
+    { 0xffe00000, 0xe9800000, "blz", CBEZ },
+    { 0xffe00000, 0xe9a00000, "bhsz", CBEZ },
+    { 0xffe00000, 0xeb400000, "cmpnei", CCMPNEI },
+    { 0xffe00000, 0xea000000, "movi", CCMPNEI },
+    { 0xffe00000, 0xea200000, "movih", CCMPNEI },
+    { 0xffe00000, 0xeb000000, "cmphsi", CCMPHSI },
+    { 0xffe00000, 0xeb200000, "cmplti", CCMPHSI },
+    { 0xffe0f000, 0xd8006000, "pldr", CPLDR },
+    { 0xffe0f000, 0xdc006000, "pldw", CPLDR },
+    { 0xffe0ffe0, 0xc4005040, "bgenr", CBGENR },
+    { 0xffe0ffe0, 0xc4007020, "xtrb0", CBGENR },
+    { 0xffe0ffe0, 0xc4007040, "xtrb1", CBGENR },
+    { 0xffe0ffe0, 0xc4007080, "xtrb2", CBGENR },
+    { 0xffe0ffe0, 0xc4007100, "xtrb3", CBGENR },
+    { 0xffe0ffe0, 0xc4006200, "brev", CBGENR },
+    { 0xffe0ffe0, 0xc4006080, "revb", CBGENR },
+    { 0xffe0ffe0, 0xc4006100, "revh", CBGENR },
+    { 0xffe0ffe0, 0xc4000200, "abs", CBGENR },
+    { 0xffe0ffe0, 0xc4007c40, "ff1", CBGENR },
+    { 0xffe0ffe0, 0xc4007c20, "ff0", CBGENR },
+    { 0xffe0ffe0, 0xc40058e0, "sextb", CBGENR },
+    { 0xffe0ffe0, 0xc40059e0, "sexth", CBGENR },
+    { 0xffe0ffe0, 0xc40054e0, "zextb", CBGENR },
+    { 0xffe0ffe0, 0xc40055e0, "zexth", CBGENR },
+    { 0xfc00ffff, 0xc4000480, "cmpne", CCMPNE },
+    { 0xfc00ffff, 0xc4000420, "cmphs", CCMPNE },
+    { 0xfc00ffff, 0xc4000440, "cmplt", CCMPNE },
+    { 0xfc00ffff, 0xc4002080, "tst", CCMPNE },
+    { 0xfc00ffff, 0xc4008820, "mulu", CCMPNE },
+    { 0xfc00ffff, 0xc4008840, "mulua", CCMPNE },
+    { 0xfc00ffff, 0xc4008880, "mulus", CCMPNE },
+    { 0xfc00ffff, 0xc4008c20, "muls", CCMPNE },
+    { 0xfc00ffff, 0xc4009040, "mulsha", CCMPNE },
+    { 0xfc00ffff, 0xc4009080, "mulshs", CCMPNE },
+    { 0xfc00ffff, 0xc4008c40, "mulsa", CCMPNE },
+    { 0xfc00ffff, 0xc4008c80, "mulss", CCMPNE },
+    { 0xfc00ffff, 0xc4001c20, "cmpix", CCMPNE },
+    { 0xffe0ffe0, 0xc4000420, "cmpls", CCMPLS },
+    { 0xffe0ffe0, 0xc4000440, "cmpgt", CCMPLS },
+    { 0xfc00ffff, 0xc4002880, "btsti", CBTSTI },
+    { 0xfc1fffe0, 0xc4005020, "bmaski", CBMASKI },
+    { 0xfc00f000, 0xe4000000, "addi", CADDI },
+    { 0xfc00f000, 0xe4001000, "subi", CADDI },
+    { 0xfc1c0000, 0xcc1c0000, "addi", CADDI18 },
+    { 0xfc00f000, 0xe4002000, "andi", CANDI },
+    { 0xfc00f000, 0xe4003000, "andni", CANDI },
+    { 0xfc00f000, 0xe4004000, "xori", CANDI },
+    { 0xfc000000, 0xec000000, "ori", CORI },
+    { 0xfc00f000, 0xd8000000, "ld.b", CLDB },
+    { 0xfc00f000, 0xdc000000, "st.b", CLDB },
+    { 0xfc00f000, 0xd8004000, "ld.bs", CLDB },
+    { 0xfc00f000, 0xd8001000, "ld.h", CLDH },
+    { 0xfc00f000, 0xd8005000, "ld.hs", CLDH },
+    { 0xfc00f000, 0xdc001000, "st.h", CLDH },
+    { 0xfc00f000, 0xd8002000, "ld.w", CLDW },
+    { 0xfc00f000, 0xd8003000, "ld.d", CLDD },
+    { 0xfc00f000, 0xd8007000, "ldex.w", CLDW },
+    { 0xfc00f000, 0xdc002000, "st.w", CLDW },
+    { 0xfc00f000, 0xdc003000, "st.d", CLDD },
+    { 0xfc00f000, 0xdc007000, "stex.w", CLDW },
+    { 0xfc1c0000, 0xcc000000, "lrs.b", CLRSB },
+    { 0xfc1c0000, 0xcc040000, "lrs.h", CLRSH },
+    { 0xfc1c0000, 0xcc080000, "lrs.w", CLRSW },
+    { 0xfc1c0000, 0xcc100000, "srs.b", CLRSB },
+    { 0xfc1c0000, 0xcc140000, "srs.h", CLRSH },
+    { 0xfc1c0000, 0xcc180000, "srs.w", CLRSW },
+    { 0xfc00ffe0, 0xc4000020, "addu", CADDU },
+    { 0xfc00ffe0, 0xc4000040, "addc", CADDU },
+    { 0xfc00ffe0, 0xc4000080, "subu", CADDU },
+    { 0xfc00ffe0, 0xc4000100, "subc", CADDU },
+    { 0xfc00ffe0, 0xc4000820, "ixh", CADDU },
+    { 0xfc00ffe0, 0xc4000840, "ixw", CADDU },
+    { 0xfc00ffe0, 0xc4000880, "ixd", CADDU },
+    { 0xfc00ffe0, 0xc4002020, "and", CADDU },
+    { 0xfc00ffe0, 0xc4002040, "andn", CADDU },
+    { 0xfc00ffe0, 0xc4002420, "or", CADDU },
+    { 0xfc00ffe0, 0xc4002440, "xor", CADDU },
+    { 0xfc00ffe0, 0xc4002480, "nor", CADDU },
+    { 0xfc00ffe0, 0xc4004020, "lsl", CADDU },
+    { 0xfc00ffe0, 0xc4004040, "lsr", CADDU },
+    { 0xfc00ffe0, 0xc4004080, "asr", CADDU },
+    { 0xfc00ffe0, 0xc4004100, "rotl", CADDU },
+    { 0xfc00ffe0, 0xc4008020, "divu", CADDU },
+    { 0xfc00ffe0, 0xc4008040, "divs", CADDU },
+    { 0xfc00ffe0, 0xc4008420, "mult", CADDU },
+    { 0xfc00ffe0, 0xc4009420, "mulsw", CADDU },
+    { 0xfc00ffe0, 0xc4009020, "mulsh", CADDU },
+    { 0xfc00ffe0, 0xc4000080, "rsub", CRSUB },
+    { 0xfc00ffe0, 0xc4000c20, "incf", CINCF },
+    { 0xfc00ffe0, 0xc4000c40, "inct", CINCF },
+    { 0xfc00ffe0, 0xc4000c80, "decf", CINCF },
+    { 0xfc00ffe0, 0xc4000d00, "dect", CINCF },
+    { 0xfc00ffe0, 0xc4001020, "decgt", CDECGT },
+    { 0xfc00ffe0, 0xc4001040, "declt", CDECGT },
+    { 0xfc00ffe0, 0xc4001080, "decne", CDECGT },
+    { 0xfc00ffe0, 0xc4004820, "lsli",  CDECGT },
+    { 0xfc00ffe0, 0xc4004840, "lsri",  CDECGT },
+    { 0xfc00ffe0, 0xc4004880, "asri",  CDECGT },
+    { 0xfc00ffe0, 0xc4004900, "rotli", CDECGT },
+    { 0xfc00ffe0, 0xc4002820, "bclri", CDECGT },
+    { 0xfc00ffe0, 0xc4002840, "bseti", CDECGT },
+    { 0xfc00ffe0, 0xc4004c80, "asrc", CSRC },
+    { 0xfc00ffe0, 0xc4004d00, "xsr", CSRC },
+    { 0xfc00ffe0, 0xc4004c20, "lslc", CSRC },
+    { 0xfc00ffe0, 0xc4004c40, "lsrc", CSRC },
+    { 0xfc00fc00, 0xc4005c00, "ins", CINS },
+    { 0xfc00fc00, 0xc4005800, "sext", CSEXT },
+    { 0xfc00fc00, 0xc4005400, "zext", CSEXT },
+    { 0xfc00ffe0, 0xd0001c20, "ldm", CLDM },
+    { 0xfc00ffe0, 0xd4001c20, "stm", CLDM },
+    { 0xfc00fe00, 0xd0000400, "ldr.h", CLDRH },
+    { 0xfc00fe00, 0xd0000800, "ldr.w", CLDRH },
+    { 0xfc00fe00, 0xd0001000, "ldr.bs", CLDRH },
+    { 0xfc00fe00, 0xd0001400, "ldr.hs", CLDRH },
+    { 0xfc00fe00, 0xd4000000, "str.b", CLDRH },
+    { 0xfc00fe00, 0xd4000400, "str.h", CLDRH },
+    { 0xfc00fe00, 0xd4000800, "str.w", CLDRH },
+    { 0xfc00fe00, 0xd0000000, "ldr.b", CLDRH },
+    { 0xfc00ffe0, 0xc0006020, "mfcr", CMFCR },
+    { 0xfc00ffe0, 0xc0006420, "mtcr", CMTCR },
+    { 0xffe00000, 0xea800000, "lrw", CLRW},
+    { 0xffe00000, 0xe4000000, "cprgr", PSEUDO },
+    { 0xffe00000, 0xe4400000, "cprgr", PSEUDO },
+    { 0xffe00000, 0xe4200000, "cpwcr", PSEUDO },
+    { 0xffe00000, 0xe4600000, "cpwgr", PSEUDO },
+    { 0xfc1c0000, 0xcc0c0000, "grs", CGRS},
+    { 0xfffffc00, 0xebc00000, "pop", CPOP},
+    { 0xfffffc00, 0xebe00000, "push", CPOP},
+    { 0xffe0fffc, 0xe9e00000, "jmpix", CJMPIX},
+    /* vfp vdsp */
+    { 0xfff0ffff, 0xf4000100, "fcmpzhss",      CFMPZHSS},
+    { 0xfff0ffff, 0xf4000120, "fcmpzlss",      CFMPZHSS},
+    { 0xfff0ffff, 0xf4000140, "fcmpznes",      CFMPZHSS},
+    { 0xfff0ffff, 0xf4000160, "fcmpzuos",      CFMPZHSS},
+    { 0xfff0ffff, 0xf4000900, "fcmpzhsd",      CFMPZHSS},
+    { 0xfff0ffff, 0xf4000920, "fcmpzlsd",      CFMPZHSS},
+    { 0xfff0ffff, 0xf4000940, "fcmpzned",      CFMPZHSS},
+    { 0xfff0ffff, 0xf4000960, "fcmpzuod",      CFMPZHSS},
+    { 0xfff0fff0, 0xf4001800, "fstosi.rn",     CFSITOS },
+    { 0xfff0fff0, 0xf4001820, "fstosi.rz",     CFSITOS },
+    { 0xfff0fff0, 0xf4001840, "fstosi.rpi",    CFSITOS },
+    { 0xfff0fff0, 0xf4001860, "fstosi.rni",    CFSITOS },
+    { 0xfff0fff0, 0xf4001880, "fstoui.rn",     CFSITOS },
+    { 0xfff0fff0, 0xf40018a0, "fstoui.rz",     CFSITOS },
+    { 0xfff0fff0, 0xf40018c0, "fstoui.rpi",    CFSITOS },
+    { 0xfff0fff0, 0xf40018e0, "fstoui.rni",    CFSITOS },
+    { 0xfff0fff0, 0xf4001900, "fdtosi.rn",     CFSITOS },
+    { 0xfff0fff0, 0xf4001920, "fdtosi.rz",     CFSITOS },
+    { 0xfff0fff0, 0xf4001940, "fdtosi.rpi",    CFSITOS },
+    { 0xfff0fff0, 0xf4001960, "fdtosi.rni",    CFSITOS },
+    { 0xfff0fff0, 0xf4001980, "fdtoui.rn",     CFSITOS },
+    { 0xfff0fff0, 0xf40019a0, "fdtoui.rz",     CFSITOS },
+    { 0xfff0fff0, 0xf40019c0, "fdtoui.rpi",    CFSITOS },
+    { 0xfff0fff0, 0xf40019e0, "fdtoui.rni",    CFSITOS },
+    { 0xfff0fff0, 0xf4001a00, "fsitos",        CFSITOS },
+    { 0xfff0fff0, 0xf4001a20, "fuitos",        CFSITOS },
+    { 0xfff0fff0, 0xf4001a80, "fsitod",        CFSITOS },
+    { 0xfff0fff0, 0xf4001aa0, "fuitod",        CFSITOS },
+    { 0xfff0fff0, 0xf4001ac0, "fdtos" ,        CFSITOS },
+    { 0xfff0fff0, 0xf4001ae0, "fstod" ,        CFSITOS },
+    { 0xfff0fff0, 0xf4000080, "fmovs" ,        CFSITOS },
+    { 0xfff0fff0, 0xf40000c0, "fabss" ,        CFSITOS },
+    { 0xfff0fff0, 0xf40000e0, "fnegs" ,        CFSITOS },
+    { 0xfff0fff0, 0xf4000340, "fsqrts",        CFSITOS },
+    { 0xfff0fff0, 0xf4000320, "frecips",       CFSITOS },
+    { 0xfff0fff0, 0xf40010c0, "fabsm",         CFSITOS },
+    { 0xfff0fff0, 0xf40010e0, "fnegm" ,        CFSITOS },
+    { 0xfff0fff0, 0xf4000880, "fmovd" ,        CFSITOS },
+    { 0xfff0fff0, 0xf4001080, "fmovm" ,        CFSITOS },
+    { 0xfff0fff0, 0xf40008c0, "fabsd",         CFSITOS },
+    { 0xfff0fff0, 0xf40008e0, "fnegd",         CFSITOS },
+    { 0xfff0fff0, 0xf4000b40, "fsqrtd",        CFSITOS },
+    { 0xfff0fff0, 0xf4000b20, "frecipd",       CFSITOS },
+    { 0xfe10ffff, 0xf4000180, "fcmphss",      CFCMPHSS },
+    { 0xfe10ffff, 0xf40001a0, "fcmplts",      CFCMPHSS },
+    { 0xfe10ffff, 0xf40001c0, "fcmpnes",      CFCMPHSS },
+    { 0xfe10ffff, 0xf40001e0, "fcmpuos",      CFCMPHSS },
+    { 0xfe10ffff, 0xf4000980, "fcmphsd",      CFCMPHSS },
+    { 0xfe10ffff, 0xf40009a0, "fcmpltd",      CFCMPHSS },
+    { 0xfe10ffff, 0xf40009c0, "fcmpned",      CFCMPHSS },
+    { 0xfe10ffff, 0xf40009e0, "fcmpuod",      CFCMPHSS },
+    { 0xfe10fff0, 0xf4000000, "fadds",          CFADDS },
+    { 0xfe10fff0, 0xf4000020, "fsubs",          CFADDS },
+    { 0xfe10fff0, 0xf4000200, "fmuls",          CFADDS },
+    { 0xfe10fff0, 0xf4000300, "fdivs",          CFADDS },
+    { 0xfe10fff0, 0xf4000280, "fmacs",          CFADDS },
+    { 0xfe10fff0, 0xf40002a0, "fmscs",          CFADDS },
+    { 0xfe10fff0, 0xf40002c0, "fnmacs",         CFADDS },
+    { 0xfe10fff0, 0xf40002e0, "fnmscs",         CFADDS },
+    { 0xfe10fff0, 0xf4000220, "fnmuls",         CFADDS },
+    { 0xfe10fff0, 0xf4000800, "faddd",          CFADDS },
+    { 0xfe10fff0, 0xf4000820, "fsubd",          CFADDS },
+    { 0xfe10fff0, 0xf4000a00, "fmuld",          CFADDS },
+    { 0xfe10fff0, 0xf4000b00, "fdivd",          CFADDS },
+    { 0xfe10fff0, 0xf4000a80, "fmacd",          CFADDS },
+    { 0xfe10fff0, 0xf4000aa0, "fmscd",          CFADDS },
+    { 0xfe10fff0, 0xf4000ac0, "fnmacd",         CFADDS },
+    { 0xfe10fff0, 0xf4000ae0, "fnmscd",         CFADDS },
+    { 0xfe10fff0, 0xf4000a20, "fnmuld",         CFADDS },
+    { 0xfe10fff0, 0xf4001000, "faddm",          CFADDS },
+    { 0xfe10fff0, 0xf4001020, "fsubm",          CFADDS },
+    { 0xfe10fff0, 0xf4001200, "fmulm",          CFADDS },
+    { 0xfe10fff0, 0xf4001280, "fmacm",          CFADDS },
+    { 0xfe10fff0, 0xf40012a0, "fmscm",          CFADDS },
+    { 0xfe10fff0, 0xf40012c0, "fnmacm",         CFADDS },
+    { 0xfe10fff0, 0xf40012e0, "fnmscm",         CFADDS },
+    { 0xfe10fff0, 0xf4001220, "fnmulm",         CFADDS },
+    { 0xfe10fff0, 0xf8000f40, "vtrch.8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100f40, "vtrch.16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000f40, "vtrch.32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000f60, "vtrcl.8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100f60, "vtrcl.16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000f60, "vtrcl.32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000000, "vadd.u8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100000, "vadd.u16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000000, "vadd.u32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000010, "vadd.s8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100010, "vadd.s16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000010, "vadd.s32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000020, "vadd.eu8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100020, "vadd.eu16",      CVTRCH },
+    { 0xfe10fff0, 0xf8000030, "vadd.es8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100030, "vadd.es16",      CVTRCH },
+    { 0xfe10fff0, 0xf8000040, "vcadd.u8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100040, "vcadd.u16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000040, "vcadd.u32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000050, "vcadd.s8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100050, "vcadd.s16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000050, "vcadd.s32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000060, "vcadd.eu8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100060, "vcadd.eu16",     CVTRCH },
+    { 0xfe10fff0, 0xf8000070, "vcadd.es8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100070, "vcadd.es16",     CVTRCH },
+    { 0xfe10fff0, 0xf8100140, "vadd.xu16.sl",   CVTRCH },
+    { 0xfe10fff0, 0xfa000140, "vadd.xu32.sl",   CVTRCH },
+    { 0xfe10fff0, 0xf8100150, "vadd.xs16.sl",   CVTRCH },
+    { 0xfe10fff0, 0xfa000150, "vadd.xs32.sl",   CVTRCH },
+    { 0xfe10fff0, 0xf8100160, "vadd.xu16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000160, "vadd.xu32",      CVTRCH },
+    { 0xfe10fff0, 0xf8100170, "vadd.xs16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000170, "vadd.xs32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000180, "vaddh.u8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100180, "vaddh.u16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000180, "vaddh.u32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000190, "vaddh.s8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100190, "vaddh.s16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000190, "vaddh.s32",      CVTRCH },
+    { 0xfe10fff0, 0xf80001a0, "vaddh.u8.r",     CVTRCH },
+    { 0xfe10fff0, 0xf81001a0, "vaddh.u16.r",    CVTRCH },
+    { 0xfe10fff0, 0xfa0001a0, "vaddh.u32.r",    CVTRCH },
+    { 0xfe10fff0, 0xf80001b0, "vaddh.s8.r",     CVTRCH },
+    { 0xfe10fff0, 0xf81001b0, "vaddh.s16.r",    CVTRCH },
+    { 0xfe10fff0, 0xfa0001b0, "vaddh.s32.r",    CVTRCH },
+    { 0xfe10fff0, 0xf80001c0, "vadd.u8.s",      CVTRCH },
+    { 0xfe10fff0, 0xf81001c0, "vadd.u16.s",     CVTRCH },
+    { 0xfe10fff0, 0xfa0001c0, "vadd.u32.s",     CVTRCH },
+    { 0xfe10fff0, 0xf80001d0, "vadd.s8.s",      CVTRCH },
+    { 0xfe10fff0, 0xf81001d0, "vadd.s16.s",     CVTRCH },
+    { 0xfe10fff0, 0xfa0001d0, "vadd.s32.s",     CVTRCH },
+    { 0xfe10fff0, 0xf8000200, "vsub.u8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100200, "vsub.u16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000200, "vsub.u32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000210, "vsub.s8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100210, "vsub.s16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000210, "vsub.s32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000220, "vsub.eu8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100220, "vsub.eu16",      CVTRCH },
+    { 0xfe10fff0, 0xf8000230, "vsub.es8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100230, "vsub.es16",      CVTRCH },
+    { 0xfe10fff0, 0xf8000240, "vsabs.u8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100240, "vsabs.u16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000240, "vsabs.u32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000250, "vsabs.s8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100250, "vsabs,s16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000250, "vsabs.s32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000260, "vsabs.eu8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100260, "vsabs.eu16",     CVTRCH },
+    { 0xfe10fff0, 0xf8000270, "vsabs.es8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100270, "vsabs.es16",     CVTRCH },
+    { 0xfe10fff0, 0xf8000280, "vsabsa.u8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100280, "vsabsa.u16",     CVTRCH },
+    { 0xfe10fff0, 0xfa000280, "vsabsa.u32",     CVTRCH },
+    { 0xfe10fff0, 0xf8000290, "vsabsa.s8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100290, "vsabsa.s16",     CVTRCH },
+    { 0xfe10fff0, 0xfa000290, "vsabsa.s32",     CVTRCH },
+    { 0xfe10fff0, 0xf80002a0, "vsabsa.eu8",     CVTRCH },
+    { 0xfe10fff0, 0xf81002a0, "vsabsa.eu16",    CVTRCH },
+    { 0xfe10fff0, 0xf80002b0, "vsabsa.es8",     CVTRCH },
+    { 0xfe10fff0, 0xf81002b0, "vsabsa.es16",    CVTRCH },
+    { 0xfe10fff0, 0xf8100360, "vsub.xu16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000360, "vsub.xu32",      CVTRCH },
+    { 0xfe10fff0, 0xf8100370, "vsub.xs16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000370, "vsub.xs32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000380, "vsubh.u8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100380, "vsubh.u16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000380, "vsubh.u32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000390, "vsubh.s8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100390, "vsubh.s16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000390, "vsubh.s32",      CVTRCH },
+    { 0xfe10fff0, 0xf80003a0, "vsubh.u8.r",     CVTRCH },
+    { 0xfe10fff0, 0xf81003a0, "vsubh.u16.r",    CVTRCH },
+    { 0xfe10fff0, 0xfa0003a0, "vsubh.u32.r",    CVTRCH },
+    { 0xfe10fff0, 0xf80003b0, "vsubh.s8.r",     CVTRCH },
+    { 0xfe10fff0, 0xf81003b0, "vsubh.s16.r",    CVTRCH },
+    { 0xfe10fff0, 0xfa0003b0, "vsubh.s32.r",    CVTRCH },
+    { 0xfe10fff0, 0xf80003c0, "vsub.u8.s",      CVTRCH },
+    { 0xfe10fff0, 0xf81003c0, "vsub.u16.s",     CVTRCH },
+    { 0xfe10fff0, 0xfa0003c0, "vsub.u32.s",     CVTRCH },
+    { 0xfe10fff0, 0xf80003d0, "vsub.s8.s",      CVTRCH },
+    { 0xfe10fff0, 0xf81003d0, "vsub.s16.s",     CVTRCH },
+    { 0xfe10fff0, 0xfa0003d0, "vsub.s32.s",     CVTRCH },
+    { 0xfe10fff0, 0xf8000400, "vmul.u8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100400, "vmul.u16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000400, "vmul.u32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000410, "vmul.s8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100410, "vmul.s16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000410, "vmul.s32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000420, "vmul.eu8.h",     CVTRCH },
+    { 0xfe10fff0, 0xf8100420, "vmul.eu16.h",    CVTRCH },
+    { 0xfe10fff0, 0xfa000420, "vmul.eu32.h",    CVTRCH },
+    { 0xfe10fff0, 0xf8000430, "vmul.es8.h",     CVTRCH },
+    { 0xfe10fff0, 0xf8100430, "vmul.es16.h",    CVTRCH },
+    { 0xfe10fff0, 0xfa000430, "vmul.es32.h",    CVTRCH },
+    { 0xfe10fff0, 0xf8000440, "vmula.u8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100440, "vmula.u16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000440, "vmula.u32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000440, "vmula.s8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100450, "vmula.s16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000450, "vmula.s32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000460, "vmula.eu8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100460, "vmula.eu16",     CVTRCH },
+    { 0xfe10fff0, 0xfa000460, "vmula.eu32",     CVTRCH },
+    { 0xfe10fff0, 0xf8000470, "vmula.es8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100470, "vmula.es16",     CVTRCH },
+    { 0xfe10fff0, 0xf8000480, "vmuls.u8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100480, "vmuls.u16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000480, "vmuls.u32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000490, "vmuls.s8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100490, "vmuls.s16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000490, "vmuls.s32",      CVTRCH },
+    { 0xfe10fff0, 0xf80004a0, "vmuls.eu8",      CVTRCH },
+    { 0xfe10fff0, 0xf81004a0, "vmuls.eu16",     CVTRCH },
+    { 0xfe10fff0, 0xf80004b0, "vmuls.es8",      CVTRCH },
+    { 0xfe10fff0, 0xf81004b0, "vmuls.es16",     CVTRCH },
+    { 0xfe10fff0, 0xf8000680, "vshr.u8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100680, "vshr.u16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000680, "vshr.u32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000690, "vshr.s8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100690, "vshr.s16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000690, "vshr.s32",       CVTRCH },
+    { 0xfe10fff0, 0xf80006c0, "vshr.u8.r",      CVTRCH },
+    { 0xfe10fff0, 0xf81006c0, "vshr.u16.r",     CVTRCH },
+    { 0xfe10fff0, 0xfa0006c0, "vshr.u32.r",     CVTRCH },
+    { 0xfe10fff0, 0xf80006d0, "vshr.s8.r",      CVTRCH },
+    { 0xfe10fff0, 0xf81006d0, "vshr.s16.r",     CVTRCH },
+    { 0xfe10fff0, 0xfa0006d0, "vshr.s32.r",     CVTRCH },
+    { 0xfe10fff0, 0xf8000780, "vshl.u8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100780, "vshl.u16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000780, "vshl.u32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000790, "vshl.s8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100790, "vshl.s16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000790, "vshl.s32",       CVTRCH },
+    { 0xfe10fff0, 0xf80007c0, "vshl.u8.s",      CVTRCH },
+    { 0xfe10fff0, 0xf81007c0, "vshl.u16.s",     CVTRCH },
+    { 0xfe10fff0, 0xfa0007c0, "vshl.u32.s",     CVTRCH },
+    { 0xfe10fff0, 0xf80007d0, "vshl.s8.s",      CVTRCH },
+    { 0xfe10fff0, 0xf81007d0, "vshl.s16.s",     CVTRCH },
+    { 0xfe10fff0, 0xfa0007d0, "vshl.s32.s",     CVTRCH },
+    { 0xfe10fff0, 0xf8000800, "vcmphs.u8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100800, "vcmphs.u16",     CVTRCH },
+    { 0xfe10fff0, 0xfa000800, "vcmphs.u32",     CVTRCH },
+    { 0xfe10fff0, 0xf8000810, "vcmphs.s8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100810, "vcmpsh.s16",     CVTRCH },
+    { 0xfe10fff0, 0xfa000810, "vcmpsh.s32",     CVTRCH },
+    { 0xfe10fff0, 0xf8000820, "vcmplt.u8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100820, "vcmplt.u16",     CVTRCH },
+    { 0xfe10fff0, 0xfa000820, "vcmplt.u32",     CVTRCH },
+    { 0xfe10fff0, 0xf8000830, "vcmplt.s8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100830, "vcmplt.s16",     CVTRCH },
+    { 0xfe10fff0, 0xfa000830, "vcmplt.s32",     CVTRCH },
+    { 0xfe10fff0, 0xf8100840, "vcmpne.u8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100840, "vcmpne.u16",     CVTRCH },
+    { 0xfe10fff0, 0xfa000840, "vcmpne.u32",     CVTRCH },
+    { 0xfe10fff0, 0xf8000850, "vcmpne.s8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100850, "vcmpne.s16",     CVTRCH },
+    { 0xfe10fff0, 0xfa000850, "vcmpne.s32",     CVTRCH },
+    { 0xfe10fff0, 0xf8000880, "vcmphsz.u8",     CVTRCH },
+    { 0xfe10fff0, 0xf8100880, "vcmphsz.u16",    CVTRCH },
+    { 0xfe10fff0, 0xfa000880, "vcmphsz.u32",    CVTRCH },
+    { 0xfe10fff0, 0xf8000890, "vcmphsz.s8",     CVTRCH },
+    { 0xfe10fff0, 0xf8100890, "vcmphsz.s16",    CVTRCH },
+    { 0xfe10fff0, 0xfa000890, "vcmphsz.s32",    CVTRCH },
+    { 0xfe10fff0, 0xf80008a0, "vcmpltz.u8",     CVTRCH },
+    { 0xfe10fff0, 0xf81008a0, "vcmpltz.u16",    CVTRCH },
+    { 0xfe10fff0, 0xfa0008a0, "vcmpltz.u32",    CVTRCH },
+    { 0xfe10fff0, 0xf80008b0, "vcmpltz.s8",     CVTRCH },
+    { 0xfe10fff0, 0xf81008b0, "vcmpltz.s16",    CVTRCH },
+    { 0xfe10fff0, 0xfa0008b0, "vcmpltz.s32",    CVTRCH },
+    { 0xfe10fff0, 0xf80008c0, "vcmpnez.u8",     CVTRCH },
+    { 0xfe10fff0, 0xf81008c0, "vcmpnez.u16",    CVTRCH },
+    { 0xfe10fff0, 0xfa0008c0, "vcmpnez.u32",    CVTRCH },
+    { 0xfe10fff0, 0xf80008d0, "vcmpnez.s8",     CVTRCH },
+    { 0xfe10fff0, 0xf81008d0, "vcmpnez.s16",    CVTRCH },
+    { 0xfe10fff0, 0xfa0008d0, "vcmpnez.s32",    CVTRCH },
+    { 0xfe10fff0, 0xf8000900, "vmax.u8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100900, "vmax.u16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000900, "vmax.u32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000910, "vmax.s8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100910, "vmax.s16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000910, "vmax.s32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000920, "vmin.u8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100920, "vmin.u16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000920, "vmin.u32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000930, "vmin.s8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100930, "vmin.s16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000930, "vmin.s32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000980, "vcmax.u8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100980, "vcmax.u16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000980, "vcmax.u32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000990, "vcmax.s8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100990, "vcmax.s16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000990, "vcmax.s32",      CVTRCH },
+    { 0xfe10fff0, 0xf80009a0, "vcmin.u8",       CVTRCH },
+    { 0xfe10fff0, 0xf81009a0, "vcmin.u16",      CVTRCH },
+    { 0xfe10fff0, 0xfa0009a0, "vcmin.u32",      CVTRCH },
+    { 0xfe10fff0, 0xf80009b0, "vcmin.s8",       CVTRCH },
+    { 0xfe10fff0, 0xf81009b0, "vcmin.s16",      CVTRCH },
+    { 0xfe10fff0, 0xfa0009b0, "vcmin.s32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000a00, "vand.8",         CVTRCH },
+    { 0xfe10fff0, 0xf8100a00, "vand.16",        CVTRCH },
+    { 0xfe10fff0, 0xfa000a00, "vand.32",        CVTRCH },
+    { 0xfe10fff0, 0xf8000a20, "vandn.8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100a20, "vandn.16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000a20, "vandn.32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000a40, "vor.8",          CVTRCH },
+    { 0xfe10fff0, 0xf8100a40, "vor.16",         CVTRCH },
+    { 0xfe10fff0, 0xfa000a40, "vor.32",         CVTRCH },
+    { 0xfe10fff0, 0xf8000a60, "vnor.8",         CVTRCH },
+    { 0xfe10fff0, 0xf8100a60, "vnor.16",        CVTRCH },
+    { 0xfe10fff0, 0xfa000a60, "vnor.32",        CVTRCH },
+    { 0xfe10fff0, 0xf8000a80, "vxor.8",         CVTRCH },
+    { 0xfe10fff0, 0xf8100a80, "vxor.16",        CVTRCH },
+    { 0xfe10fff0, 0xfa000a80, "vxor.32",        CVTRCH },
+    { 0xfe10fff0, 0xf8000b20, "vtst.8",         CVTRCH },
+    { 0xfe10fff0, 0xf8100b20, "vtst.16",        CVTRCH },
+    { 0xfe10fff0, 0xfa000b20, "vtst.32",        CVTRCH },
+    { 0xfe10fff0, 0xf8000f00, "vbpermz.8",      CVTRCH },
+    { 0xfe10fff0, 0xf8100f00, "vbpermz.16",     CVTRCH },
+    { 0xfe10fff0, 0xfa000f00, "vbpermz.32",     CVTRCH },
+    { 0xfe10fff0, 0xf8000f20, "vbperm.8",       CVTRCH },
+    { 0xfe10fff0, 0xf8100f20, "vbperm.16",      CVTRCH },
+    { 0xfe10fff0, 0xfa000f20, "vbperm.32",      CVTRCH },
+    { 0xfe10fff0, 0xf8000fc0,  "vdch.8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100fc0,  "vdch.16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000fc0,  "vdch.32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000fe0,  "vdcl.8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100fe0,  "vdcl.16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000fe0,  "vdcl.32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000f80,  "vich.8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100f80,  "vich.16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000f80,  "vich.32",       CVTRCH },
+    { 0xfe10fff0, 0xf8000fa0,  "vicl.8",        CVTRCH },
+    { 0xfe10fff0, 0xf8100fa0,  "vicl.16",       CVTRCH },
+    { 0xfe10fff0, 0xfa000fa0,  "vicl.32",       CVTRCH },
+    { 0xfe00ff00, 0xf8002000,  "vldd.8",        CVLDST },
+    { 0xfe00ff00, 0xf8002100,  "vldd.16",       CVLDST },
+    { 0xfe00ff00, 0xf8002200,  "vldd.32",       CVLDST },
+    { 0xfe00ff00, 0xf8002400,  "vldq.8",        CVLDSTQ},
+    { 0xfe00ff00, 0xf8002500,  "vldq.16",       CVLDSTQ},
+    { 0xfe00ff00, 0xf8002600,  "vldq.32",       CVLDSTQ},
+    { 0xfe00ff00, 0xf8002800,  "vstd.8",        CVLDST },
+    { 0xfe00ff00, 0xf8002900,  "vstd.16",       CVLDST },
+    { 0xfe00ff00, 0xf8002a00,  "vstd.32",       CVLDST },
+    { 0xfe00ff00, 0xf8002c00,  "vstq.8",        CVLDSTQ},
+    { 0xfe00ff00, 0xf8002d00,  "vstq.16",       CVLDSTQ},
+    { 0xfe00ff00, 0xf8002e00,  "vstq.32",       CVLDSTQ},
+    { 0xfc00ff90, 0xf8003000,  "vldrd.8",        CVLDR },
+    { 0xfc00ff90, 0xf8003100,  "vldrd.16",       CVLDR },
+    { 0xfc00ff90, 0xf8003200,  "vldrd.32",       CVLDR },
+    { 0xfc00ff90, 0xf8003400,  "vldrq.8",        CVLDR },
+    { 0xfc00ff90, 0xf8003500,  "vldrq.16",       CVLDR },
+    { 0xfc00ff90, 0xf8003600,  "vldrq.32",       CVLDR },
+    { 0xfc00ff90, 0xf8003800,  "vstrd.8",        CVLDR },
+    { 0xfc00ff90, 0xf8003900,  "vstrd.16",       CVLDR },
+    { 0xfc00ff90, 0xf8003a00,  "vstrd.32",       CVLDR },
+    { 0xfc00ff90, 0xf8003c00,  "vstrq.8",        CVLDR },
+    { 0xfc00ff90, 0xf8003d00,  "vstrq.16",       CVLDR },
+    { 0xfc00ff90, 0xf8003e00,  "vstrq.32",       CVLDR },
+    { 0xfc00ff90, 0xf4002800,   "fldrs",         CFLDRS},
+    { 0xfc00ff90, 0xf4002c00,   "fstrs",         CFLDRS},
+    { 0xfc00ff90, 0xf4002900,   "fldrd",         CFLDRS},
+    { 0xfc00ff90, 0xf4002d00,   "fstrd",         CFLDRS},
+    { 0xfc00ff90, 0xf4002a00,   "fldrm",         CFLDRS},
+    { 0xfc00ff90, 0xf4002e00,   "fstrm",         CFLDRS},
+    { 0xfe00ff00, 0xf4002000,   "flds",          CFLDST},
+    { 0xfe00ff00, 0xf4002400,   "fsts",          CFLDST},
+    { 0xfe00ff00, 0xf4002100,   "fldd",          CFLDST},
+    { 0xfe00ff00, 0xf4002500,   "fstd",          CFLDST},
+    { 0xfe00ff00, 0xf4002200,   "fldm",          CFLDST},
+    { 0xfe00ff00, 0xf4002600,   "fstm",          CFLDST},
+    { 0xfe00fff0, 0xf4003000,   "fldms",         CFLDM },
+    { 0xfe00fff0, 0xf4003400,   "fstms",         CFLDM },
+    { 0xfe00fff0, 0xf4003100,   "fldmd",         CFLDM },
+    { 0xfe00fff0, 0xf4003500,   "fstmd",         CFLDM },
+    { 0xfe00fff0, 0xf4003600,   "fstmm",         CFLDM },
+    { 0xfe00fff0, 0xf4003200,   "fldmm",         CFLDM },
+    { 0Xfff0fff0, 0xf8000060, "vcadd.eu8",       CVCADD},
+    { 0Xfff0fff0, 0xf8100060, "vcadd.eu16",      CVCADD},
+    { 0Xfff0fff0, 0xf8000070, "vcadd.es8",       CVCADD},
+    { 0Xfff0fff0, 0xf8100070, "vcadd.es16",      CVCADD},
+    { 0xfff0fff0, 0xf8000c00, "vmov",            CVCADD},
+    { 0xfff0fff0, 0xf8000c20, "vmov.eu8",        CVCADD},
+    { 0xfff0fff0, 0xf8100c20, "vmov.eu16",       CVCADD},
+    { 0xfff0fff0, 0xf8000c30, "vmov.es8",        CVCADD},
+    { 0xfff0fff0, 0xf8100c30, "vmov.es16",       CVCADD},
+    { 0xfff0fff0, 0xf8100d00, "vmov.u16.l",      CVCADD},
+    { 0xfff0fff0, 0xfa000d00, "vmov.u32.l",      CVCADD},
+    { 0xfff0fff0, 0xf8100d10, "vmov.s16.l",      CVCADD},
+    { 0xfff0fff0, 0xfa000d10, "vmov.s32.l",      CVCADD},
+    { 0xfff0fff0, 0xf8100d40, "vmov.u16.sl",     CVCADD},
+    { 0xfff0fff0, 0xfa000d40, "vmov.u32.sl",     CVCADD},
+    { 0xfff0fff0, 0xf8100d50, "vmov.s16.sl",     CVCADD},
+    { 0xfff0fff0, 0xfa000d50, "vmov.s32.sl",     CVCADD},
+    { 0xfff0fff0, 0xf8100d60, "vmov.u16.h",      CVCADD},
+    { 0xfff0fff0, 0xfa000d60, "vmov.u32.h",      CVCADD},
+    { 0xfff0fff0, 0xf8100d70, "vmov.s16.h",      CVCADD},
+    { 0xfff0fff0, 0xfa000d70, "vmov.s32.h",      CVCADD},
+    { 0xfff0fff0, 0xf8100d80, "vmov.u16.rh",     CVCADD},
+    { 0xfff0fff0, 0xfa000d80, "vmov.u32.rh",     CVCADD},
+    { 0xfff0fff0, 0xf8100d90, "vmov.s16.rh",     CVCADD},
+    { 0xfff0fff0, 0xfa000d90, "vmov.s32.rh",     CVCADD},
+    { 0xfff0fff0, 0xf8100dc0, "vstou.u16.sl",    CVCADD},
+    { 0xfff0fff0, 0xfa000dc0, "vstou.u32.sl",    CVCADD},
+    { 0xfff0fff0, 0xf8100dd0, "vstou.s16.sl",    CVCADD},
+    { 0xfff0fff0, 0xfa000dd0, "vstou.s32.sl",    CVCADD},
+    { 0xfff0fff0, 0xf8000e60, "vrev.8",          CVCADD},
+    { 0xfff0fff0, 0xf8100e60, "vrev.16",         CVCADD},
+    { 0xfff0fff0, 0xfa000e60, "vrev.32",         CVCADD},
+    { 0xfff0fff0, 0xf8000ea0, "vcnt1.8",         CVCADD},
+    { 0xfff0fff0, 0xf8000ec0, "vclz.8",          CVCADD},
+    { 0xfff0fff0, 0xf8100ec0, "vclz.16",         CVCADD},
+    { 0xfff0fff0, 0xfa000ec0, "vclz.32",         CVCADD},
+    { 0xfff0fff0, 0xf8000ee0, "vcls.u8",         CVCADD},
+    { 0xfff0fff0, 0xf8100ee0, "vcls.u16",        CVCADD},
+    { 0xfff0fff0, 0xfa000ee0, "vcls.u32",        CVCADD},
+    { 0xfff0fff0, 0xf8000ef0, "vcls.s8",         CVCADD},
+    { 0xfff0fff0, 0xf8100ef0, "vcls.s16",        CVCADD},
+    { 0xfff0fff0, 0xfa000ef0, "vcls.s32",        CVCADD},
+    { 0xfff0fff0, 0xf8001000, "vabs.u8",         CVCADD},
+    { 0xfff0fff0, 0xf8101000, "vabs.u16",        CVCADD},
+    { 0xfff0fff0, 0xfa001000, "vabs.u32",        CVCADD},
+    { 0xfff0fff0, 0xf8001010, "vabs.s8",         CVCADD},
+    { 0xfff0fff0, 0xf8101010, "vabs.s16",        CVCADD},
+    { 0xfff0fff0, 0xfa001010, "vabs.s32",        CVCADD},
+    { 0xfff0fff0, 0xf8001040, "vabs.u8.s",       CVCADD},
+    { 0xfff0fff0, 0xf8101040, "vabs.u16.s",      CVCADD},
+    { 0xfff0fff0, 0xfa001040, "vabs.u32.s",      CVCADD},
+    { 0xfff0fff0, 0xf8001050, "vabs.s8.s",       CVCADD},
+    { 0xfff0fff0, 0xf8101050, "vabs.s16.s",      CVCADD},
+    { 0xfff0fff0, 0xfa001050, "vabs.s32.s",      CVCADD},
+    { 0xfff0fff0, 0xf8001080, "vneg.u8",         CVCADD},
+    { 0xfff0fff0, 0xf8101080, "vneg.u16",        CVCADD},
+    { 0xfff0fff0, 0xfa001080, "vneg.u32",        CVCADD},
+    { 0xfff0fff0, 0xf8001090, "vneg.s8",         CVCADD},
+    { 0xfff0fff0, 0xf8101090, "vneg.s16",        CVCADD},
+    { 0xfff0fff0, 0xfa001090, "vneg.s32",        CVCADD},
+    { 0xfff0fff0, 0xf80010c0, "vneg.u8.s",       CVCADD},
+    { 0xfff0fff0, 0xf81010c0, "vneg.u16.s",      CVCADD},
+    { 0xfff0fff0, 0xfa0010c0, "vneg.u32.s",      CVCADD},
+    { 0xfff0fff0, 0xf80010d0, "vneg.s8.s",       CVCADD},
+    { 0xfff0fff0, 0xf81010d0, "vneg.s16.s",      CVCADD},
+    { 0xfff0fff0, 0xfa0010d0, "vneg.s32.s",      CVCADD},
+    { 0xfff0fff0, 0xf8000880, "vcmphsz.u8",      CVCADD},
+    { 0xfff0fff0, 0xf8100880, "vcmphsz.u16",     CVCADD},
+    { 0xfff0fff0, 0xfa000880, "vcmphsz.u32",     CVCADD},
+    { 0xfff0fff0, 0xf8000890, "vcmphsz.s8",      CVCADD},
+    { 0xfff0fff0, 0xf8100890, "vcmphsz.s16",     CVCADD},
+    { 0xfff0fff0, 0xfa000890, "vcmphsz.s32",     CVCADD},
+    { 0xfff0fff0, 0xf80008a0, "vcmpltz.u8",      CVCADD},
+    { 0xfff0fff0, 0xf81008a0, "vcmpltz.u16",     CVCADD},
+    { 0xfff0fff0, 0xfa0008a0, "vcmpltz.u32",     CVCADD},
+    { 0xfff0fff0, 0xf80008b0, "vcmpltz.s8",      CVCADD},
+    { 0xfff0fff0, 0xf81008b0, "vcmpltz.s16",     CVCADD},
+    { 0xfff0fff0, 0xfa0008b0, "vcmpltz.s32",     CVCADD},
+    { 0xfff0fff0, 0xf80008c0, "vcmpnez.u8",      CVCADD},
+    { 0xfff0fff0, 0xf81008c0, "vcmpnez.u16",     CVCADD},
+    { 0xfff0fff0, 0xfa1008c0, "vcmpnez.u32",     CVCADD},
+    { 0xfff0fff0, 0xf80008d0, "vcmpnez.s8",      CVCADD},
+    { 0xfff0fff0, 0xf81008d0, "vcmpnez.s16",     CVCADD},
+    { 0xfff0fff0, 0xfa0008d0, "vcmpnez.s32",     CVCADD},
+    { 0xfe00fff0, 0xf8001300, "vmtvr.u8",       CVMTVR  },
+    { 0xfe00fff0, 0xf8001320, "vmtvr.u16",      CVMTVR  },
+    { 0xfe00fff0, 0xf8001340, "vmtvr.u32",      CVMTVR  },
+    { 0xfe10ffe0, 0xf8001200, "vmfvr.u8",       CVMFVR  },
+    { 0xfe10ffe0, 0xf8001220, "vmfvr.u16",      CVMFVR  },
+    { 0xfe10ffe0, 0xf8001240, "vmfvr.u32",      CVMFVR  },
+    { 0xfe10ffe0, 0xf8001280, "vmfvr.s8",       CVMFVR  },
+    { 0xfe10ffe0, 0xf80012a0, "vmfvr.s16",      CVMFVR  },
+    { 0xfe00ffe0, 0xf8001a00, "vld.u8",         CVLDB   },
+    { 0xfe00ffe0, 0xf8001a20, "vld.u16",        CVLDH   },
+    { 0xfe00ffe0, 0xf8001a40, "vld.u32",        CVLDW   },
+    { 0xfe00ffe0, 0xf8001a60, "vld.u64",        CVLDW   },
+    { 0xfe00ffe0, 0xf8001a80, "vld.u128",       CVLDW   },
+    { 0xfe00ffe0, 0xf8001b00, "vst.u8" ,        CVLDB   },
+    { 0xfe00ffe0, 0xf8001b20, "vst.u16",        CVLDH   },
+    { 0xfe00ffe0, 0xf8001b40, "vst.u32",        CVLDW   },
+    { 0xfe00ffe0, 0xf8001b60, "vst.u64",        CVLDW   },
+    { 0xfe00ffe0, 0xf8001b80, "vst.u128",       CVLDW   },
+    { 0xfe10fff0, 0xf8000e80, "vdup.8",         CVDUP   },
+    { 0xfe10fff0, 0xf8100e80, "vdup.16",        CVDUP   },
+    { 0xfe10fff0, 0xfa000e80, "vdup.32",        CVDUP   },
+    { 0xfe10ffd0, 0xf8000700, "vshli.u8",       CVSHLRI },
+    { 0xfe10ffd0, 0xf8100700, "vshli.u16",      CVSHLRI },
+    { 0xfe10ffd0, 0xfa000700, "vshli.u32",      CVSHLRI },
+    { 0xfe10ffd0, 0xf8000710, "vshli.s8",       CVSHLRI },
+    { 0xfe10ffd0, 0xf8100710, "vshli.s16",      CVSHLRI },
+    { 0xfe10ffd0, 0xfa000710, "vshli.s32",      CVSHLRI },
+    { 0xfe10ffd0, 0xf8000740, "vshli.u8.s",     CVSHLRI },
+    { 0xfe10ffd0, 0xf8100740, "vshli.u16.s",    CVSHLRI },
+    { 0xfe10ffd0, 0xfa000740, "vshli.u32.s",    CVSHLRI },
+    { 0xfe10ffd0, 0xf8000750, "vshli.s8.s",     CVSHLRI },
+    { 0xfe10ffd0, 0xf8100750, "vshli.s16.s",    CVSHLRI },
+    { 0xfe10ffd0, 0xfa000750, "vshli.s32.s",    CVSHLRI },
+    { 0xfe10ffd0, 0xf8000600, "vshri.u8",       CVSHLRI },
+    { 0xfe10ffd0, 0xf8100600, "vshri.u16",      CVSHLRI },
+    { 0xfe10ffd0, 0xfa000600, "vshri.u32",      CVSHLRI },
+    { 0xfe10ffd0, 0xf8000610, "vshri.s8",       CVSHLRI },
+    { 0xfe10ffd0, 0xf8100610, "vshri.s16",      CVSHLRI },
+    { 0xfe10ffd0, 0xfa000610, "vshri.s32",      CVSHLRI },
+    { 0xfe10ffd0, 0xf8000640, "vshri.u8.r",     CVSHLRI },
+    { 0xfe10ffd0, 0xf8100640, "vshri.u16.r",    CVSHLRI },
+    { 0xfe10ffd0, 0xfa000640, "vshri.u32.r",    CVSHLRI },
+    { 0xfe10ffd0, 0xf8000650, "vshri.s8.r",     CVSHLRI },
+    { 0xfe10ffd0, 0xf8100650, "vshri.s16.r",    CVSHLRI },
+    { 0xfe10ffd0, 0xfa000650, "vshri.s32.r",    CVSHLRI },
+    { 0xfff0ffe0, 0xf4001b00, "fmfvrh",         CFMFVR  },
+    { 0xfff0ffe0, 0xf4001b20, "fmfvrl",         CFMFVR  },
+    { 0xffe0fff0, 0xf4001b40, "fmtvrh",         CFMTVR  },
+    { 0xffe0fff0, 0xf4001b60, "fmtvrl",         CFMTVR  },
+    { 0xfe10fe10, 0xf8001400, "vins.8",         CVINS   },
+    { 0xfe10fe10, 0xf8101400, "vins.16",        CVINS   },
+    { 0xfe10fe10, 0xfa001400, "vins.32",        CVINS   },
+    { 0xfe1fff00, 0xf4003800, "flrws",          FLRW   },
+    { 0xfe1fff00, 0xf4003900, "flrwd",          FLRW   },
+    { 0xfe00ff00, 0xf4001c00, "fmovis",         FMOVI   },
+    { 0xfe00ff00, 0xf4001e00, "fmovid",         FMOVI   },
+    { 0, 0, 0, 0}
+};
+
+INST_PARSE_INFO csky_inst_info_16[] = {
+    { 0xffff, 0x783c, "rts", HBKPT},
+    { 0xffff, 0x0000, "bkpt", HBKPT},
+
+    { 0xfc00, 0x0400, "br", HBR },
+    { 0xfc00, 0x0000, "bsr", HBR },
+    { 0xfc00, 0x0800, "bt", HBR },
+    { 0xfc00, 0x0c00, "bf", HBR },
+
+    { 0xfc3f, 0x6403, "mvcv", HMVCV },
+
+    { 0xfc03, 0x6803, "tstnbz", HTSTNBZ },
+    { 0xffc3, 0x7800, "jmp", HTSTNBZ },
+    { 0xffc3, 0x7801, "jsr", HTSTNBZ },
+
+    { 0xfc03, 0x6400, "cmphs", HCMPHS },
+    { 0xfc03, 0x6401, "cmplt", HCMPHS },
+    { 0xfc03, 0x6402, "cmpne", HCMPHS },
+    { 0xfc03, 0x6802, "tst", HCMPHS },
+
+    { 0xf8e0, 0x3840, "cmpnei", HCMPNEI },
+    { 0xf8e0, 0x3880, "bclri", HCMPNEI   },
+    { 0xf8e0, 0x38a0, "bseti", HCMPNEI },
+
+    { 0xf8e0, 0x3820, "cmplti", HCMPLTI },
+    { 0xf8e0, 0x3800, "cmphsi", HCMPLTI },
+
+    { 0xf800, 0x3000, "movi", HMOVI },
+
+    { 0xfc03, 0x7400, "zextb", HZEXTB },
+    { 0xfc03, 0x7401, "zexth", HZEXTB },
+    { 0xfc03, 0x7402, "sextb", HZEXTB },
+    { 0xfc03, 0x7403, "sexth", HZEXTB },
+    { 0xfc03, 0x7802, "revb", HZEXTB },
+    { 0xfc03, 0x7803, "revh", HZEXTB },
+    { 0xfc03, 0x6001, "addc", HZEXTB },
+    { 0xfc03, 0x6003, "subc", HZEXTB },
+    { 0xfc03, 0x6800, "and", HZEXTB },
+    { 0xfc03, 0x6801, "andn", HZEXTB },
+    { 0xfc03, 0x6c00, "or", HZEXTB },
+    { 0xfc03, 0x6c01, "xor", HZEXTB },
+    { 0xfc03, 0x6c02, "nor", HZEXTB },
+    { 0xfc03, 0x6c03, "mov", HZEXTB },
+    { 0xfc03, 0x7000, "lsl", HZEXTB },
+    { 0xfc03, 0x7001, "lsr", HZEXTB },
+    { 0xfc03, 0x7002, "asr", HZEXTB },
+    { 0xfc03, 0x7003, "rotl", HZEXTB },
+    { 0xfc03, 0x7c00, "mult", HZEXTB },
+    { 0xfc03, 0x7c01, "mulsh", HZEXTB},
+
+    { 0xf800, 0x4000, "lsli", HLSLI },
+    { 0xf800, 0x4800, "lsri", HLSLI },
+    { 0xf800, 0x5000, "asri", HLSLI },
+
+    { 0xf800, 0x8000, "ld.b", HLDB },
+    { 0xf800, 0xa000, "st.b", HLDB },
+    { 0xf800, 0x8800, "ld.h", HLDH },
+    { 0xf800, 0xa800, "st.h", HLDH },
+    { 0xf800, 0x9000, "ld.w", HLDW },
+    { 0xf800, 0x9800, "ld.w", HLDWSP },
+    { 0xf800, 0xb000, "st.w", HLDW },
+    { 0xf800, 0xb800, "st.w", HLDWSP },
+
+    { 0xf800, 0x2000, "addi", HADDI8 },
+    { 0xf803, 0x5802, "addi", HADDI3 },
+    { 0xf800, 0x1800, "addi", HADDI8SP },
+    { 0xfce0, 0x1400, "addi", HADDI7SP },
+
+    { 0xf800, 0x2800, "subi", HADDI8 },
+    { 0xf803, 0x5803, "subi", HADDI3 },
+    { 0xfce0, 0x1420, "subi", HSUBI7SP },
+
+    { 0xfee0, 0x1480, "pop", HPOP },
+    { 0xfee0, 0x14c0, "push", HPOP },
+    { 0xffe3, 0x14a0, "bpop.h", BPOP },
+    { 0xffe3, 0x14a2, "bpop.w", BPOP },
+    { 0xffe3, 0x14e0, "bpush.h", BPOP },
+    { 0xffe3, 0x14e2, "bpush.w", BPOP },
+
+    { 0xfc03, 0x6000, "addu", HZEXTB },
+    { 0xf803, 0x5800, "addu", HADDU2 },
+    { 0xfc03, 0x6002, "subu", HZEXTB },
+    { 0xf803, 0x5801, "subu", HADDU2 },
+
+    { 0xfc00, 0x1000, "lrw",  HLRW},
+
+    { 0xf8fc, 0x38e0, "jmpix", HJMPIX},
+
+    { 0, 0, 0, 0}
+};
+
+#if ALIAS
+/*register corresponding name*/
+static const char *v2_grname[] = {
+    "a0", "a1", "a2", "a3", "l0", "l1", "l2", "l3",
+    "l4", "l5", "l6", "l7", "t0", "t1", "sp", "lr",
+    "l8", "l9", "t2", "t3", "t4", "t5", "t6", "t7",
+    "t8", "t9", "r26", "r27", "rdb", "gb", "r30", "tls"};
+
+#else
+/*register corresponding name*/
+static const char *v2_grname[] = {
+    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+    "r8", "r9", "r10", "r11", "r12", "r13", "sp", "r15",
+    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
+    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31"};
+#endif
+/*concatenate integer to string, according to the given radix*/
+static void strcat_int(char *s, int value, int radix)
+{
+    char tmp[33];
+    char *tp = tmp;
+    int i;
+    unsigned v;
+    int sign;
+
+    if (value == 0) {
+        strcat(s, "0");
+        return;
+    }
+
+    sign = (radix == 10 && value < 0);
+
+    if (sign) {
+        v = -value;
+    } else {
+        v = (unsigned)value;
+    }
+
+    while (v || tp == tmp) {
+        i = v % radix;
+        v = v / radix;
+        if (i < 10) {
+            *tp++ = i + '0';
+        } else {
+            *tp++ = i + 'a' - 10;
+        }
+    }
+
+    if (sign) {
+        strcat(s, "-");
+    }
+    s += strlen(s);
+    while (tp > tmp) {
+        *s++ = *--tp;
+    }
+}
+
+static inline int clog2(int s)
+{
+    int r = 0;
+
+    if (s == 0) {
+        return -1;
+    }
+    while (s != 1) {
+        s >>= 1;
+        r++;
+    }
+
+    return r;
+}
+
+/*
+void number_to_chars_littleendian(char *buf, CSKY_INST_TYPE val, int n)
+{
+    if (n <= 0) {
+        abort();
+    }
+    while (n--) {
+        *buf++ = val & 0xff;
+        val >>= 8;
+    }
+}
+*/
+
+/*find instruction info according to instruction inst*/
+INST_PARSE_INFO *csky_find_inst_info(CSKY_INST_TYPE inst, int length)
+{
+    int i;
+    CSKY_INST_TYPE v;
+    INST_PARSE_INFO *d;
+
+    if (length == 2) {
+        d = csky_inst_info_16;   /*16 bit instruction*/
+    } else {
+        d = csky_inst_info_32;    /*32 bit instruction*/
+    }
+
+    for (i = 0; d[i].name; i++) {
+        v = d[i].mask & inst;     /*get instruction opcode*/
+        if (v == d[i].opcode) {
+            return &d[i];
+        }
+    }
+    return NULL;
+}
+
+#define csky_read_data                                      \
+do {                                                        \
+    status = info->read_memory_func(memaddr, buf, 2, info); \
+    if (status) {                                           \
+        info->memory_error_func(status, memaddr, info);     \
+        return info->bytes_per_chunk;                       \
+    }                                                       \
+    if (info->endian == BFD_ENDIAN_BIG) {                   \
+        inst |= (buf[0] << 8) | buf[1];                     \
+    } else if (info->endian == BFD_ENDIAN_LITTLE) {         \
+        inst |= (buf[1] << 8) | buf[0];                     \
+    } else {                                                \
+        abort();                                            \
+    }                                                       \
+    info->bytes_per_chunk += 2;                             \
+    memaddr += 2;                                           \
+} while (0)
+
+#define csky_output(s)  \
+do {                    \
+    strcat(str, s);     \
+} while (0)
+
+static const char *fields[] = {
+    "", "af", "fe", "fe,af", "ie", "ie,af", "ie,fe",
+    "ie,fe,af", "ee", "ee,af", "ee,fe", "ee,fe,af",
+    "ee,ie", "ee,ie,af", "ee,ie,fe", "ee,ie,fe,af"
+};
+
+int print_insn_csky_v2(bfd_vma memaddr, struct disassemble_info *info)
+{
+    unsigned char buf[2];
+    CSKY_INST_TYPE inst;
+    CSKY_INST_TYPE inst_lbytes;
+    int status;
+    char str[40];
+    memset(str, 0, sizeof(str));
+    info->bytes_per_chunk = 0;
+    inst = 0;
+
+    csky_read_data;
+#define insn_is_32bit ((inst & 0xc000) == 0xc000)
+    if (insn_is_32bit) {
+        inst <<= 16;
+        csky_read_data;
+    }
+
+    INST_PARSE_INFO *ii;
+    ii = csky_find_inst_info(inst, info->bytes_per_chunk);
+    if (ii == NULL) {
+        info->fprintf_func(info->stream, " .long: 0x%08lx", inst);
+        return info->bytes_per_chunk;
+    }
+
+    /* disassemble start: */
+
+    int method;
+    int c;
+
+    int v = -999; /* primary value dump */
+    int w = -999; /* secondary value dump */
+    int t = -999;
+
+    int need_comma;
+
+    strcat(str, ii->name);
+
+    c = 0;
+    need_comma = 0;
+
+#define GetData     (ii->data[c++])
+#define NOTEND      (method != MEND && method != MERR)
+#define cout(s)     (strcat(str, s))
+#define cprint(s)   (info->fprintf_func(info->stream, s))
+
+    if (ii->data[0] != MEND && ii->data[0] != MERR) {
+        strcat(str, "\t");
+    }
+
+    for (method = GetData; NOTEND;) {
+        if (need_comma > 0) {
+            if (method != MSPE) {
+                strcat(str, ", ");
+            }
+            need_comma = 0;
+        }
+
+        /* calculate */
+        switch (method) {
+        case MSPE:
+        case MSPE1:
+        case MSP:
+        case MR28:
+        case MPRINT:
+        case MPOP16:
+        case MPOP32:
+            break;
+        case MIMM1:
+            v = (inst & (CSKY_INST_TYPE)GetData);
+            t = GetData;
+            v = v + t;
+            break;
+        case MLRW16:
+            v = (inst & (CSKY_INST_TYPE)GetData);
+            t = GetData;
+
+            if (t >= 0) {
+                v >>= t;
+            } else {
+                v <<= -t;
+            }
+
+            w = (inst & (CSKY_INST_TYPE)GetData);
+            t = GetData;
+            if (t >= 0) {
+                v = ((v | w) >> t);
+            } else {
+                v = ((v | w) << -t);
+            }
+
+            break;
+        case MADDISPH:
+        case MADDISP:
+            v = (inst & (CSKY_INST_TYPE)GetData);
+            t = GetData;
+
+            if (t >= 0) {
+                v >>= t;
+            } else {
+                v <<= -t;
+            }
+
+            w = (inst & (CSKY_INST_TYPE)GetData);
+            t = GetData;
+
+            if (t >= 0) {
+                v = ((v | w) >> t);
+            } else {
+                v = ((v | w) << -t);
+            }
+
+            break;
+        default:
+            v = (inst & (CSKY_INST_TYPE)GetData);
+            t = GetData;
+            if (t >= 0) {
+                v >>= t;
+            } else {
+                v <<= -t;
+            }
+        }
+
+        switch (method) {
+        case MADD:
+        case MADDD:
+        case MSUBD:
+            w = (inst & (CSKY_INST_TYPE)GetData);
+            t = GetData;
+            if (t > 0) {
+                w >>= t;
+            } else {
+                w <<= -t;
+            }
+            break;
+        }
+        switch (method) {
+        case MLOG2:
+            v = clog2(v);
+            break;
+        case MIMMH:
+        case MIMM:
+            v += GetData;
+            break;
+        case MIMM1:
+            t = GetData;
+            if (t > 0) {
+                v >>= t;
+            } else {
+                v <<= -t;
+            }
+
+            break;
+        case MADD:
+        case MADDD:
+            v += w;
+            break;
+        case MSUBD:
+            v -= w;
+            break;
+        }
+
+        /* print */
+        switch (method) {
+        case MREG:
+            strcat(str, v2_grname[v]);
+            break;
+        case MIMM0:
+        case MIMM:
+        case MIMM1:
+        case MADDD:
+        case MSUBD:
+        case MLOG2:
+        case MADDISP:
+        case MADD:
+            strcat_int(str, v, 10);
+            break;
+        case MIMMH:
+        case MIMM0H:
+        case MLRS:
+        case MADDISPH:
+            strcat(str, "0x");
+            strcat_int(str, v, 16);
+            break;
+        case MLDM:
+            strcat(str, v2_grname[v + ((inst & 0x3e00000) >> 21)]);
+            break;
+        case MSYM:
+            /* PC + sign_extend(offset << 1) */
+            if (v & (CSKY_INST_TYPE)GetData) {
+                v |= (CSKY_INST_TYPE)GetData;   /* sign extension */
+            }
+            v += memaddr - info->bytes_per_chunk;
+            strcat(str, "0x");
+            strcat_int(str, v, 16);
+            info->fprintf_func(info->stream, "%s", str);
+            if (info->print_address_func) {
+                info->fprintf_func(info->stream, "\t//");
+                info->print_address_func(v, info);
+            }
+            return info->bytes_per_chunk;
+        case MLRW16:
+        case MSYMI:
+            /* MEM[(PC + unsign_extend(offset << 2)) & 0xFFFFFFFC] */
+            v = (memaddr - info->bytes_per_chunk + v) & 0xFFFFFFFC;
+            inst = 0;
+            memaddr = v;
+            if (info->endian == BFD_ENDIAN_BIG) {
+                csky_read_data;
+                inst <<= 16;
+                csky_read_data;
+            } else if (info->endian == BFD_ENDIAN_LITTLE) {
+                csky_read_data;
+                inst_lbytes = inst;
+                inst = 0;
+                csky_read_data;
+                inst <<= 16;
+                inst = inst | inst_lbytes;
+            } else {
+                abort();
+            }
+
+            info->bytes_per_chunk -= 4;
+            strcat(str, "0x");
+            strcat_int(str, inst, 16);
+            info->fprintf_func(info->stream, "%s", str);
+
+            if (info->print_address_func && inst != 0) {
+                info->fprintf_func(info->stream, "\t//");
+                info->print_address_func(inst, info);
+            } else {
+                info->fprintf_func(info->stream,
+                                   "\t// from address pool at 0x%lx",
+                                   (long unsigned int)memaddr);
+            }
+
+            return info->bytes_per_chunk;
+        case MPSR:
+            strcat(str, fields[v & 0xf]);
+            break;
+        case MSP:
+            strcat(str, "sp");
+            break;
+        case MPRINT:
+            strcat(str, "\t// the offset is based on .data");
+            break;
+        case MR28:
+            strcat(str, v2_grname[28]);
+            break;
+        case MSPE:
+        case MSPE1:
+            str[strlen(str)] = (char)GetData;
+            break;
+        case MPOP16:
+            if (inst & 0xf) {
+                strcat(str, v2_grname[4]);
+                if ((inst & 0xf) == 1) {
+                    /* nothing */
+                } else {
+                    strcat(str, "-");
+                    strcat(str, v2_grname[3 + (inst & 0xf)]);
+                }
+                need_comma++;
+            }
+            if (inst & 0x10) {
+                if (need_comma > 0) {
+                    strcat(str, ", ");
+                    need_comma = 0;
+                }
+                strcat(str, v2_grname[15]);
+                need_comma++;
+            }
+            need_comma = 0;
+            break;
+        case MPOP32:
+            if (inst & 0xf) {
+                strcat(str, v2_grname[4]);
+                if ((inst & 0xf) == 1) {
+                    /* nothing */
+                } else {
+                    strcat(str, "-");
+                    strcat(str, v2_grname[3 + (inst & 0xf)]);
+                }
+                need_comma++;
+            }
+
+            if (inst & 0x10) {
+                if (need_comma > 0) {
+                    strcat(str, ", ");
+                    need_comma = 0;
+                }
+                strcat(str, v2_grname[15]);
+                need_comma++;
+            }
+
+            if (inst & 0xe0) {
+                if (need_comma > 0) {
+                    strcat(str, ", ");
+                    need_comma = 0;
+                }
+                strcat(str, v2_grname[16]);
+                if (((inst & 0xe0) >> 5) == 1) {
+                    /* nothing */
+                } else {
+                    strcat(str, "-");
+                    strcat(str, v2_grname[17]);
+                }
+                need_comma++;
+            }
+
+            if (inst & 0x100) {
+                if (need_comma > 0) {
+                    strcat(str, ", ");
+                    need_comma = 0;
+                }
+                strcat(str, v2_grname[29]);
+                need_comma++;
+            }
+
+            need_comma = 0;
+            break;
+
+        }
+        switch (method) {
+        case MSPE:
+        case MSPE1:
+            method = GetData;
+            continue;
+        }
+
+        need_comma++;
+        method = GetData;
+    }
+
+    info->fprintf_func(info->stream, "%s", str);
+
+    return info->bytes_per_chunk;
+}
diff --git a/fpu/softfloat-specialize.h b/fpu/softfloat-specialize.h
index f5aed72..2f9b8ea 100644
--- a/fpu/softfloat-specialize.h
+++ b/fpu/softfloat-specialize.h
@@ -114,7 +114,8 @@ float32 float32_default_nan(float_status *status)
 #if defined(TARGET_SPARC)
     return const_float32(0x7FFFFFFF);
 #elif defined(TARGET_PPC) || defined(TARGET_ARM) || defined(TARGET_ALPHA) || \
-      defined(TARGET_XTENSA) || defined(TARGET_S390X) || defined(TARGET_TRICORE)
+      defined(TARGET_XTENSA) || defined(TARGET_S390X) || \
+      defined(TARGET_TRICORE) || defined(TARGET_CSKY)
     return const_float32(0x7FC00000);
 #else
     if (status->snan_bit_is_one) {
diff --git a/gdbstub.c b/gdbstub.c
index de62d26..c4379eb 100644
--- a/gdbstub.c
+++ b/gdbstub.c
@@ -318,6 +318,8 @@ static GDBState *gdbserver_state;
 
 bool gdb_has_xml;
 
+bool is_gdbserver_start = FALSE;
+
 #ifdef CONFIG_USER_ONLY
 /* XXX: This is not thread safe.  Do we care?  */
 static int gdbserver_fd = -1;
@@ -783,6 +785,113 @@ static int is_query_packet(const char *p, const char *query, char separator)
         (p[query_len] == '\0' || p[query_len] == separator);
 }
 
+#define TRACE_INFO_SIZE 4
+static int gdb_read_pctrace(GDBState *s, uint8_t *mem_buf,
+                            int mem_len, unsigned int num)
+{
+#ifdef TARGET_CSKY
+    CPUState *cpu = s->g_cpu;
+    CPUCSKYState *env = cpu->env_ptr;
+    struct csky_trace_info *trace_info = env->trace_info;
+    uint32_t index = (env->trace_index - 1) % TB_TRACE_NUM;
+    uint32_t pctrace_num = env->pctraces_max_num;
+    uint32_t i;
+    int len = 0;
+    uint8_t *addr = mem_buf;
+
+    if (env->tb_trace != 1) {
+        return len;
+    }
+
+    *(uint32_t *)(addr + len) = TRACE_INFO_SIZE;
+    len += TRACE_INFO_SIZE;
+
+    for (i = 0; i < pctrace_num; i++) {
+        if (index < i) {
+            index += TB_TRACE_NUM;
+        }
+        *(uint32_t *)(addr + len) = trace_info[index - i].tb_pc;
+        len += TRACE_INFO_SIZE;
+
+        if (mem_len < len + TRACE_INFO_SIZE) {
+            break;
+        }
+        if (i >= num) {
+            break;
+        }
+    }
+
+    len = TRACE_INFO_SIZE * pctrace_num;
+
+    return len;
+#else
+    return -1;
+#endif
+}
+
+static int gdb_handle_packet_usr_do_pctrace(GDBState * s, const char * line_buf)
+{
+    char buf[MAX_PACKET_LENGTH] = {0};
+    uint8_t mem_buf[MAX_PACKET_LENGTH] = {0};
+
+    unsigned int num = 0;
+    const char *p = line_buf;
+    int ch = *p++;
+
+    switch (ch) {
+    case ' ':
+        if (*p == '\0') {
+            break;
+        }
+        num = strtoul(p, (char **)&p, 10);
+        break;
+    default:
+        break;
+    }
+
+    int len = 0;
+    len = gdb_read_pctrace(s, mem_buf, MAX_PACKET_LENGTH / 2 - 1, num);
+    if (!len) {
+        return -1;
+    }
+
+    memtohex(buf, mem_buf, len);
+    put_packet(s, buf);
+
+    return 0;
+}
+
+typedef int (*cmd_cb)(GDBState * s, const char * line_buf);
+struct {
+    const char *cmd;
+    cmd_cb cmd_do;
+    int ignored;
+} gdb_handle_packet_usr_tab[] = {
+    {"pctrace", gdb_handle_packet_usr_do_pctrace, 0},
+};
+
+static int gdb_handle_packet_usr(GDBState * s, const char * line_buf)
+{
+    int ret = -1;
+    const char *p = line_buf;
+    int i = 0;
+    int size = ARRAY_SIZE(gdb_handle_packet_usr_tab);
+
+    for (i = 0; i < size; i++) {
+        int len = strlen(gdb_handle_packet_usr_tab[i].cmd);
+        const char *cmd = gdb_handle_packet_usr_tab[i].cmd;
+
+        if (!strncmp(cmd, p, len)) {
+            if (!gdb_handle_packet_usr_tab[i].ignored
+                && gdb_handle_packet_usr_tab[i].cmd_do) {
+                ret = gdb_handle_packet_usr_tab[i].cmd_do(s, p + len);
+            }
+            break;
+        }
+    }
+    return ret;
+}
+
 static int gdb_handle_packet(GDBState *s, const char *line_buf)
 {
     CPUState *cpu;
@@ -1220,6 +1329,12 @@ static int gdb_handle_packet(GDBState *s, const char *line_buf)
         /* Unrecognised 'q' command.  */
         goto unknown_command;
 
+    case 'u': {
+        if (gdb_handle_packet_usr(s, p)) {
+            goto unknown_command;
+        }
+        break;
+    }
     default:
     unknown_command:
         /* put empty packet */
@@ -1496,6 +1611,7 @@ void gdb_exit(CPUArchState *env, int code)
   qemu_chr_fe_deinit(&s->chr);
   qemu_chr_delete(chr);
 #endif
+    is_gdbserver_start = FALSE;
 }
 
 #ifdef CONFIG_USER_ONLY
@@ -1640,6 +1756,7 @@ int gdbserver_start(int port)
         return -1;
     /* accept connections */
     gdb_accept();
+    is_gdbserver_start = TRUE;
     return 0;
 }
 
@@ -1783,6 +1900,7 @@ int gdbserver_start(const char *device)
     s->state = chr ? RS_IDLE : RS_INACTIVE;
     s->mon_chr = mon_chr;
     s->current_syscall_cb = NULL;
+    is_gdbserver_start = TRUE;
 
     return 0;
 }
diff --git a/hw/arm/netduino2.c b/hw/arm/netduino2.c
index 23d7928..9f2f918 100644
--- a/hw/arm/netduino2.c
+++ b/hw/arm/netduino2.c
@@ -36,8 +36,14 @@ static void netduino2_init(MachineState *machine)
     if (machine->kernel_filename) {
         qdev_prop_set_string(dev, "kernel-filename", machine->kernel_filename);
     }
-    qdev_prop_set_string(dev, "cpu-model", "cortex-m3");
+    if (machine->cpu_model) {
+        qdev_prop_set_string(dev, "cpu-model", machine->cpu_model);
+    } else {
+        qdev_prop_set_string(dev, "cpu-model", "cortex-m4");
+    }
     object_property_set_bool(OBJECT(dev), true, "realized", &error_fatal);
+
+    sysbus_create_simple("csky_exit", 0x10002000, NULL);
 }
 
 static void netduino2_machine_init(MachineClass *mc)
diff --git a/hw/arm/stm32f205_soc.c b/hw/arm/stm32f205_soc.c
index 38425bd..6034251 100644
--- a/hw/arm/stm32f205_soc.c
+++ b/hw/arm/stm32f205_soc.c
@@ -46,46 +46,63 @@ static const int spi_irq[STM_NUM_SPIS] = {35, 36, 51};
 
 static void stm32f205_soc_initfn(Object *obj)
 {
-    STM32F205State *s = STM32F205_SOC(obj);
-    int i;
-
-    object_initialize(&s->syscfg, sizeof(s->syscfg), TYPE_STM32F2XX_SYSCFG);
-    qdev_set_parent_bus(DEVICE(&s->syscfg), sysbus_get_default());
-
-    for (i = 0; i < STM_NUM_USARTS; i++) {
-        object_initialize(&s->usart[i], sizeof(s->usart[i]),
-                          TYPE_STM32F2XX_USART);
-        qdev_set_parent_bus(DEVICE(&s->usart[i]), sysbus_get_default());
-    }
-
-    for (i = 0; i < STM_NUM_TIMERS; i++) {
-        object_initialize(&s->timer[i], sizeof(s->timer[i]),
-                          TYPE_STM32F2XX_TIMER);
-        qdev_set_parent_bus(DEVICE(&s->timer[i]), sysbus_get_default());
-    }
-
-    s->adc_irqs = OR_IRQ(object_new(TYPE_OR_IRQ));
-
-    for (i = 0; i < STM_NUM_ADCS; i++) {
-        object_initialize(&s->adc[i], sizeof(s->adc[i]),
-                          TYPE_STM32F2XX_ADC);
-        qdev_set_parent_bus(DEVICE(&s->adc[i]), sysbus_get_default());
-    }
-
-    for (i = 0; i < STM_NUM_SPIS; i++) {
-        object_initialize(&s->spi[i], sizeof(s->spi[i]),
-                          TYPE_STM32F2XX_SPI);
-        qdev_set_parent_bus(DEVICE(&s->spi[i]), sysbus_get_default());
-    }
+//    STM32F205State *s = STM32F205_SOC(obj);
+//    int i;
+//
+//    object_initialize(&s->syscfg, sizeof(s->syscfg), TYPE_STM32F2XX_SYSCFG);
+//    qdev_set_parent_bus(DEVICE(&s->syscfg), sysbus_get_default());
+//
+//    for (i = 0; i < STM_NUM_USARTS; i++) {
+//        object_initialize(&s->usart[i], sizeof(s->usart[i]),
+//                          TYPE_STM32F2XX_USART);
+//        qdev_set_parent_bus(DEVICE(&s->usart[i]), sysbus_get_default());
+//    }
+//
+//    for (i = 0; i < STM_NUM_TIMERS; i++) {
+//        object_initialize(&s->timer[i], sizeof(s->timer[i]),
+//                          TYPE_STM32F2XX_TIMER);
+//        qdev_set_parent_bus(DEVICE(&s->timer[i]), sysbus_get_default());
+//    }
+//
+//    s->adc_irqs = OR_IRQ(object_new(TYPE_OR_IRQ));
+//
+//    for (i = 0; i < STM_NUM_ADCS; i++) {
+//        object_initialize(&s->adc[i], sizeof(s->adc[i]),
+//                          TYPE_STM32F2XX_ADC);
+//        qdev_set_parent_bus(DEVICE(&s->adc[i]), sysbus_get_default());
+//    }
+//
+//    for (i = 0; i < STM_NUM_SPIS; i++) {
+//        object_initialize(&s->spi[i], sizeof(s->spi[i]),
+//                          TYPE_STM32F2XX_SPI);
+//        qdev_set_parent_bus(DEVICE(&s->spi[i]), sysbus_get_default());
+//    }
+}
+static inline DeviceState *csky_uart_create(hwaddr addr,
+                                            qemu_irq irq,
+                                            CharDriverState *chr)
+{
+    DeviceState *dev;
+    SysBusDevice *s;
+
+    dev = qdev_create(NULL, "csky_uart");
+    s = SYS_BUS_DEVICE(dev);
+    qdev_prop_set_chr(dev, "chardev", chr);
+    qdev_init_nofail(dev);
+    sysbus_mmio_map(s, 0, addr);
+    sysbus_connect_irq(s, 0, irq);
+
+    return dev;
 }
 
 static void stm32f205_soc_realize(DeviceState *dev_soc, Error **errp)
 {
     STM32F205State *s = STM32F205_SOC(dev_soc);
-    DeviceState *dev, *nvic;
-    SysBusDevice *busdev;
-    Error *err = NULL;
-    int i;
+    DeviceState *nvic;
+    //DeviceState *dev, *nvic;
+    //SysBusDevice *busdev;
+    //Error *err = NULL;
+    //int i;
 
     MemoryRegion *system_memory = get_system_memory();
     MemoryRegion *sram = g_new(MemoryRegion, 1);
@@ -113,82 +130,83 @@ static void stm32f205_soc_realize(DeviceState *dev_soc, Error **errp)
     nvic = armv7m_init(get_system_memory(), FLASH_SIZE, 96,
                        s->kernel_filename, s->cpu_model);
 
-    /* System configuration controller */
-    dev = DEVICE(&s->syscfg);
-    object_property_set_bool(OBJECT(&s->syscfg), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
-        return;
-    }
-    busdev = SYS_BUS_DEVICE(dev);
-    sysbus_mmio_map(busdev, 0, 0x40013800);
-    sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(nvic, 71));
-
-    /* Attach UART (uses USART registers) and USART controllers */
-    for (i = 0; i < STM_NUM_USARTS; i++) {
-        dev = DEVICE(&(s->usart[i]));
-        qdev_prop_set_chr(dev, "chardev",
-                          i < MAX_SERIAL_PORTS ? serial_hds[i] : NULL);
-        object_property_set_bool(OBJECT(&s->usart[i]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
-            return;
-        }
-        busdev = SYS_BUS_DEVICE(dev);
-        sysbus_mmio_map(busdev, 0, usart_addr[i]);
-        sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(nvic, usart_irq[i]));
-    }
-
-    /* Timer 2 to 5 */
-    for (i = 0; i < STM_NUM_TIMERS; i++) {
-        dev = DEVICE(&(s->timer[i]));
-        qdev_prop_set_uint64(dev, "clock-frequency", 1000000000);
-        object_property_set_bool(OBJECT(&s->timer[i]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
-            return;
-        }
-        busdev = SYS_BUS_DEVICE(dev);
-        sysbus_mmio_map(busdev, 0, timer_addr[i]);
-        sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(nvic, timer_irq[i]));
-    }
-
-    /* ADC 1 to 3 */
-    object_property_set_int(OBJECT(s->adc_irqs), STM_NUM_ADCS,
-                            "num-lines", &err);
-    object_property_set_bool(OBJECT(s->adc_irqs), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
-        return;
-    }
-    qdev_connect_gpio_out(DEVICE(s->adc_irqs), 0,
-                          qdev_get_gpio_in(nvic, ADC_IRQ));
-
-    for (i = 0; i < STM_NUM_ADCS; i++) {
-        dev = DEVICE(&(s->adc[i]));
-        object_property_set_bool(OBJECT(&s->adc[i]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
-            return;
-        }
-        busdev = SYS_BUS_DEVICE(dev);
-        sysbus_mmio_map(busdev, 0, adc_addr[i]);
-        sysbus_connect_irq(busdev, 0,
-                           qdev_get_gpio_in(DEVICE(s->adc_irqs), i));
-    }
-
-    /* SPI 1 and 2 */
-    for (i = 0; i < STM_NUM_SPIS; i++) {
-        dev = DEVICE(&(s->spi[i]));
-        object_property_set_bool(OBJECT(&s->spi[i]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
-            return;
-        }
-        busdev = SYS_BUS_DEVICE(dev);
-        sysbus_mmio_map(busdev, 0, spi_addr[i]);
-        sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(nvic, spi_irq[i]));
-    }
+    csky_uart_create(0x40015000, qdev_get_gpio_in(nvic, 0), serial_hds[0]);
+//    /* System configuration controller */
+//    dev = DEVICE(&s->syscfg);
+//    object_property_set_bool(OBJECT(&s->syscfg), true, "realized", &err);
+//    if (err != NULL) {
+//        error_propagate(errp, err);
+//        return;
+//    }
+//    busdev = SYS_BUS_DEVICE(dev);
+//    sysbus_mmio_map(busdev, 0, 0x40013800);
+//    sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(nvic, 71));
+//
+//    /* Attach UART (uses USART registers) and USART controllers */
+//    for (i = 0; i < STM_NUM_USARTS; i++) {
+//        dev = DEVICE(&(s->usart[i]));
+//        qdev_prop_set_chr(dev, "chardev",
+//                          i < MAX_SERIAL_PORTS ? serial_hds[i] : NULL);
+//        object_property_set_bool(OBJECT(&s->usart[i]), true, "realized", &err);
+//        if (err != NULL) {
+//            error_propagate(errp, err);
+//            return;
+//        }
+//        busdev = SYS_BUS_DEVICE(dev);
+//        sysbus_mmio_map(busdev, 0, usart_addr[i]);
+//        sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(nvic, usart_irq[i]));
+//    }
+//
+//    /* Timer 2 to 5 */
+//    for (i = 0; i < STM_NUM_TIMERS; i++) {
+//        dev = DEVICE(&(s->timer[i]));
+//        qdev_prop_set_uint64(dev, "clock-frequency", 1000000000);
+//        object_property_set_bool(OBJECT(&s->timer[i]), true, "realized", &err);
+//        if (err != NULL) {
+//            error_propagate(errp, err);
+//            return;
+//        }
+//        busdev = SYS_BUS_DEVICE(dev);
+//        sysbus_mmio_map(busdev, 0, timer_addr[i]);
+//        sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(nvic, timer_irq[i]));
+//    }
+//
+//    /* ADC 1 to 3 */
+//    object_property_set_int(OBJECT(s->adc_irqs), STM_NUM_ADCS,
+//                            "num-lines", &err);
+//    object_property_set_bool(OBJECT(s->adc_irqs), true, "realized", &err);
+//    if (err != NULL) {
+//        error_propagate(errp, err);
+//        return;
+//    }
+//    qdev_connect_gpio_out(DEVICE(s->adc_irqs), 0,
+//                          qdev_get_gpio_in(nvic, ADC_IRQ));
+//
+//    for (i = 0; i < STM_NUM_ADCS; i++) {
+//        dev = DEVICE(&(s->adc[i]));
+//        object_property_set_bool(OBJECT(&s->adc[i]), true, "realized", &err);
+//        if (err != NULL) {
+//            error_propagate(errp, err);
+//            return;
+//        }
+//        busdev = SYS_BUS_DEVICE(dev);
+//        sysbus_mmio_map(busdev, 0, adc_addr[i]);
+//        sysbus_connect_irq(busdev, 0,
+//                           qdev_get_gpio_in(DEVICE(s->adc_irqs), i));
+//    }
+//
+//    /* SPI 1 and 2 */
+//    for (i = 0; i < STM_NUM_SPIS; i++) {
+//        dev = DEVICE(&(s->spi[i]));
+//        object_property_set_bool(OBJECT(&s->spi[i]), true, "realized", &err);
+//        if (err != NULL) {
+//            error_propagate(errp, err);
+//            return;
+//        }
+//        busdev = SYS_BUS_DEVICE(dev);
+//        sysbus_mmio_map(busdev, 0, spi_addr[i]);
+//        sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(nvic, spi_irq[i]));
+//    }
 }
 
 static Property stm32f205_soc_properties[] = {
diff --git a/hw/audio/Makefile.objs b/hw/audio/Makefile.objs
index 7ce85a2..ecee711 100644
--- a/hw/audio/Makefile.objs
+++ b/hw/audio/Makefile.objs
@@ -6,6 +6,7 @@ common-obj-$(CONFIG_ADLIB) += fmopl.o adlib.o
 common-obj-$(CONFIG_GUS) += gus.o gusemu_hal.o gusemu_mixer.o
 common-obj-$(CONFIG_CS4231A) += cs4231a.o
 common-obj-$(CONFIG_HDA) += intel-hda.o hda-codec.o
+common-obj-$(CONFIG_CSKY_IIS) += csky_iis.o
 
 common-obj-$(CONFIG_PCSPK) += pcspk.o
 common-obj-$(CONFIG_WM8750) += wm8750.o
diff --git a/hw/audio/csky_iis.c b/hw/audio/csky_iis.c
new file mode 100644
index 0000000..e31d880
--- /dev/null
+++ b/hw/audio/csky_iis.c
@@ -0,0 +1,701 @@
+/*
+ * Csky i2s emulation.
+ * Written by wanghb
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "hw/hw.h"
+#include "hw/i2c/i2c.h"
+#include "audio/audio.h"
+#include "hw/dma/csky_dma.h"
+#include "qemu/log.h"
+
+#define RX_MODE 0x0
+#define TX_MODE 0x1
+
+#define RX_FIFO_FULL (1 << 5)
+#define RX_FIFO_NOT_EMPTY (1 << 4)
+
+#define RX_FIFO_UNDERFLOW (1 << 2)
+#define TX_FIFO_OVERFLOW (1 << 1)
+#define TX_FIFO_EMPTY (1 << 0)
+
+#define TX_FIFO_ENTRY   0x10000
+
+#define TYPE_CSKY_IIS   "csky_iis"
+#define CSKY_IIS(obj)   OBJECT_CHECK(csky_iis_state, (obj), TYPE_CSKY_IIS)
+
+static int csky_dma_can_work(csky_dma_state *s);
+static void csky_dma_update(csky_dma_state *s);
+
+typedef struct {
+    QEMUSoundCard card;
+    SWVoiceOut *out_voice;
+    uint8_t tx_fifo[TX_FIFO_ENTRY];
+    int read_pos;
+    int write_pos;
+    int len;
+} csky_codec_state;
+
+typedef struct {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    qemu_irq irq;
+
+    int enable;
+    int func_mode;
+    uint32_t iis_cnf_in;
+    uint32_t fssta;
+    uint32_t iis_cnf_out;
+    uint32_t fadtlr;
+    uint32_t compress_ctrl;
+    uint32_t tx_fifo_thr;
+    uint32_t rx_fifo_thr;
+    uint32_t status;
+    uint32_t int_mask;
+    uint32_t raw_int_status;
+    uint32_t dma_ctrl;
+    uint32_t dma_tx_data_lvl;
+    uint32_t dma_rx_data_lvl;
+    uint32_t mode_int_mask;
+    uint32_t raw_mode_int_status;
+
+    csky_codec_state codec;
+
+    csky_dma_state *dma;
+} csky_iis_state;
+
+static const VMStateDescription vmstate_csky_codec = {
+    .name = "csky_codec",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT8_ARRAY(tx_fifo, csky_codec_state, TX_FIFO_ENTRY),
+        VMSTATE_INT32(read_pos, csky_codec_state),
+        VMSTATE_INT32(write_pos, csky_codec_state),
+        VMSTATE_INT32(len, csky_codec_state),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static const VMStateDescription vmstate_csky_iis = {
+    .name = TYPE_CSKY_IIS,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_INT32(enable, csky_iis_state),
+        VMSTATE_INT32(func_mode, csky_iis_state),
+        VMSTATE_UINT32(iis_cnf_in, csky_iis_state),
+        VMSTATE_UINT32(fadtlr, csky_iis_state),
+        VMSTATE_UINT32(compress_ctrl, csky_iis_state),
+        VMSTATE_UINT32(tx_fifo_thr, csky_iis_state),
+        VMSTATE_UINT32(rx_fifo_thr, csky_iis_state),
+        VMSTATE_UINT32(status, csky_iis_state),
+        VMSTATE_UINT32(int_mask, csky_iis_state),
+        VMSTATE_UINT32(raw_int_status, csky_iis_state),
+        VMSTATE_UINT32(dma_ctrl, csky_iis_state),
+        VMSTATE_UINT32(dma_tx_data_lvl, csky_iis_state),
+        VMSTATE_UINT32(dma_tx_data_lvl, csky_iis_state),
+        VMSTATE_UINT32(mode_int_mask, csky_iis_state),
+        VMSTATE_UINT32(raw_mode_int_status, csky_iis_state),
+
+        VMSTATE_STRUCT(codec, csky_iis_state, 0,
+                       vmstate_csky_codec, csky_codec_state),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static void csky_dma_update(csky_dma_state *s)
+{
+    if (s->err_int & s->err_int_mask) {
+        s->status_int |= 1 << 4;
+    } else {
+        s->status_int &= ~(1 << 4);
+    }
+
+    if (s->dsttran_int & s->dsttran_int_mask) {
+        s->status_int |= 1 << 3;
+    } else {
+        s->status_int &= ~(1 << 3);
+    }
+
+    if (s->srctran_int & s->srctran_int_mask) {
+        s->status_int |= 1 << 2;
+    } else {
+        s->status_int &= ~(1 << 2);
+    }
+
+    if (s->block_int & s->block_int_mask) {
+        s->status_int |= 1 << 1;
+    } else {
+        s->status_int &= ~(1 << 1);
+    }
+
+    if (s->tfr_int & s->tfr_int_mask) {
+        s->status_int |= 1 << 0;
+    } else {
+        s->status_int &= ~(1 << 0);
+    }
+
+    if (s->status_int) {
+        qemu_irq_raise(s->irq);
+    } else {
+        qemu_irq_lower(s->irq);
+    }
+}
+
+static int csky_dma_can_work(csky_dma_state *s)
+{
+    return s->dma_enable
+        && (s->chan[0].chan_enable
+            || s->chan[1].chan_enable
+            || s->chan[2].chan_enable
+            || s->chan[3].chan_enable);
+}
+
+
+static void csky_iis_set_format(csky_iis_state *s);
+
+/**************************************************************************
+ * Description:
+ *     Update the interrupt flag according the IIS state
+ *     and give the flag to interrupt controller.
+ * Argument:
+ *     s  --- the pointer to the IIS state
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_iis_update(csky_iis_state *s)
+{
+    /* Update interrupts.  */
+    int int_req;
+
+    int_req = (s->raw_int_status & s->int_mask)
+        || (s->raw_mode_int_status & s->mode_int_mask);
+    qemu_set_irq(s->irq, int_req);
+}
+
+/**************************************************************************
+ * Description:
+ *     IIS controller register read function.
+ * Argument:
+ *     opaque  --- the pointer to the IIS state
+ *     offset  --- the address offset of the register
+ * Return:
+ *     the value of the corresponding register
+ **************************************************************************/
+static uint64_t csky_iis_read(void *opaque, hwaddr offset, unsigned size)
+{
+    uint64_t ret = 0;
+    csky_iis_state *s = (csky_iis_state *)opaque;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_iis_read: 0x%x must word align read\n",
+                      (int)offset);
+    }
+
+    switch (offset) {
+    case 0x0:
+        ret = s->enable;
+        break;
+    case 0x4:
+        ret = s->func_mode;
+        break;
+    case 0x8:
+        ret = s->iis_cnf_in;
+        break;
+    case 0xc:
+        ret = s->fssta;
+        break;
+    case 0x10:
+        ret = s->iis_cnf_out;
+        break;
+    case 0x14:
+        ret = s->fadtlr;
+        break;
+    case 0x18:
+        ret = s->compress_ctrl;
+        break;
+    case 0x1c:
+        ret = s->tx_fifo_thr;
+        break;
+    case 0x20:
+        ret = s->rx_fifo_thr;
+        break;
+    case 0x24:   /* tx fifo data level */
+        ret = 0;
+        break;
+    case 0x28:   /* rx fifo data level */
+        ret = 1;
+        break;
+    case 0x2c:
+        ret = s->status;
+        break;
+    case 0x30:
+        ret = s->int_mask;
+        break;
+    case 0x34:
+        ret = s->raw_int_status & s->int_mask;
+        break;
+    case 0x38:
+        ret = s->raw_int_status;
+        break;
+    case 0x3c:
+        ret = 0;
+        break;
+    case 0x4c:
+        ret = s->dma_ctrl;
+        break;
+    case 0x50:
+        ret = s->dma_tx_data_lvl;
+        break;
+    case 0x54:
+        ret = s->dma_rx_data_lvl;
+        break;
+    case 0x60:
+        ret = 0;
+        break;
+    case 0x70:
+    case 0x74:
+    case 0x78:
+    case 0x7c:
+        ret = 0;
+        break;
+    case 0x80:
+        ret = s->mode_int_mask;
+        break;
+    case 0x84:
+        ret = s->raw_mode_int_status & s->mode_int_mask;
+        break;
+    case 0x88:
+        ret = s->raw_mode_int_status;
+        break;
+    case 0x8c:
+        ret = 0;
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_iis_read: Bad offset %x\n", (int)offset);
+        break;
+    }
+
+    return ret;
+}
+
+
+/**************************************************************************
+ * Description:
+ *     IIS controller register write function.
+ * Argument:
+ *     opaque  --- the pointer to the IIS state
+ *     offset  --- the address offset of the register
+ *     value   --- the value that will be written
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_iis_write(void *opaque, hwaddr offset, uint64_t value,
+                           unsigned size)
+{
+    csky_iis_state *s = (csky_iis_state *)opaque;
+    uint32_t oldval;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_iis_write: 0x%x must word align write\n",
+                      (int)offset);
+    }
+
+    switch (offset) {
+    case 0x0:
+        oldval = s->enable;
+        s->enable = (value & 0x1);
+        if (!oldval && s->enable) {
+            s->status = 0xc;
+            if (s->func_mode == RX_MODE) {
+                s->status |= 1 << 0;
+                s->raw_mode_int_status |= 1 << 0;
+            } else {
+                s->status |= 1 << 1;
+                s->raw_int_status |= 1 << 0;
+                s->raw_mode_int_status |= 1 << 1;
+            }
+            if ((s->fssta & 0x1) == 0x1) {
+                s->fssta |= 0x1 << 4;
+            }
+            csky_iis_set_format(s);
+        } else if (oldval && !s->enable) {
+            s->status &= ~0x3;
+            if (s->func_mode == RX_MODE) {
+                s->raw_mode_int_status |= 1 << 0;
+            } else {
+                s->raw_mode_int_status |= 1 << 1;
+            }
+        }
+        break;
+    case 0x4:
+        if (s->enable) {
+            break;
+        }
+        if ((value & 0x2) == 0) {
+            break;
+        }
+        s->func_mode = value & 0x1;
+        break;
+    case 0x8:
+        if (s->enable) {
+            break;
+        }
+        s->iis_cnf_in = value & 0x117;
+        break;
+    case 0xc:
+        s->fssta = value & 0x7;
+        if ((s->fssta & 0x1) == 0) {
+            s->fssta |= value & 0xf0;
+        }
+        break;
+    case 0x10:
+        if (s->enable) {
+            break;
+        }
+        s->iis_cnf_out = value & 0x1f;
+        break;
+    case 0x14:
+        if (s->enable) {
+            break;
+        }
+        s->fadtlr = value;
+        break;
+    case 0x18:
+        s->compress_ctrl = value;
+        break;
+    case 0x1c:
+        if (s->enable) {
+            break;
+        }
+        s->tx_fifo_thr = value & 0x1f;
+        break;
+    case 0x20:
+        if (s->enable) {
+            break;
+        }
+        s->rx_fifo_thr = value & 0x1f;
+        break;
+    case 0x24:
+        break;
+    case 0x28:
+        break;
+    case 0x2c:
+        break;
+    case 0x30:
+        s->int_mask = value & 0x1f;
+        break;
+    case 0x34:
+        break;
+    case 0x38:
+        break;
+    case 0x3c:
+        s->raw_int_status &= ~value;
+        break;
+    case 0x4c:
+        s->dma_ctrl = value & 0x3;
+        break;
+    case 0x50:
+        s->dma_tx_data_lvl = value & 0x1f;
+        break;
+    case 0x54:
+        s->dma_rx_data_lvl = value & 0x1f;
+        break;
+    case 0x60:
+        *((uint32_t *)&s->codec.tx_fifo[s->codec.write_pos]) = value;
+        s->codec.write_pos = (s->codec.write_pos + 4) % TX_FIFO_ENTRY;
+        s->codec.len += 4;
+        s->raw_int_status &= ~TX_FIFO_EMPTY;
+        if (s->codec.len >= TX_FIFO_ENTRY) {
+            s->raw_int_status |= TX_FIFO_OVERFLOW;
+        }
+        break;
+    case 0x70:  /* spdif registers have not been implemented yet */
+    case 0x74:
+    case 0x78:
+    case 0x7c:
+        break;
+    case 0x80:
+        s->mode_int_mask = value & 0x3f;
+        break;
+    case 0x84:
+        break;
+    case 0x88:
+        break;
+    case 0x8c:
+        s->raw_mode_int_status &= ~value;
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_iis_write: Bad offset 0x%x\n", (int)offset);
+    }
+    csky_iis_update(s);
+}
+
+static const MemoryRegionOps csky_iis_ops = {
+    .read = csky_iis_read,
+    .write = csky_iis_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+/**************************************************************************
+ * Description:
+ *     Set the CODEC volume
+ * Argument:
+ *     s -- the pointer to the CODEC state
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_codec_set_volume(csky_codec_state *s)
+{
+    AUD_set_volume_out(s->out_voice, 0, 0xff, 0xff);
+    return;
+}
+
+static int csky_find_dma_chan_id(csky_dma_state *s)
+{
+    int i;
+    int find = 0;
+    for (i = 0; i < 4; i++) {
+        if (s->chan[i].dest == 0x1001b060) {
+            find = 1;
+            break;
+        }
+    }
+    if (find) {
+        return i;
+    }
+    printf("cannot find coresponding DMA channel\n");
+    exit(1);
+}
+
+static int csky_iis_copy_from_dma(csky_iis_state *s)
+{
+    int dma_chan_id;
+    int len;
+
+    dma_chan_id = csky_find_dma_chan_id(s->dma);
+    len = (s->dma->chan[dma_chan_id].ctrl[1])
+        << ((s->dma->chan[dma_chan_id].ctrl[0] >> 4) & 0x7);
+    if (s->codec.len + len > TX_FIFO_ENTRY) {
+        return 0;
+    }
+
+    hwaddr source;
+    source = s->dma->chan[dma_chan_id].src;
+    if (s->codec.write_pos + len < TX_FIFO_ENTRY) {
+        cpu_physical_memory_read(source,
+                                 &s->codec.tx_fifo[s->codec.write_pos],
+                                 len);
+    } else {
+        cpu_physical_memory_read(source,
+                                 &s->codec.tx_fifo[s->codec.write_pos],
+                                 TX_FIFO_ENTRY - s->codec.write_pos);
+        cpu_physical_memory_read(
+                                 source + TX_FIFO_ENTRY - s->codec.write_pos,
+                                 &s->codec.tx_fifo[0],
+                                 len + s->codec.write_pos - TX_FIFO_ENTRY);
+    }
+    s->codec.write_pos = (s->codec.write_pos + len) % TX_FIFO_ENTRY;
+    s->codec.len += len;
+
+    s->dma->tfr_int     |= 1 << dma_chan_id;
+    s->dma->block_int   |= 1 << dma_chan_id;
+    csky_dma_update(s->dma);
+
+    return len;
+}
+
+static inline void csky_audio_out_flush(csky_codec_state *codec,
+                                        int out_pos, int out_len)
+{
+    int sent = 0;
+    while (sent < out_len) {
+        sent += AUD_write(codec->out_voice,
+                          &codec->tx_fifo[out_pos],
+                          out_len - sent) ?: out_len;
+    }
+}
+
+static void csky_audio_out_cb(void *opaque, int free_b)
+{
+    csky_iis_state *s = opaque;
+    csky_codec_state *codec = &s->codec;
+
+    if (codec->len > free_b) {
+        if (codec->read_pos + free_b < TX_FIFO_ENTRY) {
+            csky_audio_out_flush(codec, codec->read_pos, free_b);
+        } else {
+            csky_audio_out_flush(codec, codec->read_pos,
+                                 TX_FIFO_ENTRY - codec->read_pos);
+            csky_audio_out_flush(codec, 0,
+                                 free_b + codec->read_pos - TX_FIFO_ENTRY);
+        }
+        codec->read_pos = (codec->read_pos + free_b) % TX_FIFO_ENTRY;
+        codec->len = codec->len - free_b;
+    }
+    if (csky_dma_can_work(s->dma)) {
+        csky_iis_copy_from_dma(s);
+    }
+    return;
+}
+
+static inline int csky_iis_get_freq(csky_iis_state *s)
+{
+    int ars, afr;
+
+    ars = (s->fssta >> 6) & 0x3;
+    afr = (s->fssta >> 4) & 0x3;
+    switch (afr) {
+    case 0:
+        return 44100 >> ars;
+    case 1:
+        return 48000 >> ars;
+    case 2:
+        return 32000 >> ars;
+    case 3:
+        return 96000;
+    default:
+        return -1;
+    }
+}
+
+/**************************************************************************
+ * Description:
+ *     Set the CODEC control format
+ * Argument:
+ *     s -- the pointer to the CODEC state
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_iis_set_format(csky_iis_state *s)
+{
+    csky_codec_state *codec = &s->codec;
+    struct audsettings fmt;
+
+    if (codec->out_voice) {
+        AUD_set_active_out(codec->out_voice, 0);
+        AUD_close_out(&codec->card, codec->out_voice);
+        codec->out_voice = NULL;
+    }
+
+    fmt.endianness = 0;
+    fmt.nchannels = 2;
+    fmt.freq = csky_iis_get_freq(s);
+    fmt.fmt = AUD_FMT_S16;
+
+    codec->out_voice = AUD_open_out(&codec->card, codec->out_voice,
+                                    "csky.codec.out", s,
+                                    csky_audio_out_cb, &fmt);
+
+    csky_codec_set_volume(codec);
+
+    AUD_set_active_out(codec->out_voice, 1);
+}
+
+/**************************************************************************
+ * Description:
+ *     Reset the IIS controller.
+ * Argument:
+ *     s -- the pointer to the IIS state
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_iis_reset(csky_iis_state *s)
+{
+    s->enable = 0;
+    s->tx_fifo_thr = 0x10;
+    s->rx_fifo_thr = 0x8;
+    s->status = 0xc;
+    s->int_mask = 0x1f;
+    s->dma_tx_data_lvl = 0x7;
+}
+
+static void csky_iis_device_reset(DeviceState *d)
+{
+    csky_iis_state *s = CSKY_IIS(d);
+
+    csky_iis_reset(s);
+}
+
+/**************************************************************************
+ * Description:
+ *     Initialize the IIS controller.
+ * Argument:
+ *     dev -- the pointer to a system bus device
+ * Return:
+ *     success
+ **************************************************************************/
+static int csky_iis_init(SysBusDevice *dev)
+{
+    csky_iis_state *s = CSKY_IIS(dev);
+
+    AUD_register_card("csky codec", &s->codec.card);
+
+    csky_iis_reset(s);
+
+    memory_region_init_io(&s->iomem, OBJECT(s), &csky_iis_ops, s,
+                          TYPE_CSKY_IIS, 0x1000);
+    sysbus_init_mmio(dev, &s->iomem);
+    sysbus_init_irq(dev, &s->irq);
+
+    return 0;
+}
+
+/*
+void csky_iis_create(const char *name, hwaddr addr, qemu_irq irq,
+                     csky_dma_state *dma)
+{
+    DeviceState *dev;
+    csky_iis_state *s;
+
+    dev = sysbus_create_simple(name, addr, irq);
+    s = FROM_SYSBUS(csky_iis_state, (SysBusDevice *)(dev));
+    s->dma = dma;
+}
+*/
+
+static void csky_iis_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
+
+    k->init = csky_iis_init;
+    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
+    dc->reset = csky_iis_device_reset;
+    dc->vmsd = &vmstate_csky_iis;
+}
+
+static const TypeInfo csky_iis_device_info = {
+    .name          = TYPE_CSKY_IIS,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_iis_state),
+    .class_init    = csky_iis_class_init,
+};
+
+static void csky_iis_register_types(void)
+{
+    type_register_static(&csky_iis_device_info);
+}
+
+type_init(csky_iis_register_types)
diff --git a/hw/block/Makefile.objs b/hw/block/Makefile.objs
index d4c3ab7..abe4397 100644
--- a/hw/block/Makefile.objs
+++ b/hw/block/Makefile.objs
@@ -8,6 +8,7 @@ common-obj-$(CONFIG_XEN_BACKEND) += xen_disk.o
 common-obj-$(CONFIG_ECC) += ecc.o
 common-obj-$(CONFIG_ONENAND) += onenand.o
 common-obj-$(CONFIG_NVME_PCI) += nvme.o
+common-obj-$(CONFIG_CSKY_NFC) += csky_nfc.o
 
 obj-$(CONFIG_SH4) += tc58128.o
 
diff --git a/hw/block/csky_nfc.c b/hw/block/csky_nfc.c
new file mode 100644
index 0000000..4d702dd
--- /dev/null
+++ b/hw/block/csky_nfc.c
@@ -0,0 +1,324 @@
+/*
+ * Csky nand flash controller emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "hw/hw.h"
+#include "hw/block/flash.h"
+#include "hw/irq.h"
+#include "sysemu/block-backend.h"
+#include "sysemu/blockdev.h"
+#include "exec/memory.h"
+#include "exec/address-spaces.h"
+#include "hw/sysbus.h"
+#include "qemu/log.h"
+
+#define NFC_EN 0x0
+#define IMASK 0x4
+#define DEVICE_CFG 0x8
+#define IDR 0xc
+#define COLAR 0x10
+#define ROWAR 0x14
+#define CMDR 0x18
+#define SR 0x1c
+#define ECC_CODE1 0x20
+#define ECC_CODE2 0x24
+#define WPR 0x28
+#define TIMOUT 0x2c
+
+#define TYPE_CSKY_NAND  "csky_nand"
+#define CSKY_NAND(obj)  OBJECT_CHECK(csky_nand_state, (obj), TYPE_CSKY_NAND)
+
+typedef struct {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    DeviceState *nand;
+    uint8_t buf0[0x880];
+    uint8_t buf1[0x880];
+    uint32_t nfc_en;
+    uint32_t imask;
+    uint32_t device_cfg;
+    uint32_t idr;
+    uint32_t colar;
+    uint32_t rowar;
+    uint32_t cmdr;
+    uint32_t sr;
+    uint32_t ecc_code1;
+    uint32_t ecc_code2;
+    uint32_t wpr;
+    uint32_t timout;
+    qemu_irq irq;
+} csky_nand_state;
+
+static uint64_t csky_nand_read(void *opaque, hwaddr addr, unsigned size)
+{
+    csky_nand_state *s = (csky_nand_state *) opaque;
+
+    if (size == 1) {
+        if (0x1000 <= addr && addr <= 0x187f) {
+            return s->buf0[addr - 0x1000];
+        } else if (0x2000 <= addr && addr <= 0x287f) {
+            return s->buf0[addr - 0x2000];
+        } else {
+            printf("csky_nand_read: Bad offset %x\n", (int)addr);
+            return 0;
+        }
+    } else if (size == 4) {
+        switch (addr) {
+        case NFC_EN:
+            return s->nfc_en;
+        case IMASK:
+            return s->imask;
+        case DEVICE_CFG:
+            return s->device_cfg;
+        case IDR:
+            return s->idr;
+        case COLAR:
+            return s->colar;
+        case ROWAR:
+            return s->rowar;
+        case CMDR:
+            return s->cmdr;
+        case SR:
+            return s->sr;
+        case ECC_CODE1:
+            return s->ecc_code1;
+        case ECC_CODE2:
+            return s->ecc_code2;
+        case WPR:
+            return s->wpr;
+        case TIMOUT:
+            return s->timout;
+        default:
+            if (0x1000 <= addr && addr <= 0x187f) {
+                return (int)s->buf0[addr - 0x1000] |
+                    (s->buf0[addr - 0x1000 + 1] << 8) |
+                    (s->buf0[addr - 0x1000 + 2] << 16) |
+                    (s->buf0[addr - 0x1000 + 3] << 24);
+            } else if (0x2000 <= addr && addr <= 0x287f) {
+                return (int)s->buf1[addr - 0x2000] |
+                    (s->buf1[addr - 0x2000 + 1] << 8) |
+                    (s->buf1[addr - 0x2000 + 2] << 16) |
+                    (s->buf1[addr - 0x2000 + 3] << 24);
+            } else {
+                qemu_log_mask(LOG_GUEST_ERROR,
+                              "csky_nand_read: Bad offset %x\n", (int)addr);
+                return 0;
+            }
+        }
+    } else {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_nand_read: Bad access size\n");
+    }
+    return 0;
+}
+
+static void csky_nand_write(void *opaque, hwaddr addr, uint64_t value,
+                            unsigned size)
+{
+    csky_nand_state *s = (csky_nand_state *) opaque;
+    int i;
+
+    if (size == 1) {
+        if (0x1000 <= addr && addr <= 0x187f) {
+            s->buf0[addr - 0x1000] = value;
+        } else if (0x2000 <= addr && addr <= 0x287f) {
+            s->buf0[addr - 0x2000] = value;
+        } else {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "csky_nand_write: Bad offset %x\n", (int)addr);
+        }
+    } else if (size == 4) {
+        switch (addr) {
+        case NFC_EN:
+            s->nfc_en = value;
+            break;
+        case IMASK:
+            s->imask = value;
+            break;
+        case DEVICE_CFG:
+            s->device_cfg = value;
+            break;
+        case IDR:  /* read only */
+            break;
+        case COLAR:
+            s->colar = value;
+            break;
+        case ROWAR:
+            s->rowar = value;
+            break;
+        case CMDR:
+            s->cmdr = value;
+            switch (s->cmdr & 0xf) {
+            case 0x0: /* read page */
+                nand_setpins(s->nand, 1, 0, 0, 1, 0); /* cmd */
+                nand_setio(s->nand, 0x00);
+                nand_setpins(s->nand, 0, 1, 0, 1, 0); /* addr */
+                nand_setio(s->nand, s->colar & 0xff);
+                nand_setio(s->nand, s->rowar & 0xff);
+                nand_setio(s->nand, (s->rowar >> 8) & 0xff);
+                nand_setio(s->nand, (s->rowar >> 16) & 0xff);
+                if (s->cmdr & 0x40) {
+                    for (i = 0; i < 528; i++) {
+                        s->buf1[i] = nand_getio(s->nand);
+                    }
+                } else {
+                    for (i = 0; i < 528; i++) {
+                        s->buf0[i] = nand_getio(s->nand);
+                    }
+                }
+                break;
+            case 0x6: /* erase block */
+                nand_setpins(s->nand, 1, 0, 0, 1, 0); /* cmd */
+                nand_setio(s->nand, 0x60);
+                nand_setpins(s->nand, 0, 1, 0, 1, 0); /* addr */
+                nand_setio(s->nand, s->rowar & 0xff);
+                nand_setio(s->nand, (s->rowar >> 8) & 0xff);
+                nand_setio(s->nand, (s->rowar >> 16) & 0xff);
+                nand_setpins(s->nand, 1, 0, 0, 1, 0); /* cmd */
+                nand_setio(s->nand, 0xd0);
+                break;
+            case 0x7: /* read status */
+                nand_setpins(s->nand, 1, 0, 0, 1, 0); /* cmd */
+                nand_setio(s->nand, 0x70);
+                i = nand_getio(s->nand);
+                s->sr = ((i & 0x1) << 1) | ((i & 0x40) >> 6);
+                s->wpr = (i & 0x80) >> 7;
+                break;
+            case 0x8:  /* program page */
+                nand_setpins(s->nand, 1, 0, 0, 1, 0); /* cmd */
+                nand_setio(s->nand, 0x80);
+                nand_setpins(s->nand, 0, 1, 0, 1, 0); /* addr */
+                nand_setio(s->nand, s->colar & 0xff);
+                nand_setio(s->nand, s->rowar & 0xff);
+                nand_setio(s->nand, (s->rowar >> 8) & 0xff);
+                nand_setio(s->nand, (s->rowar >> 16) & 0xff);
+                nand_setpins(s->nand, 0, 0, 0, 1, 0); /* data */
+                if (s->cmdr & 0x40) {
+                    for (i = 0; i < 528; i++) {
+                        nand_setio(s->nand, s->buf1[i]);
+                    }
+                } else {
+                    for (i = 0; i < 528; i++) {
+                        nand_setio(s->nand, s->buf0[i]);
+                    }
+                }
+
+                nand_setpins(s->nand, 1, 0, 0, 1, 0); /* cmd */
+                nand_setio(s->nand, 0x10);
+                break;
+            case 0x9: /* read id */
+                nand_setpins(s->nand, 1, 0, 0, 1, 0); /* cmd */
+                nand_setio(s->nand, 0x90);
+                nand_setpins(s->nand, 0, 1, 0, 1, 0); /* addr */
+                nand_setio(s->nand, 0x00);
+                for (i = 0; i < 4; i++) {
+                    s->idr |= nand_getio(s->nand) << i * 8;
+                }
+                break;
+            case 0xe: /* read parameter page */
+                break;
+            case 0xf:  /* reset */
+                nand_setpins(s->nand, 1, 0, 0, 1, 0); /* cmd */
+                nand_setio(s->nand, 0xff);
+                break;
+            default:
+                qemu_log_mask(LOG_GUEST_ERROR,
+                              "csky_nand_write: Bad offset %x\n", (int)addr);
+            }
+            break;
+        case SR:
+            break;
+        case ECC_CODE1:
+            break;
+        case ECC_CODE2:
+            break;
+        case WPR:
+            s->wpr = value;
+            break;
+        case TIMOUT:
+            s->timout = value;
+            break;
+        default:
+            if (0x1000 <= addr && addr <= 0x187f) {
+                s->buf0[addr - 0x1000] = value & 0xff;
+                s->buf0[addr - 0x1000 + 1] = (value >> 8) & 0xff;
+                s->buf0[addr - 0x1000 + 2] = (value >> 16) & 0xff;
+                s->buf0[addr - 0x1000 + 3] = (value >> 24) & 0xff;
+            } else if (0x2000 <= addr && addr <= 0x287f) {
+                s->buf1[addr - 0x2000] = value & 0xff;
+                s->buf1[addr - 0x2000 + 1] = (value >> 8) & 0xff;
+                s->buf1[addr - 0x2000 + 2] = (value >> 16) & 0xff;
+                s->buf1[addr - 0x2000 + 3] = (value >> 24) & 0xff;
+            } else {
+                qemu_log_mask(LOG_GUEST_ERROR,
+                              "csky_nand_write: Bad offset %x\n", (int)addr);
+            }
+        }
+    } else {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_nand_write: Bad access size\n");
+    }
+}
+
+static const MemoryRegionOps csky_nand_ops = {
+    .read = csky_nand_read,
+    .write = csky_nand_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static int csky_nand_init(SysBusDevice *sbd)
+{
+    DeviceState *dev = DEVICE(sbd);
+    csky_nand_state *s = CSKY_NAND(dev);
+    DriveInfo *nand = NULL;
+
+    s->idr = 0;
+    s->sr = 0;
+    s->ecc_code1 = 0;
+    s->ecc_code2 = 0;
+    s->timout = 0xffffffff;
+    s->nand = nand_init(nand ? blk_by_legacy_dinfo(nand) : NULL, 0xec, 0xa2);
+    sysbus_init_irq(sbd, &s->irq);
+    memory_region_init_io(&s->iomem, OBJECT(s), &csky_nand_ops, s,
+                          TYPE_CSKY_NAND, 0x3000);
+    sysbus_init_mmio(sbd, &s->iomem);
+
+    return 0;
+}
+
+static void csky_nand_class_init(ObjectClass *klass, void *data)
+{
+    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
+
+    k->init = csky_nand_init;
+}
+
+static const TypeInfo onenand_info = {
+    .name          = TYPE_CSKY_NAND,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_nand_state),
+    .class_init    = csky_nand_class_init,
+};
+
+static void csky_nand_register_types(void)
+{
+    type_register_static(&onenand_info);
+}
+
+type_init(csky_nand_register_types)
diff --git a/hw/char/Makefile.objs b/hw/char/Makefile.objs
index 69a553c..05ad83f 100644
--- a/hw/char/Makefile.objs
+++ b/hw/char/Makefile.objs
@@ -18,6 +18,11 @@ obj-$(CONFIG_DIGIC) += digic-uart.o
 obj-$(CONFIG_STM32F2XX_USART) += stm32f2xx_usart.o
 obj-$(CONFIG_RASPI) += bcm2835_aux.o
 
+ifeq ($(CONFIG_MODULES),y)
+common-obj-$(if $(CONFIG_CSKY_UART),m,n) += csky_uart_dummy.o
+endif
+obj-$(CONFIG_CSKY_UART) += csky_uart.o
+
 common-obj-$(CONFIG_ETRAXFS) += etraxfs_ser.o
 common-obj-$(CONFIG_ISA_DEBUG) += debugcon.o
 common-obj-$(CONFIG_GRLIB) += grlib_apbuart.o
diff --git a/hw/char/csky_uart.c b/hw/char/csky_uart.c
new file mode 100644
index 0000000..5d91ba9
--- /dev/null
+++ b/hw/char/csky_uart.c
@@ -0,0 +1,401 @@
+/*
+ * Csky UART emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "sysemu/char.h"
+#include "qemu/log.h"
+#include "trace.h"
+
+typedef struct csky_uart_state {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    uint32_t dll;   /* Divisor Latch Low */
+    uint32_t dlh;   /* Divisor Latch High */
+    uint32_t ier;   /* Interrupt Enable Register */
+    uint32_t iir;   /* Interrupt Identity Register */
+    uint32_t fcr;   /* FIFO control register */
+    uint32_t lcr;   /* line control register */
+    uint32_t mcr;   /* modem control register */
+    uint32_t lsr;   /* line status register */
+    uint32_t msr;   /* modem status register */
+    uint32_t usr;   /* uart status register */
+    uint32_t rx_fifo[16];
+    int rx_pos;
+    int rx_count;
+    int rx_trigger;
+    CharBackend chr;
+    qemu_irq irq;
+} csky_uart_state;
+
+#define TYPE_CSKY_UART  "csky_uart"
+#define CSKY_UART(obj)  OBJECT_CHECK(csky_uart_state, (obj), TYPE_CSKY_UART)
+
+/* lsr:line status register */
+#define lsr_TEMT 0x40
+#define lsr_THRE 0x20   /* no new data has been written
+                           to the THR or TX FIFO */
+#define lsr_OE   0x2    /* overruun error */
+#define lsr_DR   0x1    /* at least one character in the RBR or
+                           the receiver FIFO */
+
+
+/* flags: USR user status register */
+#define usr_REF  0x10   /* Receive FIFO Full */
+#define usr_RFNE 0x8    /* Receive FIFO not empty */
+#define usr_TFE  0x4    /* transmit FIFO empty */
+#define usr_TFNF 0x2    /* transmit FIFO not full */
+
+/* interrupt type */
+#define INT_NONE 0x1   /* no interrupt */
+#define INT_TX 0x2     /* Transmitter holding register empty */
+#define INT_RX 0x4     /* Receiver data available */
+
+static void csky_uart_update(csky_uart_state *s)
+{
+    uint32_t flags = 0;
+
+    flags = (s->iir & 0xf) == INT_TX && (s->ier & 0x2) != 0;
+    flags |= (s->iir & 0xf) == INT_RX && (s->ier & 0x1) != 0;
+    qemu_set_irq(s->irq, flags != 0);
+}
+
+static uint64_t csky_uart_read(void *opaque, hwaddr offset, unsigned size)
+{
+    csky_uart_state *s = (csky_uart_state *)opaque;
+    uint32_t c;
+    uint64_t ret = 0;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_uart_read: 0x%x must word align read\n",
+                      (int)offset);
+    }
+
+    switch ((offset & 0xfff) >> 2) {
+    case 0x0: /* RBR,DLL */
+        if (s->lcr & 0x80) {
+            ret = s->dll;
+        } else if (s->fcr & 0x1) {
+            s->usr &= ~usr_REF;   /* receive fifo not full */
+            c = s->rx_fifo[s->rx_pos];
+            if (s->rx_count > 0) {
+                s->rx_count--;
+                if (++s->rx_pos == 16) {
+                    s->rx_pos = 0;
+                }
+            }
+            if (s->rx_count == 0) {
+                s->lsr &= ~lsr_DR;
+                s->usr &= ~usr_RFNE;    /* receive fifo empty */
+            }
+            if (s->rx_count == s->rx_trigger - 1) {
+                s->iir = (s->iir & ~0xf) | INT_NONE;
+            }
+            csky_uart_update(s);
+            qemu_chr_fe_accept_input(&s->chr);
+            ret =  c;
+        } else {
+            s->usr &= ~usr_REF;
+            s->usr &= ~usr_RFNE;
+            s->lsr &= ~lsr_DR;
+            s->iir = (s->iir & ~0xf) | INT_NONE;
+            csky_uart_update(s);
+            qemu_chr_fe_accept_input(&s->chr);
+            ret =  s->rx_fifo[0];
+        }
+        break;
+    case 0x1: /* DLH, IER */
+        if (s->lcr & 0x80) {
+            ret = s->dlh;
+        } else {
+            ret = s->ier;
+        }
+        break;
+    case 0x2: /* IIR */
+        if ((s->iir & 0xf) == INT_RX) {
+            s->iir = (s->iir & ~0xf) | INT_NONE;
+            csky_uart_update(s);
+            ret = (s->iir & ~0xf) | INT_RX;
+        } else if ((s->iir & 0xf) == INT_TX) {
+            s->iir = (s->iir & ~0xf) | INT_NONE;
+            csky_uart_update(s);
+            ret = (s->iir & ~0xf) | INT_TX;
+        } else {
+            ret = s->iir;
+        }
+        break;
+    case 0x3: /* LCR */
+        ret = s->lcr;
+        break;
+    case 0x4: /* MCR */
+        ret = s->mcr;
+        break;
+    case 0x5: /* LSR */
+        ret = s->lsr;
+        break;
+    case 0x6: /* MSR */
+        ret = s->msr;
+        break;
+    case 0x1f: /* USR */
+        ret = s->usr;
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_uart_read: Bad offset %x\n", (int)offset);
+    }
+
+    return ret;
+}
+
+static void csky_uart_fcr_update(csky_uart_state *s)
+{
+    /* update rx_trigger */
+    if (s->fcr & 0x1) {
+        /* fifo enabled */
+        switch ((s->fcr >> 6) & 0x3) {
+        case 0:
+            s->rx_trigger = 1;
+            break;
+        case 1:
+            s->rx_trigger = 4;
+            break;
+        case 2:
+            s->rx_trigger = 8;
+            break;
+        case 3:
+            s->rx_trigger = 14;
+            break;
+        default:
+            s->rx_trigger = 1;
+            break;
+        }
+    } else {
+        s->rx_trigger = 1;
+    }
+
+    /* reset rx_fifo */
+    if (s->fcr & 0x2) {
+        s->rx_pos = 0;
+        s->rx_count = 0;
+    }
+}
+
+static void csky_uart_write(void *opaque, hwaddr offset, uint64_t value,
+                            unsigned size)
+{
+    csky_uart_state *s = (csky_uart_state *)opaque;
+    unsigned char ch;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_uart_write: 0x%x must word align read\n",
+                      (int)offset);
+    }
+
+    switch (offset >> 2) {
+    case 0x0: /*dll, thr */
+        if (s->lcr & 0x80) {
+            s->dll = value;
+        } else {
+            ch = value;
+            qemu_chr_fe_write_all(&s->chr, &ch, 1);
+            s->lsr |= (lsr_THRE | lsr_TEMT);
+            if ((s->iir & 0xf) != INT_RX) {
+                s->iir = (s->iir & ~0xf) | INT_TX;
+            }
+            csky_uart_update(s);
+        }
+        break;
+    case 0x1: /* DLH, IER */
+        if (s->lcr & 0x80) {
+            s->dlh = value;
+        } else {
+            s->ier = value;
+            s->iir = (s->iir & ~0xf) | INT_TX;
+            csky_uart_update(s);
+        }
+        break;
+    case 0x2: /* FCR */
+        if ((s->fcr & 0x1) ^ (value & 0x1)) {
+            /* change fifo enable bit, reset rx_fifo */
+            s->rx_pos = 0;
+            s->rx_count = 0;
+        }
+        s->fcr = value;
+        csky_uart_fcr_update(s);
+        break;
+    case 0x3: /* LCR */
+        s->lcr = value;
+        break;
+    case 0x4: /* MCR */
+        s->mcr = value;
+        break;
+    case 0x5: /* LSR read only*/
+        return;
+    case 0x6: /* MSR read only*/
+        return;
+    case 0x1f: /* USR read only*/
+        return;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_uart_write: Bad offset %x\n", (int)offset);
+    }
+}
+
+static int csky_uart_can_receive(void *opaque)
+{
+    /* always can receive data */
+    csky_uart_state *s = (csky_uart_state *)opaque;
+
+    if (s->fcr & 0x1) { /* fifo enabled */
+        return s->rx_count < 16;
+    } else {
+        return s->rx_count < 1;
+    }
+}
+
+
+static void csky_uart_receive(void *opaque, const uint8_t *buf, int size)
+{
+    csky_uart_state *s = (csky_uart_state *)opaque;
+    int slot;
+
+    if (size < 1) {
+        return;
+    }
+
+    if (s->usr & usr_REF) {
+        s->lsr |= lsr_OE;  /* overrun error */
+    }
+
+    if (!(s->fcr & 0x1)) { /* none fifo mode */
+        s->rx_fifo[0] = *buf;
+        s->usr |= usr_REF;
+        s->usr |= usr_RFNE;
+        s->iir = (s->iir & ~0xf) | INT_RX;
+        s->lsr |= lsr_DR;
+        csky_uart_update(s);
+        return;
+    }
+
+    /* fifo mode */
+    slot = s->rx_pos + s->rx_count;
+    if (slot >= 16) {
+        slot -= 16;
+    }
+    s->rx_fifo[slot] = *buf;
+    s->rx_count++;
+    s->lsr |= lsr_DR;
+    s->usr |= usr_RFNE;     /* receive fifo not empty */
+    if (s->rx_count == 16) {
+        s->usr |= usr_REF;    /* receive fifo full */
+    }
+    s->iir = (s->iir & ~0xf) | INT_RX;
+    csky_uart_update(s);
+    return;
+}
+
+static void csky_uart_event(void *opaque, int event)
+{
+}
+
+static const MemoryRegionOps csky_uart_ops = {
+    .read = csky_uart_read,
+    .write = csky_uart_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static const VMStateDescription vmstate_csky_uart = {
+    .name = TYPE_CSKY_UART,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT32(dll, csky_uart_state),
+        VMSTATE_UINT32(dlh, csky_uart_state),
+        VMSTATE_UINT32(ier, csky_uart_state),
+        VMSTATE_UINT32(iir, csky_uart_state),
+        VMSTATE_UINT32(fcr, csky_uart_state),
+        VMSTATE_UINT32(lcr, csky_uart_state),
+        VMSTATE_UINT32(mcr, csky_uart_state),
+        VMSTATE_UINT32(lsr, csky_uart_state),
+        VMSTATE_UINT32(msr, csky_uart_state),
+        VMSTATE_UINT32(usr, csky_uart_state),
+        VMSTATE_UINT32_ARRAY(rx_fifo, csky_uart_state, 16),
+        VMSTATE_INT32(rx_pos, csky_uart_state),
+        VMSTATE_INT32(rx_count, csky_uart_state),
+        VMSTATE_INT32(rx_trigger, csky_uart_state),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static Property csky_uart_properties[] = {
+    DEFINE_PROP_CHR("chardev", csky_uart_state, chr),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void csky_uart_init(Object *obj)
+{
+    csky_uart_state *s = CSKY_UART(obj);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+
+    memory_region_init_io(&s->iomem, OBJECT(s), &csky_uart_ops, s,
+                          TYPE_CSKY_UART, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+    sysbus_init_irq(sbd, &s->irq);
+
+    s->rx_trigger = 1;
+    s->dlh = 0x4;
+    s->iir = 0x1;
+    s->lsr = 0x60;
+    s->usr = 0x6;
+}
+
+static void csky_uart_realize(DeviceState *dev, Error **errp)
+{
+    csky_uart_state *s = CSKY_UART(dev);
+
+    qemu_chr_fe_set_handlers(&s->chr, csky_uart_can_receive, csky_uart_receive,
+                             csky_uart_event, s, NULL, true);
+}
+
+static void csky_uart_class_init(ObjectClass *oc, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(oc);
+
+    dc->realize = csky_uart_realize;
+    dc->vmsd = &vmstate_csky_uart;
+    dc->props = csky_uart_properties;
+}
+
+static const TypeInfo csky_uart_info = {
+    .name          = TYPE_CSKY_UART,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_uart_state),
+    .instance_init = csky_uart_init,
+    .class_init    = csky_uart_class_init,
+};
+
+
+static void csky_uart_register_types(void)
+{
+    type_register_static(&csky_uart_info);
+}
+
+type_init(csky_uart_register_types)
+
diff --git a/hw/char/csky_uart_dummy.c b/hw/char/csky_uart_dummy.c
new file mode 100644
index 0000000..5bc53e4
--- /dev/null
+++ b/hw/char/csky_uart_dummy.c
@@ -0,0 +1,402 @@
+/*
+ * Csky UART emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "sysemu/char.h"
+#include "qemu/log.h"
+#include "trace.h"
+
+typedef struct csky_uart_dummy_state {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    uint32_t dll;   /* Divisor Latch Low */
+    uint32_t dlh;   /* Divisor Latch High */
+    uint32_t ier;   /* Interrupt Enable Register */
+    uint32_t iir;   /* Interrupt Identity Register */
+    uint32_t fcr;   /* FIFO control register */
+    uint32_t lcr;   /* line control register */
+    uint32_t mcr;   /* modem control register */
+    uint32_t lsr;   /* line status register */
+    uint32_t msr;   /* modem status register */
+    uint32_t usr;   /* uart status register */
+    uint32_t rx_fifo[16];
+    int rx_pos;
+    int rx_count;
+    int rx_trigger;
+    CharBackend chr;
+    qemu_irq irq;
+} csky_uart_dummy_state;
+
+#define TYPE_CSKY_UART  "csky_uart_dummy"
+#define CSKY_UART(obj)  OBJECT_CHECK(csky_uart_dummy_state, (obj), TYPE_CSKY_UART)
+
+/* lsr:line status register */
+#define lsr_TEMT 0x40
+#define lsr_THRE 0x20   /* no new data has been written
+                           to the THR or TX FIFO */
+#define lsr_OE   0x2    /* overruun error */
+#define lsr_DR   0x1    /* at least one character in the RBR or
+                           the receiver FIFO */
+
+
+/* flags: USR user status register */
+#define usr_REF  0x10   /* Receive FIFO Full */
+#define usr_RFNE 0x8    /* Receive FIFO not empty */
+#define usr_TFE  0x4    /* transmit FIFO empty */
+#define usr_TFNF 0x2    /* transmit FIFO not full */
+
+/* interrupt type */
+#define INT_NONE 0x1   /* no interrupt */
+#define INT_TX 0x2     /* Transmitter holding register empty */
+#define INT_RX 0x4     /* Receiver data available */
+
+static void csky_uart_dummy_update(csky_uart_dummy_state *s)
+{
+    uint32_t flags = 0;
+
+    flags = (s->iir & 0xf) == INT_TX && (s->ier & 0x2) != 0;
+    flags |= (s->iir & 0xf) == INT_RX && (s->ier & 0x1) != 0;
+    qemu_set_irq(s->irq, flags != 0);
+}
+
+static uint64_t csky_uart_dummy_read(void *opaque, hwaddr offset, unsigned size)
+{
+    csky_uart_dummy_state *s = (csky_uart_dummy_state *)opaque;
+    uint32_t c;
+    uint64_t ret = 0;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_uart_dummy_read: 0x%x must word align read\n",
+                      (int)offset);
+    }
+
+    switch ((offset & 0xfff) >> 2) {
+    case 0x0: /* RBR,DLL */
+        if (s->lcr & 0x80) {
+            ret = s->dll;
+        } else if (s->fcr & 0x1) {
+            s->usr &= ~usr_REF;   /* receive fifo not full */
+            c = s->rx_fifo[s->rx_pos];
+            if (s->rx_count > 0) {
+                s->rx_count--;
+                if (++s->rx_pos == 16) {
+                    s->rx_pos = 0;
+                }
+            }
+            if (s->rx_count == 0) {
+                s->lsr &= ~lsr_DR;
+                s->usr &= ~usr_RFNE;    /* receive fifo empty */
+            }
+            if (s->rx_count == s->rx_trigger - 1) {
+                s->iir = (s->iir & ~0xf) | INT_NONE;
+            }
+            csky_uart_dummy_update(s);
+            qemu_chr_fe_accept_input(&s->chr);
+            ret =  c;
+        } else {
+            s->usr &= ~usr_REF;
+            s->usr &= ~usr_RFNE;
+            s->lsr &= ~lsr_DR;
+            s->iir = (s->iir & ~0xf) | INT_NONE;
+            csky_uart_dummy_update(s);
+            qemu_chr_fe_accept_input(&s->chr);
+            ret =  s->rx_fifo[0];
+        }
+        break;
+    case 0x1: /* DLH, IER */
+        if (s->lcr & 0x80) {
+            ret = s->dlh;
+        } else {
+            ret = s->ier;
+        }
+        break;
+    case 0x2: /* IIR */
+        if ((s->iir & 0xf) == INT_RX) {
+            s->iir = (s->iir & ~0xf) | INT_NONE;
+            csky_uart_dummy_update(s);
+            ret = (s->iir & ~0xf) | INT_RX;
+        } else if ((s->iir & 0xf) == INT_TX) {
+            s->iir = (s->iir & ~0xf) | INT_NONE;
+            csky_uart_dummy_update(s);
+            ret = (s->iir & ~0xf) | INT_TX;
+        } else {
+            ret = s->iir;
+        }
+        break;
+    case 0x3: /* LCR */
+        ret = s->lcr;
+        break;
+    case 0x4: /* MCR */
+        ret = s->mcr;
+        break;
+    case 0x5: /* LSR */
+        ret = s->lsr;
+        break;
+    case 0x6: /* MSR */
+        ret = s->msr;
+        break;
+    case 0x1f: /* USR */
+        ret = s->usr;
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_uart_dummy_read: Bad offset %x\n", (int)offset);
+    }
+
+    return ret;
+}
+
+static void csky_uart_dummy_fcr_update(csky_uart_dummy_state *s)
+{
+    /* update rx_trigger */
+    if (s->fcr & 0x1) {
+        /* fifo enabled */
+        switch ((s->fcr >> 6) & 0x3) {
+        case 0:
+            s->rx_trigger = 1;
+            break;
+        case 1:
+            s->rx_trigger = 4;
+            break;
+        case 2:
+            s->rx_trigger = 8;
+            break;
+        case 3:
+            s->rx_trigger = 14;
+            break;
+        default:
+            s->rx_trigger = 1;
+            break;
+        }
+    } else {
+        s->rx_trigger = 1;
+    }
+
+    /* reset rx_fifo */
+    if (s->fcr & 0x2) {
+        s->rx_pos = 0;
+        s->rx_count = 0;
+    }
+}
+
+static void csky_uart_dummy_write(void *opaque, hwaddr offset, uint64_t value,
+                            unsigned size)
+{
+    csky_uart_dummy_state *s = (csky_uart_dummy_state *)opaque;
+    unsigned char ch;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_uart_dummy_write: 0x%x must word align read\n",
+                      (int)offset);
+    }
+
+    switch (offset >> 2) {
+    case 0x0: /*dll, thr */
+        if (s->lcr & 0x80) {
+            s->dll = value;
+        } else {
+            ch = value;
+            qemu_chr_fe_write_all(&s->chr, &ch, 1);
+            s->lsr |= (lsr_THRE | lsr_TEMT);
+            if ((s->iir & 0xf) != INT_RX) {
+                s->iir = (s->iir & ~0xf) | INT_TX;
+            }
+            csky_uart_dummy_update(s);
+        }
+        break;
+    case 0x1: /* DLH, IER */
+        if (s->lcr & 0x80) {
+            s->dlh = value;
+        } else {
+            s->ier = value;
+            s->iir = (s->iir & ~0xf) | INT_TX;
+            csky_uart_dummy_update(s);
+        }
+        break;
+    case 0x2: /* FCR */
+        if ((s->fcr & 0x1) ^ (value & 0x1)) {
+            /* change fifo enable bit, reset rx_fifo */
+            s->rx_pos = 0;
+            s->rx_count = 0;
+        }
+        s->fcr = value;
+        csky_uart_dummy_fcr_update(s);
+        break;
+    case 0x3: /* LCR */
+        s->lcr = value;
+        break;
+    case 0x4: /* MCR */
+        s->mcr = value;
+        break;
+    case 0x5: /* LSR read only*/
+        return;
+    case 0x6: /* MSR read only*/
+        return;
+    case 0x1f: /* USR read only*/
+        return;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_uart_dummy_write: Bad offset %x\n", (int)offset);
+    }
+}
+
+static int csky_uart_dummy_can_receive(void *opaque)
+{
+    /* always can receive data */
+    csky_uart_dummy_state *s = (csky_uart_dummy_state *)opaque;
+
+    if (s->fcr & 0x1) { /* fifo enabled */
+        return s->rx_count < 16;
+    } else {
+        return s->rx_count < 1;
+    }
+}
+
+
+static void csky_uart_dummy_receive(void *opaque, const uint8_t *buf, int size)
+{
+    csky_uart_dummy_state *s = (csky_uart_dummy_state *)opaque;
+    int slot;
+
+    if (size < 1) {
+        return;
+    }
+
+    if (s->usr & usr_REF) {
+        s->lsr |= lsr_OE;  /* overrun error */
+    }
+
+    if (!(s->fcr & 0x1)) { /* none fifo mode */
+        s->rx_fifo[0] = *buf;
+        s->usr |= usr_REF;
+        s->usr |= usr_RFNE;
+        s->iir = (s->iir & ~0xf) | INT_RX;
+        s->lsr |= lsr_DR;
+        csky_uart_dummy_update(s);
+        return;
+    }
+
+    /* fifo mode */
+    slot = s->rx_pos + s->rx_count;
+    if (slot >= 16) {
+        slot -= 16;
+    }
+    s->rx_fifo[slot] = *buf;
+    s->rx_count++;
+    s->lsr |= lsr_DR;
+    s->usr |= usr_RFNE;     /* receive fifo not empty */
+    if (s->rx_count == 16) {
+        s->usr |= usr_REF;    /* receive fifo full */
+    }
+    s->iir = (s->iir & ~0xf) | INT_RX;
+    csky_uart_dummy_update(s);
+    return;
+}
+
+static void csky_uart_dummy_event(void *opaque, int event)
+{
+}
+
+static const MemoryRegionOps csky_uart_dummy_ops = {
+    .read = csky_uart_dummy_read,
+    .write = csky_uart_dummy_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static const VMStateDescription vmstate_csky_uart_dummy = {
+    .name = TYPE_CSKY_UART,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT32(dll, csky_uart_dummy_state),
+        VMSTATE_UINT32(dlh, csky_uart_dummy_state),
+        VMSTATE_UINT32(ier, csky_uart_dummy_state),
+        VMSTATE_UINT32(iir, csky_uart_dummy_state),
+        VMSTATE_UINT32(fcr, csky_uart_dummy_state),
+        VMSTATE_UINT32(lcr, csky_uart_dummy_state),
+        VMSTATE_UINT32(mcr, csky_uart_dummy_state),
+        VMSTATE_UINT32(lsr, csky_uart_dummy_state),
+        VMSTATE_UINT32(msr, csky_uart_dummy_state),
+        VMSTATE_UINT32(usr, csky_uart_dummy_state),
+        VMSTATE_UINT32_ARRAY(rx_fifo, csky_uart_dummy_state, 16),
+        VMSTATE_INT32(rx_pos, csky_uart_dummy_state),
+        VMSTATE_INT32(rx_count, csky_uart_dummy_state),
+        VMSTATE_INT32(rx_trigger, csky_uart_dummy_state),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static Property csky_uart_dummy_properties[] = {
+    DEFINE_PROP_CHR("chardev", csky_uart_dummy_state, chr),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void csky_uart_dummy_init(Object *obj)
+{
+    csky_uart_dummy_state *s = CSKY_UART(obj);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+
+    memory_region_init_io(&s->iomem, OBJECT(s), &csky_uart_dummy_ops, s,
+                          TYPE_CSKY_UART, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+    sysbus_init_irq(sbd, &s->irq);
+
+    s->rx_trigger = 1;
+    s->dlh = 0x4;
+    s->iir = 0x1;
+    s->lsr = 0x60;
+    s->usr = 0x6;
+}
+
+static void csky_uart_dummy_realize(DeviceState *dev, Error **errp)
+{
+    csky_uart_dummy_state *s = CSKY_UART(dev);
+
+    qemu_chr_fe_set_handlers(&s->chr, csky_uart_dummy_can_receive,
+                             csky_uart_dummy_receive,
+                             csky_uart_dummy_event, s, NULL, true);
+}
+
+static void csky_uart_dummy_class_init(ObjectClass *oc, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(oc);
+
+    dc->realize = csky_uart_dummy_realize;
+    dc->vmsd = &vmstate_csky_uart_dummy;
+    dc->props = csky_uart_dummy_properties;
+}
+
+static const TypeInfo csky_uart_dummy_info = {
+    .name          = TYPE_CSKY_UART,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_uart_dummy_state),
+    .instance_init = csky_uart_dummy_init,
+    .class_init    = csky_uart_dummy_class_init,
+};
+
+
+static void csky_uart_dummy_register_types(void)
+{
+    type_register_static(&csky_uart_dummy_info);
+}
+
+type_init(csky_uart_dummy_register_types)
+
diff --git a/hw/csky/Makefile.objs b/hw/csky/Makefile.objs
new file mode 100644
index 0000000..a69caad
--- /dev/null
+++ b/hw/csky/Makefile.objs
@@ -0,0 +1,16 @@
+obj-y += boot.o
+obj-y += smarth.o
+obj-y += smartl.o
+obj-y += hobbit1-2.o
+obj-y += deimos.o
+obj-y += eragon.o
+obj-y += virt.o
+obj-y += trilobite.o
+obj-y += trilobite_v2.o
+ifeq ($(CONFIG_MODULES),y)
+common-obj-$(if $(CONFIG_SMART_CARD),m,n) += smart_card.o
+obj-y += dummyh.o
+else
+obj-y += smart_card.o
+endif
+obj-$(CONFIG_MODULES) += dynsoc.o
diff --git a/hw/csky/boot.c b/hw/csky/boot.c
new file mode 100644
index 0000000..00a55d1
--- /dev/null
+++ b/hw/csky/boot.c
@@ -0,0 +1,354 @@
+/*
+ * CSKY kernel loader.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "hw/hw.h"
+#include "hw/csky/csky.h"
+#include "sysemu/kvm.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/numa.h"
+#include "hw/boards.h"
+#include "hw/loader.h"
+#include "elf.h"
+#include "sysemu/device_tree.h"
+#include "qemu/config-file.h"
+#include "exec/address-spaces.h"
+#include "sysemu/qtest.h"
+#include "target-csky/translate.h"
+
+#define KERNEL_ARGS_ADDR 0x800000
+#define KERNEL_LOAD_ADDR 0x00010000
+#define INITRD_LOAD_ADDR 0x0a000000
+#define BIOS_SIZE (4 * 1024 * 1024)
+
+#define WRITE_WORD(p, value) do { \
+    address_space_stl_notdirty(&address_space_memory, p, value, \
+                               MEMTXATTRS_UNSPECIFIED, NULL);   \
+    p += 4;                       \
+} while (0)
+
+static void set_kernel_args_old(struct csky_boot_info *info, CPUCSKYState *env)
+{
+    int initrd_size = info->initrd_size;
+    hwaddr base = info->loader_start;
+    hwaddr p;
+
+    if (info->kernel_flags == KERNEL_BIN_NO_BIOS) {
+        if (env->features & CPU_ABIV1) {
+            env->regs[2] = 0xa2a25441;
+            env->regs[3] = KERNEL_ARGS_ADDR;
+        } else if (env->features & CPU_ABIV2) {
+            env->regs[0] = 0xa2a25441;
+            env->regs[1] = KERNEL_ARGS_ADDR;
+        } else {
+            fprintf(stderr, "do_cpu_reset: bad CPU ABI\n");
+            exit(1);
+        }
+    }
+
+    p = base + KERNEL_ARGS_ADDR;
+    /* ATAG_CORE */
+    WRITE_WORD(p, 5);
+    WRITE_WORD(p, 0x54410001);
+    WRITE_WORD(p, 1);
+    WRITE_WORD(p, 0x1000);
+    WRITE_WORD(p, 0);
+    /* ATAG_MEM_RANGE */
+    WRITE_WORD(p, 5);
+    WRITE_WORD(p, 0x54410002);
+    WRITE_WORD(p, info->loader_start);
+    WRITE_WORD(p, info->ram_size);
+    WRITE_WORD(p, 1);
+
+    WRITE_WORD(p, 5);
+    WRITE_WORD(p, 0x54410004);
+    WRITE_WORD(p, 0xa000000);
+    WRITE_WORD(p, initrd_size);
+    WRITE_WORD(p, 3);
+
+    if (info->kernel_cmdline && *info->kernel_cmdline) {
+        /* ATAG_CMDLINE */
+        int cmdline_size;
+
+        cmdline_size = strlen(info->kernel_cmdline);
+        cpu_physical_memory_write(p + 8, (void *)info->kernel_cmdline,
+                                  cmdline_size + 1);
+        cmdline_size = (cmdline_size >> 2) + 1;
+        WRITE_WORD(p, cmdline_size + 2);
+        WRITE_WORD(p, 0x54410003);
+        p += cmdline_size * 4;
+    }
+
+    /* ATAG_END */
+    WRITE_WORD(p, 0);
+    WRITE_WORD(p, 0);
+}
+
+static void set_kernel_args(struct csky_boot_info *info, CPUCSKYState *env)
+{
+    if (info->kernel_flags != KERNEL_BIN_AND_BIOS) {
+        if (env->features & CPU_ABIV1) {
+            env->regs[2] = info->magic;
+            env->regs[3] = info->dtb_addr;
+        } else if (env->features & CPU_ABIV2) {
+            env->regs[0] = info->magic;
+            env->regs[1] = info->dtb_addr;
+        } else {
+            fprintf(stderr, "do_cpu_reset: bad CPU ABI\n");
+            exit(1);
+        }
+    }
+}
+
+static void do_cpu_reset(void *opaque)
+{
+    CSKYCPU *cpu = opaque;
+    CPUState *cs = CPU(cpu);
+    CPUCSKYState *env = &cpu->env;
+    struct csky_boot_info *info = env->boot_info;
+
+    cpu_reset(cs);
+
+    if (info == NULL) {
+        return;
+    }
+
+    env->pc = info->entry;
+    if (info->kernel_flags == KERNEL_BIN_AND_BIOS) {
+        cs->exception_index = EXCP_CSKY_RESET;
+    } else {
+        cs->exception_index = -1;
+    }
+
+    if (old_param) {
+        set_kernel_args_old(info, env);
+    } else {
+        set_kernel_args(info, env);
+    }
+
+    if (env->mmu_default) {
+        env->cp0.ccr |= 0x1;
+        env->tlb_context->get_physical_address = mmu_get_physical_address;
+    }
+}
+
+static uint64_t cpu_csky_sseg0_to_phys(void *opaque, uint64_t addr)
+{
+    CPUCSKYState *env = (CPUCSKYState *)opaque;
+
+    if (env->mmu_default) {
+        return addr & 0x1fffffffll;
+    } else {
+        return addr;
+    }
+}
+
+static int load_dtb(hwaddr addr, struct csky_boot_info *binfo)
+{
+    void *fdt = NULL;
+    int size;
+
+    if (binfo->dtb_filename) {
+        char *filename;
+        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, binfo->dtb_filename);
+        if (!filename) {
+            fprintf(stderr, "Couldn't open dtb file %s\n", binfo->dtb_filename);
+            goto fail;
+        }
+
+        fdt = load_device_tree(filename, &size);
+        if (!fdt) {
+            fprintf(stderr, "Couldn't open dtb file %s\n", filename);
+            g_free(filename);
+            goto fail;
+        }
+        g_free(filename);
+    } else {
+        fprintf(stderr, "Board was unable to create a dtb blob\n");
+        goto fail;
+    }
+
+    qemu_fdt_dumpdtb(fdt, size);
+
+    /* Put the DTB into the memory map as a ROM image: this will ensure
+     * the DTB is copied again upon reset, even if addr points into RAM.
+     */
+    rom_add_blob_fixed("dtb", fdt, size, addr);
+
+    g_free(fdt);
+
+
+    return 0;
+
+fail:
+    g_free(fdt);
+    return -1;
+}
+
+static void csky_load_kernel_notify(Notifier *notifier, void *data)
+{
+    int kernel_size;
+    int initrd_size = 0;
+    int is_linux = 0;
+    uint64_t elf_entry;
+    hwaddr entry;
+    hwaddr dtb_addr;
+    int big_endian;
+    int no_bios;
+    target_long bios_size;
+    int data_swab = 0;
+    /* 1 is elf.2 is uimage, 3 is bin with no bios, 4 is bin with bios,
+       5 is Kernel bin whithout cmdline and bios */
+    int kernel_flags;
+    CSKYLoadKernelNotifier *n = DO_UPCAST(CSKYLoadKernelNotifier,
+                                         notifier, notifier);
+    CSKYCPU *cpu = n->cpu;
+    struct csky_boot_info *info = container_of(n, struct csky_boot_info,
+                                                load_kernel_notifier);
+
+    CPUCSKYState *env = &cpu->env;
+
+    no_bios = 1;
+
+    info->dtb_filename = qemu_opt_get(qemu_get_machine_opts(), "dtb");
+
+    /* Load the kernel.  */
+    if (info->kernel_filename) {
+#ifdef TARGET_WORDS_BIGENDIAN
+        big_endian = 1;
+#else
+        big_endian = 0;
+#endif
+        /* Assume that raw images are linux kernels, and ELF images are not.  */
+        kernel_size = load_elf(info->kernel_filename, cpu_csky_sseg0_to_phys,
+                               env, &elf_entry,
+                               NULL, NULL, big_endian, EM_CSKY, 1, data_swab);
+        entry = elf_entry;
+        kernel_flags = KERNEL_ELF;
+
+        if (info->dtb_filename) {
+            dtb_addr = cpu_csky_sseg0_to_phys(env, info->dtb_addr);
+            if (load_dtb(dtb_addr, info) == -1) {
+                fprintf(stderr, "qemu: Could not load  dtb '%s'\n",
+                        info->dtb_filename);
+                exit(1);
+            }
+        }
+
+        if (kernel_size < 0) {
+            kernel_size = load_uimage(info->kernel_filename, &entry, NULL,
+                                      &is_linux, NULL, NULL);
+            kernel_flags = KERNEL_UIMAGE;
+        }
+
+        if (kernel_size < 0) {
+            if (info->kernel_cmdline && *info->kernel_cmdline) {
+                kernel_flags = KERNEL_BIN_NO_BIOS;
+            } else {
+                /* Kernel bin without cmdline */
+                kernel_flags = KERNEL_KBIN_NO_CMDLINE;
+            }
+            /* Load a BIOS image. */
+            if (info->initrd_filename) {
+                no_bios = 0;
+                kernel_flags = KERNEL_BIN_AND_BIOS;
+                if (info->initrd_filename) {
+                    bios_size = load_image_targphys(info->initrd_filename, 0x0,
+                                                    BIOS_SIZE);
+                } else {
+                    bios_size = -1;
+                    no_bios = 1;
+                }
+                if ((bios_size < 0 || bios_size > BIOS_SIZE)
+                    && !info->kernel_filename) {
+                    fprintf(stderr, "qemu: Could not load  bios '%s',"
+                            "and no -kernel argument was specified\n",
+                            bios_name);
+                    exit(1);
+                }
+            }
+
+            entry = info->loader_start + KERNEL_LOAD_ADDR;
+            kernel_size = load_image_targphys(info->kernel_filename, entry,
+                                              ram_size - KERNEL_LOAD_ADDR);
+            is_linux = 1;
+        }
+        if (kernel_size < 0) {
+            fprintf(stderr, "qemu: could not load kernel '%s'\n",
+                    info->kernel_filename);
+            exit(1);
+        }
+        if (is_linux) {
+            if (info->initrd_filename) {
+                initrd_size = load_image_targphys(info->initrd_filename,
+                                                  info->loader_start
+                                                  + INITRD_LOAD_ADDR,
+                                                  ram_size - INITRD_LOAD_ADDR);
+                if (initrd_size < 0) {
+                    fprintf(stderr, "qemu: could not load initrd '%s'\n",
+                            info->initrd_filename);
+                    exit(1);
+                }
+            } else {
+                initrd_size = 0;
+            }
+
+            if (no_bios == 1) {
+                if (!env->binstart) {
+                    env->binstart = 0x8000000;
+                }
+                entry = info->loader_start + env->binstart;
+                kernel_size = load_image_targphys(info->kernel_filename, entry,
+                                                  ram_size - env->binstart);
+                env->regs[2] = 0xa2a25441;
+                env->regs[3] = KERNEL_ARGS_ADDR;
+                env->pc = entry;
+            } else {
+                entry = 0x0;
+                env->pc = entry;
+            }
+        }
+
+        info->kernel_flags = kernel_flags;
+        info->entry = entry;
+        info->initrd_size = initrd_size;
+        env->boot_info = info;
+    } else if (!qtest_enabled()) {
+        fprintf(stderr, "Kernel image must be specified\n");
+        exit(-1);
+    }
+}
+
+void csky_load_kernel(CSKYCPU *cpu, struct csky_boot_info *info)
+{
+    CPUState *cs;
+
+    info->load_kernel_notifier.cpu = cpu;
+    info->load_kernel_notifier.notifier.notify = csky_load_kernel_notify;
+    qemu_add_machine_init_done_notifier(&info->load_kernel_notifier.notifier);
+
+    /* CPU objects (unlike devices) are not automatically
+     * reset on system reset, so we must always register a handler to
+     * do so. If we're actually loading a kernel, the handler is
+     * also responsible for arranging that we start it correctly.
+     */
+    for (cs = CPU(cpu); cs; cs = CPU_NEXT(cs)) {
+        qemu_register_reset(do_cpu_reset, CSKY_CPU(cs));
+    }
+}
+
diff --git a/hw/csky/deimos.c b/hw/csky/deimos.c
new file mode 100644
index 0000000..5c60113
--- /dev/null
+++ b/hw/csky/deimos.c
@@ -0,0 +1,115 @@
+/*
+ * CSKY Trilobite V2 System emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#undef NEED_CPU_H
+#define NEED_CPU_H
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "target-csky/cpu.h"
+#include "hw/csky/csky.h"
+#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "net/net.h"
+#include "sysemu/sysemu.h"
+#include "hw/boards.h"
+#include "sysemu/block-backend.h"
+#include "exec/address-spaces.h"
+#include "qemu/error-report.h"
+#include "hw/csky/cskydev.h"
+#include "hw/char/csky_uart.h"
+
+#define CORET_IRQ_NUM   1
+
+static struct csky_boot_info deimos_binfo = {
+    .loader_start = 0x0,
+    .freq         = 1000000000ll
+};
+
+static void deimos_init(MachineState *machine)
+{
+    ObjectClass *cpu_oc;
+    Object *cpuobj;
+    CSKYCPU *cpu;
+    CPUCSKYState *env;
+    qemu_irq *cpu_intc;
+    qemu_irq intc[32];
+    DeviceState *dev;
+    int i;
+    MemoryRegion *sysmem = get_system_memory();
+    MemoryRegion *ram = g_new(MemoryRegion, 1);
+
+    if (!machine->cpu_model) {
+        machine->cpu_model = "ck801";
+    }
+
+    cpu_oc = cpu_class_by_name(TYPE_CSKY_CPU, machine->cpu_model);
+    if (!cpu_oc) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
+
+    cpuobj = object_new(object_class_get_name(cpu_oc));
+
+    object_property_set_bool(cpuobj, true, "realized", &error_fatal);
+
+    cpu = CSKY_CPU(cpuobj);
+    env = &cpu->env;
+
+    memory_region_allocate_system_memory(ram, NULL, "deimos.sdram",
+                                         machine->ram_size);
+    memory_region_add_subregion(sysmem, 0x0, ram);
+
+    cpu_intc = csky_vic_v1_init_cpu(env, CORET_IRQ_NUM);
+
+    csky_tcip_v1_set_freq(deimos_binfo.freq);
+    dev = sysbus_create_simple("csky_tcip_v1", 0xE000E000, cpu_intc[0]);
+
+    for (i = 0; i < 32; i++) {
+        intc[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    csky_uart_create(0x50010000, intc[6], serial_hds[0]);
+
+    deimos_binfo.ram_size = machine->ram_size;
+    deimos_binfo.kernel_filename = machine->kernel_filename;
+    deimos_binfo.kernel_cmdline = machine->kernel_cmdline;
+    deimos_binfo.initrd_filename = machine->initrd_filename;
+    csky_load_kernel(cpu, &deimos_binfo);
+}
+
+static void deimos_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "CSKY deimos";
+    mc->init = deimos_init;
+}
+
+static const TypeInfo deimos_type = {
+    .name = MACHINE_TYPE_NAME("deimos"),
+    .parent = TYPE_MACHINE,
+    .class_init = deimos_class_init,
+};
+
+static void deimos_machine_init(void)
+{
+    type_register_static(&deimos_type);
+}
+
+type_init(deimos_machine_init)
diff --git a/hw/csky/dummyh.c b/hw/csky/dummyh.c
new file mode 100644
index 0000000..494509d
--- /dev/null
+++ b/hw/csky/dummyh.c
@@ -0,0 +1,134 @@
+/*
+ * a dummy similar with CSKY Trilobite V2 System emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#undef NEED_CPU_H
+#define NEED_CPU_H
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "target-csky/cpu.h"
+#include "hw/csky/csky.h"
+#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "net/net.h"
+#include "sysemu/sysemu.h"
+#include "hw/boards.h"
+#include "sysemu/block-backend.h"
+#include "exec/address-spaces.h"
+#include "qemu/error-report.h"
+#include "hw/csky/cskydev.h"
+#include "hw/char/csky_uart.h"
+#include "hw/csky/dynsoc.h"
+
+#define CORET_IRQ_NUM   0
+
+static struct csky_boot_info dummyh_binfo = {
+    .loader_start = 0x0,
+    .dtb_addr = 0x8f000000,
+    .magic = 0x20150401,
+};
+
+static void dummyh_init(MachineState *machine)
+{
+    ObjectClass *cpu_oc;
+    Object *cpuobj;
+    CSKYCPU *cpu;
+    CPUCSKYState *env;
+    qemu_irq *cpu_intc;
+    qemu_irq intc[32];
+    DeviceState *dev;
+    int i;
+    struct dynsoc_board_info *b_info = dynsoc_b_info;
+    MemoryRegion *sysmem = get_system_memory();
+    MemoryRegion *ram = g_new(MemoryRegion, 1);
+
+    if (!machine->cpu_model) {
+        machine->cpu_model = "ck810f";
+    }
+
+    cpu_oc = cpu_class_by_name(TYPE_CSKY_CPU, machine->cpu_model);
+    if (!cpu_oc) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
+
+    cpuobj = object_new(object_class_get_name(cpu_oc));
+
+    object_property_set_bool(cpuobj, true, "realized", &error_fatal);
+
+    cpu = CSKY_CPU(cpuobj);
+    env = &cpu->env;
+
+    if ((b_info->mem[0].name != NULL) && (b_info->mem[0].writeable == 1)) {
+        memory_region_allocate_system_memory(ram, NULL, b_info->mem[0].name,
+                                             b_info->mem[0].size);
+        memory_region_add_subregion(sysmem, b_info->mem[0].addr, ram);
+    }
+
+    cpu_intc = csky_intc_init_cpu(env);
+
+    dev = sysbus_create_simple("csky_intc", 0x10010000, cpu_intc[0]);
+
+    for (i = 0; i < 32; i++) {
+        intc[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    /* create uart */
+    dev = qdev_create(NULL, "csky_uart_dummy");
+    SysBusDevice *s = SYS_BUS_DEVICE(dev);
+    qdev_prop_set_chr(dev, "chardev", serial_hds[0]);
+    qdev_init_nofail(dev);
+    sysbus_mmio_map(s, 0, 0x10015000);
+    sysbus_connect_irq(s, 0, intc[16]);
+
+    sysbus_create_varargs("csky_timer_dummy", 0x10011000, intc[12], intc[13],
+                            intc[14], intc[15], NULL);
+
+    if (nd_table[0].used) {
+        csky_mac_v2_create(&nd_table[0], 0x10006000, intc[26]);
+    }
+
+    sysbus_create_simple("csky_lcdc", 0x10004000, intc[28]);
+
+    dummyh_binfo.ram_size = machine->ram_size;
+    dummyh_binfo.kernel_filename = machine->kernel_filename;
+    dummyh_binfo.kernel_cmdline = machine->kernel_cmdline;
+    dummyh_binfo.initrd_filename = machine->initrd_filename;
+    csky_load_kernel(cpu, &dummyh_binfo);
+}
+
+static void dummyh_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "CSKY dummyh";
+    mc->init = dummyh_init;
+}
+
+static const TypeInfo dummyh_type = {
+    .name = MACHINE_TYPE_NAME("dummyh"),
+    .parent = TYPE_MACHINE,
+    .class_init = dummyh_class_init,
+};
+
+static void dummyh_machine_init(void)
+{
+    type_register_static(&dummyh_type);
+}
+
+type_init(dummyh_machine_init)
diff --git a/hw/csky/dynsoc.c b/hw/csky/dynsoc.c
new file mode 100644
index 0000000..79ae69f
--- /dev/null
+++ b/hw/csky/dynsoc.c
@@ -0,0 +1,114 @@
+/*
+ * CSKY modules loader.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/help_option.h"
+#include "hw/csky/dynsoc.h"
+#include "qemu/module.h"
+#include "qemu/error-report.h"
+
+struct dynsoc_board_info *dynsoc_b_info;
+
+#ifdef _WIN32
+#include <windows.h>
+
+#define CSKYSIM_KEY     ("0x2333")
+
+static struct dynsoc_board_info *create_shm(void)
+{
+    HANDLE shmid;
+    char *ret;
+    struct dynsoc_board_info *shm;
+
+    shmid = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0,
+                              sizeof(struct dynsoc_board_info), CSKYSIM_KEY);
+
+    if (shmid == NULL) {
+        printf("CreateFileMapping failed\n");
+        return (void *)-1;
+    }
+
+    ret = (char *)MapViewOfFile(shmid, FILE_MAP_ALL_ACCESS, 0, 0,
+                                sizeof(struct dynsoc_board_info));
+
+    if (ret == NULL) {
+        printf("MapViewOfFile failed\n");
+        return (void *)-1;
+    }
+
+    shm = (struct dynsoc_board_info *)ret;
+    return shm;
+}
+
+#else
+#include <sys/ipc.h>
+#include <sys/shm.h>
+
+#define CSKYSIM_KEY     ((key_t)0x2333)
+static struct dynsoc_board_info *create_shm(void)
+{
+    int shmid;
+    struct dynsoc_board_info *shm;
+    shmid = shmget(CSKYSIM_KEY, sizeof(struct dynsoc_board_info),
+                   0666 | IPC_CREAT);
+
+    if (shmid == -1) {
+        error_report("shmget failed");
+        return (void *)-1;
+    }
+
+    shm = shmat(shmid, (void *)0, 0);
+    if ((void *)shm == (void *)-1) {
+        error_report("shmat failed");
+        return (void *)-1;
+    }
+
+    return shm;
+}
+
+#endif
+
+void dynsoc_load_modules(void)
+{
+    struct dynsoc_board_info *b_info;
+    int i;
+
+    b_info = create_shm();
+    dynsoc_b_info = b_info;
+
+    if (b_info == (struct dynsoc_board_info *)-1) {
+        error_report("create shm failed");
+        goto dynsoc_fail;
+    }
+
+    if (b_info->read_enable != 1) {
+        error_report("sync fail");
+        goto dynsoc_fail;
+    }
+
+    module_load_one("hw-csky-", b_info->name);
+
+    for (i = 0; i < 10; i++) {
+        if (b_info->dev[i].name != NULL) {
+            module_load_one("", b_info->dev[i].filename);
+        }
+    }
+
+    return;
+dynsoc_fail:
+    assert(0);
+}
diff --git a/hw/csky/eragon.c b/hw/csky/eragon.c
new file mode 100644
index 0000000..43ce1dd
--- /dev/null
+++ b/hw/csky/eragon.c
@@ -0,0 +1,117 @@
+/*
+ * CSKY Trilobite V2 System emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#undef NEED_CPU_H
+#define NEED_CPU_H
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "target-csky/cpu.h"
+#include "hw/csky/csky.h"
+#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "net/net.h"
+#include "sysemu/sysemu.h"
+#include "hw/boards.h"
+#include "sysemu/block-backend.h"
+#include "exec/address-spaces.h"
+#include "qemu/error-report.h"
+#include "hw/csky/cskydev.h"
+#include "hw/char/csky_uart.h"
+
+#define CORET_IRQ_NUM   0
+
+static struct csky_boot_info eragon_binfo = {
+    .loader_start = 0x0,
+};
+
+static void eragon_init(MachineState *machine)
+{
+    ObjectClass *cpu_oc;
+    Object *cpuobj;
+    CSKYCPU *cpu;
+    CPUCSKYState *env;
+    qemu_irq *cpu_intc;
+    qemu_irq intc[32];
+    DeviceState *dev;
+    int i;
+    MemoryRegion *sysmem = get_system_memory();
+    MemoryRegion *ram = g_new(MemoryRegion, 1);
+
+    if (!machine->cpu_model) {
+        machine->cpu_model = "ck807ef";
+    }
+
+    cpu_oc = cpu_class_by_name(TYPE_CSKY_CPU, machine->cpu_model);
+    if (!cpu_oc) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
+
+    cpuobj = object_new(object_class_get_name(cpu_oc));
+
+    object_property_set_bool(cpuobj, true, "realized", &error_fatal);
+
+    cpu = CSKY_CPU(cpuobj);
+    env = &cpu->env;
+
+    memory_region_allocate_system_memory(ram, NULL, "eragon.sdram",
+                                         machine->ram_size);
+    memory_region_add_subregion(sysmem, 0x8000000, ram);
+
+    cpu_intc = csky_intc_init_cpu(env);
+
+    dev = sysbus_create_simple("csky_intc", 0x10010000, cpu_intc[0]);
+
+    for (i = 0; i < 32; i++) {
+        intc[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    csky_uart_create(0x10015000, intc[16], serial_hds[0]);
+
+    csky_timer_set_freq(50000000ll);
+    sysbus_create_varargs("csky_timer", 0x10011000, intc[12], intc[13],
+                            intc[14], intc[15], NULL);
+
+    eragon_binfo.ram_size = machine->ram_size;
+    eragon_binfo.kernel_filename = machine->kernel_filename;
+    eragon_binfo.kernel_cmdline = machine->kernel_cmdline;
+    eragon_binfo.initrd_filename = machine->initrd_filename;
+    csky_load_kernel(cpu, &eragon_binfo);
+}
+
+static void eragon_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "CSKY eragon";
+    mc->init = eragon_init;
+}
+
+static const TypeInfo eragon_type = {
+    .name = MACHINE_TYPE_NAME("eragon"),
+    .parent = TYPE_MACHINE,
+    .class_init = eragon_class_init,
+};
+
+static void eragon_machine_init(void)
+{
+    type_register_static(&eragon_type);
+}
+
+type_init(eragon_machine_init)
diff --git a/hw/csky/hobbit1-2.c b/hw/csky/hobbit1-2.c
new file mode 100644
index 0000000..6ba645c
--- /dev/null
+++ b/hw/csky/hobbit1-2.c
@@ -0,0 +1,129 @@
+/*
+ * CSKY Trilobite V2 System emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#undef NEED_CPU_H
+#define NEED_CPU_H
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "target-csky/cpu.h"
+#include "hw/csky/csky.h"
+#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "net/net.h"
+#include "sysemu/sysemu.h"
+#include "hw/boards.h"
+#include "sysemu/block-backend.h"
+#include "exec/address-spaces.h"
+#include "qemu/error-report.h"
+#include "hw/csky/cskydev.h"
+#include "hw/char/csky_uart.h"
+
+#define CORET_IRQ_NUM   1
+#define HOBBIT1_2_SRAM0    (1024 * 1024)
+#define HOBBIT1_2_SRAM1    (1024 * 1024)
+#define HOBBIT1_2_SRAM2    (1024 * 1024)
+
+static struct csky_boot_info hobbit1_2_binfo = {
+    .loader_start = 0x0,
+    .freq         = 1000000000ll,
+};
+
+static void hobbit1_2_init(MachineState *machine)
+{
+    ObjectClass *cpu_oc;
+    Object *cpuobj;
+    CSKYCPU *cpu;
+    CPUCSKYState *env;
+    qemu_irq *cpu_intc;
+    qemu_irq intc[32];
+    DeviceState *dev;
+    int i;
+    MemoryRegion *sysmem = get_system_memory();
+    MemoryRegion *ram0 = g_new(MemoryRegion, 1);
+    MemoryRegion *ram1 = g_new(MemoryRegion, 1);
+    MemoryRegion *ram2 = g_new(MemoryRegion, 1);
+    if (!machine->cpu_model) {
+        machine->cpu_model = "ck802";
+    }
+
+    cpu_oc = cpu_class_by_name(TYPE_CSKY_CPU, machine->cpu_model);
+    if (!cpu_oc) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
+
+    cpuobj = object_new(object_class_get_name(cpu_oc));
+
+    object_property_set_bool(cpuobj, true, "realized", &error_fatal);
+
+    cpu = CSKY_CPU(cpuobj);
+    env = &cpu->env;
+
+    memory_region_allocate_system_memory(ram0, NULL, "hobbit1_2.sdram0",
+                                         HOBBIT1_2_SRAM0);
+    memory_region_add_subregion(sysmem, 0x0, ram0);
+    memory_region_allocate_system_memory(ram1, NULL, "hobbit1_2.sdram1",
+                                         HOBBIT1_2_SRAM1);
+    memory_region_add_subregion(sysmem, 0x10000000, ram1);
+    memory_region_allocate_system_memory(ram2, NULL, "hobbit1_2.sdram2",
+                                         HOBBIT1_2_SRAM2);
+    memory_region_add_subregion(sysmem, 0x20000000, ram2);
+
+    cpu_intc = csky_vic_v1_init_cpu(env, CORET_IRQ_NUM);
+
+    csky_tcip_v1_set_freq(hobbit1_2_binfo.freq);
+    dev = sysbus_create_simple("csky_tcip_v1", 0xE000E000, cpu_intc[0]);
+
+    for (i = 0; i < 32; i++) {
+        intc[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    /* if config uart 0, uart address = 0x50010000,
+     * if config uart 1, uart address = 0x50010400. */
+
+    /* csky_uart_create(0x50010000, intc[6], serial_hds[0]); */
+    csky_uart_create(0x50010400, intc[7], serial_hds[0]);
+
+    hobbit1_2_binfo.ram_size = machine->ram_size;
+    hobbit1_2_binfo.kernel_filename = machine->kernel_filename;
+    hobbit1_2_binfo.kernel_cmdline = machine->kernel_cmdline;
+    hobbit1_2_binfo.initrd_filename = machine->initrd_filename;
+    csky_load_kernel(cpu, &hobbit1_2_binfo);
+}
+
+static void hobbit1_2_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "CSKY hobbit1_2";
+    mc->init = hobbit1_2_init;
+}
+
+static const TypeInfo hobbit1_2_type = {
+    .name = MACHINE_TYPE_NAME("hobbit1_2"),
+    .parent = TYPE_MACHINE,
+    .class_init = hobbit1_2_class_init,
+};
+
+static void hobbit1_2_machine_init(void)
+{
+    type_register_static(&hobbit1_2_type);
+}
+
+type_init(hobbit1_2_machine_init)
diff --git a/hw/csky/smart_card.c b/hw/csky/smart_card.c
new file mode 100644
index 0000000..93a0eed
--- /dev/null
+++ b/hw/csky/smart_card.c
@@ -0,0 +1,116 @@
+/*
+ * CSKY Trilobite V2 System emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#undef NEED_CPU_H
+#define NEED_CPU_H
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "target-csky/cpu.h"
+#include "hw/csky/csky.h"
+#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "net/net.h"
+#include "sysemu/sysemu.h"
+#include "hw/boards.h"
+#include "sysemu/block-backend.h"
+#include "exec/address-spaces.h"
+#include "qemu/error-report.h"
+#include "hw/csky/cskydev.h"
+#include "hw/char/csky_uart.h"
+
+#define CORET_IRQ_NUM   0
+
+static struct csky_boot_info smart_card_binfo = {
+    .loader_start = 0x0,
+    .freq         = 1000000000ll,
+};
+
+static void smart_card_init(MachineState *machine)
+{
+    ObjectClass *cpu_oc;
+    Object *cpuobj;
+    CSKYCPU *cpu;
+    CPUCSKYState *env;
+    qemu_irq *cpu_intc;
+    qemu_irq intc[32];
+    DeviceState *dev;
+    int i;
+    MemoryRegion *sysmem = get_system_memory();
+    MemoryRegion *ram = g_new(MemoryRegion, 1);
+
+    if (!machine->cpu_model) {
+        machine->cpu_model = "ck802";
+    }
+
+    cpu_oc = cpu_class_by_name(TYPE_CSKY_CPU, machine->cpu_model);
+    if (!cpu_oc) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
+
+    cpuobj = object_new(object_class_get_name(cpu_oc));
+
+    object_property_set_bool(cpuobj, true, "realized", &error_fatal);
+
+    cpu = CSKY_CPU(cpuobj);
+    env = &cpu->env;
+
+    memory_region_allocate_system_memory(ram, NULL, "smart_card.sdram",
+                                         machine->ram_size);
+    memory_region_add_subregion(sysmem, 0x0, ram);
+
+    cpu_intc = csky_vic_v1_init_cpu(env, CORET_IRQ_NUM);
+
+    csky_tcip_v1_set_freq(smart_card_binfo.freq);
+
+    dev = sysbus_create_simple("csky_tcip_v1", 0xE000E000, cpu_intc[0]);
+
+    for (i = 0; i < 32; i++) {
+        intc[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    csky_uart_create(0x00F15000, intc[2], serial_hds[0]);
+
+    smart_card_binfo.ram_size = machine->ram_size;
+    smart_card_binfo.kernel_filename = machine->kernel_filename;
+    smart_card_binfo.kernel_cmdline = machine->kernel_cmdline;
+    smart_card_binfo.initrd_filename = machine->initrd_filename;
+    csky_load_kernel(cpu, &smart_card_binfo);
+}
+
+static void smart_card_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "CSKY smart_card";
+    mc->init = smart_card_init;
+}
+
+static const TypeInfo smart_card_type = {
+    .name = MACHINE_TYPE_NAME("smart_card"),
+    .parent = TYPE_MACHINE,
+    .class_init = smart_card_class_init,
+};
+
+static void smart_card_machine_init(void)
+{
+    type_register_static(&smart_card_type);
+}
+
+type_init(smart_card_machine_init)
diff --git a/hw/csky/smarth.c b/hw/csky/smarth.c
new file mode 100644
index 0000000..1c5f1b7
--- /dev/null
+++ b/hw/csky/smarth.c
@@ -0,0 +1,120 @@
+/*
+ * CSKY Trilobite V2 System emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#undef NEED_CPU_H
+#define NEED_CPU_H
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "target-csky/cpu.h"
+#include "hw/csky/csky.h"
+#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "net/net.h"
+#include "sysemu/sysemu.h"
+#include "hw/boards.h"
+#include "sysemu/block-backend.h"
+#include "exec/address-spaces.h"
+#include "qemu/error-report.h"
+#include "hw/csky/cskydev.h"
+#include "hw/char/csky_uart.h"
+
+#define CORET_IRQ_NUM   0
+
+static struct csky_boot_info smarth_binfo = {
+    .loader_start = 0x0,
+    .freq         = 50000000ll,
+};
+
+static void smarth_init(MachineState *machine)
+{
+    ObjectClass *cpu_oc;
+    Object *cpuobj;
+    CSKYCPU *cpu;
+    CPUCSKYState *env;
+    qemu_irq *cpu_intc;
+    qemu_irq intc[32];
+    DeviceState *dev;
+    int i;
+    MemoryRegion *sysmem = get_system_memory();
+    MemoryRegion *ram = g_new(MemoryRegion, 1);
+
+    if (!machine->cpu_model) {
+        machine->cpu_model = "ck810f";
+    }
+
+    cpu_oc = cpu_class_by_name(TYPE_CSKY_CPU, machine->cpu_model);
+    if (!cpu_oc) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
+
+    cpuobj = object_new(object_class_get_name(cpu_oc));
+
+    object_property_set_bool(cpuobj, true, "realized", &error_fatal);
+
+    cpu = CSKY_CPU(cpuobj);
+    env = &cpu->env;
+
+    memory_region_allocate_system_memory(ram, NULL, "smarth.sdram",
+                                         machine->ram_size);
+    memory_region_add_subregion(sysmem, 0x8000000, ram);
+
+    cpu_intc = csky_intc_init_cpu(env);
+
+    dev = sysbus_create_simple("csky_intc", 0x10010000, cpu_intc[0]);
+
+    for (i = 0; i < 32; i++) {
+        intc[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    csky_uart_create(0x10015000, intc[16], serial_hds[0]);
+
+    csky_timer_set_freq(smarth_binfo.freq);
+    sysbus_create_varargs("csky_timer", 0x10011000, intc[12], intc[13],
+                            intc[14], intc[15], NULL);
+
+    sysbus_create_simple("csky_exit", 0x10002000, NULL);
+
+    smarth_binfo.ram_size = machine->ram_size;
+    smarth_binfo.kernel_filename = machine->kernel_filename;
+    smarth_binfo.kernel_cmdline = machine->kernel_cmdline;
+    smarth_binfo.initrd_filename = machine->initrd_filename;
+    csky_load_kernel(cpu, &smarth_binfo);
+}
+
+static void smarth_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "CSKY smarth";
+    mc->init = smarth_init;
+}
+
+static const TypeInfo smarth_type = {
+    .name = MACHINE_TYPE_NAME("smarth"),
+    .parent = TYPE_MACHINE,
+    .class_init = smarth_class_init,
+};
+
+static void smarth_machine_init(void)
+{
+    type_register_static(&smarth_type);
+}
+
+type_init(smarth_machine_init)
diff --git a/hw/csky/smartl.c b/hw/csky/smartl.c
new file mode 100644
index 0000000..d206a71
--- /dev/null
+++ b/hw/csky/smartl.c
@@ -0,0 +1,129 @@
+/*
+ * CSKY Trilobite V2 System emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#undef NEED_CPU_H
+#define NEED_CPU_H
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "target-csky/cpu.h"
+#include "hw/csky/csky.h"
+#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "net/net.h"
+#include "sysemu/sysemu.h"
+#include "hw/boards.h"
+#include "sysemu/block-backend.h"
+#include "exec/address-spaces.h"
+#include "qemu/error-report.h"
+#include "hw/csky/cskydev.h"
+#include "hw/char/csky_uart.h"
+
+#define CORET_IRQ_NUM   1
+#define SMARTL_SRAM0    (16 * 1024 * 1024)
+#define SMARTL_SRAM1    (16 * 1024 * 1024)
+#define SMARTL_SRAM2    (16 * 1024 * 1024)
+
+static struct csky_boot_info smartl_binfo = {
+    .loader_start = 0x0,
+    .freq         = 1000000000ll,
+};
+
+static void smartl_init(MachineState *machine)
+{
+    ObjectClass *cpu_oc;
+    Object *cpuobj;
+    CSKYCPU *cpu;
+    CPUCSKYState *env;
+    qemu_irq *cpu_intc;
+    qemu_irq intc[32];
+    DeviceState *dev;
+    int i;
+    MemoryRegion *sysmem = get_system_memory();
+    MemoryRegion *ram0 = g_new(MemoryRegion, 1);
+    MemoryRegion *ram1 = g_new(MemoryRegion, 1);
+    MemoryRegion *ram2 = g_new(MemoryRegion, 1);
+
+    if (!machine->cpu_model) {
+        machine->cpu_model = "ck803efr1";
+    }
+
+    cpu_oc = cpu_class_by_name(TYPE_CSKY_CPU, machine->cpu_model);
+    if (!cpu_oc) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
+
+    cpuobj = object_new(object_class_get_name(cpu_oc));
+
+    object_property_set_bool(cpuobj, true, "realized", &error_fatal);
+
+    cpu = CSKY_CPU(cpuobj);
+    env = &cpu->env;
+
+    memory_region_allocate_system_memory(ram0, NULL, "smartl.sdram0",
+                                         SMARTL_SRAM0);
+    memory_region_add_subregion(sysmem, 0x0, ram0);
+    memory_region_allocate_system_memory(ram1, NULL, "smartl.sdram1",
+                                         SMARTL_SRAM1);
+    memory_region_add_subregion(sysmem, 0x20000000, ram1);
+    memory_region_allocate_system_memory(ram2, NULL, "smartl.sdram2",
+                                         SMARTL_SRAM2);
+    memory_region_add_subregion(sysmem, 0x60000000, ram2);
+
+    cpu_intc = csky_vic_v1_init_cpu(env, CORET_IRQ_NUM);
+
+    csky_tcip_v1_set_freq(smartl_binfo.freq);
+
+    dev = sysbus_create_simple("csky_tcip_v1", 0xE000E000, cpu_intc[0]);
+
+    for (i = 0; i < 32; i++) {
+        intc[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    csky_uart_create(0x40015000, intc[0], serial_hds[0]);
+
+    sysbus_create_simple("csky_exit", 0x10002000, NULL);
+
+    smartl_binfo.ram_size = machine->ram_size;
+    smartl_binfo.kernel_filename = machine->kernel_filename;
+    smartl_binfo.kernel_cmdline = machine->kernel_cmdline;
+    smartl_binfo.initrd_filename = machine->initrd_filename;
+    csky_load_kernel(cpu, &smartl_binfo);
+}
+
+static void smartl_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "CSKY smartl";
+    mc->init = smartl_init;
+}
+
+static const TypeInfo smartl_type = {
+    .name = MACHINE_TYPE_NAME("smartl"),
+    .parent = TYPE_MACHINE,
+    .class_init = smartl_class_init,
+};
+
+static void smartl_machine_init(void)
+{
+    type_register_static(&smartl_type);
+}
+
+type_init(smartl_machine_init)
diff --git a/hw/csky/trilobite.c b/hw/csky/trilobite.c
new file mode 100644
index 0000000..c2bd656
--- /dev/null
+++ b/hw/csky/trilobite.c
@@ -0,0 +1,133 @@
+/*
+ * CSKY Trilobite System emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#undef NEED_CPU_H
+#define NEED_CPU_H
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "target-csky/cpu.h"
+#include "hw/csky/csky.h"
+#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "net/net.h"
+#include "sysemu/sysemu.h"
+#include "hw/boards.h"
+#include "sysemu/block-backend.h"
+#include "exec/address-spaces.h"
+#include "qemu/error-report.h"
+#include "hw/csky/cskydev.h"
+#include "hw/char/csky_uart.h"
+#include "hw/csky/dynsoc.h"
+
+#define CORET_IRQ_NUM   0
+
+static struct csky_boot_info trilobite_binfo = {
+    .loader_start = 0x0,
+    .dtb_addr = 0x8f000000,
+    .magic = 0x20150401,
+    .freq = 50000000ll,
+};
+
+static void trilobite_init(MachineState *machine)
+{
+    ObjectClass *cpu_oc;
+    Object *cpuobj;
+    CSKYCPU *cpu;
+    CPUCSKYState *env;
+    qemu_irq *cpu_intc;
+    qemu_irq intc[32];
+    DeviceState *dev;
+    int i;
+    MemoryRegion *sysmem = get_system_memory();
+    MemoryRegion *ram = g_new(MemoryRegion, 1);
+
+    if (!machine->cpu_model) {
+        machine->cpu_model = "ck810f";
+    }
+
+    cpu_oc = cpu_class_by_name(TYPE_CSKY_CPU, machine->cpu_model);
+    if (!cpu_oc) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
+
+    cpuobj = object_new(object_class_get_name(cpu_oc));
+
+    object_property_set_bool(cpuobj, true, "realized", &error_fatal);
+
+    cpu = CSKY_CPU(cpuobj);
+    env = &cpu->env;
+
+    memory_region_allocate_system_memory(ram, NULL, "trilobite.sdram",
+                                         machine->ram_size);
+    memory_region_add_subregion(sysmem, 0x8000000, ram);
+
+    cpu_intc = csky_intc_init_cpu(env);
+
+    dev = sysbus_create_simple("csky_intc", 0x10010000, cpu_intc[0]);
+
+    for (i = 0; i < 32; i++) {
+        intc[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    /* create uart */
+    dev = qdev_create(NULL, "csky_uart");
+    SysBusDevice *s = SYS_BUS_DEVICE(dev);
+    qdev_prop_set_chr(dev, "chardev", serial_hds[0]);
+    qdev_init_nofail(dev);
+    sysbus_mmio_map(s, 0, 0x10015000);
+    sysbus_connect_irq(s, 0, intc[16]);
+
+    csky_timer_set_freq(trilobite_binfo.freq);
+    sysbus_create_varargs("csky_timer", 0x10011000, intc[12], intc[13],
+                            intc[14], intc[15], NULL);
+
+    if (nd_table[0].used) {
+        csky_mac_create(&nd_table[0], 0x10006000, intc[26]);
+    }
+
+    sysbus_create_simple("csky_lcdc", 0x10004000, intc[28]);
+
+    trilobite_binfo.ram_size = machine->ram_size;
+    trilobite_binfo.kernel_filename = machine->kernel_filename;
+    trilobite_binfo.kernel_cmdline = machine->kernel_cmdline;
+    trilobite_binfo.initrd_filename = machine->initrd_filename;
+    csky_load_kernel(cpu, &trilobite_binfo);
+}
+
+static void trilobite_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "CSKY trilobite";
+    mc->init = trilobite_init;
+}
+
+static const TypeInfo trilobite_type = {
+    .name = MACHINE_TYPE_NAME("trilobite"),
+    .parent = TYPE_MACHINE,
+    .class_init = trilobite_class_init,
+};
+
+static void trilobite_machine_init(void)
+{
+    type_register_static(&trilobite_type);
+}
+
+type_init(trilobite_machine_init)
diff --git a/hw/csky/trilobite_v2.c b/hw/csky/trilobite_v2.c
new file mode 100644
index 0000000..fcf6adc
--- /dev/null
+++ b/hw/csky/trilobite_v2.c
@@ -0,0 +1,133 @@
+/*
+ * CSKY Trilobite V2 System emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#undef NEED_CPU_H
+#define NEED_CPU_H
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "target-csky/cpu.h"
+#include "hw/csky/csky.h"
+#include "hw/sysbus.h"
+#include "hw/devices.h"
+#include "net/net.h"
+#include "sysemu/sysemu.h"
+#include "hw/boards.h"
+#include "sysemu/block-backend.h"
+#include "exec/address-spaces.h"
+#include "qemu/error-report.h"
+#include "hw/csky/cskydev.h"
+#include "hw/char/csky_uart.h"
+#include "hw/csky/dynsoc.h"
+
+#define CORET_IRQ_NUM   0
+
+static struct csky_boot_info trilobite_v2_binfo = {
+    .loader_start = 0x0,
+    .dtb_addr = 0x8f000000,
+    .magic = 0x20150401,
+    .freq = 50000000ll,
+};
+
+static void trilobite_v2_init(MachineState *machine)
+{
+    ObjectClass *cpu_oc;
+    Object *cpuobj;
+    CSKYCPU *cpu;
+    CPUCSKYState *env;
+    qemu_irq *cpu_intc;
+    qemu_irq intc[32];
+    DeviceState *dev;
+    int i;
+    MemoryRegion *sysmem = get_system_memory();
+    MemoryRegion *ram = g_new(MemoryRegion, 1);
+
+    if (!machine->cpu_model) {
+        machine->cpu_model = "ck810f";
+    }
+
+    cpu_oc = cpu_class_by_name(TYPE_CSKY_CPU, machine->cpu_model);
+    if (!cpu_oc) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
+
+    cpuobj = object_new(object_class_get_name(cpu_oc));
+
+    object_property_set_bool(cpuobj, true, "realized", &error_fatal);
+
+    cpu = CSKY_CPU(cpuobj);
+    env = &cpu->env;
+
+    memory_region_allocate_system_memory(ram, NULL, "trilobite_v2.sdram",
+                                         machine->ram_size);
+    memory_region_add_subregion(sysmem, 0x8000000, ram);
+
+    cpu_intc = csky_intc_init_cpu(env);
+
+    dev = sysbus_create_simple("csky_intc", 0x10010000, cpu_intc[0]);
+
+    for (i = 0; i < 32; i++) {
+        intc[i] = qdev_get_gpio_in(dev, i);
+    }
+
+    /* create uart */
+    dev = qdev_create(NULL, "csky_uart");
+    SysBusDevice *s = SYS_BUS_DEVICE(dev);
+    qdev_prop_set_chr(dev, "chardev", serial_hds[0]);
+    qdev_init_nofail(dev);
+    sysbus_mmio_map(s, 0, 0x10015000);
+    sysbus_connect_irq(s, 0, intc[16]);
+
+    csky_timer_set_freq(trilobite_v2_binfo.freq);
+    sysbus_create_varargs("csky_timer", 0x10011000, intc[12], intc[13],
+                            intc[14], intc[15], NULL);
+
+    if (nd_table[0].used) {
+        csky_mac_v2_create(&nd_table[0], 0x10006000, intc[26]);
+    }
+
+    sysbus_create_simple("csky_lcdc", 0x10004000, intc[28]);
+
+    trilobite_v2_binfo.ram_size = machine->ram_size;
+    trilobite_v2_binfo.kernel_filename = machine->kernel_filename;
+    trilobite_v2_binfo.kernel_cmdline = machine->kernel_cmdline;
+    trilobite_v2_binfo.initrd_filename = machine->initrd_filename;
+    csky_load_kernel(cpu, &trilobite_v2_binfo);
+}
+
+static void trilobite_v2_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "CSKY trilobite_v2";
+    mc->init = trilobite_v2_init;
+}
+
+static const TypeInfo trilobite_v2_type = {
+    .name = MACHINE_TYPE_NAME("trilobite_v2"),
+    .parent = TYPE_MACHINE,
+    .class_init = trilobite_v2_class_init,
+};
+
+static void trilobite_v2_machine_init(void)
+{
+    type_register_static(&trilobite_v2_type);
+}
+
+type_init(trilobite_v2_machine_init)
diff --git a/hw/csky/virt.c b/hw/csky/virt.c
new file mode 100644
index 0000000..e83f787
--- /dev/null
+++ b/hw/csky/virt.c
@@ -0,0 +1,125 @@
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "sysemu/sysemu.h"
+#include "exec/address-spaces.h"
+#include "net/net.h"
+
+#include "target-csky/cpu.h"
+#include "hw/sysbus.h"
+#include "hw/boards.h"
+#include "hw/csky/csky.h"
+#include "hw/csky/cskydev.h"
+#include "hw/char/csky_uart.h"
+
+static struct csky_boot_info virt_binfo = {
+        .loader_start   = 0,
+        .dtb_addr       = 0x8f000000,
+        .magic          = 0x20150401,
+        .freq           = 50000000ll,
+};
+
+static void virt_init(MachineState *machine)
+{
+        ObjectClass     *cpu_oc;
+        Object          *cpuobj;
+        CSKYCPU         *cpu;
+
+        DeviceState     *intc;
+
+        /*
+         * Prepare RAM.
+         */
+        MemoryRegion *sysmem = get_system_memory();
+        MemoryRegion *ram = g_new(MemoryRegion, 1);
+
+        memory_region_allocate_system_memory(ram, NULL, "ram", 0x1f400000);
+        memory_region_add_subregion(sysmem, 0, ram);
+
+        /*
+         * Prepare CPU
+         */
+#ifdef TARGET_CSKYV2
+        machine->cpu_model = "ck810f";
+#else
+        machine->cpu_model = "ck610ef";
+#endif
+
+        cpu_oc = cpu_class_by_name(TYPE_CSKY_CPU, machine->cpu_model);
+        if (!cpu_oc) {
+                fprintf(stderr, "Unable to find CPU definition\n");
+                exit(1);
+        }
+
+        cpuobj = object_new(object_class_get_name(cpu_oc));
+        object_property_set_bool(cpuobj, true, "realized", &error_fatal);
+
+        cpu = CSKY_CPU(cpuobj);
+
+        /*
+         * use C-SKY interrupt controller
+         */
+        intc = sysbus_create_simple(
+                        "csky_intc",
+                        0x1ffff000,
+                        *csky_intc_init_cpu(&cpu->env));
+
+        /*
+         * use dw-apb-timer
+         */
+        csky_timer_set_freq(virt_binfo.freq);
+        sysbus_create_varargs(
+                        "csky_timer",
+                        0x1fffd000,
+                        qdev_get_gpio_in(intc, 1),
+                        qdev_get_gpio_in(intc, 2),
+                        NULL);
+
+        /*
+         * use 16650a uart.
+         */
+        csky_uart_create(
+                        0x1fffe000,
+                        qdev_get_gpio_in(intc, 3),
+                        serial_hds[0]);
+
+        /*
+         * for qemu exit, use cmd poweroff.
+         */
+        sysbus_create_simple("csky_exit", 0x1fffc000, NULL);
+
+        /*
+         * add net, io-len is 2K.
+         */
+        csky_mac_v2_create(&nd_table[0], 0x1fffa000, qdev_get_gpio_in(intc, 4));
+
+        /*
+         * boot up kernel with unaligned_access and mmu on.
+         */
+#ifdef TARGET_CSKYV2
+        cpu->env.features |= UNALIGNED_ACCESS;
+#endif
+        cpu->env.mmu_default = 1;
+
+        virt_binfo.kernel_filename = machine->kernel_filename;
+        csky_load_kernel(cpu, &virt_binfo);
+}
+
+static void virt_class_init(ObjectClass *oc, void *data)
+{
+        MACHINE_CLASS(oc)->desc = "C-SKY QEMU virt machine";
+        MACHINE_CLASS(oc)->init = virt_init;
+}
+
+static const TypeInfo virt_type = {
+        .name           = MACHINE_TYPE_NAME("virt"),
+        .parent         = TYPE_MACHINE,
+        .class_init     = virt_class_init,
+};
+
+static void virt_machine_init(void)
+{
+        type_register_static(&virt_type);
+}
+
+type_init(virt_machine_init)
+
diff --git a/hw/display/Makefile.objs b/hw/display/Makefile.objs
index 063889b..600cfb6 100644
--- a/hw/display/Makefile.objs
+++ b/hw/display/Makefile.objs
@@ -31,6 +31,7 @@ obj-$(CONFIG_RASPI) += bcm2835_fb.o
 obj-$(CONFIG_SM501) += sm501.o
 obj-$(CONFIG_TCX) += tcx.o
 obj-$(CONFIG_CG3) += cg3.o
+obj-$(CONFIG_CSKY_LCDC) += csky_lcdc.o
 
 obj-$(CONFIG_VGA) += vga.o
 
diff --git a/hw/display/csky_lcd_template.h b/hw/display/csky_lcd_template.h
new file mode 100644
index 0000000..e72ac18
--- /dev/null
+++ b/hw/display/csky_lcd_template.h
@@ -0,0 +1,137 @@
+/*
+ * QEMU CSKY LCD Emulator templates
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#if DEPTH == 8
+# define BPP 1
+# define PIXEL_TYPE uint8_t
+#elif DEPTH == 15 || DEPTH == 16
+# define BPP 2
+# define PIXEL_TYPE uint16_t
+#elif DEPTH == 24  /* add to fix syntax bug */
+# define BPP 4
+# define PIXEL_TYPE uint32_t
+#elif DEPTH == 32
+# define BPP 4
+# define PIXEL_TYPE uint32_t
+#else
+# error unsupport depth
+#endif
+
+/*
+ * 4-bit colour
+ */
+/*
+static void glue(draw_line4_, DEPTH)(void *opaque,
+                uint8_t *d, const uint8_t *s, int width, int deststep)
+{
+    uint16_t *pal = opaque;
+    uint8_t v, r, g, b;
+
+    do {
+        v = ldub_p((void *) s);
+        r = (pal[v & 0xf] >> 4) & 0xf0;
+        g = pal[v & 0xf] & 0xf0;
+        b = (pal[v & 0xf] << 4) & 0xf0;
+        ((PIXEL_TYPE *) d)[0] = glue(rgb_to_pixel, DEPTH)(r, g, b);
+        d += BPP;
+        v >>= 4;
+        r = (pal[v & 0xf] >> 4) & 0xf0;
+        g = pal[v & 0xf] & 0xf0;
+        b = (pal[v & 0xf] << 4) & 0xf0;
+        ((PIXEL_TYPE *) d)[0] = glue(rgb_to_pixel, DEPTH)(r, g, b);
+        d += BPP;
+        s ++;
+        width -= 2;
+    } while (width > 0);
+}
+*/
+
+/*
+ * 8-bit colour
+ */
+/*
+static void glue(draw_line8_, DEPTH)(void *opaque,
+                uint8_t *d, const uint8_t *s, int width, int deststep)
+{
+    uint16_t *pal = opaque;
+    uint8_t v, r, g, b;
+
+    do {
+        v = ldub_p((void *) s);
+        r = (pal[v] >> 4) & 0xf0;
+        g = pal[v] & 0xf0;
+        b = (pal[v] << 4) & 0xf0;
+        ((PIXEL_TYPE *) d)[0] = glue(rgb_to_pixel, DEPTH)(r, g, b);
+        s ++;
+        d += BPP;
+    } while (--width != 0);
+}
+*/
+
+/*
+ * 16-bit colour
+ */
+static void glue(draw_line16_, DEPTH)(void *opaque, uint8_t *d,
+                                      const uint8_t *s, int width, int deststep)
+{
+    uint16_t v;
+    uint8_t r, g, b;
+
+    do {
+        /* FIXME: need to distinguish Endian, lack of LCDC User Guide. */
+        v = lduw_le_p((void *) s);
+        r = (v >> 7) & 0xf8;
+        g = (v >> 3) & 0x7c;
+        b = (v << 3) & 0xf8;
+        ((PIXEL_TYPE *) d)[0] = glue(rgb_to_pixel, DEPTH)(r, g, b);
+        s += 2;
+        d += BPP;
+    } while (-- width != 0);
+}
+
+/*
+ * 24-bit colour
+ */
+static void glue(draw_line24_, DEPTH)(void *opaque, uint8_t *d,
+                                      const uint8_t *s, int width, int deststep)
+{
+    uint32_t v;
+    uint8_t r, g, b;
+    csky_lcdc_state *lcd_s = (csky_lcdc_state *) opaque;
+    do {
+        v = *(uint32_t *)s;
+        if (lcd_s->endian_select == 1) {
+            /* Big-endian */
+            r = v >> 24;
+            g = (v >> 16) & 0xff;
+            b = (v >> 8) & 0xff;
+        } else {
+            /* Little-endian */
+            r = (v >> 16) & 0xff;
+            g = (v >> 8) & 0xff;
+            b = (v >> 0) & 0xff;
+        }
+
+        ((PIXEL_TYPE *) d)[0] = glue(rgb_to_pixel, DEPTH)(r, g, b);
+        s += 4;
+        d += BPP;
+    } while (--width != 0);
+}
+
+#undef DEPTH
+#undef BPP
+#undef PIXEL_TYPE
diff --git a/hw/display/csky_lcdc.c b/hw/display/csky_lcdc.c
new file mode 100644
index 0000000..cd25607
--- /dev/null
+++ b/hw/display/csky_lcdc.c
@@ -0,0 +1,570 @@
+/*
+ * CSKY LCD controller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "ui/console.h"
+#include "framebuffer.h"
+#include "ui/pixel_ops.h"
+#include "qemu/log.h"
+#include "target-csky/cpu.h"
+#include "exec/cpu-all.h"
+
+#define TYPE_CSKY_LCDC  "csky_lcdc"
+#define CSKY_LCDC(obj)  OBJECT_CHECK(csky_lcdc_state, (obj), TYPE_CSKY_LCDC)
+
+typedef struct csky_lcdc_state {
+    SysBusDevice parent_obj;
+
+    MemoryRegion *sysmem;
+    MemoryRegion iomem;
+    MemoryRegionSection fbsection;
+    QemuConsole *con;
+
+    qemu_irq irq;
+
+    int out_pixel_select;
+    int dma_watermark_level;
+    int video_mem_burst_len;
+    int endian_select;
+    int pixel_bit_size;
+    int tft;
+    int color;
+    int lcd_enable;
+
+    uint32_t timing[3];
+    uint32_t base_addr;
+    int line_fifo_run;
+    int bus_error;
+    int base_addr_update;
+    int lcd_invalidate;
+    uint32_t int_mask;
+
+    uint32_t dither_duty_12;
+    uint32_t dither_duty_47;
+    uint32_t dither_duty_35;
+    uint32_t dither_duty_23;
+    uint32_t dither_duty_57;
+    uint32_t dither_duty_34;
+    uint32_t dither_duty_45;
+    uint32_t dither_duty_67;
+
+    uint16_t palette[256];
+    int width;
+    int height;
+} csky_lcdc_state;
+
+static const VMStateDescription vmstate_csky_lcdc = {
+    .name = TYPE_CSKY_LCDC,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_INT32(out_pixel_select, csky_lcdc_state),
+        VMSTATE_INT32(dma_watermark_level, csky_lcdc_state),
+        VMSTATE_INT32(video_mem_burst_len, csky_lcdc_state),
+        VMSTATE_INT32(endian_select, csky_lcdc_state),
+        VMSTATE_INT32(pixel_bit_size, csky_lcdc_state),
+        VMSTATE_INT32(tft, csky_lcdc_state),
+        VMSTATE_INT32(color, csky_lcdc_state),
+        VMSTATE_INT32(lcd_enable, csky_lcdc_state),
+
+        VMSTATE_UINT32_ARRAY(timing, csky_lcdc_state, 3),
+        VMSTATE_UINT32(base_addr, csky_lcdc_state),
+        VMSTATE_INT32(line_fifo_run, csky_lcdc_state),
+        VMSTATE_INT32(bus_error, csky_lcdc_state),
+        VMSTATE_INT32(base_addr_update, csky_lcdc_state),
+        VMSTATE_INT32(lcd_invalidate, csky_lcdc_state),
+        VMSTATE_UINT32(int_mask, csky_lcdc_state),
+
+        VMSTATE_UINT32(dither_duty_12, csky_lcdc_state),
+        VMSTATE_UINT32(dither_duty_47, csky_lcdc_state),
+        VMSTATE_UINT32(dither_duty_35, csky_lcdc_state),
+        VMSTATE_UINT32(dither_duty_23, csky_lcdc_state),
+        VMSTATE_UINT32(dither_duty_57, csky_lcdc_state),
+        VMSTATE_UINT32(dither_duty_34, csky_lcdc_state),
+        VMSTATE_UINT32(dither_duty_45, csky_lcdc_state),
+        VMSTATE_UINT32(dither_duty_67, csky_lcdc_state),
+
+        VMSTATE_UINT16_ARRAY(palette, csky_lcdc_state, 256),
+        VMSTATE_INT32(width, csky_lcdc_state),
+        VMSTATE_INT32(height, csky_lcdc_state),
+
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+
+#define LCD_CONTROL     0x000
+#define LCD_TIMING0     0x004
+#define LCD_TIMING1     0x008
+#define LCD_TIMING2     0x00C
+#define LCD_PBASE       0x010
+
+#define LCD_PCURR       0x018
+
+#define LCD_INT_STAT    0x020
+#define LCD_INT_MASK    0x024
+#define LCD_DP1_2       0x028
+#define LCD_DP4_7       0x02C
+#define LCD_DP3_5       0x030
+#define LCD_DP2_3       0x034
+#define LCD_DP5_7       0x038
+#define LCD_DP3_4       0x03C
+#define LCD_DP4_5       0x040
+#define LCD_DP6_7       0x044
+
+#define LCD_PALETTE     0x800 ... 0x9FC
+
+
+static void csky_lcd_interrupts(csky_lcdc_state *s)
+{
+    if (s->line_fifo_run && (s->int_mask & 8)) {
+        qemu_irq_raise(s->irq);
+        return;
+    }
+
+    if (s->bus_error && (s->int_mask & 4)) {
+        qemu_irq_raise(s->irq);
+        return;
+    }
+
+    if (s->base_addr_update && (s->int_mask & 2)) {
+        qemu_irq_raise(s->irq);
+        return;
+    }
+
+    if (s->lcd_invalidate && (s->int_mask & 1)) {
+        qemu_irq_raise(s->irq);
+        return;
+    }
+
+    qemu_irq_lower(s->irq);
+}
+
+#define DEPTH 16
+#include "csky_lcd_template.h"
+#define DEPTH 24
+#include "csky_lcd_template.h"
+#define DEPTH 32
+#include "csky_lcd_template.h"
+
+static drawfn draw_line_table16[33] = {
+    [0 ... 32]    = NULL,
+    [16]    = draw_line16_16,
+    [24]    = draw_line16_24,
+    [32]    = draw_line16_32,
+}, draw_line_table24[33] = {
+    [0 ... 32]    = NULL,
+    [16]    = draw_line24_16,
+    [24]    = draw_line24_24,
+    [32]    = draw_line24_32,
+};
+
+static void csky_update_display(void *opaque)
+{
+    csky_lcdc_state *csky_lcd = (csky_lcdc_state *) opaque;
+    SysBusDevice *sbd = SYS_BUS_DEVICE(csky_lcd);
+    DisplaySurface *surface = qemu_console_surface(csky_lcd->con);
+    drawfn draw_line;
+    int height, first, last;
+    int width, linesize, step;
+    hwaddr frame_base;
+
+    if (!csky_lcd || !csky_lcd->lcd_enable ||
+        !surface_bits_per_pixel(surface)) {
+        return;
+    }
+
+    /* Colour depth */
+    switch (csky_lcd->out_pixel_select) {
+    case 0:
+        draw_line = draw_line_table16[surface_bits_per_pixel(surface)];
+        break;
+
+    case 1:
+        draw_line = draw_line_table24[surface_bits_per_pixel(surface)];
+        break;
+
+    /*
+    case 2 :
+        draw_line = draw_line_table16[surface_bits_per_pixel(surface)];
+        break;
+    */
+    default:
+        /* Unsupported at the moment.  */
+        return;
+    }
+
+    /* Resolution */
+    width = csky_lcd->width;
+    if (width != surface_width(surface) ||
+        csky_lcd->height != surface_height(surface)) {
+        qemu_console_resize(csky_lcd->con,
+                            csky_lcd->width, csky_lcd->height);
+        surface = qemu_console_surface(csky_lcd->con);
+    }
+    /* FIXME: delete csky_lcd->base_addr_update by luoy */
+    if (csky_lcd->bus_error | csky_lcd->line_fifo_run |
+        csky_lcd->lcd_invalidate) {
+        csky_lcd_interrupts(csky_lcd);
+       // return;
+    }
+    /* Content */
+    frame_base = csky_lcd->base_addr;
+
+    if (!surface_bits_per_pixel(surface)) {
+        return;
+    }
+
+    first = 0;
+    height = csky_lcd->height;
+
+    if (csky_lcd->out_pixel_select) {
+        step = width * 32 >> 3;
+    } else {
+        step = width * 16 >> 3;
+    }
+
+    linesize = surface_stride(surface);
+
+    if (csky_lcd->lcd_invalidate) {
+        framebuffer_update_memory_section(&csky_lcd->fbsection,
+                                          sysbus_address_space(sbd),
+                                          frame_base,
+                                          height, step);
+    }
+
+    framebuffer_update_display(surface, &csky_lcd->fbsection,
+                               width, height,
+                               step, linesize, 0,
+                               csky_lcd->lcd_invalidate,
+                               draw_line, csky_lcd->palette,
+                               &first, &last);
+    if (first >= 0) {
+        dpy_gfx_update(csky_lcd->con, 0, first, width, last - first + 1);
+    }
+    csky_lcd->lcd_invalidate = 0;
+}
+
+static void csky_invalidate_display(void *opaque)
+{
+    csky_lcdc_state *csky_lcd = opaque;
+    csky_lcd->lcd_invalidate = 1;
+    csky_lcd_interrupts(csky_lcd);
+}
+
+
+static uint64_t csky_lcdc_read(void *opaque, hwaddr addr, unsigned size)
+{
+    csky_lcdc_state *s = (csky_lcdc_state *) opaque;
+    uint64_t ret = 0;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_lcdc_read: 0x%x must word align read\n",
+                      (int)addr);
+    }
+
+    switch (addr) {
+    case LCD_CONTROL:
+        ret = (s->out_pixel_select << 12) | (s->dma_watermark_level << 11) |
+            (s->video_mem_burst_len << 9) | (s->endian_select << 8) |
+            (s->pixel_bit_size << 5) | (s->tft << 3) |
+            (s->color << 1) | (s->lcd_enable);
+        break;
+    case LCD_TIMING0:
+        ret = (s->timing[0] << 10) | ((s->width / 16 - 1) << 4);
+        break;
+    case LCD_TIMING1:
+        ret = (s->timing[1] << 10) | (s->height - 1);
+        break;
+    case LCD_TIMING2:
+        ret = s->timing[2];
+        break;
+    case LCD_PBASE:
+        ret = s->base_addr;
+        break;
+    case LCD_PCURR:
+        ret = s->base_addr;
+        break;
+
+    case LCD_INT_STAT:
+        ret = (s->line_fifo_run << 3) | (s->bus_error << 2) |
+            (s->base_addr_update << 1) | (s->lcd_invalidate);
+        break;
+    case LCD_INT_MASK:
+        ret = s->int_mask;
+        break;
+    case LCD_DP1_2:
+        ret = s->dither_duty_12;
+        break;
+    case LCD_DP4_7:
+        ret = s->dither_duty_47;
+        break;
+    case LCD_DP3_5:
+        ret = s->dither_duty_35;
+        break;
+    case LCD_DP2_3:
+        ret = s->dither_duty_23;
+        break;
+    case LCD_DP5_7:
+        ret = s->dither_duty_57;
+        break;
+    case LCD_DP3_4:
+        ret = s->dither_duty_34;
+        break;
+    case LCD_DP4_5:
+        ret = s->dither_duty_45;
+        break;
+    case LCD_DP6_7:
+        ret = s->dither_duty_67;
+        break;
+
+    case LCD_PALETTE:
+        if (!s->endian_select) {
+            if (addr % 4 == 0) {
+                ret = ((s->palette[(addr - 0x800) / 2 + 1]) << 16) |
+                    ((s->palette[(addr - 0x800) / 2]) & 0x0000ffff);
+            }
+        } else {
+            if (addr % 4 == 0) {
+                ret = ((s->palette[(addr - 0x800) / 2]) << 16) |
+                    ((s->palette[(addr - 0x800) / 2 + 1]) & 0x0000ffff);
+            }
+        }
+        break;
+    default:
+        break;
+    }
+
+    return ret;
+}
+
+
+static void csky_lcdc_write(void *opaque, hwaddr addr, uint64_t value,
+                            unsigned size)
+{
+    csky_lcdc_state *s = (csky_lcdc_state *) opaque;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_lcdc_read: 0x%x must word align read\n",
+                      (int)addr);
+    }
+
+    s->lcd_invalidate = 1;
+
+    switch (addr) {
+    case LCD_CONTROL:
+        {
+            s->out_pixel_select = (value >> 12) & 1;
+            s->dma_watermark_level = (value >> 11) & 1;
+            s->video_mem_burst_len = (value >> 9) & 3;
+            s->endian_select = (value >> 8) & 1;
+            s->pixel_bit_size = (value >> 5) & 3;
+            s->tft = (value >> 3) & 1;
+            s->color = (value >> 1) & 1;
+            s->lcd_enable = (value & 1) ;
+        }
+        break;
+    case LCD_TIMING0:
+        {
+            s->timing[0] = value >> 10 ;
+            s->width = (((value & 0x000003f0) >> 4) + 1) * 16;
+        }
+        break;
+    case LCD_TIMING1:
+        {
+            s->timing[1] = value >> 10 ;
+            s->height = (value & 0x000003ff) ; /* remove +1 by luoy */
+        }
+        break;
+    case LCD_TIMING2:
+        s->timing[2] = value;
+        break;
+    case LCD_PBASE:
+        s->base_addr = value;
+        break;
+
+    case LCD_PCURR:
+        break;
+
+    case LCD_INT_STAT:
+        {
+            s->line_fifo_run = (value & 0x00000008) >> 3;
+            s->bus_error = (value & 0x00000004) >> 2;
+            s->base_addr_update = (value & 0x00000002) >> 1;
+            s->lcd_invalidate = value & 0x00000001;
+            if ((value & 0x00000008) >> 3 == 1) {
+                s->line_fifo_run = 0;
+            }
+            if ((value & 0x00000004) >> 2 == 1) {
+                s->bus_error = 0;
+            }
+            if (value & 0x00000001) {
+            //    s->lcd_invalidate = 0;
+            }
+            csky_lcd_interrupts(s);
+        }
+        break;
+    case LCD_INT_MASK:
+        s->int_mask = value & 0x0000000f;
+        break;
+    case LCD_DP1_2:
+        s->dither_duty_12 = value;
+        break;
+    case LCD_DP4_7:
+        s->dither_duty_47 = value;
+        break;
+    case LCD_DP3_5:
+        s->dither_duty_35 = value;
+        break;
+    case LCD_DP2_3:
+        s->dither_duty_23 = value;
+        break;
+    case LCD_DP5_7:
+        s->dither_duty_57 = value;
+        break;
+    case LCD_DP3_4:
+        s->dither_duty_34 = value;
+        break;
+    case LCD_DP4_5:
+        s->dither_duty_45 = value;
+        break;
+    case LCD_DP6_7:
+        s->dither_duty_67 = value;
+        break;
+
+    case LCD_PALETTE:
+        {
+            if (!s->endian_select) {
+                if (addr % 4 == 0) {
+                    s->palette[(addr - 0x800) / 2 + 1] = value >> 16;
+                    s->palette[(addr - 0x800) / 2] = value & 0x0000ffff;
+                } else {
+                    break;
+                }
+            } else {
+                if (addr % 4 == 0) {
+                    s->palette[(addr - 0x800) / 2] = value >> 16;
+                    s->palette[(addr - 0x800) / 2 + 1] = value & 0x0000ffff;
+                } else {
+                    return;
+                }
+            }
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+static const MemoryRegionOps csky_lcdc_ops = {
+    .read = csky_lcdc_read,
+    .write = csky_lcdc_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static void csky_lcdc_reset(csky_lcdc_state *s)
+{
+    s->out_pixel_select = 0;
+    s->dma_watermark_level = 0;
+    s->video_mem_burst_len = 10;
+
+    s->pixel_bit_size = 0;
+    s->tft = 0;
+    s->color = 0;
+    s->lcd_enable = 0;
+
+    s->timing[0] = 0;
+    s->timing[1] = 0;
+    s->timing[2] = 0;
+    s->base_addr = 0;
+
+    s->line_fifo_run = 0;
+    s->bus_error = 0;
+    s->base_addr_update = 0;
+    s->lcd_invalidate = 0;
+    s->int_mask = 15;
+
+    s->dither_duty_12 = 0x01010000;
+    s->dither_duty_47 = 0x11110421;
+    s->dither_duty_35 = 0x92491249;
+    s->dither_duty_23 = 0x555592c9;
+    s->dither_duty_57 = 0xd5d5d555;
+    s->dither_duty_34 = 0xddddd5dd;
+    s->dither_duty_45 = 0xdfdfdfdd;
+    s->dither_duty_67 = 0xffffdfff;
+
+    s->width = 0;
+    s->height = 0;
+
+}
+
+static const GraphicHwOps csky_lcdc_gfx_ops = {
+    .invalidate  = csky_invalidate_display,
+    .gfx_update  = csky_update_display,
+};
+
+static void csky_lcdc_realize(DeviceState *dev, Error **errp)
+{
+    csky_lcdc_state *s = CSKY_LCDC(dev);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
+
+    memory_region_init_io(&s->iomem, OBJECT(s), &csky_lcdc_ops, s,
+                          TYPE_CSKY_LCDC, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+    sysbus_init_irq(sbd, &s->irq);
+    s->con = graphic_console_init(dev, 0, &csky_lcdc_gfx_ops, s);
+}
+
+static void csky_lcdc_device_reset(DeviceState *d)
+{
+    csky_lcdc_state *s = CSKY_LCDC(d);
+
+    csky_lcdc_reset(s);
+}
+
+static void csky_lcdc_init(Object *dev)
+{
+
+}
+
+static void csky_lcdc_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
+    dc->reset = csky_lcdc_device_reset;
+    dc->vmsd = &vmstate_csky_lcdc;
+    dc->realize = csky_lcdc_realize;
+}
+
+static const TypeInfo csky_lcdc_info = {
+    .name          = TYPE_CSKY_LCDC,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_lcdc_state),
+    .instance_init = csky_lcdc_init,
+    .class_init    = csky_lcdc_class_init,
+};
+
+static void csky_lcdc_register_types(void)
+{
+    type_register_static(&csky_lcdc_info);
+}
+
+type_init(csky_lcdc_register_types)
diff --git a/hw/dma/Makefile.objs b/hw/dma/Makefile.objs
index 087c8e6..fe65d1a 100644
--- a/hw/dma/Makefile.objs
+++ b/hw/dma/Makefile.objs
@@ -14,3 +14,4 @@ obj-$(CONFIG_XLNX_ZYNQMP) += xlnx_dpdma.o
 obj-$(CONFIG_OMAP) += omap_dma.o soc_dma.o
 obj-$(CONFIG_PXA2XX) += pxa2xx_dma.o
 obj-$(CONFIG_RASPI) += bcm2835_dma.o
+obj-$(CONFIG_CSKY_DMA) += csky_dma.o
diff --git a/hw/dma/csky_dma.c b/hw/dma/csky_dma.c
new file mode 100644
index 0000000..48e6cc0
--- /dev/null
+++ b/hw/dma/csky_dma.c
@@ -0,0 +1,446 @@
+/*
+ * CSKY DMA controller
+ *
+ * Written by wanghb <huibin_wang@c-sky.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "exec/address-spaces.h"
+#include "qemu/log.h"
+
+#define NR_DMA_CHAN       4   /* the total number of DMA channels */
+
+#define TYPE_CSKY_DMA   "csky_dma"
+#define CSKY_DMA(obj)   OBJECT_CHECK(csky_dma_state, (obj), TYPE_CSKY_DMA)
+
+typedef struct {
+    uint32_t src;
+    uint32_t dest;
+    uint32_t ctrl[2];
+    uint32_t conf[2];
+    int chan_enable;
+} csky_dma_channel;
+
+typedef struct {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    qemu_irq irq;
+    int dma_enable;
+    uint32_t tfr_int;
+    uint32_t block_int;
+    uint32_t srctran_int;
+    uint32_t dsttran_int;
+    uint32_t err_int;
+    uint32_t tfr_int_mask;
+    uint32_t block_int_mask;
+    uint32_t srctran_int_mask;
+    uint32_t dsttran_int_mask;
+    uint32_t err_int_mask;
+    uint32_t status_int;
+    csky_dma_channel chan[NR_DMA_CHAN];
+} csky_dma_state;
+
+static const VMStateDescription vmstate_csky_dma_channel = {
+    .name = "csky_dma_channel",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT32(src, csky_dma_channel),
+        VMSTATE_UINT32(dest, csky_dma_channel),
+        VMSTATE_UINT32_ARRAY(ctrl, csky_dma_channel, 2),
+        VMSTATE_UINT32_ARRAY(conf, csky_dma_channel, 2),
+        VMSTATE_INT32(chan_enable, csky_dma_channel),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static const VMStateDescription vmstate_csky_dma = {
+    .name = "csky_dma",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT32(tfr_int, csky_dma_state),
+        VMSTATE_UINT32(block_int, csky_dma_state),
+        VMSTATE_UINT32(srctran_int, csky_dma_state),
+        VMSTATE_UINT32(dsttran_int, csky_dma_state),
+        VMSTATE_UINT32(err_int, csky_dma_state),
+        VMSTATE_UINT32(tfr_int_mask, csky_dma_state),
+        VMSTATE_UINT32(block_int_mask, csky_dma_state),
+        VMSTATE_UINT32(srctran_int_mask, csky_dma_state),
+        VMSTATE_UINT32(dsttran_int_mask, csky_dma_state),
+        VMSTATE_UINT32(err_int_mask, csky_dma_state),
+        VMSTATE_UINT32(status_int, csky_dma_state),
+        VMSTATE_STRUCT_ARRAY(chan, csky_dma_state, NR_DMA_CHAN,
+                             1, vmstate_csky_dma_channel, csky_dma_channel),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+/**************************************************************************
+ * Description:
+ *     Update the interrupt flag according the DMA state
+ *     and give the flag to interrupt controller.
+ * Argument:
+ *     s  --- the pointer to the DMA state
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_dma_update(csky_dma_state *s)
+{
+    if (s->err_int & s->err_int_mask) {
+        s->status_int |= 1 << 4;
+    } else {
+        s->status_int &= ~(1 << 4);
+    }
+
+    if (s->dsttran_int & s->dsttran_int_mask) {
+        s->status_int |= 1 << 3;
+    } else {
+        s->status_int &= ~(1 << 3);
+    }
+
+    if (s->srctran_int & s->srctran_int_mask) {
+        s->status_int |= 1 << 2;
+    } else {
+        s->status_int &= ~(1 << 2);
+    }
+
+    if (s->block_int & s->block_int_mask) {
+        s->status_int |= 1 << 1;
+    } else {
+        s->status_int &= ~(1 << 1);
+    }
+
+    if (s->tfr_int & s->tfr_int_mask) {
+        s->status_int |= 1 << 0;
+    } else {
+        s->status_int &= ~(1 << 0);
+    }
+
+    if (s->status_int) {
+        qemu_irq_raise(s->irq);
+    } else {
+        qemu_irq_lower(s->irq);
+    }
+}
+
+/**************************************************************************
+ * Description:
+ *     DMAC register read function.
+ * Argument:
+ *     s  --- the pointer to the DMA state
+ *     offset -- the address offset of the register
+ * Return:
+ *     the value of the corresponding register
+ **************************************************************************/
+static uint64_t csky_dma_read(void *opaque, hwaddr offset, unsigned size)
+{
+    csky_dma_state *s = (csky_dma_state *) opaque;
+    unsigned int channel;
+    uint64_t ret = 0;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "%s: 0x%x must word align read\n",
+                      __func__, (int)offset);
+    }
+
+    switch (offset) {
+    case 0x000 ... 0x14c:
+        channel = offset / 0x58;
+        switch (offset % 0x58) {
+        case 0x0:
+            ret = s->chan[channel].src;
+            break;
+        case 0x8:
+            ret = s->chan[channel].dest;
+            break;
+        case 0x18:
+            ret = s->chan[channel].ctrl[0];
+            break;
+        case 0x1c:
+            ret = s->chan[channel].ctrl[1];
+            break;
+        case 0x40:
+            ret = s->chan[channel].conf[0] | (1 << 9);
+            break;
+        case 0x44:
+            ret = s->chan[channel].conf[1];
+            break;
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "%s: Bad offset 0x%x\n", __func__, (int)offset);
+            break;
+        }
+        break;
+    case 0x2c0:
+        ret = s->tfr_int;
+        break;
+    case 0x2c8:
+        ret = s->block_int;
+        break;
+    case 0x2d0:
+        ret = s->srctran_int;
+        break;
+    case 0x2d8:
+        ret = s->dsttran_int;
+        break;
+    case 0x2e0:
+        ret = s->err_int;
+        break;
+    case 0x2e8:
+        ret = s->tfr_int & s->tfr_int_mask;
+        break;
+    case 0x2f0:
+        ret = s->block_int & s->block_int_mask;
+        break;
+    case 0x2f8:
+        ret = s->srctran_int & s->srctran_int_mask;
+        break;
+    case 0x300:
+        ret = s->dsttran_int & s->dsttran_int_mask;
+        break;
+    case 0x308:
+        ret = s->err_int & s->err_int_mask;
+        break;
+    case 0x310:
+        ret = s->tfr_int_mask;
+        break;
+    case 0x318:
+        ret = s->block_int_mask;
+        break;
+    case 0x320:
+        ret = s->srctran_int_mask;
+        break;
+    case 0x328:
+        ret = s->dsttran_int_mask;
+        break;
+    case 0x330:
+        ret = s->err_int_mask;
+        break;
+    case 0x338:
+    case 0x340:
+    case 0x348:
+    case 0x350:
+    case 0x358:
+        break;
+    case 0x360:
+        ret = s->status_int;
+        break;
+    case 0x368:
+    case 0x370:
+    case 0x378:
+    case 0x380:
+    case 0x388:
+    case 0x390:
+        break;
+    case 0x398:
+        ret = s->dma_enable;
+        break;
+    case 0x3a0:
+        ret = (s->chan[3].chan_enable << 3)
+            | (s->chan[2].chan_enable << 2)
+            | (s->chan[1].chan_enable << 1)
+            | (s->chan[0].chan_enable << 0);
+        break;
+    case 0x3b0:
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "%s: Bad offset 0x%x\n", __func__, (int)offset);
+        break;
+    }
+    return ret;
+}
+
+/**************************************************************************
+ * Description:
+ *     DMAC register write function.
+ * Argument:
+ *     s  --- the pointer to the DMA state
+ *     offset -- the address offset of the register
+ *     value  -- the value that will be written
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_dma_write(void *opaque, hwaddr offset,
+                           uint64_t value, unsigned size)
+{
+    csky_dma_state *s = (csky_dma_state *) opaque;
+    unsigned int channel;
+    uint32_t tmp;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "%s: 0x%x must word align read\n",
+                      __func__, (int)offset);
+    }
+
+    switch (offset) {
+    case 0x000 ... 0x14c:
+        channel = offset / 0x58;
+        switch (offset % 0x58) {
+        case 0x0:
+            s->chan[channel].src = value;
+            break;
+        case 0x8:
+            s->chan[channel].dest = value;
+            break;
+        case 0x18:
+            s->chan[channel].ctrl[0] = value;
+            break;
+        case 0x1c:
+            s->chan[channel].ctrl[1] = value;
+            break;
+        case 0x40:
+            s->chan[channel].conf[0] = value;
+            break;
+        case 0x44:
+            s->chan[channel].conf[1] = value;
+            break;
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "%s: Bad offset 0x%x\n", __func__, (int)offset);
+            break;
+        }
+        break;
+    case 0x2c0:
+    case 0x2c8:
+    case 0x2d0:
+    case 0x2d8:
+    case 0x2e0:
+    case 0x2e8:
+    case 0x2f0:
+    case 0x2f8:
+    case 0x300:
+    case 0x308:
+        break;
+    case 0x310:
+        s->tfr_int_mask = ((value & 0x0f00) >> 8) & (value & 0xf);
+        break;
+    case 0x318:
+        s->block_int_mask = ((value & 0x0f00) >> 8) & (value & 0xf);
+        break;
+    case 0x320:
+        s->srctran_int_mask = ((value & 0x0f00) >> 8) & (value & 0xf);
+        break;
+    case 0x328:
+        s->dsttran_int_mask = ((value & 0x0f00) >> 8) & (value & 0xf);
+        break;
+    case 0x330:
+        s->err_int_mask = ((value & 0x0f00) >> 8) & (value & 0xf);
+        break;
+    case 0x338:
+        s->tfr_int &= ~value;
+        break;
+    case 0x340:
+        s->block_int &= ~value;
+        break;
+    case 0x348:
+        s->srctran_int &= ~value;
+        break;
+    case 0x350:
+        s->dsttran_int &= ~value;
+        break;
+    case 0x358:
+        s->err_int &= ~value;
+        break;
+    case 0x360:
+        break;
+    case 0x368:
+    case 0x370:
+    case 0x378:
+    case 0x380:
+    case 0x388:
+    case 0x390:
+        break;
+    case 0x398:
+        s->dma_enable = value & 0x1;
+        break;
+    case 0x3a0:
+        tmp = ((value & 0x0f00) >> 8) & (value & 0xf);
+        s->chan[3].chan_enable = tmp >> 3;
+        s->chan[2].chan_enable = tmp >> 2;
+        s->chan[1].chan_enable = tmp >> 1;
+        s->chan[0].chan_enable = tmp >> 0;
+        break;
+    case 0x3b0:
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "%s: Bad offset 0x%x\n", __func__, (int)offset);
+        break;
+    }
+    csky_dma_update(s);
+}
+
+static const MemoryRegionOps csky_dma_ops = {
+    .read = csky_dma_read,
+    .write = csky_dma_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static void csky_dma_init(Object *obj)
+{
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+    csky_dma_state *s = CSKY_DMA(obj);
+    int i;
+
+    for (i = 0; i < NR_DMA_CHAN; i++) {
+        s->chan[i].ctrl[1] = 0x2;
+        s->chan[i].conf[0] = 0xe00;
+        s->chan[i].conf[1] = 0x4;
+    }
+
+    memory_region_init_io(&s->iomem, OBJECT(s), &csky_dma_ops, s,
+                          TYPE_CSKY_DMA, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+    sysbus_init_irq(sbd, &s->irq);
+}
+/*
+csky_dma_state *csky_dma_create(const char *name, hwaddr addr, qemu_irq irq)
+{
+    DeviceState *dev;
+    csky_dma_state *s;
+
+    dev = sysbus_create_simple(name, addr, irq);
+    s = FROM_SYSBUS(csky_dma_state, (SysBusDevice *)(dev));
+    return s;
+}
+*/
+static void csky_dma_class_init(ObjectClass *oc, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(oc);
+
+    dc->vmsd = &vmstate_csky_dma;
+}
+
+static const TypeInfo csky_dma_info = {
+    .name          = TYPE_CSKY_DMA,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_dma_state),
+    .instance_init = csky_dma_init,
+    .class_init    = csky_dma_class_init,
+};
+
+static void csky_dma_register_types(void)
+{
+    type_register_static(&csky_dma_info);
+}
+
+type_init(csky_dma_register_types)
diff --git a/hw/intc/Makefile.objs b/hw/intc/Makefile.objs
index 2f44a2d..e6dc27c 100644
--- a/hw/intc/Makefile.objs
+++ b/hw/intc/Makefile.objs
@@ -41,3 +41,5 @@ obj-$(CONFIG_S390_FLIC_KVM) += s390_flic_kvm.o
 obj-$(CONFIG_ASPEED_SOC) += aspeed_vic.o
 obj-$(CONFIG_ARM_GIC) += arm_gicv3_cpuif.o
 obj-$(CONFIG_MIPS_CPS) += mips_gic.o
+obj-$(CONFIG_CSKY_INTC) += csky_intc.o
+obj-$(CONFIG_CSKY_TCIP) += csky_tcip_v1.o
diff --git a/hw/intc/armv7m_nvic.c b/hw/intc/armv7m_nvic.c
index 06d8db6..9bf8675 100644
--- a/hw/intc/armv7m_nvic.c
+++ b/hw/intc/armv7m_nvic.c
@@ -70,7 +70,7 @@ static const uint8_t nvic_id[] = {
 #define SYSTICK_CLKSOURCE (1 << 2)
 #define SYSTICK_COUNTFLAG (1 << 16)
 
-int system_clock_scale;
+int system_clock_scale = 1;
 
 /* Conversion factor from qemu timer to SysTick frequencies.  */
 static inline int64_t systick_scale(nvic_state *s)
diff --git a/hw/intc/csky_intc.c b/hw/intc/csky_intc.c
new file mode 100644
index 0000000..1bc7e2c
--- /dev/null
+++ b/hw/intc/csky_intc.c
@@ -0,0 +1,311 @@
+/*
+ * CSKY intc controller
+ *
+ * Written by lyc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "hw/ptimer.h"
+#include "sysemu/char.h"
+#include "qemu/log.h"
+#include "trace.h"
+#include "cpu.h"
+#include "hw/csky/cskydev.h"
+
+#define INTC_ICR_MASK    0x1f
+#define INTC_ICR_MFI     (1 << 12)
+#define INTC_ICR_ME      (1 << 13)
+#define INTC_ICR_FVE     (1 << 14)
+#define INTC_ICR_AVE     (1 << 15)
+
+#define INTC_ISR_VEC     0x7f
+#define INTC_ISR_FINT    (1 << 8)
+#define INTC_ISR_INT     (1 << 9)
+
+#define PR0              0x40
+#define PR28             0x5c
+#define INTC_LEVEL       (1 << 10)
+
+#define TYPE_CSKY_INTC   "csky_intc"
+#define CSKY_INTC(obj)   OBJECT_CHECK(csky_intc_state, (obj), TYPE_CSKY_INTC)
+
+typedef struct csky_intc_state {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    SysBusDevice busdev;
+    uint32_t int_icr;
+    uint32_t int_isr;
+    uint32_t int_source; /*irq from device*/
+    uint32_t int_ifr;
+    uint32_t int_ipr;
+    uint32_t int_nier;
+    uint32_t int_nipr;
+    uint32_t int_fier;
+    uint32_t int_fipr;
+    uint32_t pr[32];
+    qemu_irq irq;
+} csky_intc_state;
+
+static void csky_intc_update(csky_intc_state *s)
+{
+    uint32_t f;
+    uint32_t i;
+    uint32_t flag;
+
+    f = s->int_source | s->int_ifr;
+    if (f == 0) {
+        s->int_ipr = 0;
+    } else {
+        i = __builtin_clz(f);
+        s->int_ipr = 1 << s->pr[31 - i];
+        f &= ~(1 << (31 - i));
+        while (f != 0) {
+            i = __builtin_clz(f);
+            s->int_ipr |= 1 << s->pr[31 - i];
+            f &= ~(1 << (31 - i));
+        }
+    }
+
+    if (s->int_icr & INTC_ICR_ME) {
+        if (s->int_icr & INTC_ICR_MFI) {
+            s->int_nipr = 0;
+            s->int_fipr = s->int_ipr & s->int_fier &
+                (0xffffffff << ((s->int_icr & INTC_ICR_MASK) + 1));
+        } else {
+            s->int_fipr = s->int_ipr & s->int_fier;
+            s->int_nipr = s->int_ipr & s->int_nier &
+                (0xffffffff << ((s->int_icr & INTC_ICR_MASK) + 1));
+        }
+    } else {
+        s->int_fipr = s->int_ipr & s->int_fier;
+        s->int_nipr = s->int_ipr & s->int_nier;
+    }
+
+    s->int_isr = ((s->int_fipr != 0) << 8) | ((s->int_nipr != 0) << 9);
+
+    if (s->int_icr & INTC_ICR_FVE) {
+        if (s->int_fipr) {
+            s->int_isr |= 63 - __builtin_clz(s->int_fipr);
+        } else if (s->int_nipr) {
+            s->int_isr |= 31 - __builtin_clz(s->int_nipr);
+        }
+    } else {
+        if (s->int_fipr) {
+            s->int_isr |= 31 - __builtin_clz(s->int_fipr);
+        } else if (s->int_nipr) {
+            s->int_isr |= 31 - __builtin_clz(s->int_nipr);
+        }
+    }
+
+    flag = ((s->int_fipr || s->int_nipr) << 10) |
+        (s->int_isr + 32) | ((s->int_icr & INTC_ICR_AVE) >> 8);
+    qemu_set_irq(s->irq, flag);
+}
+
+static void csky_intc_set_irq(void *opaque, int irq, int level)
+{
+    csky_intc_state *s = (csky_intc_state *)opaque;
+    if (level) {
+        s->int_source |= 1 << irq;
+    } else {
+        s->int_source &= ~(1 << irq);
+    }
+    csky_intc_update(s);
+}
+
+static uint64_t csky_intc_read(void *opaque, hwaddr offset, unsigned size)
+{
+    csky_intc_state *s = (csky_intc_state *)opaque;
+
+    if (size == 2) {
+        switch (offset) {
+        case 0x00: /*ISR*/
+            return s->int_isr;
+        case 0x02: /*ICR*/
+            return s->int_icr;
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR, "csky_intc_read: "
+                          "Bad register offset 0x%x\n", (int)offset);
+        }
+    } else if (size == 4) {
+        switch (offset) {
+        case 0x00: /*ISR & ICR*/
+            return s->int_isr | (s->int_icr << 16);
+        case 0x08: /*IFR*/
+            return s->int_ifr;
+        case 0x0c: /*IPR*/
+            return s->int_ipr;
+        case 0x10: /*NIER*/
+            return s->int_nier;
+        case 0x14: /*NIPR*/
+            return s->int_nipr;
+        case 0x18: /*FIER*/
+            return s->int_fier;
+        case 0x1c: /*FIPR*/
+            return s->int_fipr;
+        case PR0 ... PR28: /*PR[32]*/
+            return ((s->pr[offset - PR0] << 24) |
+                    (s->pr[offset - PR0 + 1] << 16) |
+                    (s->pr[offset - PR0 + 2] << 8) |
+                    s->pr[offset - PR0 + 3]);
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR, "csky_intc_read: "
+                          "Bad register offset 0x%x\n", (int)offset);
+        }
+    } else {
+        qemu_log_mask(LOG_GUEST_ERROR, "csky_intc_read: "
+                      "Bad size 0x%x\n", size);
+    }
+
+    return 0;
+}
+
+static void csky_intc_write(void *opaque, hwaddr offset,
+                            uint64_t value, unsigned size)
+{
+    csky_intc_state *s = (csky_intc_state *)opaque;
+
+    if (size == 2) {
+        switch (offset) {
+        case 0x00: /*ISR*/
+            return;
+        case 0x02: /*ICR*/
+            s->int_icr = value;
+            return;
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR, "csky_intc_write: "
+                          "Bad register offset 0x%x\n", (int)offset);
+            return;
+        }
+    } else if (size == 4) {
+        switch (offset) {
+        case 0x00: /*ICR*/
+            s->int_icr = value >> 16;
+            break;
+        case 0x08: /*IFR*/
+            s->int_ifr = value;
+            break;
+        case 0x10: /*NIER*/
+            s->int_nier = value;
+            break;
+        case 0x18: /*FIER*/
+            s->int_fier = value;
+            break;
+        case PR0 ... PR28: /*PR[32]*/
+            s->pr[offset - PR0] = (value >> 24) & 0xff;
+            s->pr[offset - PR0 + 1] = (value >> 16) & 0xff;
+            s->pr[offset - PR0 + 2] = (value >> 8) & 0xff;
+            s->pr[offset - PR0 + 3] = value & 0xff;
+            break;
+        case 0x0c: /*IPR*/
+        case 0x14: /*NIPR*/
+        case 0x1c: /*FIPR*/
+            return;
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR, "csky_intc_write: "
+                          "Bad register offset 0x%x\n", (int)offset);
+            return;
+        }
+    } else {
+        qemu_log_mask(LOG_GUEST_ERROR, "csky_intc_write: "
+                      "Bad size 0x%x\n", size);
+    }
+    csky_intc_update(s);
+}
+
+static const MemoryRegionOps csky_intc_ops = {
+    .read = csky_intc_read,
+    .write = csky_intc_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static void csky_intc_cpu_handler(void *opaque, int irq, int level)
+{
+    CPUCSKYState *env = (CPUCSKYState *)opaque;
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+
+    env->intc_signals.vec_b = level & INTC_ISR_VEC;
+    env->intc_signals.avec_b = (level & 0x80) >> 7;
+    env->intc_signals.fint_b = (level & INTC_ISR_FINT) >> 8;
+    env->intc_signals.int_b = (level & INTC_ISR_INT) >> 9;
+
+    if (level & INTC_LEVEL) {
+        cpu_interrupt(cs, CPU_INTERRUPT_HARD);
+    } else {
+        cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);
+    }
+}
+
+qemu_irq *csky_intc_init_cpu(CPUCSKYState *env)
+{
+    return qemu_allocate_irqs(csky_intc_cpu_handler, env, 1);
+}
+
+static void csky_intc_init(Object *obj)
+{
+    DeviceState *dev = DEVICE(obj);
+    csky_intc_state *s = CSKY_INTC(obj);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+
+    memory_region_init_io(&s->iomem, obj, &csky_intc_ops,
+                          s, TYPE_CSKY_INTC, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+    qdev_init_gpio_in(dev, csky_intc_set_irq, 32);
+    sysbus_init_irq(sbd, &s->irq);
+}
+
+static const VMStateDescription vmstate_csky_intc = {
+    .name = TYPE_CSKY_INTC,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT32(int_icr, csky_intc_state),
+        VMSTATE_UINT32(int_isr, csky_intc_state),
+        VMSTATE_UINT32(int_source, csky_intc_state),
+        VMSTATE_UINT32(int_ifr, csky_intc_state),
+        VMSTATE_UINT32(int_ipr, csky_intc_state),
+        VMSTATE_UINT32(int_nier, csky_intc_state),
+        VMSTATE_UINT32(int_nipr, csky_intc_state),
+        VMSTATE_UINT32(int_fier, csky_intc_state),
+        VMSTATE_UINT32(int_fipr, csky_intc_state),
+        VMSTATE_UINT32_ARRAY(pr, csky_intc_state, 32),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static void csky_intc_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->vmsd = &vmstate_csky_intc;
+}
+
+static const TypeInfo csky_intc_info = {
+    .name          = TYPE_CSKY_INTC,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_intc_state),
+    .instance_init = csky_intc_init,
+    .class_init    = csky_intc_class_init,
+};
+
+static void csky_register_types(void)
+{
+    type_register_static(&csky_intc_info);
+}
+
+type_init(csky_register_types)
diff --git a/hw/intc/csky_tcip_v1.c b/hw/intc/csky_tcip_v1.c
new file mode 100644
index 0000000..7a044b8
--- /dev/null
+++ b/hw/intc/csky_tcip_v1.c
@@ -0,0 +1,570 @@
+/*
+ * CSKY tcip v1 emulation.
+ *
+ * Written by wanghb
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "hw/ptimer.h"
+#include "sysemu/char.h"
+#include "qemu/log.h"
+#include "trace.h"
+#include "cpu.h"
+#include "hw/csky/cskydev.h"
+
+/* CoreTim */
+#define CT_CSR_COUNTFLAG    (1 << 16)
+#define CT_CSR_INTERNAL_CLK (1 << 2)
+#define CT_CSR_TICKINT      (1 << 1)
+#define CT_CSR_ENABLE       (1 << 0)
+
+/* VIC */
+#define VIC_ISR_VEC         0xff
+#define VIC_ISR_INT         (1 << 10)
+#define VIC_ISR_PEND_SHF    12
+#define PR0                 0x400
+#define PR28                0x41c
+#define VIC_IPTR_EN         0x80000000
+#define GET_IPTR_PRI(a)     ((a & 0xc0) >> 6)
+
+#define TYPE_CSKY_TCIP_V1   "csky_tcip_v1"
+#define CSKY_TCIP_V1(obj)   OBJECT_CHECK(csky_tcip_v1_state, (obj), \
+                                         TYPE_CSKY_TCIP_V1)
+
+typedef struct csky_tcip_v1_state {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    ptimer_state *timer;
+    uint32_t coret_csr;
+    uint32_t coret_rvr;
+    uint32_t vic_iser;
+    uint32_t vic_iwer;
+    uint32_t vic_source; /* irq from device */
+    uint32_t vic_ispr;
+    uint32_t vic_pr[32]; /* for each vic_pr[i], only the
+                            lowest two bits are valid */
+    CPUCSKYState *env;
+    qemu_irq irq;
+} csky_tcip_v1_state;
+
+static int coretim_irq_no;
+uint32_t coretim_freq = 1000000000ll;
+
+/* find the highest priority interrupt source
+ * first poll priority_bitmap[0], then priority_bitmap[1], ...[2], ...[3]
+ * count the number of trailing 0-bits starting from the least
+ * significant bit position use builtin function ctz
+ */
+static uint32_t find_highest_priority_vec(uint32_t priority_bitmap[])
+{
+    uint32_t i;
+    uint32_t int_vec = 0;
+    for (i = 0; i < 4; i++) {
+        if (priority_bitmap[i] == 0) {
+            continue;
+        }
+        int_vec = __builtin_ctz(priority_bitmap[i]);
+        break;
+    }
+    return int_vec;
+}
+/**************************************************************************
+ * Description:
+ *     Update the interrupt flag according the vic state and
+ *     give the flag to cpu.
+ * Argument:
+ *     s  --- the pointer to the vic state
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_vic_v1_update(csky_tcip_v1_state *s)
+{
+    uint32_t int_req = 0;
+    uint32_t int_best = 0;
+    uint32_t int_active;
+    uint32_t int_pend;
+    uint32_t priority_bitmap[4] = {0, 0, 0, 0};
+    uint32_t i;
+    uint32_t flag = 0;
+    uint32_t iptr_en = s->env->intc_signals.iptr & VIC_IPTR_EN;
+    uint32_t iptr_pri = GET_IPTR_PRI(s->env->intc_signals.iptr);
+
+    s->vic_ispr |= s->vic_source;
+    int_req = s->vic_ispr & s->vic_iser;
+    int_active = s->env->intc_signals.isr & VIC_ISR_VEC;
+
+    /* There is no irq, clear the interrupt_request. */
+    if ((int_req == 0) && (s->env->intc_signals.int_b == 0)) {
+        qemu_set_irq(s->irq, 0);
+        return;
+    }
+
+    /* generate the bitmap for each priority level and each interrupt source.
+     * priority_bitmap[i] stands for priority level i, 0<=i<=3
+     * and each bit of priority_bitmap[i] stands for one interrupt source
+     */
+    do {
+        i = __builtin_clz(int_req);
+        priority_bitmap[s->vic_pr[31 - i]] |= 1 << (31 - i);
+        int_req &= ~(1 << (31 - i));
+    } while (int_req != 0);
+
+    int_best = find_highest_priority_vec(priority_bitmap);
+
+    /* If psr.ee or psr.ie is not set or the irq are handling now,
+     * just pending it and update the isr. */
+    if (((s->env->cp0.psr & (PSR_EE_MASK | PSR_IE_MASK)) != 0x140)
+        || ((s->env->intc_signals.iabr & (1 << int_best)) != 0))
+    {
+        s->env->intc_signals.isr = (int_active |
+                                    ((int_best + 32) << VIC_ISR_PEND_SHF));
+        return;
+    }
+
+    /* Response or Pending the new irq. */
+    if ((s->env->intc_signals.iabr == 0)
+        || ((s->vic_pr[int_best] < s->vic_pr[int_active - 32])
+            && ((iptr_en == 0) || (s->vic_pr[int_best] < iptr_pri)))) {
+        /* There is no irq before, or New irq that can nest the last one.  */
+        s->vic_ispr &= ~(1 << int_best);
+        if ((s->vic_ispr & s->vic_iser) == 0) {
+            int_pend = 0;
+        } else {
+            priority_bitmap[s->vic_pr[int_best]] &= ~(1 << int_best);
+            int_pend = find_highest_priority_vec(priority_bitmap) + 32;
+        }
+
+        s->env->intc_signals.isr = ((int_best + 32)
+                                    | (int_pend << VIC_ISR_PEND_SHF));
+        s->env->intc_signals.iabr |= 1 << int_best;
+        flag = (int_best + 32) | VIC_ISR_INT;
+        qemu_set_irq(s->irq, flag);
+    } else {
+        /* New irq, but can not nest the last irq. */
+        s->env->intc_signals.isr = (int_active |
+                                    ((int_best + 32) << VIC_ISR_PEND_SHF));
+    }
+}
+
+/**************************************************************************
+ * Description:
+ *     Interrupt request from other devices to VIC.
+ * Argument:
+ *     opaque  ---  the pointer to VIC state.
+ *     irq     ---  vector number of the interrupt request
+ *     level   ---  set or clear the corresponding interrupt
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_vic_v1_set_irq(void *opaque, int irq, int level)
+{
+    csky_tcip_v1_state *s = (csky_tcip_v1_state *)opaque;
+    if (level) {
+        s->vic_source |= 1 << irq;
+    } else {
+        s->vic_source &= ~(1 << irq);
+    }
+    csky_vic_v1_update(s);
+}
+
+/**************************************************************************
+ * Description:
+ *     Read the value of TCIP registers.
+ * Argument:
+ *     opaque  --  the pointer of the TCIP state.
+ *     offset  --  the offset of the register which will be read.
+ * Return:
+ *     The value of the corresponding TCIP register.
+ **************************************************************************/
+static uint64_t csky_tcip_v1_read(void *opaque, hwaddr offset, unsigned size)
+{
+    csky_tcip_v1_state *s = (csky_tcip_v1_state *)opaque;
+    uint64_t ret = 0;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_tcip_v1_read: 0x%x must word align read\n",
+                      (int)offset);
+    }
+
+    switch (offset) {
+    case 0x10: /* CoreTim CSR */
+        ret = s->coret_csr;
+        s->coret_csr &= ~CT_CSR_COUNTFLAG;
+        csky_vic_v1_set_irq(s, coretim_irq_no, 0);
+        break;
+    case 0x14: /* CoreTim ReloadValue */
+        ret = s->coret_rvr;
+        break;
+    case 0x18: /* CoreTim CurrentValue */
+        if (s->coret_csr & CT_CSR_ENABLE) {
+            ret = ptimer_get_count(s->timer);
+        }
+        break;
+    case 0x1c:
+        break;
+
+    case 0x100: /*ISER*/
+    case 0x180: /*ICER*/
+        ret = s->vic_iser;
+        break;
+    case 0x140: /*IWER*/
+    case 0x1c0: /*IWDR*/
+        ret =  s->vic_iwer;
+        break;
+    case 0x240: /*ISSR*/
+    case 0x2c0: /*ICSR*/
+        if (s->env->features & ABIV2_TEE) {
+            if (s->env->psr_s == 1 && s->env->psr_t == 1) {
+                ret = s->env->intc_signals.issr;
+            } else {
+                ret = 0;
+            }
+        } else {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "csky_tcip_v1_read: Bad register offset 0x%x\n",
+                          (int)offset);
+        }
+        break;
+    case 0x200: /*ISPR*/
+    case 0x280: /*ICPR*/
+        ret = s->vic_ispr;
+        break;
+    case 0x300: /*IABR*/
+        ret = s->env->intc_signals.iabr;
+        break;
+    case PR0 ... PR28: /*PR[32]*/
+        ret =  ((s->vic_pr[offset - PR0] << 6)
+                | (s->vic_pr[offset - PR0 + 1] << 14)
+                | (s->vic_pr[offset - PR0 + 2] << 22)
+                | (s->vic_pr[offset - PR0 + 3] << 30));
+        break;
+    case 0xc00: /* VIC_ISR */
+        ret = s->env->intc_signals.isr;
+        break;
+    case 0xc04: /* VIC_IPTR */
+        ret = s->env->intc_signals.iptr;
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_tcip_v1_read: Bad register offset 0x%x\n",
+                      (int)offset);
+    }
+
+    return ret;
+}
+
+/**************************************************************************
+ * Description:
+ *     Write the value to TCIP registers.
+ * Argument:
+ *     opaque  --  the pointer of the TCIP state.
+ *     offset  --  the offset of the register.
+ *     value   --  the value which will be writen.
+ * Return:
+ *     Void
+ **************************************************************************/
+static void csky_tcip_v1_write(void *opaque, hwaddr offset, uint64_t value,
+                               unsigned size)
+{
+    csky_tcip_v1_state *s = (csky_tcip_v1_state *)opaque;
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_tcip_v1_write: 0x%x must word align write\n",
+                      (int)offset);
+    }
+
+    switch (offset) {
+    case 0x10:  /* CoreTim CSR */
+        s->coret_csr = (s->coret_csr & CT_CSR_COUNTFLAG) | (value & 0x7);
+
+        ptimer_set_limit(s->timer, s->coret_rvr, s->coret_csr & CT_CSR_ENABLE);
+        if (s->coret_csr & CT_CSR_ENABLE) {
+            ptimer_run(s->timer, 0);
+        }
+        if ((s->coret_csr & CT_CSR_COUNTFLAG) &&
+            (s->coret_csr & CT_CSR_TICKINT)) {
+            s->vic_source |= 1 << coretim_irq_no;
+        } else {
+            s->vic_source &= ~(1 << coretim_irq_no);
+        }
+        break;
+    case 0x14:  /* CoreTim ReloadValue */
+        s->coret_rvr = value & 0x00ffffff;
+        if (s->coret_rvr == 0) {
+            ptimer_stop(s->timer);
+        } else if (s->coret_csr & CT_CSR_ENABLE) {
+            ptimer_set_limit(s->timer, s->coret_rvr, 0);
+            ptimer_run(s->timer, 0);
+        }
+        break;
+    case 0x18:  /* CoreTim CurrentValue */
+        ptimer_set_limit(s->timer, s->coret_rvr, 1);
+        s->coret_csr &= ~CT_CSR_COUNTFLAG;
+        s->vic_source &= ~(1 << coretim_irq_no);
+        break;
+    case 0x1c:
+        break;
+
+    case 0x100: /* ISER */
+        s->vic_iser |= value;
+        break;
+    case 0x140: /* IWER */
+        s->vic_iwer |= value;
+        break;
+    case 0x180: /* ICER */
+        s->vic_iser &= ~value;
+        break;
+    case 0x1c0: /* IWDR */
+        s->vic_iwer &= ~value;
+        break;
+    case 0x200: /* ISPR */
+        s->vic_ispr |= value;
+        break;
+    case 0x240: /* ISSR */
+        if (s->env->features & ABIV2_TEE) {
+            if (s->env->psr_s == 1 && s->env->psr_t == 1) {
+                s->env->intc_signals.issr |= value;
+            }
+        } else {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "csky_tcip_v1_write: Bad register offset 0x%x\n",
+                          (int)offset);
+        }
+        break;
+    case 0x280: /* ICPR */
+        s->vic_ispr &= ~value;
+        break;
+    case 0x2c0: /* ICSR */
+        if (s->env->features & ABIV2_TEE) {
+            if (s->env->psr_s == 1 && s->env->psr_t == 1) {
+                s->env->intc_signals.issr &= ~value;
+            }
+        } else {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "csky_tcip_v1_write: Bad register offset 0x%x\n",
+                          (int)offset);
+        }
+        break;
+    case 0x300: /* IABR */
+        /* Useguide says "if write 0 to iabr, it will clear the active state,
+         * but write 1 to iabr, it maybe cause an unpredictable error",
+         * so in qemu when write to iabr, it will clear iabr anyway. */
+        s->env->intc_signals.iabr = 0;
+        break;
+    case PR0 ... PR28: /* PR[32] */ /* big endian */
+        s->vic_pr[offset - PR0] = (value >> 6) & 0x3;
+        s->vic_pr[offset - PR0 + 1] = (value >> 14) & 0x3;
+        s->vic_pr[offset - PR0 + 2] = (value >> 22) & 0x3;
+        s->vic_pr[offset - PR0 + 3] = (value >> 30) & 0x3;
+        break;
+    case 0xc00: /* ISR */
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "Attempt to write a read-only register ISR!\n");
+        break;
+    case 0xc04: /* IPTR */
+        if (s->env->features & ABIV2_TEE) {
+            if (s->env->psr_s == 1 && s->env->psr_t == 1) {
+                s->env->intc_signals.iptr = value;
+            }
+        } else {
+            s->env->intc_signals.iptr = value;
+        }
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_tcip_v1_write: Bad register offset 0x%x\n",
+                      (int)offset);
+        return;
+    }
+    csky_vic_v1_update(s);
+}
+
+static const MemoryRegionOps csky_tcip_v1_ops = {
+    .read = csky_tcip_v1_read,
+    .write = csky_tcip_v1_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static void csky_tcip_v1_reset(DeviceState *d)
+{
+    csky_tcip_v1_state *s = CSKY_TCIP_V1(d);
+
+    s->coret_csr = CT_CSR_INTERNAL_CLK;
+    s->vic_iser = 0;
+    s->vic_iwer = 0;
+    s->vic_source = 0;
+    s->vic_ispr = 0;
+    s->env->intc_signals.iabr = 0;
+    s->env->intc_signals.isr = 0;
+    s->env->intc_signals.iptr = 0;
+    s->env->intc_signals.issr = 0;
+    csky_vic_v1_update(s);
+}
+
+/**************************************************************************
+* Description:
+*     Interrupt handler: generate signals to cpu.
+* Argument:
+*     opaque  --  the pointer to CPU state.
+*     irq     --  vector number of interrupt.
+*     level   --  contains some important information to help
+*                 handle the interrupt.
+* Return:
+*     void
+**************************************************************************/
+static void csky_vic_v1_cpu_handler(void *opaque, int irq, int level)
+{
+    CPUCSKYState *env = (CPUCSKYState *)opaque;
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+
+    env->intc_signals.vec_b = level & VIC_ISR_VEC;
+    env->intc_signals.avec_b = 0;
+    env->intc_signals.fint_b = 0;
+    env->intc_signals.int_b = (level & VIC_ISR_INT) >> 10;
+
+    if (level & VIC_ISR_INT) {
+        cpu_interrupt(cs, CPU_INTERRUPT_HARD);
+    } else {
+        cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);
+    }
+}
+
+/**************************************************************************
+* Description:
+*     Allocate irq for VIC and register the handler.
+* Argument:
+*     env  --  the pointer to CPU state.
+* Return:
+*     the pointer to the allocated irq
+**************************************************************************/
+qemu_irq *csky_vic_v1_init_cpu(CPUCSKYState *env, int coret_irq_num)
+{
+    coretim_irq_no = coret_irq_num;
+
+    return qemu_allocate_irqs(csky_vic_v1_cpu_handler, env, 1);
+}
+
+/**************************************************************************
+ * Description:
+ *     Be called when current value of the timer reaches 0.
+ * Argument:
+ *     opaque  --  the pointer to TCIP state.
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_coretim_tick(void *opaque)
+{
+    csky_tcip_v1_state *s = (csky_tcip_v1_state *)opaque;
+
+    ptimer_set_limit(s->timer, s->coret_rvr, 1);
+    s->coret_csr |= CT_CSR_COUNTFLAG;
+    if (s->coret_csr & CT_CSR_TICKINT) {
+        csky_vic_v1_set_irq(s, coretim_irq_no, 1);
+    }
+}
+
+/**************************************************************************
+ * Description:
+ *     Initial TCIP.
+ * Argument:
+ *     obj  --  the pointer to csky_tcip_v1_info.
+ * Return:
+ *     success or failure
+ **************************************************************************/
+static void csky_tcip_v1_init(Object *obj)
+{
+    DeviceState *dev = DEVICE(obj);
+    csky_tcip_v1_state *s = CSKY_TCIP_V1(obj);
+    CSKYCPU *cpu = CSKY_CPU(qemu_get_cpu(0));
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+    QEMUBH *bh;
+
+    if (cpu == NULL) {
+        return;
+    }
+
+    s->coret_csr = CT_CSR_INTERNAL_CLK;
+    s->env = &cpu->env;
+    s->vic_iser = 0;
+    s->vic_iwer = 0;
+    s->vic_source = 0;
+    s->vic_ispr = 0;
+    s->env->intc_signals.iabr = 0;
+    s->env->intc_signals.isr = 0;
+    s->env->intc_signals.iptr = 0;
+    s->env->intc_signals.issr = 0;
+
+    /* CSKY VIC intialization */
+    qdev_init_gpio_in(dev, csky_vic_v1_set_irq, 32);
+    sysbus_init_irq(sbd, &s->irq);
+
+    /* CSKY CoreTim intialization */
+    bh = qemu_bh_new(csky_coretim_tick, s);
+    s->timer = ptimer_init(bh, PTIMER_POLICY_DEFAULT);
+    ptimer_set_freq(s->timer, coretim_freq);
+
+    memory_region_init_io(&s->iomem, obj, &csky_tcip_v1_ops,
+                          s, TYPE_CSKY_TCIP_V1, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+}
+
+static const VMStateDescription vmstate_tcip_v1 = {
+    .name = TYPE_CSKY_TCIP_V1,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_PTIMER(timer, csky_tcip_v1_state),
+        VMSTATE_UINT32(coret_csr, csky_tcip_v1_state),
+        VMSTATE_UINT32(coret_rvr, csky_tcip_v1_state),
+        VMSTATE_UINT32(vic_iser, csky_tcip_v1_state),
+        VMSTATE_UINT32(vic_iwer, csky_tcip_v1_state),
+        VMSTATE_UINT32(vic_source, csky_tcip_v1_state),
+        VMSTATE_UINT32(vic_ispr, csky_tcip_v1_state),
+        VMSTATE_UINT32_ARRAY(vic_pr, csky_tcip_v1_state, 32),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+void csky_tcip_v1_set_freq(uint32_t freq)
+{
+    coretim_freq = freq;
+}
+
+static void csky_tcip_v1_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->vmsd  = &vmstate_tcip_v1;
+    dc->reset = csky_tcip_v1_reset;
+}
+
+static const TypeInfo csky_tcip_v1_info = {
+    .name          = TYPE_CSKY_TCIP_V1,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_init = csky_tcip_v1_init,
+    .instance_size = sizeof(csky_tcip_v1_state),
+    .class_init    = csky_tcip_v1_class_init,
+};
+
+static void csky_tcip_v1_register_types(void)
+{
+    type_register_static(&csky_tcip_v1_info);
+}
+
+type_init(csky_tcip_v1_register_types)
diff --git a/hw/misc/Makefile.objs b/hw/misc/Makefile.objs
index 1a89615..d81d4aa 100644
--- a/hw/misc/Makefile.objs
+++ b/hw/misc/Makefile.objs
@@ -47,6 +47,8 @@ obj-$(CONFIG_STM32F2XX_SYSCFG) += stm32f2xx_syscfg.o
 obj-$(CONFIG_MIPS_CPS) += mips_cmgcr.o
 obj-$(CONFIG_MIPS_CPS) += mips_cpc.o
 obj-$(CONFIG_MIPS_ITU) += mips_itu.o
+obj-$(CONFIG_CSKY_EXIT) += csky_exit.o
+obj-$(CONFIG_CSKY_MEMLOG) += csky_memlog.o
 
 obj-$(CONFIG_PVPANIC) += pvpanic.o
 obj-$(CONFIG_EDU) += edu.o
diff --git a/hw/misc/csky_exit.c b/hw/misc/csky_exit.c
new file mode 100644
index 0000000..2377c15
--- /dev/null
+++ b/hw/misc/csky_exit.c
@@ -0,0 +1,111 @@
+/*
+ * CSKY exit.
+ *
+ * using to exit QEMU from target linux.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "trace.h"
+#include "qemu/timer.h"
+
+typedef struct {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+} csky_exit_state;
+
+#define TYPE_CSKY_EXIT  "csky_exit"
+#define CSKY_EXIT(obj)  OBJECT_CHECK(csky_exit_state, (obj), \
+                                       TYPE_CSKY_EXIT)
+
+static uint64_t csky_exit_read(void *opaque, hwaddr offset, unsigned size)
+{
+    qemu_log_mask(LOG_GUEST_ERROR, "csky_exit_read: should not read\n");
+
+    return 0;
+}
+
+#define EXIT_RETURN_VALUE   0x0
+#define EXIT_LABEL          0x40
+#define EXIT_GET_CYCLE      0x44
+static void csky_exit_write(void *opaque, hwaddr offset,
+                            uint64_t value, unsigned size)
+{
+    switch (offset) {
+    case EXIT_RETURN_VALUE:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_exit_write: exit(%d)\n", (int)value);
+        exit(value);
+        break;
+    case EXIT_LABEL:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "label: %d\n", (int)value);
+        break;
+    case EXIT_GET_CYCLE:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "current cycle: %ld\n", cpu_get_icount_raw());
+        break;
+    default:
+        exit(0);
+    }
+}
+
+static const MemoryRegionOps csky_exit_ops = {
+    .read = csky_exit_read,
+    .write = csky_exit_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+
+static void csky_exit_init(Object *obj)
+{
+    csky_exit_state *s = CSKY_EXIT(obj);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+
+    memory_region_init_io(&s->iomem, OBJECT(s), &csky_exit_ops, s,
+                          TYPE_CSKY_EXIT, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+}
+
+static void csky_exit_realize(DeviceState *dev, Error **errp)
+{
+
+}
+
+static void csky_exit_class_init(ObjectClass *oc, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(oc);
+
+    dc->realize = csky_exit_realize;
+}
+
+static const TypeInfo csky_exit_info = {
+    .name          = TYPE_CSKY_EXIT,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_exit_state),
+    .instance_init = csky_exit_init,
+    .class_init    = csky_exit_class_init,
+};
+
+
+static void csky_exit_register_types(void)
+{
+    type_register_static(&csky_exit_info);
+}
+
+type_init(csky_exit_register_types)
+
diff --git a/hw/misc/csky_memlog.c b/hw/misc/csky_memlog.c
new file mode 100644
index 0000000..bdb7021
--- /dev/null
+++ b/hw/misc/csky_memlog.c
@@ -0,0 +1,115 @@
+/*
+ * CSKY memlog.
+ *
+ * using to print log QEMU from target linux.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "sysemu/char.h"
+#include "trace.h"
+
+typedef struct {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    int fd;
+} csky_memlog_state;
+
+#define TYPE_CSKY_MEMLOG  "csky_memlog"
+#define CSKY_MEMLOG(obj)  OBJECT_CHECK(csky_memlog_state, (obj), \
+                                       TYPE_CSKY_MEMLOG)
+
+static uint64_t csky_memlog_read(void *opaque, hwaddr offset, unsigned size)
+{
+    qemu_log_mask(LOG_GUEST_ERROR, "csky_memlog_read: should not read\n");
+
+    return 0;
+}
+
+static void csky_memlog_write(void *opaque, hwaddr offset,
+                              uint64_t value, unsigned size)
+{
+    csky_memlog_state *s = (csky_memlog_state *)opaque;
+    char a = value;
+    int ret;
+
+    if (offset != 0) {
+        qemu_log_mask(LOG_GUEST_ERROR, "csky_memlog_write: bad offset\n");
+    }
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_memlog_write: only support word align access\n");
+    }
+
+    do {
+        ret = write(s->fd, &a, 1);
+    } while (ret < 0 && errno == EINTR);
+}
+
+static const MemoryRegionOps csky_memlog_ops = {
+    .read = csky_memlog_read,
+    .write = csky_memlog_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static const VMStateDescription vmstate_csky_memlog = {
+    .name = TYPE_CSKY_MEMLOG,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_INT32(fd, csky_memlog_state),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static void csky_memlog_init(Object *obj)
+{
+    csky_memlog_state *s = CSKY_MEMLOG(obj);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+
+    memory_region_init_io(&s->iomem, OBJECT(s), &csky_memlog_ops, s,
+                          TYPE_CSKY_MEMLOG, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+
+    do {
+        s->fd = open("mem.log",  O_CREAT | O_TRUNC | O_WRONLY, 0644);
+    } while (s->fd < 0 && errno == EINTR);
+}
+
+static void csky_memlog_class_init(ObjectClass *oc, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(oc);
+
+    dc->vmsd = &vmstate_csky_memlog;
+}
+
+static const TypeInfo csky_memlog_info = {
+    .name          = TYPE_CSKY_MEMLOG,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_memlog_state),
+    .instance_init = csky_memlog_init,
+    .class_init    = csky_memlog_class_init,
+};
+
+
+static void csky_memlog_register_types(void)
+{
+    type_register_static(&csky_memlog_info);
+}
+
+type_init(csky_memlog_register_types)
diff --git a/hw/net/Makefile.objs b/hw/net/Makefile.objs
index 610ed3e..74f47ff 100644
--- a/hw/net/Makefile.objs
+++ b/hw/net/Makefile.objs
@@ -32,6 +32,8 @@ obj-$(CONFIG_COLDFIRE) += mcf_fec.o
 obj-$(CONFIG_MILKYMIST) += milkymist-minimac2.o
 obj-$(CONFIG_PSERIES) += spapr_llan.o
 obj-$(CONFIG_XILINX_ETHLITE) += xilinx_ethlite.o
+obj-$(CONFIG_CSKY_MAC) += csky_mac.o
+obj-$(CONFIG_CSKY_MAC2) += csky_mac_v2.o
 
 obj-$(CONFIG_VIRTIO) += virtio-net.o
 obj-y += vhost_net.o
diff --git a/hw/net/csky_mac.c b/hw/net/csky_mac.c
new file mode 100644
index 0000000..3af392b
--- /dev/null
+++ b/hw/net/csky_mac.c
@@ -0,0 +1,558 @@
+/*
+ * CSKY Ethernet interface emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "net/net.h"
+#include <zlib.h>
+#include "qemu/log.h"
+#include "cpu.h"
+#include "hw/csky/cskydev.h"
+
+#define NUM_BD 128
+
+#define TYPE_CSKY_MAC "csky_mac"
+#define CSKY_MAC(obj) OBJECT_CHECK(csky_mac_state, (obj), TYPE_CSKY_MAC)
+
+/* buffer descriptor*/
+typedef struct {
+    uint32_t status;
+    uint32_t buffer_addr;
+} csky_mac_bd;
+
+typedef struct {
+    SysBusDevice parent_obj;
+
+    MemoryRegion mmio;
+    NICState *nic;
+    NICConf conf;
+    qemu_irq irq;
+    uint32_t moder;
+    uint32_t int_source;
+    uint32_t int_mask;
+    uint32_t ipgt;
+    uint32_t ipgr1;
+    uint32_t ipgr2;
+    uint32_t packetlen;
+    uint32_t collconf;
+    uint32_t tx_bd_num;
+    uint32_t ctrlmoder;
+    uint32_t mii_moder;
+    uint32_t mii_command;
+    uint32_t mii_address;
+    uint32_t mii_tx_data;
+    uint32_t mii_rx_data;
+    uint32_t mii_status;
+    uint32_t eth_hash0_adr;
+    uint32_t eth_hash1_adr;
+    uint32_t eth_tx_ctrl;
+    csky_mac_bd bd_buffer[NUM_BD];
+    int32_t next_rx;
+} csky_mac_state;
+
+static const VMStateDescription vmstate_csky_mac_bd = {
+    .name = "csky_mac_bd",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields      = (VMStateField []) {
+        VMSTATE_UINT32(status, csky_mac_bd),
+        VMSTATE_UINT32(status, csky_mac_bd),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static const VMStateDescription vmstate_csky_mac = {
+    .name = "csky_mac",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields      = (VMStateField []) {
+        VMSTATE_UINT32(moder, csky_mac_state),
+        VMSTATE_UINT32(int_source, csky_mac_state),
+        VMSTATE_UINT32(int_mask, csky_mac_state),
+        VMSTATE_UINT32(ipgt, csky_mac_state),
+        VMSTATE_UINT32(ipgr1, csky_mac_state),
+        VMSTATE_UINT32(ipgr2, csky_mac_state),
+        VMSTATE_UINT32(packetlen, csky_mac_state),
+        VMSTATE_UINT32(collconf, csky_mac_state),
+        VMSTATE_UINT32(tx_bd_num, csky_mac_state),
+        VMSTATE_UINT32(ctrlmoder, csky_mac_state),
+        VMSTATE_UINT32(mii_moder, csky_mac_state),
+        VMSTATE_UINT32(mii_command, csky_mac_state),
+        VMSTATE_UINT32(mii_address, csky_mac_state),
+        VMSTATE_UINT32(mii_tx_data, csky_mac_state),
+        VMSTATE_UINT32(mii_rx_data, csky_mac_state),
+        VMSTATE_UINT32(mii_status, csky_mac_state),
+        VMSTATE_UINT32(eth_hash0_adr, csky_mac_state),
+        VMSTATE_UINT32(eth_hash1_adr, csky_mac_state),
+        VMSTATE_UINT32(eth_tx_ctrl, csky_mac_state),
+        VMSTATE_STRUCT_ARRAY(bd_buffer, csky_mac_state, NUM_BD, 1,
+                             vmstate_csky_mac_bd, csky_mac_bd),
+        VMSTATE_INT32(next_rx, csky_mac_state),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+/* moder register */
+#define MODER_RESMALL   0x10000
+#define MODER_PAD       0x8000
+#define MODER_HUGEN     0X4000
+#define MODER_CRCEN     0X2000
+#define MODER_DLYCRCEN  0x1000
+#define MODER_LOOPBACK  0x80
+#define MODER_PRO       0x10
+#define MODER_TXEN      0X2
+#define MODER_RXEN      0X1
+
+#define INT_SOURCE_BER  0X80
+#define INT_SOURCE_RXC  0X40
+#define INT_SOURCE_TXC  0X20
+#define INT_SOURCE_BUSY 0X10
+#define INT_SOURCE_RXE  0x8
+#define INT_SOURCE_RXB  0x4
+#define INT_SOURCE_TXE  0X2
+#define INT_SOURCE_TXB  0X1
+
+#define CTRL_MODER_TXFLOW 0X4
+#define CTRL_MODER_RXFLOW 0X2
+#define CTRL_MODER_PASSALL 0X1
+
+/* receive buffer descriptor */
+#define RXBD_EMPTY   (1 << 15)
+#define RXBD_IRQ     (1 << 14)
+#define RXBD_WR      (1 << 13)
+#define RXBD_CF      (1 << 8)
+#define RXBD_MISS    (1 << 7)
+#define RXBD_DN      (1 << 4)
+#define RXBD_TL      (1 << 3)
+#define RXBD_SF      (1 << 2)
+#define RXBD_CRC     (1 << 1)
+
+/* transmit buffer descriptor */
+#define TXBD_RD      (1 << 15)
+#define TXBD_IRQ     (1 << 14)
+#define TXBD_WR      (1 << 13)
+#define TXBD_PAD     (1 << 12)
+#define TXBD_CRC     (1 << 11)
+
+static ssize_t csky_mac_receive(NetClientState *nc, const uint8_t *buf,
+                                size_t size);
+
+static void csky_mac_update(csky_mac_state *s)
+{
+    int level;
+
+    level = ((s->int_source & s->int_mask) != 0);
+    qemu_set_irq(s->irq, level);
+}
+
+static uint64_t csky_mac_read(void *opaque, hwaddr offset, unsigned size)
+{
+    csky_mac_state *s = (csky_mac_state *)opaque;
+    uint64_t ret;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_mac_read: 0x%x must word align read\n",
+                      (int)offset);
+    }
+
+    switch (offset) {
+    case 0x0:
+        ret = s->moder;
+        break;
+    case 0x4:
+        ret = s->int_source;
+        break;
+    case 0x8:
+        ret = s->int_mask;
+        break;
+    case 0xc:
+        ret = s->ipgt;
+        break;
+    case 0x10:
+        ret = s->ipgr1;
+        break;
+    case 0x14:
+        ret = s->ipgr2;
+        break;
+    case 0x18:
+        ret = s->packetlen;
+        break;
+    case 0x1c:
+        ret = s->collconf;
+        break;
+    case 0x20:
+        ret = s->tx_bd_num;
+        break;
+    case 0x24:
+        ret = s->ctrlmoder;
+        break;
+    case 0x28:
+        ret = s->mii_moder;
+        break;
+    case 0x2c:
+        ret = s->mii_command;
+        break;
+    case 0x30:
+        ret = s->mii_address;
+        break;
+    case 0x34:
+        ret = s->mii_tx_data;
+        break;
+    case 0x38:
+        ret = s->mii_tx_data;
+        break;
+    case 0x3c:
+        ret = s->mii_status;
+        break;
+    case 0x40:
+        ret = (s->conf.macaddr.a[2] << 24) | (s->conf.macaddr.a[3] << 16)
+            | (s->conf.macaddr.a[4] << 8) | s->conf.macaddr.a[5];
+        break;
+    case 0x44:
+        ret = (s->conf.macaddr.a[0] << 8) | (s->conf.macaddr.a[1]);
+        break;
+    case 0x48:
+        ret = s->eth_hash0_adr;
+        break;
+    case 0x4c:
+        ret = s->eth_hash1_adr;
+        break;
+    case 0x50:
+        ret = s->eth_tx_ctrl;
+        break;
+    default:
+        if ((offset < 0x1400) || (offset > 0x1800)) {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "csky_mac_read: Bad offset %x\n", (int)offset);
+            ret = 0;
+        } else {
+            /* read bd */
+            int index = (offset - 0x1400) / 0x8;
+            int addend = (offset - 0x1400) % 0x8;
+            if (addend / 0x4 == 0) {
+                ret = s->bd_buffer[index].status;
+            } else {
+                ret = s->bd_buffer[index].buffer_addr;
+            }
+        }
+        break;
+    }
+
+    return ret;
+}
+
+static inline void csky_mac_release_packet(csky_mac_state *s, int index)
+{
+    int status;
+    int size;
+    uint8_t *p;
+    uint8_t frame[2032];
+    NetClientState *nc = qemu_get_queue(s->nic);
+
+    p = frame;
+
+    status = s->bd_buffer[index].status;
+    size = status >> 16;
+
+    if (size < 4) { /* do not send this packet */
+        s->bd_buffer[index].status &= ~TXBD_RD;
+        return;
+    }
+
+    cpu_physical_memory_read(s->bd_buffer[index].buffer_addr, p, size);
+    p += size;
+
+    if (status & TXBD_PAD) {
+        /* Add pad */
+        int MinFL = 60;
+        if (size < MinFL) {
+            memset(p, 0, MinFL - size);
+            size  = MinFL;
+        }
+    }
+
+    if (s->moder & MODER_LOOPBACK) {
+        s->bd_buffer[index].status &= ~TXBD_RD;
+
+        if (status & TXBD_IRQ) {
+            s->int_source |= INT_SOURCE_TXB;
+            csky_mac_update(s);
+        }
+
+        csky_mac_receive(nc, frame, size);
+        return;
+    }
+
+    qemu_send_packet(nc, frame, size);
+
+    s->bd_buffer[index].status &= ~TXBD_RD;
+
+    if (status & TXBD_IRQ) {
+        s->int_source |= INT_SOURCE_TXB;
+        csky_mac_update(s);
+    }
+}
+
+static void csky_mac_write(void *opaque, hwaddr offset,
+                           uint64_t value, unsigned size)
+{
+    csky_mac_state *s = (csky_mac_state *)opaque;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_mac_write: 0x%x must word align write\n",
+                      (int)offset);
+    }
+
+    switch (offset) {
+    case 0x0:
+        if (!(s->moder & MODER_RXEN) && (value & MODER_RXEN)) {
+            s->next_rx = s->tx_bd_num;
+        }
+        s->moder = value;
+        return;
+    case 0x4:
+        s->int_source &= ~value;
+        csky_mac_update(s);
+        return;
+    case 0x8:
+        s->int_mask = value;
+        return;
+    case 0xc:
+        s->ipgt = value;
+        return;
+    case 0x10:
+        s->ipgr1 = value;
+        return;
+    case 0x14:
+        s->ipgr2 = value;
+        return;
+    case 0x18:
+        s->packetlen = value;
+        return;
+    case 0x1c:
+        s->collconf = value;
+        return;
+    case 0x20:
+        s->tx_bd_num = value;
+        return;
+    case 0x24:
+        s->ctrlmoder = value;
+        return;
+    case 0x28:
+        s->mii_moder = value;
+        return;
+    case 0x2c:
+        s->mii_command = value;
+        return;
+    case 0x30:
+        s->mii_address = value;
+        return;
+    case 0x34:
+        s->mii_tx_data = value;
+        return;
+    case 0x38: /* mii_rx_data register read only */
+        return;
+    case 0x3c: /* mii_status register read only */
+        return;
+    case 0x40:
+        s->conf.macaddr.a[2] = value >> 24;
+        s->conf.macaddr.a[3] = value >> 16;
+        s->conf.macaddr.a[4] = value >> 8;
+        s->conf.macaddr.a[5] = value;
+        return;
+    case 0x44:
+        s->conf.macaddr.a[0] = value >> 8;
+        s->conf.macaddr.a[1] = value;
+        return;
+    case 0x48:
+        s->eth_hash0_adr = value;
+        return;
+    case 0x4c:
+        s->eth_hash1_adr = value;
+        return;
+    case 0x50:
+        s->eth_tx_ctrl = value;
+        return;
+    default:
+        if ((offset < 0x1400) || (offset > 0x1800)) {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "csky_mac_write: Bad offset %x\n", (int)offset);
+            return;
+        } else {
+            /* write bd */
+            int index, addend;
+
+            index = (offset - 0x1400) / 0x8;
+            addend = (offset - 0x1400) % 0x8;
+
+            if (addend / 0x4) {
+                s->bd_buffer[index].buffer_addr = value;
+            } else {
+                s->bd_buffer[index].status = value;
+                if ((index < s->tx_bd_num) && (value & TXBD_RD)) {
+                    /* send a packet */
+                    csky_mac_release_packet(s, index);
+                }
+            }
+            return;
+        }
+    }
+}
+
+static const MemoryRegionOps csky_mac_ops = {
+    .read = csky_mac_read,
+    .write = csky_mac_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+/*
+static int csky_mac_can_receive(NetClientState *nc)
+{
+    csky_mac_state *s = qemu_get_nic_opaque(nc);
+
+    if ((s->moder & MODER_RXEN) &&
+       (s->tx_bd_num != 128) &&
+       (s->bd_buffer[s->next_rx].status & RXBD_EMPTY)) {
+        return 1;
+    }
+    return 0;
+}
+*/
+
+static ssize_t csky_mac_receive(NetClientState *nc, const uint8_t *buf,
+                                size_t size)
+{
+    csky_mac_state *s = qemu_get_nic_opaque(nc);
+
+    if (!((s->moder & MODER_RXEN) &&
+       (s->tx_bd_num != 128) &&
+       (s->bd_buffer[s->next_rx].status & RXBD_EMPTY))) {
+        return -1;
+    }
+
+    s->bd_buffer[s->next_rx].status &= ~RXBD_EMPTY;
+
+    cpu_physical_memory_write(s->bd_buffer[s->next_rx].buffer_addr, buf, size);
+
+    s->bd_buffer[s->next_rx].status |= ((size + 4) << 16);
+
+    if (s->bd_buffer[s->next_rx].status & RXBD_IRQ) {
+        s->int_source |= INT_SOURCE_RXB;
+        csky_mac_update(s);
+    }
+
+    if (s->bd_buffer[s->next_rx].status & RXBD_WR) {
+        s->next_rx = s->tx_bd_num;
+    } else {
+        s->next_rx++;
+    }
+
+    return size;
+}
+
+static void csky_mac_cleanup(NetClientState *nc)
+{
+    csky_mac_state *s = qemu_get_nic_opaque(nc);
+
+    s->nic = NULL;
+}
+
+static NetClientInfo net_csky_mac_info = {
+    .type = NET_CLIENT_DRIVER_NIC,
+    .size = sizeof(NICState),
+/*    .can_receive = csky_mac_can_receive,*/
+    .receive = csky_mac_receive,
+    .cleanup = csky_mac_cleanup,
+};
+
+static inline void csky_mac_reset(csky_mac_state *s)
+{
+    s->moder = 0xa000;
+    s->ipgt = 0x12;
+    s->ipgr1 = 0xc;
+    s->ipgr2 = 0x12;
+    s->packetlen = 0x400600;
+    s->collconf = 0xf003f;
+    s->tx_bd_num = 0x40;
+    s->mii_moder = 0x64;
+    s->next_rx = s->tx_bd_num;
+}
+
+static int csky_mac_init(SysBusDevice *sbd)
+{
+    DeviceState *dev = DEVICE(sbd);
+    csky_mac_state *s = CSKY_MAC(dev);
+
+    memory_region_init_io(&s->mmio, OBJECT(s), &csky_mac_ops, s,
+                          TYPE_CSKY_MAC, 0x2000);
+    sysbus_init_mmio(sbd, &s->mmio);
+    sysbus_init_irq(sbd, &s->irq);
+    qemu_macaddr_default_if_unset(&s->conf.macaddr);
+
+    s->nic = qemu_new_nic(&net_csky_mac_info, &s->conf,
+                          object_get_typename(OBJECT(dev)), dev->id, s);
+    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);
+
+    csky_mac_reset(s);
+    return 0;
+}
+
+static Property csky_mac_properties[] = {
+    DEFINE_NIC_PROPERTIES(csky_mac_state, conf),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void csky_mac_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
+
+    k->init = csky_mac_init;
+    dc->props = csky_mac_properties;
+    dc->vmsd = &vmstate_csky_mac;
+}
+
+static const TypeInfo csky_mac_info = {
+    .name          = TYPE_CSKY_MAC,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_mac_state),
+    .class_init    = csky_mac_class_init,
+};
+
+static void csky_mac_register_types(void)
+{
+    type_register_static(&csky_mac_info);
+}
+
+
+void csky_mac_create(NICInfo *nd, uint32_t base, qemu_irq irq)
+{
+    DeviceState *dev;
+    SysBusDevice *s;
+
+    qemu_check_nic_model(nd, "csky_mac");
+    dev = qdev_create(NULL, "csky_mac");
+    qdev_set_nic_properties(dev, nd);
+    qdev_init_nofail(dev);
+    s = SYS_BUS_DEVICE(dev);
+    sysbus_mmio_map(s, 0, base);
+    sysbus_connect_irq(s, 0, irq);
+}
+
+type_init(csky_mac_register_types)
diff --git a/hw/net/csky_mac_v2.c b/hw/net/csky_mac_v2.c
new file mode 100644
index 0000000..07405c1
--- /dev/null
+++ b/hw/net/csky_mac_v2.c
@@ -0,0 +1,949 @@
+/*
+ * CSKY GMAC IP emulation.
+ *
+ * Author: wanghb
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "net/net.h"
+#include <zlib.h>
+#include "qemu/log.h"
+#include "cpu.h"
+#include "hw/csky/cskydev.h"
+#include "hw/ptimer.h"
+#include "sysemu/sysemu.h"
+
+#define CSKY_BUS_WIDTH                  32    /* 32 bit ahb bus */
+
+#define TYPE_CSKY_MAC_V2 "csky_mac_v2"
+#define CSKY_MAC_V2(obj) \
+    OBJECT_CHECK(csky_mac_v2_state, (obj), TYPE_CSKY_MAC_V2)
+#define CSKY_MAC_V2_FREQ                40000000ll
+
+/* buffer descriptor*/
+typedef struct {
+    uint32_t status1;
+    uint32_t status2;
+    uint32_t buffer1;
+    uint32_t buffer2;
+} csky_mac_v2_bd;
+
+typedef struct {
+    SysBusDevice parent_obj;
+
+    MemoryRegion mmio;
+    NICState *nic;
+    NICConf conf;
+    qemu_irq irq;
+    ptimer_state *timer;
+    /* MAC Reg */
+    uint32_t config;
+    uint32_t frame_filter;
+    uint32_t hash_tab_high;
+    uint32_t hash_tab_low;
+    uint32_t mii_addr;
+    uint32_t mii_data;
+    uint32_t debug;
+    uint32_t int_status;
+    uint32_t int_mask;
+    uint32_t watchdog_timeout;
+    /* MAC MDA Reg */
+    uint32_t bus_mode;
+    uint32_t tx_poll_demand;
+    uint32_t rx_poll_demand;
+    uint32_t rx_des_list_addr;
+    uint32_t tx_des_list_addr;
+    uint32_t status;
+    uint32_t operation_mode;
+    uint32_t int_en;
+    uint32_t missed_frame_buf_flow_ctrl;
+    uint32_t rx_int_watchdog_timer;
+    uint32_t ahb_axi_status;
+    uint32_t cur_tx_des_addr;
+    uint32_t cur_rx_des_addr;
+    uint32_t cur_tx_buf_addr;
+    uint32_t cur_rx_buf_addr;
+} csky_mac_v2_state;
+
+static const VMStateDescription vmstate_csky_mac_v2 = {
+    .name = "csky_mac_v2",
+    .version_id = 2,
+    .minimum_version_id = 2,
+    .fields      = (VMStateField []) {
+        VMSTATE_UINT32(config, csky_mac_v2_state),
+        VMSTATE_UINT32(frame_filter, csky_mac_v2_state),
+        VMSTATE_UINT32(hash_tab_high, csky_mac_v2_state),
+        VMSTATE_UINT32(hash_tab_low, csky_mac_v2_state),
+        VMSTATE_UINT32(mii_addr, csky_mac_v2_state),
+        VMSTATE_UINT32(mii_data, csky_mac_v2_state),
+        VMSTATE_UINT32(debug, csky_mac_v2_state),
+        VMSTATE_UINT32(int_status, csky_mac_v2_state),
+        VMSTATE_UINT32(int_mask, csky_mac_v2_state),
+        VMSTATE_UINT32(watchdog_timeout, csky_mac_v2_state),
+        VMSTATE_UINT32(bus_mode, csky_mac_v2_state),
+        VMSTATE_UINT32(tx_poll_demand, csky_mac_v2_state),
+        VMSTATE_UINT32(rx_poll_demand, csky_mac_v2_state),
+        VMSTATE_UINT32(rx_des_list_addr, csky_mac_v2_state),
+        VMSTATE_UINT32(tx_des_list_addr, csky_mac_v2_state),
+        VMSTATE_UINT32(status, csky_mac_v2_state),
+        VMSTATE_UINT32(operation_mode, csky_mac_v2_state),
+        VMSTATE_UINT32(int_en, csky_mac_v2_state),
+        VMSTATE_UINT32(missed_frame_buf_flow_ctrl, csky_mac_v2_state),
+        VMSTATE_UINT32(rx_int_watchdog_timer, csky_mac_v2_state),
+        VMSTATE_UINT32(ahb_axi_status, csky_mac_v2_state),
+        VMSTATE_UINT32(cur_tx_des_addr, csky_mac_v2_state),
+        VMSTATE_UINT32(cur_rx_des_addr, csky_mac_v2_state),
+        VMSTATE_UINT32(cur_tx_buf_addr, csky_mac_v2_state),
+        VMSTATE_UINT32(cur_rx_buf_addr, csky_mac_v2_state),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+/* configuration register */
+#define CONFIG_2kPACK                   (0x1 << 27)
+#define CONFIG_CRC_STRIP                (0x1 << 25)
+#define CONFIG_JUMBO_FRAME              (0x1 << 20)
+#define CONFIG_LOOPBACK                 (0x1 << 12)
+#define CONFIG_COE                      (0x1 << 10)  /* checksum offload */
+#define CONFIG_PAD_CRC_STRIP            (0x1 << 07)
+#define CONFIG_TXEN                     (0x1 << 03)
+#define CONFIG_RXEN                     (0x1 << 02)
+
+/* frame filter reg */
+#define FILTER_REC_ALL                  (0x1 << 31)
+#define FILTER_PROMISCUOUS              (0x1 << 00)
+#define FILTER_BROADCAST_DIS            (0x1 << 05)
+#define FILTER_MULTICAST_EN             (0x1 << 04)
+
+/* mii addr reg */
+#define MII_PHY_ADDR                    (0x1f << 11)
+#define MII_REG_NUM                     (0x1f << 6)
+#define MII_WRITE                       (0x1 << 01)
+#define MII_BUSY                        (0x1 << 00)
+
+/* debug reg */
+#define DEBUG_TXFIFO_FULL               (0x1 << 25)
+#define DEBUG_TXFIFO_NOT_EMPTY          (0x1 << 24)
+#define DEBUG_RXFIFO_STATUS             (0x3 << 8)
+#define DEBUG_RXFIFO_FULL               (0x3 << 8)
+
+/* interrupt status reg */
+#define INT_STATUS_MII_CHANGE           (0x1 << 0)
+
+/* mac address high reg */
+#define MACADDR_ENABLE                  (0x1 << 31)
+
+/* bus mode reg */
+#define BUSMODE_DSL                     (0x1f << 2) /* descriptor skip length */
+#define BUSMODE_RESET                   (0x1 << 00)
+
+/* status reg */
+#define STATUS_LINK_CHANGE              (0x1 << 26)
+#define STATUS_TX_STATE_STOPPED         (0x0 << 20)
+#define STATUS_TX_STATE_RUNNING         (0x3 << 20)
+#define STATUS_TX_STATE_SUSPEND         (0x6 << 20)
+#define STATUS_RX_STATE_STOPPED         (0x0 << 17)
+#define STATUS_RX_STATE_RUNNING         (0x3 << 17)
+#define STATUS_RX_STATE_SUSPEND         (0x4 << 17)
+#define STATUS_NORMAL_INT               (0x1 << 16)
+#define STATUS_ABNORMAL_INT             (0x1 << 15)
+#define STATUS_RX_BUF_UNAVAILABLE       (0x1 << 07)
+#define STATUS_RX_INT                   (0x1 << 06)
+#define STATUS_TX_UNDERFLOW             (0x1 << 05)
+#define STATUS_TX_BUF_UNAVAILABLE       (0x1 << 02)
+#define STATUS_TX_INT                   (0x1 << 00)
+
+/* operation mode reg */
+#define OPMODE_START_TX                 (0x1 << 13)
+#define OPMODE_FW_ERR_FRAME             (0x1 << 07)
+#define OPMODE_FW_SMALL_FRAME           (0x1 << 06)
+#define OPMODE_START_RX                 (0x1 << 01)
+
+/* interrupt enable reg */
+#define INT_NORMAL_EN                   (0x1 << 16)
+#define INT_ABNORMAL_EN                 (0x1 << 15)
+#define INT_RX_BUF_UNAVAILABLE_EN       (0x1 << 07)
+#define INT_RX_EN                       (0x1 << 06)
+#define INT_TX_BUF_UNAVAILABLE_EN       (0x1 << 02)
+#define INT_TX_EN                       (0x1 << 00)
+
+/* transmit descriptor 1 */
+#define TXBD_OWN                        (0x1 << 31)
+#define TXBD_IPHEADER_ERR               (0x1 << 16)
+#define TXBD_ERR_SUMMARY                (0x1 << 15)
+#define TXBD_CHECKSUM_ERR               (0x1 << 12)
+#define TXBD_UNDERFLOW_ERR              (0x1 << 01)
+
+/* transmit descriptor 2 */
+#define TXBD_IC              (0x1 << 31)   /* interrupt on completion */
+#define TXBD_LS              (0x1 << 30)   /* last segment */
+#define TXBD_FS              (0x1 << 29)   /* first segment */
+#define TXBD_CIC             (0x3 << 27)   /* checksum insertion control */
+#define TXBD_CRC_DIS         (0x1 << 26)
+#define TXBD_TER             (0x1 << 25)   /* transmit end of ring */
+#define TXBD_TCH             (0x1 << 24)   /* second addr chained */
+#define TXBD_DP              (0x1 << 23)   /* disable padding */
+#define TXBD_BUF2_SIZE       (0x7ff << 11) /* buf2 size */
+#define TXBD_BUF1_SIZE       (0x7ff << 0)  /* buf1 size */
+
+/* receive descriptor 1 */
+#define RXBD_OWN             (0x1 << 31)
+#define RXBD_DAFF            (0x1 << 30) /* dest addr filter fail */
+#define RXBD_ES              (0x1 << 15) /* error summary */
+#define RXBD_DE              (0x1 << 14) /* descriptor error */
+#define RXBD_LE              (0x1 << 12) /* length error */
+#define RXBD_FS              (0x1 << 9)  /* first segment */
+#define RXBD_LS              (0x1 << 8)  /* last segment */
+#define RXBD_CE_GF           (0x1 << 7)  /* IPC checksum error or giant frame */
+#define RXBD_FT              (0x1 << 5)  /* frame type */
+#define RXBD_ERR             (0x1 << 3)  /* receive error */
+#define RXBD_DBE             (0x1 << 2)  /* dribble bit error */
+#define RXBD_CRC_ERR         (0x1 << 1)
+#define RXBD_MAC_ADDR_ERR    (0x1 << 0)  /* rx mac addr or payload
+                                            checksum error */
+
+/*receive descriptor 2 */
+#define RXBD_IC_DIS       (0x1 << 31)   /* disable interrupt on completion */
+#define RXBD_RER          (0x1 << 25)   /* receive end of ring */
+#define RXBD_RCH          (0x1 << 24)   /* second addr chained */
+#define RXBD_BUF2_SIZE    (0x7ff << 11) /* buf2 size */
+#define RXBD_BUF1_SIZE    (0x7ff << 0)  /* buf1 size */
+
+static ssize_t csky_mac_v2_receive(NetClientState *s, const uint8_t *buf,
+                                   size_t size);
+
+static inline void csky_mac_v2_reset(csky_mac_v2_state *s);
+
+
+/**************************************************************************
+ * Description:
+ *     Update the interrupt flag according the MAC state and
+ *     give the flag to interrupt controller.
+ * Argument:
+ *     s  --- the pointer to the MAC state
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_mac_v2_update(csky_mac_v2_state *s)
+{
+    int level;
+
+    level = !!(s->status & s->int_en);
+    qemu_set_irq(s->irq, level);
+}
+
+/**************************************************************************
+ * Description:
+ *     Read a MAC register according to the offset.
+ * Argument:
+ *     opaque  --- the pointer to the MAC state
+ *     offset  --- the offset from the base address
+ * Return:
+ *     the data which is read from the corrsponding register
+ **************************************************************************/
+static uint64_t csky_mac_v2_read(void *opaque, hwaddr offset, unsigned size)
+{
+    csky_mac_v2_state *s = (csky_mac_v2_state *)opaque;
+    uint64_t ret = 0;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_mac_v2_read: 0x%x must word align read\n",
+                      (int)offset);
+    }
+
+    switch (offset) {
+        /* MAC Reg */
+    case 0x0:
+        ret = s->config & ~CONFIG_COE;
+        break;
+    case 0x4:
+        ret = s->frame_filter;
+        break;
+    case 0x8:
+        ret = s->hash_tab_high;
+        break;
+    case 0xc:
+        ret = s->hash_tab_low;
+        break;
+    case 0x10:
+        ret = s->mii_addr;
+        break;
+    case 0x14:
+        ret = s->mii_data;
+        break;
+    case 0x20:
+        ret = 0x1037;
+        break;
+    case 0x24:
+        ret = s->debug;
+        break;
+    case 0x38:
+        ret = s->int_status;
+        break;
+    case 0x3c:
+        ret = s->int_mask;
+        break;
+    case 0x40:
+        ret = (MACADDR_ENABLE | s->conf.macaddr.a[0] << 8) |
+            (s->conf.macaddr.a[1]);
+        break;
+    case 0x44:
+        ret = (s->conf.macaddr.a[2] << 24) | (s->conf.macaddr.a[3] << 16)
+            | (s->conf.macaddr.a[4] << 8) | s->conf.macaddr.a[5];
+        break;
+    case 0xdc:
+        ret = s->watchdog_timeout;
+        qemu_log("watchdog timeout 0x%lx\n",ret);
+        break;
+        /* MAC DMA Reg */
+    case 0x1000:
+        ret = s->bus_mode;
+        break;
+    case 0x1004:
+        ret = s->tx_poll_demand;
+        break;
+    case 0x1008:
+        ret = s->rx_poll_demand;
+        break;
+    case 0x100c:
+        ret = s->rx_des_list_addr;
+        break;
+    case 0x1010:
+        ret = s->tx_des_list_addr;
+        break;
+    case 0x1014:
+        ret = s->status;
+        break;
+    case 0x1018:
+        ret = s->operation_mode;
+        break;
+    case 0x101c:
+        ret = s->int_en;
+        break;
+    case 0x1020:   /* missed_frame_buf_flow_ctrl register
+                      is cleared when it is read */
+        ret = s->missed_frame_buf_flow_ctrl;
+        s->missed_frame_buf_flow_ctrl = 0x0;
+        break;
+    case 0x1024:
+        ret = s->rx_int_watchdog_timer;
+        break;
+    case 0x102c:
+        ret = s->ahb_axi_status;
+        break;
+    case 0x1048:
+        ret = s->cur_tx_des_addr;
+        break;
+    case 0x104c:
+        ret = s->cur_rx_des_addr;
+        break;
+    case 0x1050:
+        ret = s->cur_tx_buf_addr;
+        break;
+    case 0x1054:
+        ret = s->cur_tx_buf_addr;
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_mac_v2_read: Bad offset 0x%x\n", (int)offset);
+        ret = 0;
+        break;
+    }
+
+    return ret;
+}
+
+/**************************************************************************
+ * Description:
+ *     Send a frame according to the tx bd.
+ * Argument:
+ *     s  --- the pointer to the MAC state
+ * Return:
+ *     void
+ **************************************************************************/
+
+static void csky_mac_v2_release_packet(csky_mac_v2_state *s)
+{
+    int size;
+    uint8_t *p;
+    uint8_t frame[1518];
+    csky_mac_v2_bd cur_tx_bd;
+    int end_of_ring;
+    NetClientState *nc = qemu_get_queue(s->nic);
+    int en_int;
+
+    p = frame;
+    int len=0;
+    while (1) {
+
+        /* acquire current tx bd, save the important control bits */
+        cpu_physical_memory_read(s->cur_tx_des_addr, (uint8_t *)&cur_tx_bd, 16);
+        en_int           = cur_tx_bd.status2 & TXBD_IC;
+        end_of_ring      = cur_tx_bd.status2 & TXBD_TER;
+        size             = cur_tx_bd.status2 & TXBD_BUF1_SIZE;
+
+        assert(size <= 1518 && len <= 1518);
+        if ((cur_tx_bd.status1 & TXBD_OWN) == 0) {
+            s->status |= STATUS_TX_BUF_UNAVAILABLE | STATUS_NORMAL_INT;
+            s->status |= STATUS_TX_STATE_SUSPEND;
+            break;
+        }
+        cpu_physical_memory_read(cur_tx_bd.buffer1, p, size);
+        p += size;
+        len +=size;
+        if (cur_tx_bd.status2 & TXBD_LS) {
+            qemu_send_packet(nc, frame, len);
+            cur_tx_bd.status1 &= ~TXBD_OWN;
+            cpu_physical_memory_write(s->cur_tx_des_addr, (uint8_t *)&cur_tx_bd, 16);
+            if (en_int) {
+                s->status |= STATUS_TX_INT | STATUS_NORMAL_INT;
+                csky_mac_v2_update(s);
+            }
+            p = frame;
+            len = 0;
+        }
+        else {
+            cur_tx_bd.status1 &= ~TXBD_OWN;
+            cpu_physical_memory_write(s->cur_tx_des_addr, (uint8_t *)&cur_tx_bd, 16);
+        }
+        if (end_of_ring) {
+            s->cur_tx_des_addr = s->tx_des_list_addr;
+        } else {
+            s->cur_tx_des_addr += (s->bus_mode & BUSMODE_DSL) + 16;
+        }
+
+    }
+
+    csky_mac_v2_update(s);
+}
+
+
+/**************************************************************************
+ * Description:
+ *     Read the PHY register.
+ * Argument:
+ *     phy_addr --- the PHY address (0 to 31), for this case, is 1
+ *     phy_reg  --- the PHY register number.
+ * Return:
+ *     the data being read(always 0)
+ **************************************************************************/
+static uint32_t csky_phy_read(uint32_t phy_addr, uint32_t phy_reg)
+{
+    if (phy_addr != 0x1) {
+        return 0xffff;
+    }
+    switch (phy_reg) {
+    case 0:
+        return 0x2100;
+    case 1:
+        return 0x786d;
+    case 3:
+        return 0x8201;
+    case 4:
+        return 0x0100;
+    case 5:
+        return 0x0100;
+    case 17:
+        return 0x0080;
+    case 19:
+        return 0x0023;
+    case 25:
+        return 0x0101;
+    default:
+        return 0x0;
+    }
+
+}
+
+/**************************************************************************
+ * Description:
+ *     Write to the PHY register.
+ * Argument:
+ *     phy_addr --- the PHY address (0 to 31), for this case, is 1
+ *     phy_reg  --- the PHY register number.
+ *     value    --- the value which will be written to PHY
+ * Return:
+ *     void
+ **************************************************************************/
+static inline void csky_phy_write(uint32_t phy_addr, uint32_t phy_reg,
+                                  uint32_t value)
+{
+    return;
+}
+
+/**************************************************************************
+ * Description:
+ *     Write to the MAC register.
+ * Argument:
+ *     opaque --- the pointer to to MAC state
+ *     offset --- the offset from the base address
+ *     value  --- the value which will be written to the register
+ * Return:
+ *     void
+ **************************************************************************/
+static void csky_mac_v2_write(void *opaque, hwaddr offset,
+                               uint64_t value, unsigned size)
+{
+    csky_mac_v2_state *s = (csky_mac_v2_state *)opaque;
+    csky_mac_v2_bd cur_bd;
+    uint8_t *p_cur_bd = (uint8_t *)&cur_bd;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_mac_v2_write: 0x%x must word align write\n",
+                      (int)offset);
+    }
+    switch (offset) {
+        /* MAC Reg */
+    case 0x0:
+        if (!(s->config & CONFIG_RXEN) && (value & CONFIG_RXEN)) {
+            s->cur_rx_des_addr = s->rx_des_list_addr;
+        }
+        if (!(s->config & CONFIG_TXEN) && (value & CONFIG_TXEN)) {
+            s->cur_tx_des_addr = s->tx_des_list_addr;
+        }
+        s->config = value;
+        return;
+    case 0x4:
+        s->frame_filter = value;
+        return;
+    case 0x8:
+        s->hash_tab_high = value;
+        return;
+    case 0xc:
+        s->hash_tab_low = value;
+        return;
+    case 0x10:
+        s->mii_addr = value;
+        /* try to write phy reg */
+        if (s->mii_addr & MII_WRITE) {
+            csky_phy_write((s->mii_addr & MII_PHY_ADDR) >> 11,
+                           (s->mii_addr & MII_REG_NUM) >> 6, s->mii_data);
+        /* try to read phy reg, update the mii_data value */
+        } else {
+            s->mii_data = csky_phy_read((s->mii_addr & MII_PHY_ADDR) >> 11,
+                                        (s->mii_addr & MII_REG_NUM) >> 6);
+        }
+        s->mii_addr &= ~MII_BUSY;   /* MII returns to idle state after
+                                       read/write process. */
+        return;
+    case 0x14:
+        s->mii_data = value;
+        return;
+    case 0x24: /* debug register read only */
+        return;
+    case 0x38: /* int_status register read only */
+        return;
+    case 0x3c: /* the corresponding interrupt source is
+                  not realized in hardware configuration. */
+        s->int_mask = value;
+        return;
+    case 0x40:
+        s->conf.macaddr.a[2] = value >> 24;
+        s->conf.macaddr.a[3] = value >> 16;
+        s->conf.macaddr.a[4] = value >> 8;
+        s->conf.macaddr.a[5] = value;
+        return;
+    case 0x44:
+        s->conf.macaddr.a[0] = value >> 8;
+        s->conf.macaddr.a[1] = value;
+        return;
+    case 0xdc:
+        s->watchdog_timeout = value;
+        return;
+    case 0x100:
+        return;
+    case 0x10c:
+        return;
+    case 0x110:
+        return;
+    case 0x1000:
+        s->bus_mode = value;
+        if (s->bus_mode & BUSMODE_RESET) {
+            csky_mac_v2_reset(s);
+        }
+        return;
+    case 0x1004:  /* tx_poll_demand register read only */
+        if ( s->operation_mode & OPMODE_START_TX && s->config & CONFIG_TXEN){
+             s->status |= STATUS_TX_STATE_RUNNING;
+             csky_mac_v2_release_packet(s);
+        }
+        return;
+    case 0x1008:  /* rx_poll_demand register read only */
+        cpu_physical_memory_read(s->cur_rx_des_addr, p_cur_bd, 16);
+        if (cur_bd.status1 & RXBD_OWN) {
+            s->status &= ~STATUS_RX_BUF_UNAVAILABLE;
+            if (!(s->status & STATUS_TX_UNDERFLOW)) {
+                s->status &= ~STATUS_ABNORMAL_INT;
+            }
+        } else {
+            s->status |= STATUS_RX_BUF_UNAVAILABLE | STATUS_ABNORMAL_INT;
+        }
+        csky_mac_v2_update(s);
+        return;
+    case 0x100c:
+        /* the lowest two bits are always 0 for 32-bit bus width. */
+        s->rx_des_list_addr = value & (~0x3);
+        if (!(s->operation_mode & OPMODE_START_RX)) {
+            s->cur_rx_des_addr = s->rx_des_list_addr;
+        }
+        return;
+    case 0x1010:
+        /* the lowest two bits are always 0 for 32-bit bus width. */
+        s->tx_des_list_addr = value & (~0x3);
+        if (!(s->operation_mode & OPMODE_START_TX)) {
+            s->cur_tx_des_addr = s->tx_des_list_addr;
+        }
+        return;
+    case 0x1014: /* status register */
+        s->status = ((s->status & 0x7fff) & (~value)) |
+            (s->status & 0xfffe0000);
+        if (s->status & (STATUS_TX_BUF_UNAVAILABLE | STATUS_TX_INT |
+                         STATUS_RX_INT)) {
+            s->status |= STATUS_NORMAL_INT;
+        } else {
+            s->status &= ~STATUS_NORMAL_INT;
+        }
+
+        if (s->status & (STATUS_RX_BUF_UNAVAILABLE | STATUS_TX_UNDERFLOW)) {
+            s->status |= STATUS_ABNORMAL_INT;
+        } else {
+            s->status &= ~STATUS_ABNORMAL_INT;
+        }
+        csky_mac_v2_update(s);
+        return;
+    case 0x1018:  /* operation mode register */
+        if (!(s->operation_mode & OPMODE_START_TX) &&
+            (value & OPMODE_START_TX)) {        
+           
+            s->operation_mode = value & OPMODE_START_TX; 
+            s->status |= STATUS_TX_STATE_RUNNING;
+        } else if ((s->operation_mode & OPMODE_START_TX) &&
+                   !(value & OPMODE_START_TX)) {
+            s->status |= STATUS_TX_STATE_STOPPED;
+        }
+
+        if (!(s->operation_mode & OPMODE_START_RX) &&
+            (value & OPMODE_START_RX)) {
+            cpu_physical_memory_read(s->cur_rx_des_addr, p_cur_bd, 16);
+            if (cur_bd.status1 & RXBD_OWN) {
+                s->status &= ~STATUS_RX_BUF_UNAVAILABLE;
+                if ((!(s->status & STATUS_TX_UNDERFLOW))) {
+                    s->status &= ~STATUS_ABNORMAL_INT;
+                }
+                s->status |= STATUS_RX_STATE_RUNNING;
+            } else {
+                s->status |= STATUS_RX_BUF_UNAVAILABLE | STATUS_ABNORMAL_INT;
+                s->status |= STATUS_RX_STATE_SUSPEND;
+            }
+            csky_mac_v2_update(s);
+        } else if ((s->operation_mode & OPMODE_START_RX) &&
+                   !(value & OPMODE_START_RX)) {
+            s->status |= STATUS_RX_STATE_STOPPED;
+        }
+
+        s->operation_mode = value;
+        return;
+    case 0x101c:
+        s->int_en = value;
+        csky_mac_v2_update(s);
+        return;
+    case 0x1020: /* missed_frame_buf_flow_ctrl register bit is set internal */
+        return;
+    case 0x1024:
+        s->rx_int_watchdog_timer = value & 0xff;
+        return;
+    case 0x102c:   /* ahb_axi_status read only */
+        return;
+    case 0x1048:   /* cur_tx_des_addr read only */
+        return;
+    case 0x104c:   /* cur_rx_des_addr read only */
+        return;
+    case 0x1050:   /* cur_tx_buf_addr read only */
+        return;
+    case 0x1054:   /* cur_rx_buf_addr read only */
+        return;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_mac_v2_write: Bad offset 0x%x\n", (int)offset);
+        return;
+    }
+}
+
+static const MemoryRegionOps csky_mac_v2_ops = {
+    .read = csky_mac_v2_read,
+    .write = csky_mac_v2_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+/**************************************************************************
+ * Description:
+ *     Decide whether MAC can receive packet.
+ * Argument:
+ *     nc --- the pointer to the VLAN Client state
+ * Return:
+ *     1  --- can receive
+ *     0  --- can not receive
+ **************************************************************************/
+/*
+static int csky_mac_v2_can_receive(NetClientState *nc)
+{
+    csky_mac_v2_state *s = qemu_get_nic_opaque(nc);
+
+    if ((s->operation_mode & OPMODE_START_RX)
+        && !(s->status & STATUS_RX_BUF_UNAVAILABLE)
+        && (s->config & CONFIG_RXEN)) {
+        return 1;
+    }
+    return 0;
+}
+*/
+/**************************************************************************
+ * Description:
+ *     Drop some unqualified packets according to control bits
+ * Argument:
+ *     s  --- the pointer to the MAC state
+ *     buf -- the pointer to the packet
+ *     size -- the packet size
+ * Return:
+ *     -1  --- unqualified
+ *     0   --- qualified
+ **************************************************************************/
+/*
+static int csky_mac_v2_receive_filter(csky_mac_v2_state *s, const uint8_t *buf,
+                                      size_t size)
+{
+    if (s->frame_filter & FILTER_REC_ALL) return 0;
+    if (s->frame_filter & FILTER_PROMISCUOUS) return 0;
+    if (s->frame_filter & FILTER_BROADCAST_DIS) {
+        if ((buf[0] == 0xff)
+            && (buf[1] == 0xff)
+            && (buf[2] == 0xff)
+            && (buf[3] == 0xff)
+            && (buf[4] == 0xff)
+            && (buf[5] == 0xff))
+            return -1;
+        return 0;
+    }
+    if (s->frame_filter & ~FILTER_MULTICAST_EN) {
+        if ((buf[0] & 0x1) == 1) return -1;
+        return 0;
+    }
+}
+*/
+/**************************************************************************
+ * Description:
+ *     Receive a packet.
+ * Argument:
+ *     nc  --- the pointer to the VLAN Client state.
+ *     buf -- the pointer to the packet
+ *     size -- the packet size
+ * Return:
+ *     the total size of the packet
+ **************************************************************************/
+static ssize_t csky_mac_v2_receive(NetClientState *nc, const uint8_t *buf,
+                                   size_t size)
+{
+    csky_mac_v2_state *s = qemu_get_nic_opaque(nc);
+    csky_mac_v2_bd cur_rx_bd;
+    int dis_int, end_of_ring;
+
+    if (!((s->operation_mode & OPMODE_START_RX)
+        && !(s->status & STATUS_RX_BUF_UNAVAILABLE)
+        && (s->config & CONFIG_RXEN))) {
+        return -1;
+    }
+    /* acquire current rx bd, save the important bits */
+    assert( size <= 1518 );
+    cpu_physical_memory_read(s->cur_rx_des_addr, (uint8_t *)&cur_rx_bd, 16);
+    dis_int        = cur_rx_bd.status2 & RXBD_IC_DIS;
+    end_of_ring    = cur_rx_bd.status2 & RXBD_RER;
+
+    if ((cur_rx_bd.status1 & RXBD_OWN) == 0){
+        if (end_of_ring) {
+            s->cur_rx_des_addr = s->rx_des_list_addr;
+        } else {
+            s->cur_rx_des_addr += (s->bus_mode & BUSMODE_DSL) + 16;
+        }
+        return -1;
+    }
+    cpu_physical_memory_write(cur_rx_bd.buffer1, buf, size);
+    cur_rx_bd.status1 &= ~0x3fff0000;
+    cur_rx_bd.status1 |= (size + 4) << 16;
+    cur_rx_bd.status1 |= RXBD_FS | RXBD_LS;
+    cur_rx_bd.status1 &= ~RXBD_OWN;
+    cpu_physical_memory_write(s->cur_rx_des_addr, (uint8_t *)&cur_rx_bd, 16);
+    if (!dis_int) {
+        s->status |= STATUS_RX_INT | STATUS_NORMAL_INT;
+        csky_mac_v2_update(s);
+        /* disabled timer before it runs out */
+        ptimer_stop(s->timer);
+    }
+    /* if non-zero,ritw get activated */
+    if (s->rx_int_watchdog_timer != 0 && ptimer_get_count(s->timer) == 0){
+        ptimer_set_limit(s->timer, s->rx_int_watchdog_timer*256 ,0);
+        ptimer_set_freq(s->timer, CSKY_MAC_V2_FREQ);
+        ptimer_run(s->timer,1);
+    }
+    /*
+    s->status |= STATUS_RX_INT | STATUS_NORMAL_INT;
+    csky_mac_v2_update(s);
+    */
+    if (end_of_ring) {
+        s->cur_rx_des_addr = s->rx_des_list_addr;
+    } else {
+        s->cur_rx_des_addr += (s->bus_mode & BUSMODE_DSL) + 16;
+    }
+
+    return size;
+}
+
+/**************************************************************************
+ * Description
+ *     Asserting RI when riwt runs out.
+ * Argument:
+ *     opaque  --- the pointer to the csky_mac_v2_state.
+ * Return:
+ *     void
+ ***************************************************************************/
+static void csky_mac_v2_timer_tick(void *opaque){
+    csky_mac_v2_state *s = (csky_mac_v2_state*)opaque;
+    s->status |= STATUS_RX_INT | STATUS_NORMAL_INT;
+    csky_mac_v2_update(s);
+}
+
+/**************************************************************************
+ * Description:
+ *     Clean up the created MAC.
+ * Argument:
+ *     nc  --- the pointer to the VLAN Client state.
+ * Return:
+ *     void
+ ***************************************************************************/
+static void csky_mac_v2_cleanup(NetClientState *nc)
+{
+    csky_mac_v2_state *s = qemu_get_nic_opaque(nc);
+
+    s->nic = NULL;
+}
+
+static NetClientInfo net_csky_mac_v2_info = {
+    .type = NET_CLIENT_DRIVER_NIC,
+    .size = sizeof(NICState),
+/*    .can_receive = csky_mac_v2_can_receive,*/
+    .receive = csky_mac_v2_receive,
+    .cleanup = csky_mac_v2_cleanup,
+};
+
+/**************************************************************************
+ * Description:
+ *     Reset the MAC controller.
+ * Argument:
+ *     s  --- the pointer to the MAC state
+ * Return:
+ *     void
+ ***************************************************************************/
+static inline void csky_mac_v2_reset(csky_mac_v2_state *s)
+{
+    memset(&s->config, 0, 25 * sizeof(uint32_t));
+    s->bus_mode = 0x00020100;
+}
+
+/**************************************************************************
+ * Description:
+ *     Initial the MAC controller.
+ * Argument:
+ *     dev  --- the pointer to the MAC state
+ * Return:
+ *     SUCCESS or FAILURE
+ ***************************************************************************/
+static int csky_mac_v2_init(SysBusDevice *sbd)
+{
+    QEMUBH *bh;
+    DeviceState *dev = DEVICE(sbd);
+    csky_mac_v2_state *s = CSKY_MAC_V2(dev);
+
+    memory_region_init_io(&s->mmio, OBJECT(s), &csky_mac_v2_ops, s,
+                          TYPE_CSKY_MAC_V2, 0x2000);
+    sysbus_init_mmio(sbd, &s->mmio);
+    sysbus_init_irq(sbd, &s->irq);
+    qemu_macaddr_default_if_unset(&s->conf.macaddr);
+
+    s->nic = qemu_new_nic(&net_csky_mac_v2_info, &s->conf,
+                          object_get_typename(OBJECT(dev)), dev->id, s);
+    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);
+
+    csky_mac_v2_reset(s);
+    bh = qemu_bh_new(csky_mac_v2_timer_tick, s);
+    s->timer = ptimer_init(bh, PTIMER_POLICY_DEFAULT);
+    return 0;
+}
+
+static Property csky_mac_v2_properties[] = {
+    DEFINE_NIC_PROPERTIES(csky_mac_v2_state, conf),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void csky_mac_v2_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
+
+    k->init = csky_mac_v2_init;
+    dc->props = csky_mac_v2_properties;
+    dc->vmsd = &vmstate_csky_mac_v2;
+}
+
+static const TypeInfo csky_mac_v2_info = {
+    .name          = TYPE_CSKY_MAC_V2,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_mac_v2_state),
+    .class_init    = csky_mac_v2_class_init,
+};
+
+static void csky_mac_v2_register_types(void)
+{
+    type_register_static(&csky_mac_v2_info);
+}
+
+/**************************************************************************
+ * Description:
+ *     Create the MAC controller.
+ * Argument:
+ *     nd   --- the pointer to the MAC infomation
+ *     base --- the base address of the MAC mmio address
+ *     irq  --- the interrupt request signal line
+ * Return:
+ *     void
+ ***************************************************************************/
+
+void csky_mac_v2_create(NICInfo *nd, uint32_t base, qemu_irq irq)
+{
+    DeviceState *dev;
+    SysBusDevice *s;
+
+    qemu_check_nic_model(nd, "csky_mac_v2");
+    dev = qdev_create(NULL, "csky_mac_v2");
+    qdev_set_nic_properties(dev, nd);
+    qdev_init_nofail(dev);
+    s = SYS_BUS_DEVICE(dev);
+    sysbus_mmio_map(s, 0, base);
+    sysbus_connect_irq(s, 0, irq);
+}
+
+type_init(csky_mac_v2_register_types)
diff --git a/hw/sd/Makefile.objs b/hw/sd/Makefile.objs
index 31c8330..260a845 100644
--- a/hw/sd/Makefile.objs
+++ b/hw/sd/Makefile.objs
@@ -6,3 +6,4 @@ common-obj-$(CONFIG_SDHCI) += sdhci.o
 obj-$(CONFIG_MILKYMIST) += milkymist-memcard.o
 obj-$(CONFIG_OMAP) += omap_mmc.o
 obj-$(CONFIG_PXA2XX) += pxa2xx_mmci.o
+obj-$(CONFIG_CSKY_SDHC) += csky_sdhc.o
diff --git a/hw/sd/csky_sdhc.c b/hw/sd/csky_sdhc.c
new file mode 100644
index 0000000..425c6a0
--- /dev/null
+++ b/hw/sd/csky_sdhc.c
@@ -0,0 +1,732 @@
+/*
+ * CSKY SD Host Controller emulation for CSKY V2.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "sysemu/block-backend.h"
+#include "sysemu/blockdev.h"
+#include "hw/sysbus.h"
+#include "hw/sd/sd.h"
+#include "qemu/log.h"
+#include "qapi/error.h"
+
+#define TYPE_CSKY_SDHC "csky_sdhc"
+#define CSKY_SDHC(obj) OBJECT_CHECK(csky_sdhc_state, (obj), TYPE_CSKY_SDHC)
+
+typedef struct {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    BlockDriverState *bdrv;
+    SDState *card;
+    uint32_t Ctrl;
+    uint32_t Pow_En;
+    uint32_t Clk_Div;
+    uint32_t Clk_Src;
+    uint32_t Clk_En;
+    uint32_t Timeout;
+    uint32_t Card_Type;
+    uint32_t Blk_Size;
+    uint32_t Byte_Cnt;
+    uint32_t Int_Mask;
+    uint32_t Cmd_Arg;
+    uint32_t Cmd;
+    uint32_t Resp[4];
+    uint32_t Mask_Int_Stas;
+    uint32_t Raw_Int_Stas;
+    uint32_t Status;
+    uint32_t Fifoth;
+    uint32_t Card_Detc;
+    uint32_t Write_Protec;
+    uint32_t Gpio;
+    uint32_t Tccbc;
+    uint32_t Thbbc;
+    uint32_t Deb_Cnt;
+    uint32_t Usr_ID;
+    uint32_t Ver_ID;
+    uint32_t HW_Config;
+    uint32_t Bus_Mode;
+    uint32_t Poll_Demad;
+    uint32_t Descrip_LBA;
+    uint32_t IDMAC_Stas;
+    uint32_t IDMAC_Int_En;
+    uint32_t Cur_Host_Des_Addr;
+    uint32_t Cur_Buf_Des_Addr;
+#define FIFODEPTH    0x80         /* FIFO depth */
+    uint32_t Fifo[FIFODEPTH];
+    uint8_t  Fifo_start;
+
+    qemu_irq irq;
+    qemu_irq *dma;
+} csky_sdhc_state;
+
+static const VMStateDescription vmstate_csky_sdhc = {
+    .name = TYPE_CSKY_SDHC,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT32(Ctrl, csky_sdhc_state),
+        VMSTATE_UINT32(Pow_En, csky_sdhc_state),
+        VMSTATE_UINT32(Clk_Div, csky_sdhc_state),
+        VMSTATE_UINT32(Clk_En, csky_sdhc_state),
+        VMSTATE_UINT32(Timeout, csky_sdhc_state),
+        VMSTATE_UINT32(Card_Type, csky_sdhc_state),
+        VMSTATE_UINT32(Blk_Size, csky_sdhc_state),
+        VMSTATE_UINT32(Byte_Cnt, csky_sdhc_state),
+        VMSTATE_UINT32(Int_Mask, csky_sdhc_state),
+        VMSTATE_UINT32(Cmd_Arg, csky_sdhc_state),
+        VMSTATE_UINT32(Cmd, csky_sdhc_state),
+        VMSTATE_UINT32_ARRAY(Resp, csky_sdhc_state, 4),
+        VMSTATE_UINT32(Mask_Int_Stas, csky_sdhc_state),
+        VMSTATE_UINT32(Raw_Int_Stas, csky_sdhc_state),
+        VMSTATE_UINT32(Status, csky_sdhc_state),
+        VMSTATE_UINT32(Fifoth, csky_sdhc_state),
+        VMSTATE_UINT32(Card_Detc, csky_sdhc_state),
+        VMSTATE_UINT32(Write_Protec, csky_sdhc_state),
+        VMSTATE_UINT32(Gpio, csky_sdhc_state),
+        VMSTATE_UINT32(Tccbc, csky_sdhc_state),
+        VMSTATE_UINT32(Thbbc, csky_sdhc_state),
+        VMSTATE_UINT32(Deb_Cnt, csky_sdhc_state),
+        VMSTATE_UINT32(Usr_ID, csky_sdhc_state),
+        VMSTATE_UINT32(Ver_ID, csky_sdhc_state),
+        VMSTATE_UINT32(HW_Config, csky_sdhc_state),
+        VMSTATE_UINT32(Bus_Mode, csky_sdhc_state),
+        VMSTATE_UINT32(Poll_Demad, csky_sdhc_state),
+        VMSTATE_UINT32(Descrip_LBA, csky_sdhc_state),
+        VMSTATE_UINT32(IDMAC_Stas, csky_sdhc_state),
+        VMSTATE_UINT32(IDMAC_Int_En, csky_sdhc_state),
+        VMSTATE_UINT32(Cur_Host_Des_Addr, csky_sdhc_state),
+        VMSTATE_UINT32(Cur_Buf_Des_Addr, csky_sdhc_state),
+        VMSTATE_UINT32_ARRAY(Fifo, csky_sdhc_state, 0x80),
+        VMSTATE_UINT8(Fifo_start, csky_sdhc_state),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+#define CTRL         0x00       /* SDHC control register */
+#define POW_EN       0x04       /* SD POWER CONTROL */
+#define CLK_DIV      0x08       /* CLOCK DIVIDER */
+#define CLK_SRC      0x0C       /* SD CLOCK SOURCE */
+#define CLK_EN       0x10       /* CLOCK ENABLE */
+#define TIMEOUT      0x14       /* TIME OUT */
+#define CTYPE        0x18       /* CARD TYPE */
+#define BLKSIZE      0x1C       /* BLOCK SIZE */
+#define BYTCNT       0x20       /* BYTE COUNT */
+#define INTMASK      0x24       /* INTERRUPT MASK */
+#define CMDARG       0x28       /* COMMAND ARGUMENT */
+#define CMD          0x2c       /* command */
+#define RESP0        0x30       /* RESPONSE 0 */
+#define RESP1        0x34       /* RESPONSE 1 */
+#define RESP2        0x38       /* RESPONSE 2 */
+#define RESP3        0x3C       /* RESPONSE 3 */
+#define MASK_INT_STS 0x40       /* MASKED INTERRUPT SD_STATUS */
+#define RAW_INT_STS  0x44       /* RAW INTERRUPT SD_STATUS */
+#define SD_STATUS    0x48       /* SD_STATUS */
+#define FIFOTH       0x4C       /* FIFO WATER MARK */
+#define CDET         0x50       /* CARD DETECT */
+#define WP           0x54       /* WRITE PROTECT */
+#define GPIO         0x58       /* general purpose input and output register */
+#define TCCBC        0x5C       /* TRANSFERRED CIU CARD BYTE COUNT */
+#define THBBC        0x60       /* TRANSFERRED HOST TO BIU BYTE COUNT */
+#define DEBCNT       0x64       /* DEBOUNCE COUNT */
+#define UID          0x68       /* user ID */
+#define VID          0x6c       /* version ID */
+#define HCIG         0x70       /* HARDWARE CONFIGURATION */
+#define BMD          0x80       /* BUS MODE */
+#define PDMD         0x84       /* POLL DEMAND */
+#define DLBA         0x88       /* DESCRIPTOR LIST BASE ADDRESS */
+#define IDMACS       0x8c       /* internal dmac status */
+#define IDMACIEN     0x90       /* INTERNAL DMAC INTERRUPT ENABLE */
+#define CHDA         0x94       /* CURRENT HOST DESCRIPTOR ADDRESS */
+#define CBDA         0x98       /* CURRENT BUFFER DESCRIPTOR ADDRESS */
+#define FIFOADDR     0x100      /* FIFO ADDRESS */
+
+/*================================================================
+ *       BIT
+ *---------------------------------------------------------
+ */
+#define BIT0        0x00000001
+#define BIT1        0x00000002
+#define BIT2        0x00000004
+#define BIT3        0x00000008
+#define BIT4        0x00000010
+#define BIT5        0x00000020
+#define BIT6        0x00000040
+#define BIT7        0x00000080
+
+#define BIT8        0x00000100
+#define BIT9        0x00000200
+#define BIT10       0x00000400
+#define BIT11       0x00000800
+#define BIT12       0x00001000
+#define BIT13       0x00002000
+#define BIT14       0x00004000
+#define BIT15       0x00008000
+
+#define BIT16       0x00010000
+#define BIT17       0x00020000
+#define BIT18       0x00040000
+#define BIT19       0x00080000
+#define BIT20       0x00100000
+#define BIT21       0x00200000
+#define BIT22       0x00400000
+#define BIT23       0x00800000
+
+#define BIT24       0x01000000
+#define BIT25       0x02000000
+#define BIT26       0x04000000
+#define BIT27       0x08000000
+#define BIT28       0x10000000
+#define BIT29       0x20000000
+#define BIT30       0x40000000
+#define BIT31       0x80000000
+
+/*********************************************************
+ *  FIELD
+ */
+#define FIFO_CNT     0x3ffe0000 /* the vocation of fifocount in status */
+
+
+/*****************************************************************************
+ **
+ ** Description: This function is uesed to reset SD host
+ **
+ *****************************************************************************/
+
+static void csky_sdhc_reset(DeviceState *d)
+{
+    csky_sdhc_state *host = CSKY_SDHC(d);
+
+    host->Ctrl = 0;
+    host->Pow_En = 0x0;
+    host->Clk_Div = 0x0;
+    host->Clk_Src = 0x0;
+    host->Clk_En = 0x0;
+    host->Timeout = 0xffffff40;
+    host->Card_Type = 0x0;
+    host->Blk_Size = 0x200;
+    host->Byte_Cnt = 0x200;
+    host->Int_Mask = 0x0;
+    host->Cmd_Arg = 0x0;
+    host->Cmd = 0x0;
+    memset(host->Resp, 0, sizeof(host->Resp));
+    host->Mask_Int_Stas = 0x0;
+    host->Raw_Int_Stas = 0x0;
+    host->Status = 0x106;         /* need to be consider */
+    host->Fifoth &= 0x000f0000;
+    host->Card_Detc = 0xfffffffe;
+    host->Tccbc = 0x0;
+    host->Thbbc = 0x0;
+    host->Deb_Cnt = 0x00ffffff;
+    host->Usr_ID = 0x0;
+    host->Ver_ID = 0x0;
+    host->HW_Config = 0x792cc3;
+    host->Bus_Mode = 0x0;
+    host->Poll_Demad = 0x0;
+    host->Descrip_LBA = 0x0;
+    host->IDMAC_Stas = 0x0;
+    host->IDMAC_Int_En = 0x0;
+    host->Cur_Host_Des_Addr = 0x0;
+    host->Cur_Buf_Des_Addr = 0x0;
+}
+
+/******************************************************************************
+ **
+ ** Description:
+ This function is uesed to update certain bits related to fifo status
+ **
+ ******************************************************************************/
+
+static void csky_sdhc_fifolevel_update(csky_sdhc_state *host)
+{
+    int fifocnt = (host->Status & FIFO_CNT) >> 17;
+    int fiforxwm = (host->Fifoth & 0xfff0000) >> 16;
+    int fifotxwm = (host->Fifoth & 0xfff);
+    int direct = host->Cmd & BIT10;     /* "1" REPRESENT WRITE DATA TO CARD */
+
+    if (host->Ctrl & BIT1) {              /* reset fifo */
+        host->Fifo_start = 0;
+        host->Status = (~FIFO_CNT) & host->Status;
+        host->Status |= BIT2 | BIT1;
+        host->Status &= ~(BIT3 | BIT0);
+        host->Raw_Int_Stas |= BIT4;
+        host->Mask_Int_Stas = host->Raw_Int_Stas & host->Int_Mask;
+        return;
+    }
+    if (!fifocnt) {
+        host->Status |= BIT2;           /* FIFO is empty */
+    } else {
+        host->Status &= ~BIT2;
+    }
+
+    if (fifocnt == FIFODEPTH) {           /* FIFO IS FULL */
+        host->Status |= BIT3;
+    } else {
+        host->Status &= ~BIT3;
+    }
+    /* set RXDR bit */
+    if (fifocnt > fiforxwm && !direct) {
+        host->Raw_Int_Stas |= BIT5;
+    }
+
+    /* set TXDR bit */
+    if (fifocnt <= fifotxwm && direct) {
+        host->Raw_Int_Stas |= BIT4;
+    }
+
+    host->Mask_Int_Stas = host->Raw_Int_Stas & host->Int_Mask;
+
+    if (fifocnt > fiforxwm) {
+        host->Status |= BIT0;
+    } else {
+        host->Status &= ~BIT0;
+    }
+    if (fifocnt <= fifotxwm) {
+        host->Status |= BIT1;
+    } else {
+        host->Status &= ~BIT1;
+    }
+
+    return ;
+}
+
+
+/*
+ * Description: update interrupt status and raise interrupt
+ *
+ */
+
+static void csky_sdhc_interrupts_update(csky_sdhc_state *host)
+{
+    qemu_set_irq(host->irq, host->Mask_Int_Stas && (host->Ctrl & BIT4));
+}
+
+/*
+ * Description: transfer data between sdhc and SD card
+ */
+static void csky_sdhc_transfer(csky_sdhc_state *host)
+{
+    uint8_t value[4];
+    uint32_t value1;
+    uint32_t fifocnt = (host->Status & FIFO_CNT) >> 17;
+    uint32_t write = host->Cmd & BIT10;
+    if (!(host->Cmd & BIT9)) {              /* return if no data expected */
+        return;
+    }
+    if (!write) {         /* read a date from sd card */
+        while ((fifocnt < 0x80) && (host->Byte_Cnt > 0)) {
+            value[0] = sd_read_data(host->card);
+            value[1] = sd_read_data(host->card);
+            value[2] = sd_read_data(host->card);
+            value[3] = sd_read_data(host->card);
+            host->Fifo[(host->Fifo_start + fifocnt) & (FIFODEPTH - 1)] =
+                (value[3] << 24) | (value[2] << 16) | (value[1] << 8) |
+                value[0];
+            fifocnt++;
+            host->Byte_Cnt -= 4;
+        }
+    } else {                            /* write date to SD Card */
+        while ((fifocnt > 0) && (host->Byte_Cnt > 0)) {
+            value1 = host->Fifo[host->Fifo_start];
+            host->Fifo_start = (host->Fifo_start + 1) % FIFODEPTH;
+            sd_write_data(host->card, value1);
+            sd_write_data(host->card, value1 >> 8);
+            sd_write_data(host->card, value1 >> 16);
+            sd_write_data(host->card, value1 >> 24);
+            fifocnt--;
+            host->Byte_Cnt -= 4;
+        }
+    }
+
+    if (host->Byte_Cnt == 0) {                  /* data transfer over */
+        host->Raw_Int_Stas = host->Raw_Int_Stas | BIT3;
+        host->Mask_Int_Stas = host->Raw_Int_Stas & host->Int_Mask;
+    }
+    host->Status = (fifocnt << 17) | (~FIFO_CNT & host->Status);
+}
+/*
+ * Description:  sending commmanfs to sd card
+ */
+static void csky_sdhc_command(csky_sdhc_state *host)
+{
+    SDRequest request;
+    uint8_t response[16];
+    int rlen;
+
+    request.cmd = (uint8_t)(host->Cmd & 0X3F);     /* fetch command index */
+    request.arg = host->Cmd_Arg;
+    if ((host->Cmd & BIT21) != 0x0) {             /* do not send command */
+        host->Cmd = host->Cmd & ~BIT31;           /* clear start_cmd bit */
+        return;
+    }
+    rlen = sd_do_command(host->card, &request, response);
+    host->Cmd = host->Cmd & ~BIT31;
+
+    if (host->Cmd & BIT6) {                  /* response expected */
+        if (rlen == 4 && !(host->Cmd & BIT7)) {         /* SHORT RESPONSE */
+            host->Resp[0] = (response[0] << 24) | (response[1] << 16) |
+                (response[2] << 8)  |  response[3];     /* bit 0 in Resp
+                                                           correspond to LSB */
+            host->Resp[1] = host->Resp[2] = host->Resp[3] = 0;
+        } else if (rlen == 16 && (host->Cmd & BIT7)) {      /* LONG RESPONSE */
+            host->Resp[0] = (response[0] << 24) | (response[1] << 16) |
+                (response[2] << 8) |  response[3];
+            host->Resp[1] = (response[4] << 24) | (response[5] << 16) |
+                (response[6] << 8)  |  response[7];
+            host->Resp[2] = (response[8] << 24) | (response[9] << 16) |
+                (response[10] << 8)  |  response[11];
+            host->Resp[3] = (response[12] << 24) | (response[13] << 16) |
+                (response[14] << 8) |  response[15];
+        } else {
+            host->Raw_Int_Stas |= BIT8;         /* RESPONSE ERROR */
+        }
+    }
+    if ((host->Cmd & BIT12)) {  /* sending CMD12 */
+        request.cmd = 12;       /* fetch command index */
+        sd_do_command(host->card, &request, response);
+    }
+    host->Raw_Int_Stas |= BIT2;            /* set command done bit */
+    host->Mask_Int_Stas = host->Raw_Int_Stas & host->Int_Mask;
+}
+
+static void csky_sdhc_update(void *opaque)
+{
+    csky_sdhc_state  *host = (csky_sdhc_state  *)opaque;
+    csky_sdhc_transfer(host);
+    csky_sdhc_fifolevel_update(host);
+    csky_sdhc_interrupts_update(host);
+}
+
+/*
+ *Description: read date in register
+ */
+static uint64_t csky_sdhc_read(void *opaque, hwaddr offset, unsigned size)
+{
+    uint32_t i;
+    csky_sdhc_state *s = (csky_sdhc_state *) opaque;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_sdhc_read: 0x%x must word align read\n",
+                      (int)offset);
+    }
+
+    switch (offset) {
+    case CTRL: /* SDHC control register */
+        return s->Ctrl;
+
+    case POW_EN: /* power enable */
+        return s->Pow_En ;
+
+    case CLK_DIV: /* clock divider*/
+        return s->Clk_Div;
+
+    case CLK_SRC: /* clock source */
+        return s->Clk_Src;
+
+    case CLK_EN: /* clock enable */
+        return s->Clk_En;
+
+    case TIMEOUT: /* time out */
+        return s->Timeout;
+
+    case CTYPE: /* card type */
+        return s->Card_Type;
+
+    case BLKSIZE: /* block size */
+        return s->Blk_Size;
+
+    case BYTCNT: /* byte count */
+        return  s->Byte_Cnt;
+
+    case INTMASK: /* interrupt mask */
+        return s->Int_Mask;
+
+    case CMDARG: /* command argument */
+        return s->Cmd_Arg;
+
+    case CMD: /* command */
+        return s->Cmd;
+
+    case RESP0: /* response */
+    case RESP1: /* response 1 */
+    case RESP2: /* response2 */
+    case RESP3: /* response 3*/
+        return s->Resp[(offset - RESP0) >> 2];
+    case MASK_INT_STS:  /*masked interrupted status*/
+        return s->Mask_Int_Stas;
+    case RAW_INT_STS:   /*raw interrupted status*/
+        return s->Raw_Int_Stas;
+    case SD_STATUS:   /*status*/
+        return s->Status;
+    case FIFOTH:   /*FIFO Water mark*/
+        return s->Fifoth;
+    case CDET:   /*card detect*/
+        return s->Card_Detc;
+    case WP:   /*write protect*/
+        return s->Write_Protec;
+    case GPIO:   /*general purpose input/output register*/
+        return s->Gpio;
+    case TCCBC:   /*transferred CIU card byte count*/
+        return s->Tccbc;
+    case THBBC:   /*transferred  host to BIU-FIFO byte count*/
+        return s->Thbbc;
+    case DEBCNT:   /*debounce count*/
+        return s->Deb_Cnt;
+    case UID:   /*user ID*/
+        return s->Usr_ID;
+    case VID:   /*version ID*/
+        return s->Ver_ID;
+    case HCIG:   /*Hardware configuration*/
+        return s->HW_Config;
+    case BMD:   /*bus mode*/
+        return s->Bus_Mode;
+    case PDMD:   /*poll demand*/
+        return s->Poll_Demad;
+    case DLBA:   /*descriptor list base address*/
+        return s->Descrip_LBA;
+    case IDMACS:   /*internal dmac status*/
+        return s->IDMAC_Stas;
+    case IDMACIEN:   /*internal dmac interrupt status*/
+        return s->IDMAC_Int_En;
+    case CHDA:   /*current host descriptor address*/
+        return s->Cur_Host_Des_Addr;
+    case CBDA:   /*current buffer descriptor address*/
+        return s->Cur_Buf_Des_Addr;
+    default:
+        if (offset >= FIFOADDR) {
+            int fifocnt = (s->Status & FIFO_CNT) >> 17;
+            if (s->Status & BIT2) {
+                s->Raw_Int_Stas = s->Raw_Int_Stas | BIT11;
+                s->Mask_Int_Stas = s->Raw_Int_Stas & s->Int_Mask;
+                qemu_log_mask(LOG_GUEST_ERROR,
+                              "MMC: FIFO underrun\n");
+                return 0;
+            }
+            i = s->Fifo[s->Fifo_start];
+            s->Fifo_start = (s->Fifo_start + 1) % FIFODEPTH;
+            fifocnt--;
+            s->Status = (fifocnt << 17) | (~FIFO_CNT & s->Status);
+            csky_sdhc_update(s);
+            return i;
+        } else {                            /* invalid address */
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "%s: Bad register %x\n", __func__, (int)offset);
+        }
+        return -1;
+    }
+}
+
+/*
+ * Description: to write value to register
+ */
+static void csky_sdhc_write(void *opaque, hwaddr offset, uint64_t value,
+                            unsigned size)
+{
+    uint16_t i;
+    csky_sdhc_state *s = (csky_sdhc_state *) opaque;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_sdhc_write: 0x%x must word align read\n",
+                      (int)offset);
+    }
+
+    switch (offset) {
+    case CTRL:
+        s->Ctrl = value;
+        csky_sdhc_update(s);
+        s->Ctrl &= ~BIT1;
+        s->Ctrl &= ~BIT0;
+        break;
+    case POW_EN:
+        s->Pow_En = value;
+        sd_enable(s->card, (s->Pow_En & 1));      /* enable sd card */
+        break;
+    case CLK_DIV:
+        s->Clk_Div = value;
+        break;
+    case CLK_SRC:
+        s->Clk_Src = value;
+        break;
+    case CLK_EN:
+        s->Clk_En = value;
+        break;
+    case TIMEOUT:
+        s->Timeout = value;
+        break;
+    case CTYPE:
+        s->Card_Type = value;
+        break;
+    case BLKSIZE:
+        s->Blk_Size = value;
+        break;
+    case BYTCNT:
+        s->Byte_Cnt = value;
+        break;
+    case INTMASK:
+        s->Int_Mask = value;
+        break;
+    case CMDARG:
+        s->Cmd_Arg = value;
+        break;
+    case CMD:                                        /* processing command */
+        s->Cmd = value;
+        for (i = 0; i < 4; i++) {
+            s->Resp[i] = 0x0;
+        }
+        csky_sdhc_command(s);
+        csky_sdhc_update(s);
+        break;
+
+    case RESP0:
+    case RESP1:
+    case RESP2:
+    case RESP3:
+        break;
+    case MASK_INT_STS:
+        break;
+    case RAW_INT_STS:
+        s->Raw_Int_Stas &= ~value;
+        s->Mask_Int_Stas = s->Raw_Int_Stas & s->Int_Mask;
+        break;
+    case SD_STATUS:
+        break;
+    case FIFOTH:
+        s->Fifoth = value;
+        break;
+    case CDET:
+        s->Card_Detc = value;
+        break;
+    case WP:
+        break;
+    case GPIO:
+        s->Gpio = value;
+        break;
+    case TCCBC:
+
+        break;
+    case THBBC:
+
+        break;
+    case DEBCNT:
+        s->Deb_Cnt = value;
+        break;
+    case UID:
+        s->Usr_ID = value;
+    case VID:
+
+        break;
+    case HCIG:
+        break;
+    case BMD:
+
+        break;
+    case PDMD:
+        s->Poll_Demad = value;
+        break;
+    case DLBA:
+        s->Descrip_LBA = value;
+        break;
+    case IDMACS:
+        s->IDMAC_Stas = value;
+        break;
+    case IDMACIEN:
+        s->IDMAC_Int_En = value;
+        break;
+    case CHDA:
+
+        break;
+    case CBDA:
+
+        break;
+    default:
+        if (offset >= FIFOADDR) {
+            int fifocnt = (s->Status & FIFO_CNT) >> 17;
+            if (s->Status & BIT3) {                 /* FIFO is full */
+                s->Raw_Int_Stas = s->Raw_Int_Stas | BIT11;
+                s->Mask_Int_Stas = s->Raw_Int_Stas & s->Int_Mask;
+                qemu_log_mask(LOG_GUEST_ERROR,
+                              "MMC: FIFO overrun\n");
+                return;
+            }
+            s->Fifo[(fifocnt + s->Fifo_start) &(FIFODEPTH - 1)] = value;
+            fifocnt++;
+            /* new filled location in FIFO */
+            s->Status = (fifocnt << 17) | (~FIFO_CNT & s->Status);
+            csky_sdhc_update(s);
+        } else {                            /* invalid address */
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "%s: Bad register %x\n", __func__, (int)offset);
+        }
+    }
+}
+
+static const MemoryRegionOps csky_sdhc_ops = {
+    .read = csky_sdhc_read,
+    .write = csky_sdhc_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static void csky_sdhc_init(Object *obj)
+{
+    csky_sdhc_state *s = CSKY_SDHC(obj);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+
+    memory_region_init_io(&s->iomem, obj, &csky_sdhc_ops, s,
+                          TYPE_CSKY_SDHC, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+    sysbus_init_irq(sbd, &s->irq);
+}
+
+static void csky_sdhc_realize(DeviceState *dev, Error **errp)
+{
+    csky_sdhc_state *s = CSKY_SDHC(dev);
+    DriveInfo *dinfo;
+
+    /* FIXME use a qdev drive property instead of drive_get_next() */
+    dinfo = drive_get_next(IF_SD);
+    s->card = sd_init(dinfo ? blk_by_legacy_dinfo(dinfo) : NULL, false);
+    if (s->card == NULL) {
+        error_setg(errp, "sd_init failed");
+    }
+}
+
+static void csky_sdhc_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *k = DEVICE_CLASS(klass);
+
+    k->vmsd = &vmstate_csky_sdhc;
+    k->reset = csky_sdhc_reset;
+    /* Reason: init() method uses drive_get_next() */
+    k->cannot_instantiate_with_device_add_yet = true;
+    k->realize = csky_sdhc_realize;
+}
+
+static const TypeInfo csky_sdhc_info = {
+    .name          = TYPE_CSKY_SDHC,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_sdhc_state),
+    .instance_init = csky_sdhc_init,
+    .class_init    = csky_sdhc_class_init,
+};
+
+static void csky_sdhc_register_types(void)
+{
+    type_register_static(&csky_sdhc_info);
+}
+
+type_init(csky_sdhc_register_types)
diff --git a/hw/timer/Makefile.objs b/hw/timer/Makefile.objs
index 7ba8c23..2f75a35 100644
--- a/hw/timer/Makefile.objs
+++ b/hw/timer/Makefile.objs
@@ -28,6 +28,11 @@ obj-$(CONFIG_SH4) += sh_timer.o
 obj-$(CONFIG_DIGIC) += digic-timer.o
 obj-$(CONFIG_MIPS_CPS) += mips_gictimer.o
 
+ifeq ($(CONFIG_MODULES),y)
+common-obj-$(if $(CONFIG_CSKY_TIMER),m,n) += csky_timer_dummy.o
+endif
+obj-$(CONFIG_CSKY_TIMER) += csky_timer.o
+
 obj-$(CONFIG_MC146818RTC) += mc146818rtc.o
 
 obj-$(CONFIG_ALLWINNER_A10_PIT) += allwinner-a10-pit.o
diff --git a/hw/timer/csky_timer.c b/hw/timer/csky_timer.c
new file mode 100644
index 0000000..ce29d68
--- /dev/null
+++ b/hw/timer/csky_timer.c
@@ -0,0 +1,313 @@
+/*
+ * CSKY timer emulation.
+ *
+ * Written by lyc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "qemu/timer.h"
+#include "sysemu/sysemu.h"
+#include "qemu/cutils.h"
+#include "qemu/log.h"
+#include "hw/ptimer.h"
+#include "cpu.h"
+#include "hw/csky/cskydev.h"
+
+#define TIMER_CTRL_ENABLE         (1 << 0)
+#define TIMER_CTRL_MODE           (1 << 1)
+#define TIMER_CTRL_IE             (1 << 2)
+#define TIMER_CTRL_CLOCK          (1 << 3)
+
+#define TYPE_CSKY_TIMER     "csky_timer"
+#define CSKY_TIMER(obj)     OBJECT_CHECK(csky_timer_state, (obj), \
+                                         TYPE_CSKY_TIMER)
+
+uint32_t csky_timer_freq = 50000000ll;
+
+typedef struct csky_timer_state {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    ptimer_state * timer[4];
+    uint32_t control[4];
+    uint32_t limit[4];
+    int freq[4];
+    int int_level[4];
+    qemu_irq irq[4];
+} csky_timer_state;
+
+static void csky_timer_update(csky_timer_state *s, int index)
+{
+    /* Update interrupts.  */
+    if (s->int_level[index] && !(s->control[index] & TIMER_CTRL_IE)) {
+        qemu_irq_raise(s->irq[index]);
+    } else {
+        qemu_irq_lower(s->irq[index]);
+    }
+}
+
+static uint32_t csky_timer_read(csky_timer_state *s, hwaddr offset, int index)
+{
+    switch (offset >> 2) {
+    case 0: /* TimerN LoadCount */
+        return s->limit[index];
+    case 1: /* TimerN CurrentValue */
+        return ptimer_get_count(s->timer[index]);
+    case 2: /* TimerN ControlReg */
+        return s->control[index];
+    case 3: /* TimerN EOI */
+        s->int_level[index] = 0;
+        csky_timer_update(s, index);
+        return 0;
+    case 4: /* TimerN IntStatus */
+        return s->int_level[index] && !(s->control[index] & TIMER_CTRL_IE);
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timer_read: Bad offset %x\n", (int)offset);
+        return 0;
+    }
+}
+
+static void csky_timer_reload(csky_timer_state *s, int reload, int index)
+{
+    uint32_t limit;
+    if (s->control[index] & TIMER_CTRL_MODE) {
+        limit = s->limit[index];
+    } else {
+        limit = s->limit[index];
+    }
+    ptimer_set_limit(s->timer[index], limit, reload);
+}
+
+static void csky_timer_write(csky_timer_state *s, hwaddr offset,
+                             uint64_t value, int index)
+{
+    switch (offset >> 2) {
+    case 0: /*TimerN LoadCount*/
+        s->limit[index] = value;
+        if (s->control[index] & TIMER_CTRL_ENABLE) {
+            csky_timer_reload(s, 0, index);
+            ptimer_run(s->timer[index], 0);
+        }
+        break;
+    case 2: /*TimerN ControlReg*/
+        if (s->control[index] & TIMER_CTRL_ENABLE) {
+            /* Pause the timer if it is running. */
+            ptimer_stop(s->timer[index]);
+        }
+        s->control[index] = value;
+        csky_timer_reload(s, s->control[index] & TIMER_CTRL_ENABLE, index);
+        ptimer_set_freq(s->timer[index], s->freq[index]);
+        if (s->control[index] & TIMER_CTRL_ENABLE) {
+            /* Restart the timer if still enabled. */
+            ptimer_run(s->timer[index], 0);
+        }
+        break;
+
+    case 1: /*TimerN CurrentValue*/
+    case 3: /*TimerN EOI*/
+    case 4: /*TimerN IntStatus*/
+        return;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timer_write: Bad offset %x\n", (int)offset);
+    }
+    csky_timer_update(s, index);
+}
+
+static void csky_timer_tick0(void *opaque)
+{
+    csky_timer_state *s = (csky_timer_state *)opaque;
+    csky_timer_reload(s, 1, 0);
+    s->int_level[0] = 1;
+    csky_timer_update(s, 0);
+}
+
+static void csky_timer_tick1(void *opaque)
+{
+    csky_timer_state *s = (csky_timer_state *)opaque;
+    csky_timer_reload(s, 1, 1);
+    s->int_level[1] = 1;
+    csky_timer_update(s, 1);
+}
+
+static void csky_timer_tick2(void *opaque)
+{
+    csky_timer_state *s = (csky_timer_state *)opaque;
+    csky_timer_reload(s, 1, 2);
+    s->int_level[2] = 1;
+    csky_timer_update(s, 2);
+}
+
+static void csky_timer_tick3(void *opaque)
+{
+    csky_timer_state *s = (csky_timer_state *)opaque;
+    csky_timer_reload(s, 1, 3);
+    s->int_level[3] = 1;
+    csky_timer_update(s, 3);
+}
+
+static uint64_t csky_timers_read(void *opaque, hwaddr offset, unsigned size)
+{
+    csky_timer_state *s = (csky_timer_state *)opaque;
+    int n;
+    int i;
+    uint32_t ret;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timers_read: Bad read size\n");
+    }
+
+    n = offset / 0x14;
+    switch (n) {
+    case 0: /*TimerN*/
+    case 1:
+    case 2:
+    case 3:
+        return csky_timer_read(s, offset % 0x14, n);
+    case 8: /*Timer System Register*/
+        switch ((offset % 0x14) >> 2) {
+        case 0: /*TimersIntStatus*/
+            ret = ((s->int_level[0] && !(s->control[0] & TIMER_CTRL_IE)) |
+                   ((s->int_level[1] &&
+                     !(s->control[1] & TIMER_CTRL_IE)) << 1) |
+                   ((s->int_level[2] &&
+                     !(s->control[2] & TIMER_CTRL_IE)) << 2) |
+                   ((s->int_level[3] &&
+                     !(s->control[3] & TIMER_CTRL_IE)) << 3));
+            return ret;
+        case 1: /*TimersEOI*/
+            for (i = 0; i <= 3; i++) {
+                s->int_level[i] = 0;
+                csky_timer_update(s, i);
+            }
+            return 0;
+        case 2: /*TimersRawIntStatus*/
+            return (s->int_level[0] | (s->int_level[1] << 1) |
+                    (s->int_level[2] << 2) | (s->int_level[3] << 3));
+
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "csky_timers_read: Bad offset %x\n", (int)offset);
+            return 0;
+        }
+
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timers_read: Bad timer %d\n", n);
+        return 0;
+    }
+}
+
+static void csky_timers_write(void *opaque, hwaddr offset, uint64_t value,
+                              unsigned size)
+{
+    csky_timer_state *s = (csky_timer_state *)opaque;
+    int n;
+
+    n = offset / 0x14;
+    if (n > 3) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timers_write: Bad timer %d\n", n);
+    }
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timers_write: Bad write size\n");
+    }
+
+    csky_timer_write(s, offset % 0x14, value, n);
+}
+
+static const MemoryRegionOps csky_timer_ops = {
+    .read = csky_timers_read,
+    .write = csky_timers_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+void csky_timer_set_freq(uint32_t freq)
+{
+    csky_timer_freq = freq;
+}
+
+static void csky_timer_init(Object *obj)
+{
+    QEMUBH *bh;
+    csky_timer_state *s = CSKY_TIMER(obj);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+
+    s->freq[0] = csky_timer_freq;
+    bh = qemu_bh_new(csky_timer_tick0, s);
+    s->timer[0] = ptimer_init(bh, PTIMER_POLICY_DEFAULT);
+    sysbus_init_irq(sbd, &s->irq[0]);
+
+    s->freq[1] = csky_timer_freq;
+    bh = qemu_bh_new(csky_timer_tick1, s);
+    s->timer[1] = ptimer_init(bh, PTIMER_POLICY_DEFAULT);
+    sysbus_init_irq(sbd, &s->irq[1]);
+
+    s->freq[2] = csky_timer_freq;
+    bh = qemu_bh_new(csky_timer_tick2, s);
+    s->timer[2] = ptimer_init(bh, PTIMER_POLICY_DEFAULT);
+    sysbus_init_irq(sbd, &s->irq[2]);
+
+    s->freq[3] = csky_timer_freq;
+    bh = qemu_bh_new(csky_timer_tick3, s);
+    s->timer[3] = ptimer_init(bh, PTIMER_POLICY_DEFAULT);
+    sysbus_init_irq(sbd, &s->irq[3]);
+
+    memory_region_init_io(&s->iomem, obj, &csky_timer_ops, s,
+                          TYPE_CSKY_TIMER, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+}
+
+static const VMStateDescription vmstate_csky_timer = {
+    .name = TYPE_CSKY_TIMER,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_PTIMER_ARRAY(timer, csky_timer_state, 4),
+        VMSTATE_UINT32_ARRAY(control, csky_timer_state, 4),
+        VMSTATE_UINT32_ARRAY(limit, csky_timer_state, 4),
+        VMSTATE_INT32_ARRAY(freq, csky_timer_state, 4),
+        VMSTATE_INT32_ARRAY(int_level, csky_timer_state, 4),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static void csky_timer_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->vmsd = &vmstate_csky_timer;
+}
+
+static const TypeInfo csky_timer_info = {
+    .name          = TYPE_CSKY_TIMER,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_timer_state),
+    .instance_init = csky_timer_init,
+    .class_init    = csky_timer_class_init,
+};
+
+static void csky_timer_register_types(void)
+{
+    type_register_static(&csky_timer_info);
+}
+
+type_init(csky_timer_register_types)
diff --git a/hw/timer/csky_timer_dummy.c b/hw/timer/csky_timer_dummy.c
new file mode 100644
index 0000000..86b205f
--- /dev/null
+++ b/hw/timer/csky_timer_dummy.c
@@ -0,0 +1,309 @@
+/*
+ * CSKY timer emulation.
+ *
+ * Written by lyc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "qemu/timer.h"
+#include "sysemu/sysemu.h"
+#include "qemu/cutils.h"
+#include "qemu/log.h"
+#include "hw/ptimer.h"
+
+#define TIMER_CTRL_ENABLE         (1 << 0)
+#define TIMER_CTRL_MODE           (1 << 1)
+#define TIMER_CTRL_IE             (1 << 2)
+#define TIMER_CTRL_CLOCK          (1 << 3)
+
+#define TYPE_CSKY_TIMER     "csky_timer_dummy"
+#define CSKY_TIMER(obj)     OBJECT_CHECK(csky_timer_dummy_state, (obj), \
+                                         TYPE_CSKY_TIMER)
+
+typedef struct csky_timer_dummy_state {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    ptimer_state * timer[4];
+    uint32_t control[4];
+    uint32_t limit[4];
+    int freq[4];
+    int int_level[4];
+    qemu_irq irq[4];
+} csky_timer_dummy_state;
+
+static void csky_timer_dummy_update(csky_timer_dummy_state *s, int index)
+{
+    /* Update interrupts.  */
+    if (s->int_level[index] && !(s->control[index] & TIMER_CTRL_IE)) {
+        qemu_irq_raise(s->irq[index]);
+    } else {
+        qemu_irq_lower(s->irq[index]);
+    }
+}
+
+static uint32_t csky_timer_dummy_read(csky_timer_dummy_state *s, hwaddr offset,
+                                      int index)
+{
+    switch (offset >> 2) {
+    case 0: /* TimerN LoadCount */
+        return s->limit[index];
+    case 1: /* TimerN CurrentValue */
+        return ptimer_get_count(s->timer[index]);
+    case 2: /* TimerN ControlReg */
+        return s->control[index];
+    case 3: /* TimerN EOI */
+        s->int_level[index] = 0;
+        csky_timer_dummy_update(s, index);
+        return 0;
+    case 4: /* TimerN IntStatus */
+        return s->int_level[index] && !(s->control[index] & TIMER_CTRL_IE);
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timer_dummy_read: Bad offset %x\n", (int)offset);
+        return 0;
+    }
+}
+
+static void csky_timer_dummy_reload(csky_timer_dummy_state *s, int reload,
+                                    int index)
+{
+    uint32_t limit;
+    if (s->control[index] & TIMER_CTRL_MODE) {
+        limit = s->limit[index];
+    } else {
+        limit = 0xffffffff;
+    }
+    ptimer_set_limit(s->timer[index], limit, reload);
+}
+
+static void csky_timer_dummy_write(csky_timer_dummy_state *s, hwaddr offset,
+                             uint64_t value, int index)
+{
+    switch (offset >> 2) {
+    case 0: /*TimerN LoadCount*/
+        s->limit[index] = value;
+        if (s->control[index] & TIMER_CTRL_ENABLE) {
+            csky_timer_dummy_reload(s, 0, index);
+            ptimer_run(s->timer[index], 0);
+        }
+        break;
+    case 2: /*TimerN ControlReg*/
+        if (s->control[index] & TIMER_CTRL_ENABLE) {
+            /* Pause the timer if it is running. */
+            ptimer_stop(s->timer[index]);
+        }
+        s->control[index] = value;
+        csky_timer_dummy_reload(s, s->control[index] & TIMER_CTRL_ENABLE,
+                                index);
+        ptimer_set_freq(s->timer[index], 1000000000ll);
+        if (s->control[index] & TIMER_CTRL_ENABLE) {
+            /* Restart the timer if still enabled. */
+            ptimer_run(s->timer[index], 0);
+        }
+        break;
+
+    case 1: /*TimerN CurrentValue*/
+    case 3: /*TimerN EOI*/
+    case 4: /*TimerN IntStatus*/
+        return;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timer_dummy_write: Bad offset %x\n", (int)offset);
+    }
+    csky_timer_dummy_update(s, index);
+}
+
+static void csky_timer_dummy_tick0(void *opaque)
+{
+    csky_timer_dummy_state *s = (csky_timer_dummy_state *)opaque;
+    csky_timer_dummy_reload(s, 1, 0);
+    s->int_level[0] = 1;
+    csky_timer_dummy_update(s, 0);
+}
+
+static void csky_timer_dummy_tick1(void *opaque)
+{
+    csky_timer_dummy_state *s = (csky_timer_dummy_state *)opaque;
+    csky_timer_dummy_reload(s, 1, 1);
+    s->int_level[1] = 1;
+    csky_timer_dummy_update(s, 1);
+}
+
+static void csky_timer_dummy_tick2(void *opaque)
+{
+    csky_timer_dummy_state *s = (csky_timer_dummy_state *)opaque;
+    csky_timer_dummy_reload(s, 1, 2);
+    s->int_level[2] = 1;
+    csky_timer_dummy_update(s, 2);
+}
+
+static void csky_timer_dummy_tick3(void *opaque)
+{
+    csky_timer_dummy_state *s = (csky_timer_dummy_state *)opaque;
+    csky_timer_dummy_reload(s, 1, 3);
+    s->int_level[3] = 1;
+    csky_timer_dummy_update(s, 3);
+}
+
+static uint64_t csky_timer_dummys_read(void *opaque, hwaddr offset,
+                                       unsigned size)
+{
+    csky_timer_dummy_state *s = (csky_timer_dummy_state *)opaque;
+    int n;
+    int i;
+    uint32_t ret;
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timer_dummys_read: Bad read size\n");
+    }
+
+    n = offset / 0x14;
+    switch (n) {
+    case 0: /*TimerN*/
+    case 1:
+    case 2:
+    case 3:
+        return csky_timer_dummy_read(s, offset % 0x14, n);
+    case 8: /*Timer System Register*/
+        switch ((offset % 0x14) >> 2) {
+        case 0: /*TimersIntStatus*/
+            ret = ((s->int_level[0] && !(s->control[0] & TIMER_CTRL_IE)) |
+                   ((s->int_level[1] &&
+                     !(s->control[1] & TIMER_CTRL_IE)) << 1) |
+                   ((s->int_level[2] &&
+                     !(s->control[2] & TIMER_CTRL_IE)) << 2) |
+                   ((s->int_level[3] &&
+                     !(s->control[3] & TIMER_CTRL_IE)) << 3));
+            return ret;
+        case 1: /*TimersEOI*/
+            for (i = 0; i <= 3; i++) {
+                s->int_level[i] = 0;
+                csky_timer_dummy_update(s, i);
+            }
+            return 0;
+        case 2: /*TimersRawIntStatus*/
+            return (s->int_level[0] | (s->int_level[1] << 1) |
+                    (s->int_level[2] << 2) | (s->int_level[3] << 3));
+
+        default:
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "csky_timer_dummys_read: Bad offset %x\n",
+                          (int)offset);
+            return 0;
+        }
+
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timer_dummys_read: Bad timer %d\n", n);
+        return 0;
+    }
+}
+
+static void csky_timer_dummys_write(void *opaque, hwaddr offset, uint64_t value,
+                              unsigned size)
+{
+    csky_timer_dummy_state *s = (csky_timer_dummy_state *)opaque;
+    int n;
+
+    n = offset / 0x14;
+    if (n > 3) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timer_dummys_write: Bad timer %d\n", n);
+    }
+
+    if (size != 4) {
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "csky_timer_dummys_write: Bad write size\n");
+    }
+
+    csky_timer_dummy_write(s, offset % 0x14, value, n);
+}
+
+static const MemoryRegionOps csky_timer_dummy_ops = {
+    .read = csky_timer_dummys_read,
+    .write = csky_timer_dummys_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static void csky_timer_dummy_init(Object *obj)
+{
+    QEMUBH *bh;
+    csky_timer_dummy_state *s = CSKY_TIMER(obj);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+
+    s->freq[0] = 1000000000ll;
+    bh = qemu_bh_new(csky_timer_dummy_tick0, s);
+    s->timer[0] = ptimer_init(bh, PTIMER_POLICY_DEFAULT);
+    sysbus_init_irq(sbd, &s->irq[0]);
+
+    s->freq[1] = 1000000000ll;
+    bh = qemu_bh_new(csky_timer_dummy_tick1, s);
+    s->timer[1] = ptimer_init(bh, PTIMER_POLICY_DEFAULT);
+    sysbus_init_irq(sbd, &s->irq[1]);
+
+    s->freq[2] = 1000000000ll;
+    bh = qemu_bh_new(csky_timer_dummy_tick2, s);
+    s->timer[2] = ptimer_init(bh, PTIMER_POLICY_DEFAULT);
+    sysbus_init_irq(sbd, &s->irq[2]);
+
+    s->freq[3] = 1000000000ll;
+    bh = qemu_bh_new(csky_timer_dummy_tick3, s);
+    s->timer[3] = ptimer_init(bh, PTIMER_POLICY_DEFAULT);
+    sysbus_init_irq(sbd, &s->irq[3]);
+
+    memory_region_init_io(&s->iomem, obj, &csky_timer_dummy_ops, s,
+                          TYPE_CSKY_TIMER, 0x1000);
+    sysbus_init_mmio(sbd, &s->iomem);
+}
+
+static const VMStateDescription vmstate_csky_timer_dummy = {
+    .name = TYPE_CSKY_TIMER,
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_PTIMER_ARRAY(timer, csky_timer_dummy_state, 4),
+        VMSTATE_UINT32_ARRAY(control, csky_timer_dummy_state, 4),
+        VMSTATE_UINT32_ARRAY(limit, csky_timer_dummy_state, 4),
+        VMSTATE_INT32_ARRAY(freq, csky_timer_dummy_state, 4),
+        VMSTATE_INT32_ARRAY(int_level, csky_timer_dummy_state, 4),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static void csky_timer_dummy_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->vmsd = &vmstate_csky_timer_dummy;
+}
+
+static const TypeInfo csky_timer_dummy_info = {
+    .name          = TYPE_CSKY_TIMER,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(csky_timer_dummy_state),
+    .instance_init = csky_timer_dummy_init,
+    .class_init    = csky_timer_dummy_class_init,
+};
+
+static void csky_timer_dummy_register_types(void)
+{
+    type_register_static(&csky_timer_dummy_info);
+}
+
+type_init(csky_timer_dummy_register_types)
diff --git a/include/disas/bfd.h b/include/disas/bfd.h
index 8a3488c..1bb076c 100644
--- a/include/disas/bfd.h
+++ b/include/disas/bfd.h
@@ -224,6 +224,9 @@ enum bfd_architecture
 #define bfd_mach_ia64_elf32    32
   bfd_arch_lm32,       /* Lattice Mico32 */
 #define bfd_mach_lm32 1
+  bfd_arch_csky,
+#define bfd_mach_csky_v1 1
+#define bfd_mach_csky_v2 2
   bfd_arch_last
   };
 #define bfd_mach_s390_31 31
@@ -415,6 +418,8 @@ int print_insn_crisv10          (bfd_vma, disassemble_info*);
 int print_insn_microblaze       (bfd_vma, disassemble_info*);
 int print_insn_ia64             (bfd_vma, disassemble_info*);
 int print_insn_lm32             (bfd_vma, disassemble_info*);
+int print_insn_csky_v1          (bfd_vma, disassemble_info*);
+int print_insn_csky_v2          (bfd_vma, disassemble_info*);
 
 #if 0
 /* Fetch the disassembler for a given BFD, if that support is available.  */
diff --git a/include/elf.h b/include/elf.h
index 1c2975d..ec5355d 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -86,6 +86,8 @@ typedef int64_t  Elf64_Sxword;
 #define EM_PPC	       20	/* PowerPC */
 #define EM_PPC64       21       /* PowerPC64 */
 
+#define EM_CSKY        39       /* CSKY architecture */
+
 #define EM_ARM		40		/* ARM */
 
 #define EM_SH	       42	/* SuperH */
diff --git a/include/exec/gdbstub.h b/include/exec/gdbstub.h
index f9708bb..815c968 100644
--- a/include/exec/gdbstub.h
+++ b/include/exec/gdbstub.h
@@ -123,4 +123,7 @@ extern bool gdb_has_xml;
 /* in gdbstub-xml.c, generated by scripts/feature_to_c.sh */
 extern const char *const xml_builtin[][2];
 
+/* if is_gdbserver_start = TRUE, gdbserver is working. */
+extern bool is_gdbserver_start;
+
 #endif
diff --git a/include/hw/char/csky_uart.h b/include/hw/char/csky_uart.h
new file mode 100644
index 0000000..0628e3c
--- /dev/null
+++ b/include/hw/char/csky_uart.h
@@ -0,0 +1,39 @@
+/*
+ * Csky UART emulation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef HW_CSKY_UART_H
+#define HW_CSKY_UART_H
+
+static inline DeviceState *csky_uart_create(hwaddr addr,
+                                            qemu_irq irq,
+                                            CharDriverState *chr)
+{
+    DeviceState *dev;
+    SysBusDevice *s;
+
+    dev = qdev_create(NULL, "csky_uart");
+    s = SYS_BUS_DEVICE(dev);
+    qdev_prop_set_chr(dev, "chardev", chr);
+    qdev_init_nofail(dev);
+    sysbus_mmio_map(s, 0, addr);
+    sysbus_connect_irq(s, 0, irq);
+
+    return dev;
+}
+
+#endif
diff --git a/include/hw/csky/csky.h b/include/hw/csky/csky.h
new file mode 100644
index 0000000..9481adc
--- /dev/null
+++ b/include/hw/csky/csky.h
@@ -0,0 +1,71 @@
+/*
+ * CSKY hw header.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef HW_CSKY_H
+#define HW_CSKY_H
+
+#include "exec/memory.h"
+#include "target-csky/cpu-qom.h"
+#include "hw/irq.h"
+#include "qemu/notify.h"
+
+/*
+ * struct used as a parameter of the csky_load_kernel machine init
+ * done notifier
+ */
+typedef struct {
+    Notifier notifier; /* actual notifier */
+    CSKYCPU *cpu; /* handle to the first cpu object */
+} CSKYLoadKernelNotifier;
+
+struct csky_boot_info {
+    int ram_size;
+    const char *kernel_filename;
+    const char *kernel_cmdline;
+    const char *initrd_filename;
+    const char *dtb_filename;
+    hwaddr loader_start;
+    hwaddr initrd_size;
+    uint32_t kernel_flags;
+    hwaddr entry;
+    hwaddr dtb_addr;
+    uint32_t magic;
+    uint32_t freq;
+    CSKYLoadKernelNotifier load_kernel_notifier;
+};
+
+/* kernel flags */
+#define KERNEL_ELF                  1 /* elf */
+#define KERNEL_UIMAGE               2 /* uimage */
+#define KERNEL_BIN_NO_BIOS          3 /* bin without bios */
+#define KERNEL_BIN_AND_BIOS         4 /* bin with bios */
+#define KERNEL_KBIN_NO_CMDLINE      5 /* Kernel bin whithout cmdline and bios */
+
+/**
+ * csky_load_kernel - Loads memory with everything needed to boot
+ *
+ * @cpu: handle to the first CPU object
+ * @info: handle to the boot info struct
+ * Registers a machine init done notifier that copies to memory
+ * everything needed to boot, depending on machine and user options:
+ * kernel image, boot loaders, initrd, dtb. Also registers the CPU
+ * reset handler.
+ */
+
+void csky_load_kernel(CSKYCPU *cpu, struct csky_boot_info *info);
+
+#endif
diff --git a/include/hw/csky/cskydev.h b/include/hw/csky/cskydev.h
new file mode 100644
index 0000000..c6bbd5e
--- /dev/null
+++ b/include/hw/csky/cskydev.h
@@ -0,0 +1,47 @@
+/*
+ * CSKY cpudev header.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef HW_CSKY_CPUDEV_H
+#define HW_CSKY_CPUDEV_H 1
+
+#include "hw/dma/csky_dma.h"
+
+/* CSKY device prototypes */
+
+/* csky-mac.c */
+void csky_mac_create(NICInfo *nd, uint32_t base, qemu_irq irq);
+
+/* csky-mac.c */
+void csky_mac_v2_create(NICInfo *nd, uint32_t base, qemu_irq irq);
+
+/* csky_iis.c */
+void csky_iis_create(const char *name, hwaddr addr, qemu_irq irq,
+                     csky_dma_state *dma);
+
+
+/* csky_intc.c*/
+qemu_irq *csky_intc_init_cpu(CPUCSKYState *env);
+
+/* csky_tcip_v1.c*/
+qemu_irq *csky_vic_v1_init_cpu(CPUCSKYState *env, int coret_irq_num);
+
+/* csky_tcip_v1.c*/
+void csky_tcip_v1_set_freq(uint32_t freq);
+
+/* csky_timer.c*/
+void csky_timer_set_freq(uint32_t freq);
+
+#endif
diff --git a/include/hw/csky/dynsoc.h b/include/hw/csky/dynsoc.h
new file mode 100644
index 0000000..36c49e2
--- /dev/null
+++ b/include/hw/csky/dynsoc.h
@@ -0,0 +1,91 @@
+/*
+ * CSKY dynamic soc header.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef DYNSOC_H
+#define DYNSOC_H
+
+#include <stdint.h>
+
+#define DYNSOC_UART    (1 << 0)
+#define DYNSOC_TIMER   (1 << 1)
+#define DYNSOC_LCDC    (1 << 2)
+#define DYNSOC_MAC     (1 << 3)
+#define DYNSOC_EXIT    (1 << 4)
+#define DYNSOC_MEMLOG  (1 << 5)
+#define DYNSOC_DMA     (1 << 6)
+#define DYNSOC_IIS     (1 << 7)
+#define DYNSOC_NAND    (1 << 8)
+#define DYNSOC_SDHC    (1 << 9)
+
+struct dynsoc_cpu {
+    char        cpu_name[32];
+    char        abi[8];
+    char        endian[8];
+};
+
+struct cpu_property {
+    char        vdsp[8];
+    char        pctrace[8];
+    char        elrw[8];
+    char        mem_prot[8];
+    char        mmu_default[8];
+};
+
+struct dynsoc_device {
+    int         type;
+    char        name[32];
+    char        filename[32];
+    uint32_t    addr;
+    int         irq;
+};
+
+struct dynsoc_memory {
+    char        name[32];
+    uint32_t    addr;
+    uint32_t    size;
+    uint32_t    writeable;
+};
+
+struct dynsoc_board_info {
+    uint32_t                write_enable;
+    uint32_t                read_enable;
+    char                    name[32];
+    struct dynsoc_cpu       cpu;
+    /*
+     * 0.uart
+     * 1.timer
+     * 2.lcdc
+     * 3.mac
+     * 4.exit
+     * 5.memlog
+     * 6.dma
+     * 7.iis
+     * 8.nand
+     * 9.sdhc
+     */
+    struct dynsoc_device    dev[10];
+    struct dynsoc_memory    mem[4];
+    struct cpu_property     cpu_prop;
+    char                    misc[1024];
+    uint32_t                flags;
+    int                     shmid;
+};
+
+void dynsoc_load_modules(void);
+extern struct dynsoc_board_info *dynsoc_b_info;
+
+#endif
diff --git a/include/hw/dma/csky_dma.h b/include/hw/dma/csky_dma.h
new file mode 100644
index 0000000..da5edf1
--- /dev/null
+++ b/include/hw/dma/csky_dma.h
@@ -0,0 +1,53 @@
+/*
+ * CSKY dma header.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef CSKY_DMA_H
+#define CSKY_DMA_H
+
+#define NR_DMA_CHAN       4   /* the total number of DMA channels */
+
+typedef struct {
+    hwaddr src;
+    hwaddr dest;
+    uint32_t ctrl[2];
+    uint32_t conf[2];
+    int chan_enable;
+} csky_dma_channel;
+
+typedef struct {
+    SysBusDevice parent_obj;
+
+    MemoryRegion iomem;
+    qemu_irq irq;
+    int dma_enable;
+    uint32_t tfr_int;
+    uint32_t block_int;
+    uint32_t srctran_int;
+    uint32_t dsttran_int;
+    uint32_t err_int;
+    uint32_t tfr_int_mask;
+    uint32_t block_int_mask;
+    uint32_t srctran_int_mask;
+    uint32_t dsttran_int_mask;
+    uint32_t err_int_mask;
+    uint32_t status_int;
+    csky_dma_channel *chan;
+} csky_dma_state;
+
+csky_dma_state *csky_dma_create(const char *name, hwaddr addr, qemu_irq irq);
+
+#endif
diff --git a/include/qemu/log.h b/include/qemu/log.h
index a50e994..9f1371b 100644
--- a/include/qemu/log.h
+++ b/include/qemu/log.h
@@ -43,6 +43,7 @@ static inline bool qemu_log_separate(void)
 #define CPU_LOG_PAGE       (1 << 14)
 #define LOG_TRACE          (1 << 15)
 #define CPU_LOG_TB_OP_IND  (1 << 16)
+#define CPU_TB_TRACE       (1 << 17)
 
 /* Returns true if a bit is set in the current loglevel mask
  */
diff --git a/include/sysemu/arch_init.h b/include/sysemu/arch_init.h
index 1c9dad1..665943d 100644
--- a/include/sysemu/arch_init.h
+++ b/include/sysemu/arch_init.h
@@ -23,6 +23,7 @@ enum {
     QEMU_ARCH_UNICORE32 = (1 << 14),
     QEMU_ARCH_MOXIE = (1 << 15),
     QEMU_ARCH_TRICORE = (1 << 16),
+    QEMU_ARCH_CSKY = (1 << 17),
 };
 
 extern const uint32_t arch_type;
diff --git a/linux-user/csky/syscall_nr.h b/linux-user/csky/syscall_nr.h
new file mode 100644
index 0000000..f4a77a4
--- /dev/null
+++ b/linux-user/csky/syscall_nr.h
@@ -0,0 +1,708 @@
+/*
+ * CSKY syscall header.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * This file contains the system call numbers.
+ */
+#include "config-target.h"
+#ifdef CONFIG_CSKY_KERNEL_4X
+#define TARGET_NR_io_setup 0
+#define TARGET_NR_io_destroy 1
+#define TARGET_NR_io_submit 2
+#define TARGET_NR_io_cancel 3
+#define TARGET_NR_io_getevents 4
+#define TARGET_NR_setxattr 5
+#define TARGET_NR_lsetxattr 6
+#define TARGET_NR_fsetxattr 7
+#define TARGET_NR_getxattr 8
+#define TARGET_NR_lgetxattr 9
+#define TARGET_NR_fgetxattr 10
+#define TARGET_NR_listxattr 11
+#define TARGET_NR_llistxattr 12
+#define TARGET_NR_flistxattr 13
+#define TARGET_NR_removexattr 14
+#define TARGET_NR_lremovexattr 15
+#define TARGET_NR_fremovexattr 16
+#define TARGET_NR_getcwd 17
+#define TARGET_NR_lookup_dcookie 18
+#define TARGET_NR_eventfd2 19
+#define TARGET_NR_epoll_create1 20
+#define TARGET_NR_epoll_ctl 21
+#define TARGET_NR_epoll_pwait 22
+#define TARGET_NR_dup 23
+#define TARGET_NR_dup3 24
+#define TARGET_NR3264_fcntl 25
+#define TARGET_NR_inotify_init1 26
+#define TARGET_NR_inotify_add_watch 27
+#define TARGET_NR_inotify_rm_watch 28
+#define TARGET_NR_ioctl 29
+#define TARGET_NR_ioprio_set 30
+#define TARGET_NR_ioprio_get 31
+#define TARGET_NR_flock 32
+#define TARGET_NR_mknodat 33
+#define TARGET_NR_mkdirat 34
+#define TARGET_NR_unlinkat 35
+#define TARGET_NR_symlinkat 36
+#define TARGET_NR_linkat 37
+#define TARGET_NR_renameat 38
+#define TARGET_NR_umount2 39
+#define TARGET_NR_mount 40
+#define TARGET_NR_pivot_root 41
+#define TARGET_NR_nfsservctl 42
+#define TARGET_NR3264_statfs 43
+#define TARGET_NR3264_fstatfs 44
+#define TARGET_NR3264_truncate 45
+#define TARGET_NR3264_ftruncate 46
+#define TARGET_NR_fallocate 47
+#define TARGET_NR_faccessat 48
+#define TARGET_NR_chdir 49
+#define TARGET_NR_fchdir 50
+#define TARGET_NR_chroot 51
+#define TARGET_NR_fchmod 52
+#define TARGET_NR_fchmodat 53
+#define TARGET_NR_fchownat 54
+#define TARGET_NR_fchown 55
+#define TARGET_NR_openat 56
+#define TARGET_NR_close 57
+#define TARGET_NR_vhangup 58
+#define TARGET_NR_pipe2 59
+#define TARGET_NR_quotactl 60
+#define TARGET_NR_getdents64 61
+#define TARGET_NR3264_lseek 62
+#define TARGET_NR_read 63
+#define TARGET_NR_write 64
+#define TARGET_NR_readv 65
+#define TARGET_NR_writev 66
+#define TARGET_NR_pread64 67
+#define TARGET_NR_pwrite64 68
+#define TARGET_NR_preadv 69
+#define TARGET_NR_pwritev 70
+#define TARGET_NR3264_sendfile 71
+#define TARGET_NR_pselect6 72
+#define TARGET_NR_ppoll 73
+#define TARGET_NR_signalfd4 74
+#define TARGET_NR_vmsplice 75
+#define TARGET_NR_splice 76
+#define TARGET_NR_tee 77
+#define TARGET_NR_readlinkat 78
+#define TARGET_NR3264_fstatat 79
+#define TARGET_NR3264_fstat 80
+#define TARGET_NR_sync 81
+#define TARGET_NR_fsync 82
+#define TARGET_NR_fdatasync 83
+#define TARGET_NR_sync_file_range2 84
+#define TARGET_NR_timerfd_create 85
+#define TARGET_NR_timerfd_settime 86
+#define TARGET_NR_timerfd_gettime 87
+#define TARGET_NR_utimensat 88
+#define TARGET_NR_acct 89
+#define TARGET_NR_capget 90
+#define TARGET_NR_capset 91
+#define TARGET_NR_personality 92
+#define TARGET_NR_exit 93
+#define TARGET_NR_exit_group 94
+#define TARGET_NR_waitid 95
+#define TARGET_NR_set_tid_address 96
+#define TARGET_NR_unshare 97
+#define TARGET_NR_futex 98
+#define TARGET_NR_set_robust_list 99
+#define TARGET_NR_get_robust_list 100
+#define TARGET_NR_nanosleep 101
+#define TARGET_NR_getitimer 102
+#define TARGET_NR_setitimer 103
+#define TARGET_NR_kexec_load 104
+#define TARGET_NR_init_module 105
+#define TARGET_NR_delete_module 106
+#define TARGET_NR_timer_create 107
+#define TARGET_NR_timer_gettime 108
+#define TARGET_NR_timer_getoverrun 109
+#define TARGET_NR_timer_settime 110
+#define TARGET_NR_timer_delete 111
+#define TARGET_NR_clock_settime 112
+#define TARGET_NR_clock_gettime 113
+#define TARGET_NR_clock_getres 114
+#define TARGET_NR_clock_nanosleep 115
+#define TARGET_NR_syslog 116
+#define TARGET_NR_ptrace 117
+#define TARGET_NR_sched_setparam 118
+#define TARGET_NR_sched_setscheduler 119
+#define TARGET_NR_sched_getscheduler 120
+#define TARGET_NR_sched_getparam 121
+#define TARGET_NR_sched_setaffinity 122
+#define TARGET_NR_sched_getaffinity 123
+#define TARGET_NR_sched_yield 124
+#define TARGET_NR_sched_get_priority_max 125
+#define TARGET_NR_sched_get_priority_min 126
+#define TARGET_NR_sched_rr_get_interval 127
+#define TARGET_NR_restart_syscall 128
+#define TARGET_NR_kill 129
+#define TARGET_NR_tkill 130
+#define TARGET_NR_tgkill 131
+#define TARGET_NR_sigaltstack 132
+#define TARGET_NR_rt_sigsuspend 133
+#define TARGET_NR_rt_sigaction 134
+#define TARGET_NR_rt_sigprocmask 135
+#define TARGET_NR_rt_sigpending 136
+#define TARGET_NR_rt_sigtimedwait 137
+#define TARGET_NR_rt_sigqueueinfo 138
+#define TARGET_NR_rt_sigreturn 173
+#define TARGET_NR_setpriority 140
+#define TARGET_NR_getpriority 141
+#define TARGET_NR_reboot 142
+#define TARGET_NR_setregid 143
+#define TARGET_NR_setgid 144
+#define TARGET_NR_setreuid 145
+#define TARGET_NR_setuid 146
+#define TARGET_NR_setresuid 147
+#define TARGET_NR_getresuid 148
+#define TARGET_NR_setresgid 149
+#define TARGET_NR_getresgid 150
+#define TARGET_NR_setfsuid 151
+#define TARGET_NR_setfsgid 152
+#define TARGET_NR_times 153
+#define TARGET_NR_setpgid 154
+#define TARGET_NR_getpgid 155
+#define TARGET_NR_getsid 156
+#define TARGET_NR_setsid 157
+#define TARGET_NR_getgroups 158
+#define TARGET_NR_setgroups 159
+#define TARGET_NR_uname 160
+#define TARGET_NR_sethostname 161
+#define TARGET_NR_setdomainname 162
+#define TARGET_NR_getrlimit 163
+#define TARGET_NR_setrlimit 164
+#define TARGET_NR_getrusage 165
+#define TARGET_NR_umask 166
+#define TARGET_NR_prctl 167
+#define TARGET_NR_getcpu 168
+#define TARGET_NR_gettimeofday 169
+#define TARGET_NR_settimeofday 170
+#define TARGET_NR_adjtimex 171
+#define TARGET_NR_getpid 172
+#define TARGET_NR_getppid 139
+#define TARGET_NR_getuid 174
+#define TARGET_NR_geteuid 175
+#define TARGET_NR_getgid 176
+#define TARGET_NR_getegid 177
+#define TARGET_NR_gettid 178
+#define TARGET_NR_sysinfo 179
+#define TARGET_NR_mq_open 180
+#define TARGET_NR_mq_unlink 181
+#define TARGET_NR_mq_timedsend 182
+#define TARGET_NR_mq_timedreceive 183
+#define TARGET_NR_mq_notify 184
+#define TARGET_NR_mq_getsetattr 185
+#define TARGET_NR_msgget 186
+#define TARGET_NR_msgctl 187
+#define TARGET_NR_msgrcv 188
+#define TARGET_NR_msgsnd 189
+#define TARGET_NR_semget 190
+#define TARGET_NR_semctl 191
+#define TARGET_NR_semtimedop 192
+#define TARGET_NR_semop 193
+#define TARGET_NR_shmget 194
+#define TARGET_NR_shmctl 195
+#define TARGET_NR_shmat 196
+#define TARGET_NR_shmdt 197
+#define TARGET_NR_socket 198
+#define TARGET_NR_socketpair 199
+#define TARGET_NR_bind 200
+#define TARGET_NR_listen 201
+#define TARGET_NR_accept 202
+#define TARGET_NR_connect 203
+#define TARGET_NR_getsockname 204
+#define TARGET_NR_getpeername 205
+#define TARGET_NR_sendto 206
+#define TARGET_NR_recvfrom 207
+#define TARGET_NR_setsockopt 208
+#define TARGET_NR_getsockopt 209
+#define TARGET_NR_shutdown 210
+#define TARGET_NR_sendmsg 211
+#define TARGET_NR_recvmsg 212
+#define TARGET_NR_readahead 213
+#define TARGET_NR_brk 214
+#define TARGET_NR_munmap 215
+#define TARGET_NR_mremap 216
+#define TARGET_NR_add_key 217
+#define TARGET_NR_request_key 218
+#define TARGET_NR_keyctl 219
+#define TARGET_NR_clone 220
+#define TARGET_NR_execve 221
+#define TARGET_NR3264_mmap 222
+#define TARGET_NR3264_fadvise64 223
+#define TARGET_NR_swapon 224
+#define TARGET_NR_swapoff 225
+#define TARGET_NR_mprotect 226
+#define TARGET_NR_msync 227
+#define TARGET_NR_mlock 228
+#define TARGET_NR_munlock 229
+#define TARGET_NR_mlockall 230
+#define TARGET_NR_munlockall 231
+#define TARGET_NR_mincore 232
+#define TARGET_NR_madvise 233
+#define TARGET_NR_remap_file_pages 234
+#define TARGET_NR_mbind 235
+#define TARGET_NR_get_mempolicy 236
+#define TARGET_NR_set_mempolicy 237
+#define TARGET_NR_migrate_pages 238
+#define TARGET_NR_move_pages 239
+#define TARGET_NR_rt_tgsigqueueinfo 240
+#define TARGET_NR_perf_event_open 241
+#define TARGET_NR_accept4 242
+#define TARGET_NR_recvmmsg 243
+#define TARGET_NR_arch_specific_syscall 244
+#define TARGET_NR_wait4 260
+#define TARGET_NR_prlimit64 261
+#define TARGET_NR_fanotify_init 262
+#define TARGET_NR_fanotify_mark 263
+#define TARGET_NR_name_to_handle_at         264
+#define TARGET_NR_open_by_handle_at         265
+#define TARGET_NR_clock_adjtime 266
+#define TARGET_NR_syncfs 267
+#define TARGET_NR_setns 268
+#define TARGET_NR_sendmmsg 269
+#define TARGET_NR_process_vm_readv 270
+#define TARGET_NR_process_vm_writev 271
+#define TARGET_NR_kcmp 272
+#define TARGET_NR_finit_module 273
+#define TARGET_NR_sched_setattr 274
+#define TARGET_NR_sched_getattr 275
+#define TARGET_NR_renameat2 276
+#define TARGET_NR_seccomp 277
+#define TARGET_NR_getrandom 278
+#define TARGET_NR_memfd_create 279
+#define TARGET_NR_bpf 280
+#define TARGET_NR_execveat 281
+#define TARGET_NR_userfaultfd 282
+#define TARGET_NR_membarrier 283
+#define TARGET_NR_mlock2 284
+#define TARGET_NR_copy_file_range 285
+#define TARGET_NR_preadv2 286
+#define TARGET_NR_pwritev2 287
+#define TARGET_NR_pkey_mprotect 288
+#define TARGET_NR_pkey_alloc 289
+#define TARGET_NR_pkey_free 290
+#define TARGET_NR_open 1024
+#define TARGET_NR_link 1025
+#define TARGET_NR_unlink 1026
+#define TARGET_NR_mknod 1027
+#define TARGET_NR_chmod 1028
+#define TARGET_NR_chown 1029
+#define TARGET_NR_mkdir 1030
+#define TARGET_NR_rmdir 1031
+#define TARGET_NR_lchown 1032
+#define TARGET_NR_access 1033
+#define TARGET_NR_rename 1034
+#define TARGET_NR_readlink 1035
+#define TARGET_NR_symlink 1036
+#define TARGET_NR_utimes 1037
+#define TARGET_NR3264_stat 1038
+#define TARGET_NR3264_lstat 1039
+#define TARGET_NR_pipe 1040
+#define TARGET_NR_dup2 1041
+#define TARGET_NR_epoll_create 1042
+#define TARGET_NR_inotify_init 1043
+#define TARGET_NR_eventfd 1044
+#define TARGET_NR_signalfd 1045
+#define TARGET_NR_sendfile 1046
+#define TARGET_NR_ftruncate 1047
+#define TARGET_NR_truncate 1048
+#define TARGET_NR_stat 1049
+#define TARGET_NR_lstat 1050
+#define TARGET_NR_fstat 1051
+#define TARGET_NR_fcntl 1052
+#define TARGET_NR_fadvise64 1053
+#define TARGET_NR_newfstatat 1054
+#define TARGET_NR_fstatfs 1055
+#define TARGET_NR_statfs 1056
+#define TARGET_NR_lseek 1057
+#define TARGET_NR_mmap 1058
+#define TARGET_NR_alarm 1059
+#define TARGET_NR_getpgrp 1060
+#define TARGET_NR_pause 1061
+#define TARGET_NR_time 1062
+#define TARGET_NR_utime 1063
+#define TARGET_NR_creat 1064
+#define TARGET_NR_getdents 1065
+#define TARGET_NR_futimesat 1066
+#define TARGET_NR_select 1067
+#define TARGET_NR_poll 1068
+#define TARGET_NR_epoll_wait 1069
+#define TARGET_NR_ustat 1070
+#define TARGET_NR_vfork 1071
+#define TARGET_NR_oldwait4 1072
+#define TARGET_NR_recv 1073
+#define TARGET_NR_send 1074
+#define TARGET_NR_bdflush 1075
+#define TARGET_NR_umount 1076
+#define TARGET_NR_uselib 1077
+#define TARGET_NR__sysctl 1078
+#define TARGET_NR_fork 1079
+
+#define TARGET_NR_set_thread_area    (TARGET_NR_arch_specific_syscall + 0)
+#define TARGET_NR_ipc                (TARGET_NR_arch_specific_syscall + 1)
+#define TARGET_NR_socketcall         (TARGET_NR_arch_specific_syscall + 2)
+#define TARGET_NR_ugetrlimit         (TARGET_NR_arch_specific_syscall + 3)
+#define TARGET_NR_cacheflush         (TARGET_NR_arch_specific_syscall + 4)
+#define TARGET_NR_sysfs              (TARGET_NR_arch_specific_syscall + 5)
+#define TARGET_NR_fcntl64            TARGET_NR3264_fcntl
+#define TARGET_NR_statfs64           TARGET_NR3264_statfs
+#define TARGET_NR_fstatfs64          TARGET_NR3264_fstatfs
+#define TARGET_NR_truncate64         TARGET_NR3264_truncate
+#define TARGET_NR_ftruncate64        TARGET_NR3264_ftruncate
+#define TARGET_NR_llseek             TARGET_NR3264_lseek
+#define TARGET_NR_sendfile64         TARGET_NR3264_sendfile
+#define TARGET_NR_fstatat64          TARGET_NR3264_fstatat
+#define TARGET_NR_fstat64            TARGET_NR3264_fstat
+#define TARGET_NR_mmap2              TARGET_NR3264_mmap
+#define TARGET_NR_fadvise64_64       TARGET_NR3264_fadvise64
+#ifdef TARGET_NR3264_stat
+#define TARGET_NR_stat64             TARGET_NR3264_stat
+#define TARGET_NR_lstat64            TARGET_NR3264_lstat
+#endif
+
+#else
+#define TARGET_NR_restart_syscall   0
+#define TARGET_NR_exit              1
+#define TARGET_NR_fork              2
+#define TARGET_NR_read              3
+#define TARGET_NR_write             4
+#define TARGET_NR_open              5
+#define TARGET_NR_close             6
+#define TARGET_NR_waitpid           7
+#define TARGET_NR_creat             8
+#define TARGET_NR_link              9
+#define TARGET_NR_unlink            10
+#define TARGET_NR_execve            11
+#define TARGET_NR_chdir             12
+#define TARGET_NR_time              13
+#define TARGET_NR_mknod             14
+#define TARGET_NR_chmod             15
+#define TARGET_NR_chown             16
+#define TARGET_NR_break             17
+#define TARGET_NR_oldstat           18
+#define TARGET_NR_lseek             19
+#define TARGET_NR_getpid            20
+#define TARGET_NR_mount             21
+#define TARGET_NR_umount            22
+#define TARGET_NR_setuid            23
+#define TARGET_NR_getuid            24
+#define TARGET_NR_stime             25
+#define TARGET_NR_ptrace            26
+#define TARGET_NR_alarm             27
+#define TARGET_NR_oldfstat          28
+#define TARGET_NR_pause             29
+#define TARGET_NR_utime             30
+#define TARGET_NR_stty              31
+#define TARGET_NR_gtty              32
+#define TARGET_NR_access            33
+#define TARGET_NR_nice              34
+#define TARGET_NR_ftime             35
+#define TARGET_NR_sync              36
+#define TARGET_NR_kill              37
+#define TARGET_NR_rename            38
+#define TARGET_NR_mkdir             39
+#define TARGET_NR_rmdir             40
+#define TARGET_NR_dup               41
+#define TARGET_NR_pipe              42
+#define TARGET_NR_times             43
+#define TARGET_NR_prof              44
+#define TARGET_NR_brk               45
+#define TARGET_NR_setgid            46
+#define TARGET_NR_getgid            47
+#define TARGET_NR_signal            48
+#define TARGET_NR_geteuid           49
+#define TARGET_NR_getegid           50
+#define TARGET_NR_acct              51
+#define TARGET_NR_umount2           52
+#define TARGET_NR_lock              53
+#define TARGET_NR_ioctl             54
+#define TARGET_NR_fcntl             55
+#define TARGET_NR_mpx               56
+#define TARGET_NR_setpgid           57
+#define TARGET_NR_ulimit            58
+#define TARGET_NR_oldolduname       59
+#define TARGET_NR_umask             60
+#define TARGET_NR_chroot            61
+#define TARGET_NR_ustat             62
+#define TARGET_NR_dup2              63
+#define TARGET_NR_getppid           64
+#define TARGET_NR_getpgrp           65
+#define TARGET_NR_setsid            66
+#define TARGET_NR_sigaction         67
+#define TARGET_NR_sgetmask          68
+#define TARGET_NR_ssetmask          69
+#define TARGET_NR_setreuid          70
+#define TARGET_NR_setregid          71
+#define TARGET_NR_sigsuspend        72
+#define TARGET_NR_sigpending        73
+#define TARGET_NR_sethostname       74
+#define TARGET_NR_setrlimit         75
+#define TARGET_NR_getrlimit         76
+#define TARGET_NR_getrusage         77
+#define TARGET_NR_gettimeofday      78
+#define TARGET_NR_settimeofday      79
+#define TARGET_NR_getgroups         80
+#define TARGET_NR_setgroups         81
+#define TARGET_NR_select            82
+#define TARGET_NR_symlink           83
+#define TARGET_NR_oldlstat          84
+#define TARGET_NR_readlink          85
+#define TARGET_NR_uselib            86
+#define TARGET_NR_swapon            87
+#define TARGET_NR_reboot            88
+#define TARGET_NR_readdir           89
+#define TARGET_NR_mmap              90
+#define TARGET_NR_munmap            91
+#define TARGET_NR_truncate          92
+#define TARGET_NR_ftruncate         93
+#define TARGET_NR_fchmod            94
+#define TARGET_NR_fchown            95
+#define TARGET_NR_getpriority       96
+#define TARGET_NR_setpriority       97
+#define TARGET_NR_profil            98
+#define TARGET_NR_statfs            99
+#define TARGET_NR_fstatfs           100
+#define TARGET_NR_ioperm            101
+#define TARGET_NR_socketcall        102
+#define TARGET_NR_syslog            103
+#define TARGET_NR_setitimer         104
+#define TARGET_NR_getitimer         105
+#define TARGET_NR_stat              106
+#define TARGET_NR_lstat             107
+#define TARGET_NR_fstat             108
+#define TARGET_NR_olduname          109
+#define TARGET_NR_vhangup           111
+#define TARGET_NR_wait4             114
+#define TARGET_NR_swapoff           115
+#define TARGET_NR_sysinfo           116
+#define TARGET_NR_ipc               117
+#define TARGET_NR_fsync             118
+#define TARGET_NR_sigreturn         119
+#define TARGET_NR_clone             120
+#define TARGET_NR_setdomainname     121
+#define TARGET_NR_uname             122
+#define TARGET_NR_cacheflush        123
+#define TARGET_NR_adjtimex          124
+#define TARGET_NR_mprotect          125
+#define TARGET_NR_sigprocmask       126
+#define TARGET_NR_create_module     127
+#define TARGET_NR_init_module       128
+#define TARGET_NR_delete_module     129
+#define TARGET_NR_get_kernel_syms   130
+#define TARGET_NR_quotactl          131
+#define TARGET_NR_getpgid           132
+#define TARGET_NR_fchdir            133
+#define TARGET_NR_bdflush           134
+#define TARGET_NR_sysfs             135
+#define TARGET_NR_personality       136
+#define TARGET_NR_afs_syscall       137 /* Syscall for Andrew File System */
+#define TARGET_NR_setfsuid          138
+#define TARGET_NR_setfsgid          139
+#define TARGET_NR__llseek           140
+#define TARGET_NR_getdents          141
+#define TARGET_NR__newselect        142
+#define TARGET_NR_flock             143
+#define TARGET_NR_msync             144
+#define TARGET_NR_readv             145
+#define TARGET_NR_writev            146
+#define TARGET_NR_getsid            147
+#define TARGET_NR_fdatasync         148
+#define TARGET_NR__sysctl           149
+#define TARGET_NR_mlock             150
+#define TARGET_NR_munlock           151
+#define TARGET_NR_mlockall          152
+#define TARGET_NR_munlockall            153
+#define TARGET_NR_sched_setparam        154
+#define TARGET_NR_sched_getparam        155
+#define TARGET_NR_sched_setscheduler    156
+#define TARGET_NR_sched_getscheduler    157
+#define TARGET_NR_sched_yield       158
+#define TARGET_NR_sched_get_priority_max    159
+#define TARGET_NR_sched_get_priority_min    160
+#define TARGET_NR_sched_rr_get_interval 161
+#define TARGET_NR_nanosleep         162
+#define TARGET_NR_mremap            163
+#define TARGET_NR_setresuid         164
+#define TARGET_NR_getresuid         165
+#define TARGET_NR_getpagesize       166
+#define TARGET_NR_query_module      167
+#define TARGET_NR_poll              168
+#define TARGET_NR_nfsservctl        169
+#define TARGET_NR_setresgid         170
+#define TARGET_NR_getresgid         171
+#define TARGET_NR_prctl             172
+#define TARGET_NR_rt_sigreturn      173
+#define TARGET_NR_rt_sigaction      174
+#define TARGET_NR_rt_sigprocmask    175
+#define TARGET_NR_rt_sigpending     176
+#define TARGET_NR_rt_sigtimedwait   177
+#define TARGET_NR_rt_sigqueueinfo   178
+#define TARGET_NR_rt_sigsuspend     179
+#define TARGET_NR_pread64           180
+#define TARGET_NR_pwrite64          181
+#define TARGET_NR_lchown            182
+#define TARGET_NR_getcwd            183
+#define TARGET_NR_capget            184
+#define TARGET_NR_capset            185
+#define TARGET_NR_sigaltstack       186
+#define TARGET_NR_sendfile          187
+#define TARGET_NR_getpmsg           188 /* some people actually want streams */
+#define TARGET_NR_putpmsg           189 /* some people actually want streams */
+#define TARGET_NR_vfork             190
+#define TARGET_NR_ugetrlimit        191
+#define TARGET_NR_mmap2             192
+#define TARGET_NR_truncate64        193
+#define TARGET_NR_ftruncate64       194
+#define TARGET_NR_stat64            195
+#define TARGET_NR_lstat64           196
+#define TARGET_NR_fstat64           197
+#define TARGET_NR_chown32           198
+#define TARGET_NR_getuid32          199
+#define TARGET_NR_getgid32          200
+#define TARGET_NR_geteuid32         201
+#define TARGET_NR_getegid32         202
+#define TARGET_NR_setreuid32        203
+#define TARGET_NR_setregid32        204
+#define TARGET_NR_getgroups32       205
+#define TARGET_NR_setgroups32       206
+#define TARGET_NR_fchown32          207
+#define TARGET_NR_setresuid32       208
+#define TARGET_NR_getresuid32       209
+#define TARGET_NR_setresgid32       210
+#define TARGET_NR_getresgid32       211
+#define TARGET_NR_lchown32          212
+#define TARGET_NR_setuid32          213
+#define TARGET_NR_setgid32          214
+#define TARGET_NR_setfsuid32        215
+#define TARGET_NR_setfsgid32        216
+#define TARGET_NR_pivot_root        217
+#define TARGET_NR_set_thread_area   218
+#define TARGET_NR_getdents64        220
+#define TARGET_NR_gettid            221
+#define TARGET_NR_tkill             222
+#define TARGET_NR_setxattr          223
+#define TARGET_NR_lsetxattr         224
+#define TARGET_NR_fsetxattr         225
+#define TARGET_NR_getxattr          226
+#define TARGET_NR_lgetxattr         227
+#define TARGET_NR_fgetxattr         228
+#define TARGET_NR_listxattr         229
+#define TARGET_NR_llistxattr        230
+#define TARGET_NR_flistxattr        231
+#define TARGET_NR_removexattr       232
+#define TARGET_NR_lremovexattr      233
+#define TARGET_NR_fremovexattr      234
+#define TARGET_NR_futex             235
+#define TARGET_NR_sendfile64        236
+#define TARGET_NR_mincore           237
+#define TARGET_NR_madvise           238
+#define TARGET_NR_fcntl64           239
+#define TARGET_NR_readahead         240
+#define TARGET_NR_io_setup          241
+#define TARGET_NR_io_destroy        242
+#define TARGET_NR_io_getevents      243
+#define TARGET_NR_io_submit         244
+#define TARGET_NR_io_cancel         245
+#define TARGET_NR_fadvise64         246
+#define TARGET_NR_exit_group        247
+#define TARGET_NR_lookup_dcookie    248
+#define TARGET_NR_epoll_create      249
+#define TARGET_NR_epoll_ctl         250
+#define TARGET_NR_epoll_wait        251
+#define TARGET_NR_remap_file_pages  252
+#define TARGET_NR_set_tid_address   253
+#define TARGET_NR_timer_create      254
+#define TARGET_NR_timer_settime     255
+#define TARGET_NR_timer_gettime     256
+#define TARGET_NR_timer_getoverrun  257
+#define TARGET_NR_timer_delete      258
+#define TARGET_NR_clock_settime     259
+#define TARGET_NR_clock_gettime     260
+#define TARGET_NR_clock_getres      261
+#define TARGET_NR_clock_nanosleep   262
+#define TARGET_NR_statfs64          263
+#define TARGET_NR_fstatfs64         264
+#define TARGET_NR_tgkill            265
+#define TARGET_NR_utimes            266
+#define TARGET_NR_fadvise64_64      267
+#define TARGET_NR_mbind             268
+#define TARGET_NR_get_mempolicy     269
+#define TARGET_NR_set_mempolicy     270
+#define TARGET_NR_mq_open           271
+#define TARGET_NR_mq_unlink         272
+#define TARGET_NR_mq_timedsend      273
+#define TARGET_NR_mq_timedreceive   274
+#define TARGET_NR_mq_notify         275
+#define TARGET_NR_mq_getsetattr     276
+#define TARGET_NR_waitid            277
+#define TARGET_NR_vserver           278
+#define TARGET_NR_add_key           279
+#define TARGET_NR_request_key       280
+#define TARGET_NR_keyctl            281
+#define TARGET_NR_ioprio_set        282
+#define TARGET_NR_ioprio_get        283
+#define TARGET_NR_inotify_init      284
+#define TARGET_NR_inotify_add_watch 285
+#define TARGET_NR_inotify_rm_watch  286
+#define TARGET_NR_migrate_pages     287
+#define TARGET_NR_openat            288
+#define TARGET_NR_mkdirat           289
+#define TARGET_NR_mknodat           290
+#define TARGET_NR_fchownat          291
+#define TARGET_NR_futimesat         292
+#define TARGET_NR_fstatat64         293
+#define TARGET_NR_unlinkat          294
+#define TARGET_NR_renameat          295
+#define TARGET_NR_linkat            296
+#define TARGET_NR_symlinkat         297
+#define TARGET_NR_readlinkat        298
+#define TARGET_NR_fchmodat          299
+#define TARGET_NR_faccessat         300
+#define TARGET_NR_pselect6          301
+#define TARGET_NR_ppoll             302
+#define TARGET_NR_unshare           303
+#define TARGET_NR_set_robust_list   304
+#define TARGET_NR_get_robust_list   305
+#define TARGET_NR_splice            306
+#define TARGET_NR_sync_file_range   307
+#define TARGET_NR_tee               308
+#define TARGET_NR_vmsplice          309
+#define TARGET_NR_move_pages        310
+#define TARGET_NR_sched_setaffinity 311
+#define TARGET_NR_sched_getaffinity 312
+#define TARGET_NR_kexec_load        313
+#define TARGET_NR_getcpu            314
+#define TARGET_NR_epoll_pwait       315
+#define TARGET_NR_utimensat         316
+#define TARGET_NR_signalfd          317
+#define TARGET_NR_timerfd_create    318
+#define TARGET_NR_eventfd           319
+#define TARGET_NR_fallocate         320
+#define TARGET_NR_timerfd_settime   321
+#define TARGET_NR_timerfd_gettime   322
+#define TARGET_NR_signalfd4         323
+#define TARGET_NR_eventfd2          324
+#define TARGET_NR_epoll_create1     325
+#define TARGET_NR_dup3              326
+#define TARGET_NR_pipe2             327
+#define TARGET_NR_inotify_init1     328
+#define TARGET_NR_preadv            329
+#define TARGET_NR_pwritev           330
+#define TARGET_NR_rt_tgsigqueueinfo 331
+#define TARGET_NR_perf_event_open   332
+#endif
diff --git a/linux-user/csky/target_cpu.h b/linux-user/csky/target_cpu.h
new file mode 100644
index 0000000..da6d8a0
--- /dev/null
+++ b/linux-user/csky/target_cpu.h
@@ -0,0 +1,48 @@
+/*
+ * CSKY virtual CPU header
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TARGET_CPU_H
+#define TARGET_CPU_H
+
+static inline void cpu_clone_regs(CPUCSKYState *env, target_ulong newsp)
+{
+#ifdef TARGET_CSKYV1
+    if (newsp) {
+        env->regs[0] = newsp;
+    }
+    env->regs[2] = 0;
+#elif defined  TARGET_CSKYV2
+    if (newsp) {
+        env->regs[14] = newsp;
+    }
+    env->regs[0] = 0;
+#endif
+}
+
+#ifdef TARGET_CSKYV1
+static inline void cpu_set_tls(CPUCSKYState *env, target_ulong newtls)
+{
+    env->tls_value = newtls;
+}
+#elif defined TARGET_CSKYV2
+static inline void cpu_set_tls(CPUCSKYState *env, target_ulong newtls)
+{
+    env->regs[31] = newtls;
+}
+#endif
+
+#endif
diff --git a/linux-user/csky/target_signal.h b/linux-user/csky/target_signal.h
new file mode 100644
index 0000000..205ee88
--- /dev/null
+++ b/linux-user/csky/target_signal.h
@@ -0,0 +1,50 @@
+/*
+ * CSKY signal header.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TARGET_SIGNAL_H
+#define TARGET_SIGNAL_H
+
+#include "cpu.h"
+
+/* this struct defines a stack used during syscall handling */
+
+typedef struct target_sigaltstack {
+    abi_ulong ss_sp;
+    abi_long ss_flags;
+    abi_ulong ss_size;
+} target_stack_t;
+
+
+/*
+ * sigaltstack controls
+ */
+#define TARGET_SS_ONSTACK   1
+#define TARGET_SS_DISABLE   2
+
+#define TARGET_MINSIGSTKSZ  2048
+#define TARGET_SIGSTKSZ     8192
+
+static inline abi_ulong get_sp_from_cpustate(CPUCSKYState *state)
+{
+#if defined(TARGET_CSKYV1)
+    return state->regs[0];
+#else
+    return state->regs[14];
+#endif
+}
+
+#endif /* TARGET_SIGNAL_H */
diff --git a/linux-user/csky/target_structs.h b/linux-user/csky/target_structs.h
new file mode 100644
index 0000000..b3bc4a1
--- /dev/null
+++ b/linux-user/csky/target_structs.h
@@ -0,0 +1,47 @@
+/*
+ * CSKY structs.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef CSKY_TARGET_STRUCTS_H
+#define CSKY_TARGET_STRUCTS_H
+
+struct target_ipc_perm {
+    abi_int __key;                      /* Key.  */
+    abi_uint uid;                       /* Owner's user ID.  */
+    abi_uint gid;                       /* Owner's group ID.  */
+    abi_uint cuid;                      /* Creator's user ID.  */
+    abi_uint cgid;                      /* Creator's group ID.  */
+    abi_uint mode;                      /* Read/write permission.  */
+    abi_ushort __seq;                   /* Sequence number.  */
+    abi_ushort __pad1;
+    abi_ulong __unused1;
+    abi_ulong __unused2;
+};
+
+struct target_shmid_ds {
+    struct target_ipc_perm shm_perm;    /* operation permission struct */
+    abi_long shm_segsz;                 /* size of segment in bytes */
+    abi_ulong shm_atime;                /* time of last shmat() */
+    abi_ulong shm_dtime;                /* time of last shmdt() */
+    abi_ulong shm_ctime;                /* time of last change by shmctl() */
+    abi_int shm_cpid;                   /* pid of creator */
+    abi_int shm_lpid;                   /* pid of last shmop */
+    abi_ulong shm_nattch;               /* number of current attaches */
+    abi_ulong __unused1;
+    abi_ulong __unused2;
+};
+
+#endif
diff --git a/linux-user/csky/target_syscall.h b/linux-user/csky/target_syscall.h
new file mode 100644
index 0000000..13763d3
--- /dev/null
+++ b/linux-user/csky/target_syscall.h
@@ -0,0 +1,69 @@
+/*
+ * CSKY syscall header.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* this struct defines the way the registers are stored on the
+   stack during a system call. */
+struct target_pt_regs {
+    unsigned long   pc;
+    long            r1;
+    /*
+     * When syscall fails, we must recover syscall arg (r2, modified when
+     * syscall return), Modified by Li Chunqiang  20050626.
+     */
+    long            syscallr2;
+    unsigned long   sr; /* psr */
+    long            r2;
+    long            r3;
+    long            r4;
+    long            r5;
+    long            r6;
+    long            r7;
+    long            r8;
+    long            r9;
+    long            r10;
+    long            r11;
+    long            r12;
+    long            r13;
+    long            r14;
+    long            r15;
+#ifdef TARGET_CSKYV2
+    long            r16;
+    long            r17;
+    long            r18;
+    long            r19;
+    long            r20;
+    long            r21;
+    long            r22;
+    long            r23;
+    long            r24;
+    long            r25;
+    long            r26;
+    long            r27;
+    long            r28;
+    long            r29;
+    long            r30;
+    long            r31;
+#endif
+    /* FIXME  add by shangyh */
+    long            r0;
+};
+
+#define UNAME_MINIMUM_RELEASE "2.6.32"
+
+#define TARGET_MINSIGSTKSZ 2048
+#define TARGET_MLOCKALL_MCL_CURRENT 1
+#define TARGET_MLOCKALL_MCL_FUTURE  2
diff --git a/linux-user/csky/termbits.h b/linux-user/csky/termbits.h
new file mode 100644
index 0000000..c6de767
--- /dev/null
+++ b/linux-user/csky/termbits.h
@@ -0,0 +1,249 @@
+/*
+ * CSKY termbits header.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* from asm/termbits.h */
+/* NOTE: exactly the same as i386 */
+
+#define TARGET_NCCS 19
+
+struct target_termios {
+    unsigned int c_iflag;               /* input mode flags */
+    unsigned int c_oflag;               /* output mode flags */
+    unsigned int c_cflag;               /* control mode flags */
+    unsigned int c_lflag;               /* local mode flags */
+    unsigned char c_line;               /* line discipline */
+    unsigned char c_cc[TARGET_NCCS];    /* control characters */
+};
+
+/* c_iflag bits */
+#define TARGET_IGNBRK  0000001
+#define TARGET_BRKINT  0000002
+#define TARGET_IGNPAR  0000004
+#define TARGET_PARMRK  0000010
+#define TARGET_INPCK   0000020
+#define TARGET_ISTRIP  0000040
+#define TARGET_INLCR   0000100
+#define TARGET_IGNCR   0000200
+#define TARGET_ICRNL   0000400
+#define TARGET_IUCLC   0001000
+#define TARGET_IXON    0002000
+#define TARGET_IXANY   0004000
+#define TARGET_IXOFF   0010000
+#define TARGET_IMAXBEL 0020000
+#define TARGET_IUTF8   0040000
+
+/* c_oflag bits */
+#define TARGET_OPOST   0000001
+#define TARGET_OLCUC   0000002
+#define TARGET_ONLCR   0000004
+#define TARGET_OCRNL   0000010
+#define TARGET_ONOCR   0000020
+#define TARGET_ONLRET  0000040
+#define TARGET_OFILL   0000100
+#define TARGET_OFDEL   0000200
+#define TARGET_NLDLY   0000400
+#define   TARGET_NL0   0000000
+#define   TARGET_NL1   0000400
+#define TARGET_CRDLY   0003000
+#define   TARGET_CR0   0000000
+#define   TARGET_CR1   0001000
+#define   TARGET_CR2   0002000
+#define   TARGET_CR3   0003000
+#define TARGET_TABDLY  0014000
+#define   TARGET_TAB0  0000000
+#define   TARGET_TAB1  0004000
+#define   TARGET_TAB2  0010000
+#define   TARGET_TAB3  0014000
+#define   TARGET_XTABS 0014000
+#define TARGET_BSDLY   0020000
+#define   TARGET_BS0   0000000
+#define   TARGET_BS1   0020000
+#define TARGET_VTDLY   0040000
+#define   TARGET_VT0   0000000
+#define   TARGET_VT1   0040000
+#define TARGET_FFDLY   0100000
+#define   TARGET_FF0   0000000
+#define   TARGET_FF1   0100000
+
+/* c_cflag bit meaning */
+#define TARGET_CBAUD   0010017
+#define  TARGET_B0     0000000         /* hang up */
+#define  TARGET_B50    0000001
+#define  TARGET_B75    0000002
+#define  TARGET_B110   0000003
+#define  TARGET_B134   0000004
+#define  TARGET_B150   0000005
+#define  TARGET_B200   0000006
+#define  TARGET_B300   0000007
+#define  TARGET_B600   0000010
+#define  TARGET_B1200  0000011
+#define  TARGET_B1800  0000012
+#define  TARGET_B2400  0000013
+#define  TARGET_B4800  0000014
+#define  TARGET_B9600  0000015
+#define  TARGET_B19200 0000016
+#define  TARGET_B38400 0000017
+#define TARGET_EXTA B19200
+#define TARGET_EXTB B38400
+#define TARGET_CSIZE   0000060
+#define   TARGET_CS5   0000000
+#define   TARGET_CS6   0000020
+#define   TARGET_CS7   0000040
+#define   TARGET_CS8   0000060
+#define TARGET_CSTOPB  0000100
+#define TARGET_CREAD   0000200
+#define TARGET_PARENB  0000400
+#define TARGET_PARODD  0001000
+#define TARGET_HUPCL   0002000
+#define TARGET_CLOCAL  0004000
+#define TARGET_CBAUDEX 0010000
+#define  TARGET_B57600  0010001
+#define  TARGET_B115200 0010002
+#define  TARGET_B230400 0010003
+#define  TARGET_B460800 0010004
+#define  TARGET_B500000 0010005
+#define  TARGET_B576000 0010006
+#define  TARGET_B921600 0010007
+#define  TARGET_B1000000 0010010
+#define  TARGET_B1152000 0010011
+#define  TARGET_B1500000 0010012
+#define  TARGET_B2000000 0010013
+#define  TARGET_B2500000 0010014
+#define  TARGET_B3000000 0010015
+#define  TARGET_B3500000 0010016
+#define  TARGET_B4000000 0010017
+#define TARGET_CIBAUD    002003600000  /* input baud rate (not used) */
+#define TARGET_CMSPAR    010000000000  /* mark or space (stick) parity */
+#define TARGET_CRTSCTS   020000000000  /* flow control */
+
+/* c_lflag bits */
+#define TARGET_ISIG    0000001
+#define TARGET_ICANON  0000002
+#define TARGET_XCASE   0000004
+#define TARGET_ECHO    0000010
+#define TARGET_ECHOE   0000020
+#define TARGET_ECHOK   0000040
+#define TARGET_ECHONL  0000100
+#define TARGET_NOFLSH  0000200
+#define TARGET_TOSTOP  0000400
+#define TARGET_ECHOCTL 0001000
+#define TARGET_ECHOPRT 0002000
+#define TARGET_ECHOKE  0004000
+#define TARGET_FLUSHO  0010000
+#define TARGET_PENDIN  0040000
+#define TARGET_IEXTEN  0100000
+
+/* c_cc character offsets */
+#define TARGET_VINTR    0
+#define TARGET_VQUIT    1
+#define TARGET_VERASE   2
+#define TARGET_VKILL    3
+#define TARGET_VEOF 4
+#define TARGET_VTIME    5
+#define TARGET_VMIN 6
+#define TARGET_VSWTC    7
+#define TARGET_VSTART   8
+#define TARGET_VSTOP    9
+#define TARGET_VSUSP    10
+#define TARGET_VEOL 11
+#define TARGET_VREPRINT 12
+#define TARGET_VDISCARD 13
+#define TARGET_VWERASE  14
+#define TARGET_VLNEXT   15
+#define TARGET_VEOL2    16
+
+/* ioctls */
+
+#define TARGET_TCGETS       0x5401
+#define TARGET_TCSETS       0x5402
+#define TARGET_TCSETSW      0x5403
+#define TARGET_TCSETSF      0x5404
+#define TARGET_TCGETA       0x5405
+#define TARGET_TCSETA       0x5406
+#define TARGET_TCSETAW      0x5407
+#define TARGET_TCSETAF      0x5408
+#define TARGET_TCSBRK       0x5409
+#define TARGET_TCXONC       0x540A
+#define TARGET_TCFLSH       0x540B
+
+#define TARGET_TIOCEXCL 0x540C
+#define TARGET_TIOCNXCL 0x540D
+#define TARGET_TIOCSCTTY    0x540E
+#define TARGET_TIOCGPGRP    0x540F
+#define TARGET_TIOCSPGRP    0x5410
+#define TARGET_TIOCOUTQ 0x5411
+#define TARGET_TIOCSTI      0x5412
+#define TARGET_TIOCGWINSZ   0x5413
+#define TARGET_TIOCSWINSZ   0x5414
+#define TARGET_TIOCMGET 0x5415
+#define TARGET_TIOCMBIS 0x5416
+#define TARGET_TIOCMBIC 0x5417
+#define TARGET_TIOCMSET 0x5418
+#define TARGET_TIOCGSOFTCAR 0x5419
+#define TARGET_TIOCSSOFTCAR 0x541A
+#define TARGET_FIONREAD 0x541B
+#define TARGET_TIOCINQ      TARGET_FIONREAD
+#define TARGET_TIOCLINUX    0x541C
+#define TARGET_TIOCCONS 0x541D
+#define TARGET_TIOCGSERIAL  0x541E
+#define TARGET_TIOCSSERIAL  0x541F
+#define TARGET_TIOCPKT      0x5420
+#define TARGET_FIONBIO      0x5421
+#define TARGET_TIOCNOTTY    0x5422
+#define TARGET_TIOCSETD 0x5423
+#define TARGET_TIOCGETD 0x5424
+#define TARGET_TCSBRKP      0x5425  /* Needed for POSIX tcsendbreak() */
+#define TARGET_TIOCTTYGSTRUCT   0x5426  /* For debugging only */
+#define TARGET_TIOCSBRK 0x5427  /* BSD compatibility */
+#define TARGET_TIOCCBRK 0x5428  /* BSD compatibility */
+#define TARGET_TIOCGSID 0x5429  /* Return the session ID of FD */
+
+/* Get Pty Number (of pty-mux device) */
+#define TARGET_TIOCGPTN TARGET_IOR('T', 0x30, unsigned int)
+
+#define TARGET_TIOCSPTLCK   TARGET_IOW('T', 0x31, int)  /* Lock/unlock Pty */
+
+#define TARGET_FIONCLEX 0x5450  /* these numbers need to be adjusted. */
+#define TARGET_FIOCLEX      0x5451
+#define TARGET_FIOASYNC 0x5452
+#define TARGET_TIOCSERCONFIG    0x5453
+#define TARGET_TIOCSERGWILD 0x5454
+#define TARGET_TIOCSERSWILD 0x5455
+#define TARGET_TIOCGLCKTRMIOS   0x5456
+#define TARGET_TIOCSLCKTRMIOS   0x5457
+#define TARGET_TIOCSERGSTRUCT   0x5458 /* For debugging only */
+#define TARGET_TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TARGET_TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TARGET_TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+/* wait for a change on serial input line(s) */
+#define TARGET_TIOCMIWAIT   0x545C
+/* read serial port inline interrupt counts */
+#define TARGET_TIOCGICOUNT  0x545D
+#define TARGET_TIOCGHAYESESP   0x545E  /* Get Hayes ESP configuration */
+#define TARGET_TIOCSHAYESESP   0x545F  /* Set Hayes ESP configuration */
+
+/* Used for packet mode */
+#define TARGET_TIOCPKT_DATA      0
+#define TARGET_TIOCPKT_FLUSHREAD     1
+#define TARGET_TIOCPKT_FLUSHWRITE    2
+#define TARGET_TIOCPKT_STOP      4
+#define TARGET_TIOCPKT_START         8
+#define TARGET_TIOCPKT_NOSTOP       16
+#define TARGET_TIOCPKT_DOSTOP       32
+
+#define TARGET_TIOCSER_TEMT    0x01 /* Transmitter physically empty */
diff --git a/linux-user/elfload.c b/linux-user/elfload.c
index 547053c..145b7cc 100644
--- a/linux-user/elfload.c
+++ b/linux-user/elfload.c
@@ -257,6 +257,85 @@ static void elf_core_copy_regs(target_elf_gregset_t *regs, const CPUX86State *en
 
 #endif
 
+#ifdef TARGET_CSKY
+
+#define ELF_START_MMAP 0x80000000
+
+#define elf_check_arch(x) ((x) == EM_CSKY)
+
+#define ELF_CLASS   ELFCLASS32
+
+#define ELF_ARCH    EM_CSKY
+
+static inline void init_thread(struct target_pt_regs *regs,
+                               struct image_info *infop)
+{
+    regs->pc = infop->entry;
+    regs->r7 = 0;
+#ifdef TARGET_CSKYV1
+    regs->r0 = infop->start_stack;
+#else
+    regs->r14 = infop->start_stack;
+#endif
+
+}
+
+/* See linux kernel: arch/ckcore/include/asm/elf.h.  */
+#define ELF_NREG 35
+typedef target_elf_greg_t target_elf_gregset_t[ELF_NREG];
+
+/* See linux kernel: arch/ckcore/include/asm/elf.h  */
+static void elf_core_copy_regs(target_elf_gregset_t *regs,
+                               const CPUCSKYState *env)
+{
+    (*regs)[0] = tswapl(env->pc);
+    (*regs)[1] = tswapl(env->regs[1]);
+    //(*regs)[2] = tswapl(env->reg[]);
+    /*  FIXME */
+    (*regs)[3] = tswapl(env->cp0.psr | env->psr_c);
+    (*regs)[4] = tswapl(env->regs[2]);
+    (*regs)[5] = tswapl(env->regs[3]);
+    (*regs)[6] = tswapl(env->regs[4]);
+    (*regs)[7] = tswapl(env->regs[5]);
+    (*regs)[8] = tswapl(env->regs[6]);
+    (*regs)[9] = tswapl(env->regs[7]);
+    (*regs)[10] = tswapl(env->regs[8]);
+    (*regs)[11] = tswapl(env->regs[9]);
+    (*regs)[12] = tswapl(env->regs[10]);
+    (*regs)[13] = tswapl(env->regs[11]);
+    (*regs)[14] = tswapl(env->regs[12]);
+    (*regs)[15] = tswapl(env->regs[13]);
+    (*regs)[16] = tswapl(env->regs[14]);
+    (*regs)[17] = tswapl(env->regs[15]);
+    (*regs)[18] = tswapl(env->regs[0]);
+#if defined (TARGET_CSKYV2)
+    (*regs)[18] = tswapl(env->regs[16]);
+    (*regs)[19] = tswapl(env->regs[17]);
+    (*regs)[20] = tswapl(env->regs[18]);
+    (*regs)[21] = tswapl(env->regs[19]);
+    (*regs)[22] = tswapl(env->regs[20]);
+    (*regs)[23] = tswapl(env->regs[21]);
+    (*regs)[24] = tswapl(env->regs[22]);
+    (*regs)[25] = tswapl(env->regs[23]);
+    (*regs)[26] = tswapl(env->regs[24]);
+    (*regs)[27] = tswapl(env->regs[25]);
+    (*regs)[28] = tswapl(env->regs[26]);
+    (*regs)[29] = tswapl(env->regs[27]);
+    (*regs)[30] = tswapl(env->regs[28]);
+    (*regs)[31] = tswapl(env->regs[29]);
+    (*regs)[32] = tswapl(env->regs[30]);
+    (*regs)[33] = tswapl(env->regs[31]);
+    (*regs)[34] = tswapl(env->regs[0]);
+#endif
+}
+
+#define USE_ELF_CORE_DUMP
+#define ELF_EXEC_PAGESIZE        4096
+
+#define ELF_HWCAP   (0)
+
+#endif /* TARGET_CSKY */
+
 #ifdef TARGET_ARM
 
 #ifndef TARGET_AARCH64
diff --git a/linux-user/main.c b/linux-user/main.c
index 65a769c..8d99de8 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -71,6 +71,8 @@ do {                                                                    \
 # ifdef TARGET_MIPS
 /* MIPS only supports 31 bits of virtual address space for user space */
 unsigned long reserved_va = 0x77000000;
+# elif TARGET_CSKY
+unsigned long reserved_va = 0x40000000;
 # else
 unsigned long reserved_va = 0xf7000000;
 # endif
@@ -368,6 +370,149 @@ void cpu_loop(CPUX86State *env)
 }
 #endif
 
+#ifdef TARGET_CSKY
+
+void cpu_loop(CPUCSKYState *env)
+{
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+    int trapnr;
+    int *host_ptr;
+    target_siginfo_t info;
+    abi_ulong pc;
+
+    for (;;)
+    {
+        cpu_exec_start(cs);
+        trapnr = cpu_exec(cs);
+        cpu_exec_end(cs);
+        process_queued_cpu_work(cs);
+
+        switch (trapnr)
+        {
+        case EXCP_INTERRUPT:
+            /* just indicate that signals should be handled asap */
+            break;
+        case EXCP_DEBUG:
+            {
+                int sig;
+
+                sig = gdb_handlesig(cs, TARGET_SIGTRAP);
+                if (sig)
+                {
+                    info.si_signo = sig;
+                    info.si_errno = 0;
+                    info.si_code = TARGET_TRAP_BRKPT;
+                    queue_signal(env, info.si_signo, QEMU_SI_FAULT, &info);
+                }
+            }
+            break;
+        case EXCP_CSKY_TRAP0:
+            /*FIXME implement tls*/
+#if defined (TARGET_CSKYV1)
+            env->pc += 2;
+            /*CLONE_SETTLS=0x8000 */
+#if defined(CONFIG_CSKY_KERNEL_4X)
+           if((env->regs[1] == 220) && (env->regs[2] & 0x8000)){
+                cpu_set_tls(env, env->regs[6]);
+            }
+            if(env->regs[1] == 244){
+                cpu_set_tls(env, env->regs[2]);
+                break;
+            }
+#else
+           if((env->regs[1] == 120) && (env->regs[2] & 0x8000)){
+                cpu_set_tls(env, env->regs[6]);
+            }
+            if(env->regs[1] == 218){
+                cpu_set_tls(env, env->regs[2]);
+                break;
+            }
+#endif
+            env->regs[2] = do_syscall(env, env->regs[1],
+                                      env->regs[2], env->regs[3], env->regs[4],
+                                      env->regs[5], env->regs[6], env->regs[7],
+                                      0, 0);
+#else
+            env->pc += 4;
+            /*two ways to set tls*/
+#if defined(CONFIG_CSKY_KERNEL_4X)
+            if((env->regs[7] == 220) && (env->regs[0] & 0x8000)){
+                cpu_set_tls(env, env->regs[4]);
+            }
+            if(env->regs[7] == 244){
+                cpu_set_tls(env, env->regs[0]);
+                break;
+            }
+#else
+            if((env->regs[7] == 120) && (env->regs[0] & 0x8000)){
+                cpu_set_tls(env, env->regs[4]);
+            }
+            if(env->regs[7] == 218){
+                cpu_set_tls(env, env->regs[0]);
+                break;
+            }
+#endif
+            env->regs[0] = do_syscall(env, env->regs[7],
+                                      env->regs[0], env->regs[1], env->regs[2],
+                                      env->regs[3], env->regs[4], env->regs[5],
+                                      0, 0);
+#endif
+            break;
+        case EXCP_CSKY_TRAP2:
+#if defined(TARGET_CSKYV1)
+            env->pc += 2;
+            host_ptr = g2h(env->regs[4]);
+            if(tswap32(env->regs[2]) != *host_ptr)
+                env->regs[2] = 1;
+            else{
+                *host_ptr = tswap32(env->regs[3]);
+                env->regs[2] = 0;
+            }
+#elif defined(TARGET_CSKYV2)
+            env->pc += 4;
+            host_ptr = g2h(env->regs[2]);
+            if(tswap32(env->regs[0]) != *host_ptr)
+                env->regs[0] = 1;
+            else{
+                *host_ptr = tswap32(env->regs[1]);
+                env->regs[0] = 0;
+            }
+#endif
+            break;
+        case EXCP_CSKY_TRAP3:
+#if defined(TARGET_CSKYV1)
+            env->pc += 2;
+            env->regs[2] = env->tls_value;
+            break;
+#elif  defined(TARGET_CSKYV2)
+            fprintf(stderr, "Dont need to implemente trap3 in cskyv2\n");
+            break;
+#endif
+        case EXCP_CSKY_DIV:
+            {
+                info.si_signo = SIGFPE;
+                info.si_errno = 0;
+                info.si_code = TARGET_FPE_INTDIV;
+                queue_signal(env, info.si_signo, QEMU_SI_FAULT, &info);
+            }
+            break;
+        case EXCP_CSKY_DATA_ABORT:      /* fall through */
+        case EXCP_CSKY_UDEF:            /* fall through */
+        case EXCP_CSKY_PRIVILEGE:       /* fall through */
+        case EXCP_CSKY_BKPT:            /* fall through */
+        default:
+            pc = env->pc;
+            fprintf(stderr, "qemu: 0x%08x: unhandled CPU exception 0x%x - aborting\n",
+                    pc, trapnr);
+            /* TODO: call cpu_dump_state */
+            abort();
+        }
+        process_pending_signals(env);
+    }
+}
+
+#endif
+
 #ifdef TARGET_ARM
 
 #define get_user_code_u32(x, gaddr, env)                \
@@ -2638,7 +2783,7 @@ void cpu_loop(CPUCRISState *env)
     CPUState *cs = CPU(cris_env_get_cpu(env));
     int trapnr, ret;
     target_siginfo_t info;
-    
+
     while (1) {
         cpu_exec_start(cs);
         trapnr = cpu_exec(cs);
@@ -2660,13 +2805,13 @@ void cpu_loop(CPUCRISState *env)
 	  /* just indicate that signals should be handled asap */
 	  break;
         case EXCP_BREAK:
-            ret = do_syscall(env, 
-                             env->regs[9], 
-                             env->regs[10], 
-                             env->regs[11], 
-                             env->regs[12], 
-                             env->regs[13], 
-                             env->pregs[7], 
+            ret = do_syscall(env,
+                             env->regs[9],
+                             env->regs[10],
+                             env->regs[11],
+                             env->regs[12],
+                             env->regs[13],
+                             env->pregs[7],
                              env->pregs[11],
                              0, 0);
             if (ret == -TARGET_ERESTARTSYS) {
@@ -2708,7 +2853,7 @@ void cpu_loop(CPUMBState *env)
     CPUState *cs = CPU(mb_env_get_cpu(env));
     int trapnr, ret;
     target_siginfo_t info;
-    
+
     while (1) {
         cpu_exec_start(cs);
         trapnr = cpu_exec(cs);
@@ -2733,13 +2878,13 @@ void cpu_loop(CPUMBState *env)
             /* Return address is 4 bytes after the call.  */
             env->regs[14] += 4;
             env->sregs[SR_PC] = env->regs[14];
-            ret = do_syscall(env, 
-                             env->regs[12], 
-                             env->regs[5], 
-                             env->regs[6], 
-                             env->regs[7], 
-                             env->regs[8], 
-                             env->regs[9], 
+            ret = do_syscall(env,
+                             env->regs[12],
+                             env->regs[5],
+                             env->regs[6],
+                             env->regs[7],
+                             env->regs[8],
+                             env->regs[9],
                              env->regs[10],
                              0, 0);
             if (ret == -TARGET_ERESTARTSYS) {
@@ -3635,6 +3780,18 @@ static void handle_arg_stack_size(const char *arg)
     }
 }
 
+static int jcount_start;
+static int jcount_end;
+static void handle_jcount_start(const char *arg)
+{
+    jcount_start = strtoul(arg, NULL, 16);
+}
+
+static void handle_jcount_end(const char *arg)
+{
+    jcount_end = strtoul(arg, NULL, 16);
+}
+
 static void handle_arg_ld_prefix(const char *arg)
 {
     interp_prefix = strdup(arg);
@@ -3735,6 +3892,12 @@ static void handle_arg_strace(const char *arg)
     do_strace = 1;
 }
 
+static int do_tb_trace;
+static void handle_arg_tb_trace(const char *arg)
+{
+    do_tb_trace = 1;
+}
+
 static void handle_arg_version(const char *arg)
 {
     printf("qemu-" TARGET_NAME " version " QEMU_VERSION QEMU_PKGVERSION
@@ -3794,6 +3957,12 @@ static const struct qemu_argument arg_table[] = {
      "",           "run in singlestep mode"},
     {"strace",     "QEMU_STRACE",      false, handle_arg_strace,
      "",           "log system calls"},
+    {"tb_trace",   "QEMU_TB_TRACE",    false, handle_arg_tb_trace,
+     "",           "log all tb trace"},
+    {"jcount_start", "QEMU_JCOUNT_START", true, handle_jcount_start,
+     "addr",       "set the start addr for jcount"},
+    {"jcount_end", "QEMU_JCOUNT_END",     true, handle_jcount_end,
+     "addr",       "set the end addr for jcount"},
     {"seed",       "QEMU_RAND_SEED",   true,  handle_arg_randseed,
      "",           "Seed for pseudo-random number generator"},
     {"trace",      "QEMU_TRACE",       true,  handle_arg_trace,
@@ -4020,6 +4189,10 @@ int main(int argc, char **argv, char **envp)
 #endif
 #elif defined(TARGET_ARM)
         cpu_model = "any";
+#elif defined(TARGET_CSKYV1)
+        cpu_model = "ck610ef";
+#elif defined(TARGET_CSKYV2)
+        cpu_model = "ck810f";
 #elif defined(TARGET_UNICORE32)
         cpu_model = "any";
 #elif defined(TARGET_M68K)
@@ -4069,6 +4242,23 @@ int main(int argc, char **argv, char **envp)
         do_strace = 1;
     }
 
+    if (getenv("QEMU_TB_TRACE")) {
+        do_tb_trace = 1;
+    }
+
+#ifdef TARGET_CSKY
+    if (do_tb_trace == 1) {
+        env->tb_trace = 1;
+    }
+
+    if (jcount_start != 0) {
+        env->jcount_start = jcount_start;
+        env->jcount_end = jcount_end;
+    } else {
+        env->jcount_start = 0;
+        env->jcount_end = 0;
+    }
+#endif
     if (getenv("QEMU_RAND_SEED")) {
         handle_arg_randseed(getenv("QEMU_RAND_SEED"));
     }
@@ -4309,6 +4499,48 @@ int main(int argc, char **argv, char **envp)
     cpu_x86_load_seg(env, R_FS, 0);
     cpu_x86_load_seg(env, R_GS, 0);
 #endif
+#elif defined(TARGET_CSKY)
+    {
+        env->regs[0] = regs->r0;
+        env->regs[1] = regs->r1;
+        env->regs[2] = regs->r2;
+        env->regs[3] = regs->r3;
+        env->regs[4] = regs->r4;
+        env->regs[5] = regs->r5;
+        env->regs[6] = regs->r6;
+        env->regs[7] = regs->r7;
+        env->regs[8] = regs->r8;
+        env->regs[9] = regs->r9;
+        env->regs[10] = regs->r10;
+        env->regs[11] = regs->r11;
+        env->regs[12] = regs->r12;
+        env->regs[13] = regs->r13;
+        env->regs[14] = regs->r14;
+        env->regs[15] = regs->r15;
+#if defined (TARGET_CSKYV2)
+        env->regs[16] = regs->r16;
+        env->regs[17] = regs->r17;
+        env->regs[18] = regs->r18;
+        env->regs[19] = regs->r19;
+        env->regs[20] = regs->r20;
+        env->regs[21] = regs->r21;
+        env->regs[22] = regs->r22;
+        env->regs[23] = regs->r23;
+        env->regs[24] = regs->r24;
+        env->regs[25] = regs->r25;
+        env->regs[26] = regs->r26;
+        env->regs[27] = regs->r27;
+        env->regs[28] = regs->r28;
+        env->regs[29] = regs->r29;
+        env->regs[30] = regs->r30;
+        env->regs[31] = regs->r31;
+#endif
+        env->pc = regs->pc;
+        env->cp0.psr = regs->sr;
+        env->psr_c = 0;
+        env->psr_s = 0;
+        env->dcsr_v = 0;
+    }
 #elif defined(TARGET_AARCH64)
     {
         int i;
@@ -4419,23 +4651,23 @@ int main(int argc, char **argv, char **envp)
         env->regs[12] = regs->r12;
         env->regs[13] = regs->r13;
         env->regs[14] = regs->r14;
-        env->regs[15] = regs->r15;	    
-        env->regs[16] = regs->r16;	    
-        env->regs[17] = regs->r17;	    
-        env->regs[18] = regs->r18;	    
-        env->regs[19] = regs->r19;	    
-        env->regs[20] = regs->r20;	    
-        env->regs[21] = regs->r21;	    
-        env->regs[22] = regs->r22;	    
-        env->regs[23] = regs->r23;	    
-        env->regs[24] = regs->r24;	    
-        env->regs[25] = regs->r25;	    
-        env->regs[26] = regs->r26;	    
-        env->regs[27] = regs->r27;	    
-        env->regs[28] = regs->r28;	    
-        env->regs[29] = regs->r29;	    
-        env->regs[30] = regs->r30;	    
-        env->regs[31] = regs->r31;	    
+        env->regs[15] = regs->r15;
+        env->regs[16] = regs->r16;
+        env->regs[17] = regs->r17;
+        env->regs[18] = regs->r18;
+        env->regs[19] = regs->r19;
+        env->regs[20] = regs->r20;
+        env->regs[21] = regs->r21;
+        env->regs[22] = regs->r22;
+        env->regs[23] = regs->r23;
+        env->regs[24] = regs->r24;
+        env->regs[25] = regs->r25;
+        env->regs[26] = regs->r26;
+        env->regs[27] = regs->r27;
+        env->regs[28] = regs->r28;
+        env->regs[29] = regs->r29;
+        env->regs[30] = regs->r30;
+        env->regs[31] = regs->r31;
         env->sregs[SR_PC] = regs->pc;
     }
 #elif defined(TARGET_MIPS)
@@ -4511,7 +4743,7 @@ int main(int argc, char **argv, char **envp)
 	    env->regs[12] = regs->r12;
 	    env->regs[13] = regs->r13;
 	    env->regs[14] = info->start_stack;
-	    env->regs[15] = regs->acr;	    
+	    env->regs[15] = regs->acr;
 	    env->pc = regs->erp;
     }
 #elif defined(TARGET_S390X)
diff --git a/linux-user/signal.c b/linux-user/signal.c
index c750053..9251324 100644
--- a/linux-user/signal.c
+++ b/linux-user/signal.c
@@ -1170,7 +1170,7 @@ long do_sigreturn(CPUX86State *env)
 
     trace_user_do_sigreturn(env, frame_addr);
     if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))
-        goto badframe;
+		goto badframe;
     /* set blocked signals */
     __get_user(target_set.sig[0], &frame->sc.oldmask);
     for(i = 1; i < TARGET_NSIG_WORDS; i++) {
@@ -2249,6 +2249,720 @@ long do_rt_sigreturn(CPUARMState *env)
     }
 }
 
+#elif defined(TARGET_CSKY)
+
+#if defined(TARGET_CSKYV1)
+#define CSKY_NGREG 19
+#elif defined(TARGET_CSKYV2)
+#define CSKY_NGREG 35
+#endif
+
+
+#ifdef CONFIG_CSKY_KERNEL_4X
+struct target_sigcontext {
+    abi_ulong  sc_mask;     /* old sigmask */
+    abi_ulong  sc_usp;      /* old user stack pointer */
+    abi_ulong  sc_a0;
+    abi_ulong  sc_a1;
+    abi_ulong  sc_a2;
+    abi_ulong  sc_a3;
+    abi_ulong  sc_regs[10];
+    abi_ulong  sc_r15;
+#ifdef TARGET_CSKYV2
+    abi_ulong  sc_exregs[16];
+    abi_ulong  sc_rhi;
+    abi_ulong  sc_rlo;
+#endif
+    abi_ulong  sc_sr;       /* psr */
+    abi_ulong  sc_pc;
+
+    abi_ulong  sc_fcr;
+    abi_ulong  sc_fsr;
+    abi_ulong  sc_fesr;
+    abi_ulong  sc_feinst1;
+    abi_ulong  sc_feinst2;
+    abi_ulong  sc_fpregs[32];
+
+};
+
+struct target_ucontext {
+    unsigned long           tuc_flags;
+    struct target_ucontext  *tuc_link;
+    target_stack_t          tuc_stack;
+    struct sigcontext        tuc_mcontext;
+    target_sigset_t         tuc_sigmask;    /* mask last for extensibility */
+};
+
+struct rt_sigframe
+{
+    abi_long sig;
+    abi_ulong pinfo;
+    abi_ulong puc;
+    struct target_siginfo info;
+    struct target_ucontext uc;
+    uint16_t retcode[4];                /* include <stdint> ?? */
+};
+#else
+typedef struct fpregset {
+    int f_fsr;
+    int f_fesr;
+    int f_feinst1;
+    int f_feinst2;
+    int f_fpregs[32];
+} csky_fpregset_t;
+
+
+struct ckcontext {
+    int version;
+    greg_t gregs[CSKY_NGREG];
+    csky_fpregset_t fpregs;
+};
+
+#define MCONTEXT_VERSION 2
+
+struct target_ucontext {
+    unsigned long           tuc_flags;
+    struct target_ucontext  *tuc_link;
+    target_stack_t          tuc_stack;
+    struct ckcontext        tuc_mcontext;
+    target_sigset_t         tuc_sigmask;    /* mask last for extensibility */
+};
+
+
+struct target_sigcontext {
+    abi_ulong  sc_mask;     /* old sigmask */
+    abi_ulong  sc_usp;      /* old user stack pointer */
+    abi_ulong  sc_r1;
+    abi_ulong  sc_r2;
+    abi_ulong  sc_r3;
+    abi_ulong  sc_r4;
+    abi_ulong  sc_r5;
+    abi_ulong  sc_r6;
+    abi_ulong  sc_r7;
+    abi_ulong  sc_r8;
+    abi_ulong  sc_r9;
+    abi_ulong  sc_r10;
+    abi_ulong  sc_r11;
+    abi_ulong  sc_r12;
+    abi_ulong  sc_r13;
+    abi_ulong  sc_r14;
+    abi_ulong  sc_r15;
+#ifdef TARGET_CSKYV2
+    abi_ulong  sc_r16;
+    abi_ulong  sc_r17;
+    abi_ulong  sc_r18;
+    abi_ulong  sc_r19;
+    abi_ulong  sc_r20;
+    abi_ulong  sc_r21;
+    abi_ulong  sc_r22;
+    abi_ulong  sc_r23;
+    abi_ulong  sc_r24;
+    abi_ulong  sc_r25;
+    abi_ulong  sc_r26;
+    abi_ulong  sc_r27;
+    abi_ulong  sc_r28;
+    abi_ulong  sc_r29;
+    abi_ulong  sc_r30;
+    abi_ulong  sc_r31;
+    abi_ulong  sc_r32;
+#endif
+    abi_ulong  sc_sr;       /* psr */
+    abi_ulong  sc_pc;
+
+    abi_ulong  sc_fsr;
+    abi_ulong  sc_fesr;
+    abi_ulong  sc_feinst1;
+    abi_ulong  sc_feinst2;
+    abi_ulong  sc_fpregs[32];
+
+};
+
+struct sigframe
+{
+    abi_long sig;
+    struct target_sigcontext sc;
+    uint16_t retcode[4];                /* include <stdint.h> ?? */
+    abi_ulong extramask[TARGET_NSIG_WORDS-1];
+};
+
+struct rt_sigframe
+{
+    abi_long sig;
+    abi_ulong pinfo;
+    abi_ulong puc;
+    struct target_siginfo info;
+    struct target_ucontext uc;
+    uint16_t retcode[4];                /* include <stdint> ?? */
+};
+#endif
+
+static void
+rt_save_fpu_state(struct target_ucontext *uc,
+                  CPUCSKYState *env)
+{
+#ifdef CONFIG_CPU_HAS_FPU
+#error "not implemented yet"
+#endif
+}
+
+static void
+rt_restore_fpu_state(struct target_ucontext *uc,
+                     CPUCSKYState *env)
+{
+#ifdef CONFIG_CPU_HAS_FPU
+#error "not implemented yet"
+#endif
+}
+
+static inline abi_ulong
+get_sigframe(struct target_sigaction *ka, CPUCSKYState *env, size_t frame_size)
+{
+#ifdef TARGET_CSKYV1
+    unsigned long sp = env->regs[0];
+#elif defined TARGET_CSKYV2
+    unsigned long sp = env->regs[14];
+#endif
+    /* This is the X/Open sanctioned signal stack switching.  */
+    if ((ka->sa_flags & TARGET_SA_ONSTACK) && !sas_ss_flags(sp))
+        sp = target_sigaltstack_used.ss_sp + target_sigaltstack_used.ss_size;
+
+    /* force 8-byte align */
+    return (sp - frame_size) & ~7;
+}
+
+#ifdef CONFIG_CSKY_KERNEL_4X
+static void
+setup_return(CPUCSKYState *env, struct target_sigaction *ka,
+             uint16_t rc[], int usig, abi_ulong rc_addr, int real_time)
+{
+    /* abi_ulong handler = ka->_sa_handler; */
+    abi_ulong retcode;
+    /* int err = 0; */
+
+    if (ka->sa_flags & TARGET_SA_RESTORER) {
+        retcode = ka->sa_restorer;
+    } else {
+#if defined(TARGET_CSKYV1)
+        /* movi r1, 127; addi r1, 32; addi r1, (_NR_rt_sigreturn - 127 -32); trap0 */
+        __put_user(0x6000 + (127 << 4) + 1, rc);
+        __put_user(0x2000 + (31 << 4) +1, rc + 1);
+        __put_user(0x2000 + ((TARGET_NR_rt_sigreturn - 127 - 32 -1) << 4) + 1, rc + 2);
+        __put_user(0x0008, rc + 3);
+#elif defined(TARGET_CSKYV2)
+        __put_user(0xea07, rc);/* movi r7, xxx */
+        __put_user(TARGET_NR_rt_sigreturn, rc + 1);
+        __put_user(0xC000, rc + 2);/* trap32 0 */
+        __put_user(0x2020, rc + 3);
+#endif
+        retcode = rc_addr;
+    }
+
+    env->pc = ka->_sa_handler;
+#if defined(TARGET_CSKYV1)
+    env->regs[2] = usig;
+#elif defined(TARGET_CSKYV2)
+    env->regs[0] = usig;
+#endif
+    env->regs[15] = retcode;
+}
+
+static int rt_setup_ucontext(struct target_ucontext *uc, CPUCSKYState *env)
+{
+    struct target_sigcontext* sc =  (struct target_sigcontext*)&uc->tuc_mcontext;
+    int i = 0;
+    __put_user(env->pc, &sc->sc_pc);
+    __put_user(env->regs[14], &sc->sc_usp);
+    __put_user(env->regs[0], &sc->sc_a0);
+    __put_user(env->regs[1], &sc->sc_a1);
+    __put_user(env->regs[2], &sc->sc_a2);
+    __put_user(env->regs[3], &sc->sc_a3);
+    for(i = 0; i < 10; i++)
+    {
+        __put_user(env->regs[i+4], &sc->sc_regs[i]);
+    }
+    __put_user(env->regs[15], &sc->sc_r15);
+#ifdef TARGET_CSKYV2
+   for(i = 0; i < 16; i++)
+    {
+        __put_user(env->regs[i+16], &sc->sc_exregs[i]);
+    }
+    __put_user(env->hi, &sc->sc_rhi);
+    __put_user(env->lo, &sc->sc_rlo);
+#endif
+    __put_user(env->cp0.psr | env->psr_c, &sc->sc_sr);
+    rt_save_fpu_state(uc, env);
+
+    return 0;
+}
+
+static void rt_restore_ucontext(struct target_ucontext *uc, CPUCSKYState *env)
+{
+    struct target_sigcontext *sc =(struct target_sigcontext*)&uc->tuc_mcontext;
+    int i=0;
+    __get_user(env->pc, &sc->sc_pc);
+    __get_user(env->regs[14], &sc->sc_usp);
+    __get_user(env->regs[0], &sc->sc_a0);
+    __get_user(env->regs[1], &sc->sc_a1);
+    __get_user(env->regs[2], &sc->sc_a2);
+    __get_user(env->regs[3], &sc->sc_a3);
+    for(i = 0; i < 10; i++)
+    {
+        __get_user(env->regs[i+4], &sc->sc_regs[i]);
+    }
+    __get_user(env->regs[15], &sc->sc_r15);
+#ifdef TARGET_CSKYV2
+    for(i = 0; i < 16; i++)
+    {
+        __get_user(env->regs[i+16], &sc->sc_exregs[i]);
+    }
+    __get_user(env->hi, &sc->sc_rhi);
+    __get_user(env->lo, &sc->sc_rlo);
+#endif
+    __get_user(env->cp0.psr, &sc->sc_sr);
+    __get_user(env->psr_c, &sc->sc_sr);
+    env->cp0.psr &= 0xfffe;
+    env->psr_c &= 0x0001;
+    rt_restore_fpu_state(uc, env);
+}
+
+#else
+
+static void
+save_fpu_state(struct target_sigcontext *sc,
+               CPUCSKYState *env)
+{
+#ifdef CONFIG_CPU_HAS_FPU
+#error "not implemented yet"
+#endif
+}
+
+static void
+restore_fpu_state(struct target_sigcontext *sc,
+                  CPUCSKYState *env)
+{
+#ifdef CONFIG_CPU_HAS_FPU
+#error "not implemented yet"
+#endif
+}
+
+static void
+setup_sigcontext(struct target_sigcontext *sc,
+                 CPUCSKYState *env, abi_ulong mask)
+{
+    __put_user(env->regs[0], &sc->sc_usp);
+    __put_user(env->regs[1], &sc->sc_r1);
+    __put_user(env->regs[2], &sc->sc_r2);
+    __put_user(env->regs[3], &sc->sc_r3);
+    __put_user(env->regs[4], &sc->sc_r4);
+    __put_user(env->regs[5], &sc->sc_r5);
+    __put_user(env->regs[6], &sc->sc_r6);
+    __put_user(env->regs[7], &sc->sc_r7);
+    __put_user(env->regs[8], &sc->sc_r8);
+    __put_user(env->regs[9], &sc->sc_r9);
+    __put_user(env->regs[10], &sc->sc_r10);
+    __put_user(env->regs[11], &sc->sc_r11);
+    __put_user(env->regs[12], &sc->sc_r12);
+    __put_user(env->regs[13], &sc->sc_r13);
+    __put_user(env->regs[14], &sc->sc_r14);
+    __put_user(env->regs[15], &sc->sc_r15);
+#ifdef TARGET_CSKYV2
+    __put_user(env->regs[16], &sc->sc_r16);
+    __put_user(env->regs[17], &sc->sc_r17);
+    __put_user(env->regs[18], &sc->sc_r18);
+    __put_user(env->regs[19], &sc->sc_r19);
+    __put_user(env->regs[20], &sc->sc_r20);
+    __put_user(env->regs[21], &sc->sc_r21);
+    __put_user(env->regs[22], &sc->sc_r22);
+    __put_user(env->regs[23], &sc->sc_r23);
+    __put_user(env->regs[24], &sc->sc_r24);
+    __put_user(env->regs[25], &sc->sc_r25);
+    __put_user(env->regs[26], &sc->sc_r26);
+    __put_user(env->regs[27], &sc->sc_r27);
+    __put_user(env->regs[28], &sc->sc_r28);
+    __put_user(env->regs[29], &sc->sc_r29);
+    __put_user(env->regs[30], &sc->sc_r30);
+    __put_user(env->regs[31], &sc->sc_r31);
+#endif
+
+    /*  FIXME shangyh */
+    /* __put_user(mask, &sc->sc_mask); */
+    __put_user(env->pc, &sc->sc_pc);  /* pc??? */
+    /*  FIXME shangyh */
+    __put_user((env->cp0.psr | env->psr_c), &sc->sc_sr);   /* what's sr??? */
+
+    save_fpu_state(sc, env);
+}
+
+static void
+restore_sigcontext(CPUCSKYState *env, struct target_sigcontext *sc)
+{
+    __get_user(env->regs[0], &sc->sc_usp);
+    __get_user(env->regs[1], &sc->sc_r1);
+    __get_user(env->regs[2], &sc->sc_r2);
+    __get_user(env->regs[3], &sc->sc_r3);
+    __get_user(env->regs[4], &sc->sc_r4);
+    __get_user(env->regs[5], &sc->sc_r5);
+    __get_user(env->regs[6], &sc->sc_r6);
+    __get_user(env->regs[7], &sc->sc_r7);
+    __get_user(env->regs[8], &sc->sc_r8);
+    __get_user(env->regs[9], &sc->sc_r9);
+    __get_user(env->regs[10], &sc->sc_r10);
+    __get_user(env->regs[11], &sc->sc_r11);
+    __get_user(env->regs[12], &sc->sc_r12);
+    __get_user(env->regs[13], &sc->sc_r13);
+    __get_user(env->regs[14], &sc->sc_r14);
+    __get_user(env->regs[15], &sc->sc_r15);
+#ifdef TARGET_CSKYV2
+    __get_user(env->regs[16], &sc->sc_r16);
+    __get_user(env->regs[17], &sc->sc_r17);
+    __get_user(env->regs[18], &sc->sc_r18);
+    __get_user(env->regs[19], &sc->sc_r19);
+    __get_user(env->regs[20], &sc->sc_r20);
+    __get_user(env->regs[21], &sc->sc_r21);
+    __get_user(env->regs[22], &sc->sc_r22);
+    __get_user(env->regs[23], &sc->sc_r23);
+    __get_user(env->regs[24], &sc->sc_r24);
+    __get_user(env->regs[25], &sc->sc_r25);
+    __get_user(env->regs[26], &sc->sc_r26);
+    __get_user(env->regs[27], &sc->sc_r27);
+    __get_user(env->regs[28], &sc->sc_r28);
+    __get_user(env->regs[29], &sc->sc_r29);
+    __get_user(env->regs[30], &sc->sc_r30);
+    __get_user(env->regs[31], &sc->sc_r31);
+#endif
+
+    /* FIXME  add by shangyh */
+    /* __get_user(mask, &sc->sc_mask); */
+    __get_user(env->pc, &sc->sc_pc);  /* pc??? */
+    __get_user(env->cp0.psr, &sc->sc_sr);   /* what's sr??? */
+    __get_user(env->psr_c, &sc->sc_sr);
+    env->cp0.psr &= 0xfffe;
+    env->psr_c &= 0x0001;
+
+    restore_fpu_state(sc, env);
+}
+
+static void
+rt_setup_ucontext(struct target_ucontext *uc, CPUCSKYState *env)
+{
+    greg_t *gregs = uc->tuc_mcontext.gregs;
+    __put_user(MCONTEXT_VERSION, &uc->tuc_mcontext.version);
+    __put_user(env->pc, &gregs[0]);
+    __put_user(env->regs[1], &gregs[1]);
+    __put_user(-1, &gregs[2]);
+    __put_user(env->cp0.psr | env->psr_c, &gregs[3]);
+    __put_user(env->regs[2], &gregs[4]);
+    __put_user(env->regs[3], &gregs[5]);
+    __put_user(env->regs[4], &gregs[6]);
+    __put_user(env->regs[5], &gregs[7]);
+    __put_user(env->regs[6], &gregs[8]);
+    __put_user(env->regs[7], &gregs[9]);
+    __put_user(env->regs[8], &gregs[10]);
+    __put_user(env->regs[9], &gregs[11]);
+    __put_user(env->regs[10], &gregs[12]);
+    __put_user(env->regs[11], &gregs[13]);
+    __put_user(env->regs[12], &gregs[14]);
+    __put_user(env->regs[13], &gregs[15]);
+    __put_user(env->regs[14], &gregs[16]);
+    __put_user(env->regs[15], &gregs[17]);
+#ifdef TARGET_CSKYV2
+    __put_user(env->regs[16], &gregs[18]);
+    __put_user(env->regs[17], &gregs[19]);
+    __put_user(env->regs[18], &gregs[20]);
+    __put_user(env->regs[19], &gregs[21]);
+    __put_user(env->regs[20], &gregs[22]);
+    __put_user(env->regs[21], &gregs[23]);
+    __put_user(env->regs[22], &gregs[24]);
+    __put_user(env->regs[23], &gregs[25]);
+    __put_user(env->regs[24], &gregs[26]);
+    __put_user(env->regs[25], &gregs[27]);
+    __put_user(env->regs[26], &gregs[28]);
+    __put_user(env->regs[27], &gregs[29]);
+    __put_user(env->regs[28], &gregs[30]);
+    __put_user(env->regs[29], &gregs[31]);
+    __put_user(env->regs[30], &gregs[32]);
+    __put_user(env->regs[31], &gregs[33]);
+#endif
+    __put_user(env->regs[0], &gregs[34]);
+
+    rt_save_fpu_state(uc, env);
+}
+
+static void
+rt_restore_ucontext(struct target_ucontext *uc, CPUCSKYState *env)
+{
+    greg_t *gregs = uc->tuc_mcontext.gregs;
+    __get_user(MCONTEXT_VERSION, &uc->tuc_mcontext.version);
+    __get_user(env->pc, &gregs[0]);
+    __get_user(env->regs[1], &gregs[1]);
+    __get_user(-1, &gregs[2]);
+    __get_user(env->cp0.psr , &gregs[3]);
+    __get_user(env->psr_c, &gregs[3]);
+    env->cp0.psr &= 0xfffe;
+    env->psr_c &= 0x0001;
+
+     __get_user(env->regs[2], &gregs[4]);
+    __get_user(env->regs[3], &gregs[5]);
+    __get_user(env->regs[4], &gregs[6]);
+    __get_user(env->regs[5], &gregs[7]);
+    __get_user(env->regs[6], &gregs[8]);
+    __get_user(env->regs[7], &gregs[9]);
+    __get_user(env->regs[8], &gregs[10]);
+    __get_user(env->regs[9], &gregs[11]);
+    __get_user(env->regs[10], &gregs[12]);
+    __get_user(env->regs[11], &gregs[13]);
+    __get_user(env->regs[12], &gregs[14]);
+    __get_user(env->regs[13], &gregs[15]);
+    __get_user(env->regs[14], &gregs[16]);
+    __get_user(env->regs[15], &gregs[17]);
+#ifdef TARGET_CSKYV2
+    __get_user(env->regs[16], &gregs[18]);
+    __get_user(env->regs[17], &gregs[19]);
+    __get_user(env->regs[18], &gregs[20]);
+    __get_user(env->regs[19], &gregs[21]);
+    __get_user(env->regs[20], &gregs[22]);
+    __get_user(env->regs[21], &gregs[23]);
+    __get_user(env->regs[22], &gregs[24]);
+    __get_user(env->regs[23], &gregs[25]);
+    __get_user(env->regs[24], &gregs[26]);
+    __get_user(env->regs[25], &gregs[27]);
+    __get_user(env->regs[26], &gregs[28]);
+    __get_user(env->regs[27], &gregs[29]);
+    __get_user(env->regs[28], &gregs[30]);
+    __get_user(env->regs[29], &gregs[31]);
+    __get_user(env->regs[30], &gregs[32]);
+    __get_user(env->regs[31], &gregs[33]);
+#endif
+    __get_user(env->regs[0], &gregs[34]);
+
+    rt_restore_fpu_state(uc, env);
+}
+static void
+setup_return(CPUCSKYState *env, struct target_sigaction *ka,
+             uint16_t rc[], int usig, abi_ulong rc_addr, int real_time)
+{
+    /* abi_ulong handler = ka->_sa_handler; */
+    abi_ulong retcode;
+    /* int err = 0; */
+
+    if (ka->sa_flags & TARGET_SA_RESTORER) {
+        retcode = ka->sa_restorer;
+    } else {
+#if defined(TARGET_CSKYV1)
+        if (real_time) {
+            __put_user(0x6000 + (TARGET_NR_rt_sigreturn << 4) + 1, rc);
+        } else {
+            __put_user(0x6000 + (TARGET_NR_sigreturn << 4) + 1, rc);
+        }
+        __put_user(0x08, rc+1);
+#elif defined(TARGET_CSKYV2)
+        __put_user(0xea07, rc);/* movih r1, xxx */
+#else
+        if (real_time) {
+            __put_user(TARGET_NR_rt_sigreturn, rc + 1);
+        } else {
+            __put_user(TARGET_NR_sigreturn, rc + 1);
+        }
+        __put_user(0xC000, rc + 2);/* trap32 0 */
+        __put_user(0x2020, rc + 3);
+#endif
+        retcode = rc_addr;
+    }
+
+    env->pc = ka->_sa_handler;
+#if defined(TARGET_CSKYV1)
+    env->regs[2] = usig;
+#elif defined(TARGET_CSKYV2)
+    env->regs[0] = usig;
+#endif
+    env->regs[15] = retcode;
+}
+
+/* compare linux/arch/csky/kernel/signal.c:setup_frame() */
+static void setup_frame(int usig, struct target_sigaction *ka,
+                        target_sigset_t *set, CPUCSKYState *env)
+{
+    struct sigframe *frame;
+    abi_ulong frame_addr = get_sigframe(ka, env, sizeof(*frame));
+    int i;
+
+    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {
+        goto give_sigsegv;
+    }
+
+    setup_sigcontext(&frame->sc, env, set->sig[0]);
+
+    for (i = 1; i < TARGET_NSIG_WORDS; i++) {
+        __put_user(set->sig[i], &frame->extramask[i - 1]);
+    }
+
+    setup_return(env, ka, frame->retcode, usig,
+                 frame_addr + offsetof(struct sigframe, retcode), 0);
+
+#if defined(TARGET_CSKYV1)
+    env->regs[0] = frame_addr;
+#elif defined(TARGET_CSKYV2)
+    env->regs[14] = frame_addr;
+#endif
+    return;
+
+give_sigsegv:
+    force_sigsegv(usig);
+}
+
+long do_sigreturn(CPUCSKYState *env)
+{
+    abi_ulong frame_addr;
+    struct sigframe *frame;
+    target_sigset_t set;
+    sigset_t host_set;
+    int i;
+#ifdef TARGET_CSKYV1
+    if (env->regs[0] & 7) {
+        goto badframe;
+    }
+
+    frame_addr = env->regs[0];
+#elif defined TARGET_CSKYV2
+    if (env->regs[14] & 7) {
+        goto badframe;
+    }
+
+    frame_addr = env->regs[14];
+#endif
+
+    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {
+        goto badframe;
+    }
+
+    __get_user(set.sig[0], &frame->sc.sc_mask);
+
+    for (i = 1; i < TARGET_NSIG_WORDS; i++) {
+        __get_user(set.sig[i], &frame->extramask[i - 1]);
+    }
+
+    target_to_host_sigset_internal(&host_set, &set);
+    set_sigmask(&host_set);
+
+    restore_sigcontext(env, &frame->sc);
+
+    unlock_user_struct(frame, frame_addr, 0);
+    return -TARGET_QEMU_SIGRETURN;
+
+badframe:
+    unlock_user_struct(frame, frame_addr, 0);
+    force_sig(TARGET_SIGSEGV /* , current */);
+    return 0; /* unreachable */
+}
+#endif
+
+static void setup_rt_frame(int usig, struct target_sigaction *ka,
+                           target_siginfo_t *info,
+                           target_sigset_t *set, CPUCSKYState *env)
+{
+    struct rt_sigframe *frame;
+    abi_ulong frame_addr = get_sigframe(ka, env, sizeof(*frame));
+    int i;
+    abi_ulong info_addr, uc_addr;
+
+    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {
+        goto give_sigsegv;
+    }
+
+    /* save pinfo */
+    info_addr = frame_addr + offsetof(struct rt_sigframe, info);
+    __put_user(info_addr, &frame->pinfo);
+
+    /* save puc  */
+    uc_addr = frame_addr + offsetof(struct rt_sigframe, uc);
+    __put_user(uc_addr, &frame->puc);
+
+    /* save info */
+    tswap_siginfo(&frame->info, info);
+
+    /* Now, we begin to create the ucontext */
+
+    /* Clear all the bits of the ucontext we don't use.  */
+    memset(&frame->uc, 0, offsetof(struct target_ucontext, tuc_mcontext));
+
+    /*
+       __put_user(0, &(frame->uc).tuc_flags);
+       __put_user(0x0, &(frame->uc).tuc_link);
+     */
+
+    /* save information of the stack */
+    __put_user(target_sigaltstack_used.ss_sp, &frame->uc.tuc_stack.ss_sp);
+    __put_user(target_sigaltstack_used.ss_size, &frame->uc.tuc_stack.ss_size);
+    __put_user(sas_ss_flags(get_sp_from_cpustate(env)),
+               &frame->uc.tuc_stack.ss_flags);
+
+
+    /* save ucontext */
+    rt_setup_ucontext(&frame->uc, env);
+
+    /* save sigmask */
+    for (i = 0; i < TARGET_NSIG_WORDS; i++) {
+        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);
+    }
+
+    setup_return(env, ka, frame->retcode, usig,
+                 frame_addr + offsetof(struct rt_sigframe, retcode), 1);
+#if defined(TARGET_CSKYV1)
+    env->regs[3] = info_addr;
+    env->regs[4] = uc_addr;
+    env->regs[0] = frame_addr;
+#elif defined(TARGET_CSKYV2)
+    env->regs[1] = info_addr;
+    env->regs[2] = uc_addr;
+    env->regs[14] = frame_addr;
+#endif
+    unlock_user_struct(frame, frame_addr, 1);
+    return;
+
+give_sigsegv:
+    force_sigsegv(usig);
+}
+long do_rt_sigreturn(CPUCSKYState *env)
+{
+    abi_ulong frame_addr;
+    struct rt_sigframe *frame;
+    sigset_t host_set;
+#if defined(TARGET_CSKYV1)
+    if (env->regs[0] & 7) {
+        goto badframe;
+    }
+
+    frame_addr = env->regs[0];
+#elif defined(TARGET_CSKYV2)
+    if (env->regs[14] & 7) {
+        goto badframe;
+    }
+
+    frame_addr = env->regs[14];
+#endif
+    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {
+        goto badframe;
+    }
+
+    target_to_host_sigset(&host_set, &frame->uc.tuc_sigmask);
+    set_sigmask(&host_set);
+
+    rt_restore_ucontext(&frame->uc, env);
+
+    if (do_sigaltstack(frame_addr + offsetof(struct rt_sigframe, uc.tuc_stack),
+                       0, get_sp_from_cpustate(env)) == -EFAULT) {
+        goto badframe;
+    }
+
+    unlock_user_struct(frame, frame_addr, 0);
+    return -TARGET_QEMU_ESIGRETURN;
+
+badframe:
+    unlock_user_struct(frame, frame_addr, 0);
+    force_sig(TARGET_SIGSEGV /* , current */);
+    return -TARGET_QEMU_ESIGRETURN;
+}
+
 #elif defined(TARGET_SPARC)
 
 #define __SUNOS_MAXWIN   31
@@ -2348,7 +3062,7 @@ struct target_rt_signal_frame {
 #define UREG_FP        UREG_I6
 #define UREG_SP        UREG_O6
 
-static inline abi_ulong get_sigframe(struct target_sigaction *sa, 
+static inline abi_ulong get_sigframe(struct target_sigaction *sa,
                                      CPUSPARCState *env,
                                      unsigned long framesize)
 {
@@ -2359,8 +3073,10 @@ static inline abi_ulong get_sigframe(struct target_sigaction *sa,
     /* This is the X/Open sanctioned signal stack switching.  */
     if (sa->sa_flags & TARGET_SA_ONSTACK) {
         if (!on_sig_stack(sp)
-                && !((target_sigaltstack_used.ss_sp + target_sigaltstack_used.ss_size) & 7)) {
-            sp = target_sigaltstack_used.ss_sp + target_sigaltstack_used.ss_size;
+                && !((target_sigaltstack_used.ss_sp +
+                      target_sigaltstack_used.ss_size) & 7)) {
+            sp = target_sigaltstack_used.ss_sp +
+                target_sigaltstack_used.ss_size;
         }
     }
     return sp - framesize;
@@ -2385,24 +3101,6 @@ setup___siginfo(__siginfo_t *si, CPUSPARCState *env, abi_ulong mask)
     return err;
 }
 
-#if 0
-static int
-setup_sigcontext(struct target_sigcontext *sc, /*struct _fpstate *fpstate,*/
-                 CPUSPARCState *env, unsigned long mask)
-{
-    int err = 0;
-
-    __put_user(mask, &sc->sigc_mask);
-    __put_user(env->regwptr[UREG_SP], &sc->sigc_sp);
-    __put_user(env->pc, &sc->sigc_pc);
-    __put_user(env->npc, &sc->sigc_npc);
-    __put_user(env->psr, &sc->sigc_psr);
-    __put_user(env->gregs[1], &sc->sigc_g1);
-    __put_user(env->regwptr[UREG_O0], &sc->sigc_o0);
-
-    return err;
-}
-#endif
 #define NF_ALIGNEDSZ  (((sizeof(struct target_signal_frame) + 7) & (~7)))
 
 static void setup_frame(int sig, struct target_sigaction *ka,
@@ -2413,7 +3111,7 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     int sigframe_size, err, i;
 
     /* 1. Make sure everything is clean */
-    //synchronize_user_stack();
+    /* synchronize_user_stack(); */
 
     sigframe_size = NF_ALIGNEDSZ;
     sf_addr = get_sigframe(ka, env, sigframe_size);
@@ -2424,17 +3122,11 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     if (!sf) {
         goto sigsegv;
     }
-#if 0
-    if (invalid_frame_pointer(sf, sigframe_size))
-        goto sigill_and_return;
-#endif
+
     /* 2. Save the current process state */
     err = setup___siginfo(&sf->info, env, set->sig[0]);
     __put_user(0, &sf->extra_size);
 
-    //save_fpu_state(regs, &sf->fpu_state);
-    //__put_user(&sf->fpu_state, &sf->fpu_save);
-
     __put_user(set->sig[0], &sf->info.si_mask);
     for (i = 0; i < TARGET_NSIG_WORDS - 1; i++) {
         __put_user(set->sig[i + 1], &sf->extramask[i]);
@@ -2443,19 +3135,22 @@ static void setup_frame(int sig, struct target_sigaction *ka,
     for (i = 0; i < 8; i++) {
         __put_user(env->regwptr[i + UREG_L0], &sf->ss.locals[i]);
     }
+
     for (i = 0; i < 8; i++) {
         __put_user(env->regwptr[i + UREG_I0], &sf->ss.ins[i]);
     }
-    if (err)
+
+    if (err) {
         goto sigsegv;
+    }
 
     /* 3. signal handler back-trampoline and parameters */
     env->regwptr[UREG_FP] = sf_addr;
     env->regwptr[UREG_I0] = sig;
     env->regwptr[UREG_I1] = sf_addr +
-            offsetof(struct target_signal_frame, info);
+        offsetof(struct target_signal_frame, info);
     env->regwptr[UREG_I2] = sf_addr +
-            offsetof(struct target_signal_frame, info);
+        offsetof(struct target_signal_frame, info);
 
     /* 4. signal handler */
     env->pc = ka->_sa_handler;
@@ -2476,19 +3171,13 @@ static void setup_frame(int sig, struct target_sigaction *ka,
         /* t 0x10 */
         val32 = 0x91d02010;
         __put_user(val32, &sf->insns[1]);
-        if (err)
+        if (err) {
             goto sigsegv;
-
-        /* Flush instruction space. */
-        // flush_sig_insns(current->mm, (unsigned long) &(sf->insns[0]));
-        // tb_flush(env);
+        }
     }
     unlock_user(sf, sf_addr, sizeof(struct target_signal_frame));
     return;
-#if 0
-sigill_and_return:
-    force_sig(TARGET_SIGILL);
-#endif
+
 sigsegv:
     unlock_user(sf, sf_addr, sizeof(struct target_signal_frame));
     force_sigsegv(sig);
@@ -2541,6 +3230,7 @@ long do_sigreturn(CPUSPARCState *env)
     for (i=0; i < 8; i++) {
         __get_user(env->gregs[i], &sf->info.si_regs.u_regs[i]);
     }
+
     for (i=0; i < 8; i++) {
         __get_user(env->regwptr[i + UREG_I0], &sf->info.si_regs.u_regs[i+8]);
     }
@@ -2555,6 +3245,7 @@ long do_sigreturn(CPUSPARCState *env)
          * the races which exist anyways.
          */
     __get_user(set.sig[0], &sf->info.si_mask);
+
     for(i = 1; i < TARGET_NSIG_WORDS; i++) {
         __get_user(set.sig[i], &sf->extramask[i - 1]);
     }
@@ -2764,7 +3455,7 @@ void sparc64_get_context(CPUSPARCState *env)
     if (!lock_user_struct(VERIFY_WRITE, ucp, ucp_addr, 0)) {
         goto do_sigsegv;
     }
-    
+
     mcp = &ucp->tuc_mcontext;
     grp = &mcp->mc_gregs;
 
@@ -5290,7 +5981,7 @@ static inline int target_rt_restore_ucontext(CPUM68KState *env,
 {
     int temp;
     target_greg_t *gregs = uc->tuc_mcontext.gregs;
-    
+
     __get_user(temp, &uc->tuc_mcontext.version);
     if (temp != TARGET_MCONTEXT_VERSION)
         goto badframe;
@@ -5992,6 +6683,8 @@ static void handle_pending_signal(CPUArchState *cpu_env, int sig,
         || defined(TARGET_PPC64)
         /* These targets do not have traditional signals.  */
         setup_rt_frame(sig, sa, &k->info, &target_old_set, cpu_env);
+#elif defined(TARGET_CSKY)&&defined(CONFIG_CSKY_KERNEL_4X)
+        setup_rt_frame(sig, sa, &k->info, &target_old_set, cpu_env);
 #else
         if (sa->sa_flags & TARGET_SA_SIGINFO)
             setup_rt_frame(sig, sa, &k->info, &target_old_set, cpu_env);
diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 7b77503..14124b3 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -1247,7 +1247,7 @@ static inline rlim_t target_to_host_rlim(abi_ulong target_rlim)
 {
     abi_ulong target_rlim_swap;
     rlim_t result;
-    
+
     target_rlim_swap = tswapal(target_rlim);
     if (target_rlim_swap == TARGET_RLIM_INFINITY)
         return RLIM_INFINITY;
@@ -1255,7 +1255,7 @@ static inline rlim_t target_to_host_rlim(abi_ulong target_rlim)
     result = target_rlim_swap;
     if (target_rlim_swap != (rlim_t)result)
         return RLIM_INFINITY;
-    
+
     return result;
 }
 
@@ -1263,13 +1263,13 @@ static inline abi_ulong host_to_target_rlim(rlim_t rlim)
 {
     abi_ulong target_rlim_swap;
     abi_ulong result;
-    
+
     if (rlim == RLIM_INFINITY || rlim != (abi_long)rlim)
         target_rlim_swap = TARGET_RLIM_INFINITY;
     else
         target_rlim_swap = rlim;
     result = tswapal(target_rlim_swap);
-    
+
     return result;
 }
 
@@ -1642,9 +1642,9 @@ static inline abi_long target_to_host_cmsg(struct msghdr *msgh,
     abi_ulong target_cmsg_addr;
     struct target_cmsghdr *target_cmsg, *target_cmsg_start;
     socklen_t space = 0;
-    
+
     msg_controllen = tswapal(target_msgh->msg_controllen);
-    if (msg_controllen < sizeof (struct target_cmsghdr)) 
+    if (msg_controllen < sizeof (struct target_cmsghdr))
         goto the_end;
     target_cmsg_addr = tswapal(target_msgh->msg_control);
     target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1);
@@ -1726,7 +1726,7 @@ static inline abi_long host_to_target_cmsg(struct target_msghdr *target_msgh,
     socklen_t space = 0;
 
     msg_controllen = tswapal(target_msgh->msg_controllen);
-    if (msg_controllen < sizeof (struct target_cmsghdr)) 
+    if (msg_controllen < sizeof (struct target_cmsghdr))
         goto the_end;
     target_cmsg_addr = tswapal(target_msgh->msg_control);
     target_cmsg = lock_user(VERIFY_WRITE, target_cmsg_addr, msg_controllen, 0);
@@ -5902,7 +5902,7 @@ abi_long do_set_thread_area(CPUX86State *env, abi_ulong ptr)
     }
     unlock_user_struct(target_ldt_info, ptr, 1);
 
-    if (ldt_info.entry_number < TARGET_GDT_ENTRY_TLS_MIN || 
+    if (ldt_info.entry_number < TARGET_GDT_ENTRY_TLS_MIN ||
         ldt_info.entry_number > TARGET_GDT_ENTRY_TLS_MAX)
            return -TARGET_EINVAL;
     seg_32bit = ldt_info.flags & 1;
@@ -5980,7 +5980,7 @@ static abi_long do_get_thread_area(CPUX86State *env, abi_ulong ptr)
     lp = (uint32_t *)(gdt_table + idx);
     entry_1 = tswap32(lp[0]);
     entry_2 = tswap32(lp[1]);
-    
+
     read_exec_only = ((entry_2 >> 9) & 1) ^ 1;
     contents = (entry_2 >> 10) & 3;
     seg_not_present = ((entry_2 >> 15) & 1) ^ 1;
@@ -5996,8 +5996,8 @@ static abi_long do_get_thread_area(CPUX86State *env, abi_ulong ptr)
         (read_exec_only << 3) | (limit_in_pages << 4) |
         (seg_not_present << 5) | (useable << 6) | (lm << 7);
     limit = (entry_1 & 0xffff) | (entry_2  & 0xf0000);
-    base_addr = (entry_1 >> 16) | 
-        (entry_2 & 0xff000000) | 
+    base_addr = (entry_1 >> 16) |
+        (entry_2 & 0xff000000) |
         ((entry_2 & 0xff) << 16);
     target_ldt_info->base_addr = tswapal(base_addr);
     target_ldt_info->limit = tswap32(limit);
@@ -7527,6 +7527,7 @@ static target_timer_t get_timer_id(abi_long arg)
     return timerid;
 }
 
+long long total_jcount;
 /* do_syscall() should always have a single exit point at the end so
    that actions, such as logging of syscall results, can be performed.
    All errnos that do_syscall() returns must be -TARGET_<errcode>. */
@@ -9038,7 +9039,7 @@ abi_long do_syscall(void *cpu_env, int num, abi_long arg1,
 #if (defined(TARGET_I386) && defined(TARGET_ABI32)) || \
     (defined(TARGET_ARM) && defined(TARGET_ABI32)) || \
     defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE) \
-    || defined(TARGET_S390X)
+    || defined(TARGET_S390X) || defined(TARGET_CSKY)
         {
             abi_ulong *v;
             abi_ulong v1, v2, v3, v4, v5, v6;
@@ -9642,6 +9643,9 @@ abi_long do_syscall(void *cpu_env, int num, abi_long arg1,
         _mcleanup();
 #endif
         gdb_exit(cpu_env, arg1);
+        if (total_jcount != 0) {
+            printf("jcount = %lld\n", total_jcount);
+        }
         ret = get_errno(exit_group(arg1));
         break;
 #endif
@@ -10633,7 +10637,7 @@ abi_long do_syscall(void *cpu_env, int num, abi_long arg1,
         break;
 #if defined(TARGET_NR_fchownat)
     case TARGET_NR_fchownat:
-        if (!(p = lock_user_string(arg2))) 
+        if (!(p = lock_user_string(arg2)))
             goto efault;
         ret = get_errno(fchownat(arg1, p, low2highuid(arg3),
                                  low2highgid(arg4), arg5));
diff --git a/linux-user/syscall_defs.h b/linux-user/syscall_defs.h
index 0b15466..c5fad7f 100644
--- a/linux-user/syscall_defs.h
+++ b/linux-user/syscall_defs.h
@@ -59,7 +59,8 @@
 #if (defined(TARGET_I386) && defined(TARGET_ABI32)) \
     || (defined(TARGET_ARM) && defined(TARGET_ABI32)) \
     || defined(TARGET_SPARC) \
-    || defined(TARGET_M68K) || defined(TARGET_SH4) || defined(TARGET_CRIS)
+    || defined(TARGET_M68K) || defined(TARGET_SH4) || defined(TARGET_CRIS) \
+    || defined(TARGET_CSKY)
     /* 16 bit uid wrappers emulation */
 #define USE_UID16
 #define target_id uint16_t
@@ -70,7 +71,7 @@
 #if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_SH4) \
     || defined(TARGET_M68K) || defined(TARGET_CRIS) \
     || defined(TARGET_UNICORE32) || defined(TARGET_S390X) \
-    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX)
+    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX) || defined(TARGET_CSKY)
 
 #define TARGET_IOC_SIZEBITS	14
 #define TARGET_IOC_DIRBITS	2
@@ -417,7 +418,7 @@ int do_sigaction(int sig, const struct target_sigaction *act,
     || defined(TARGET_M68K) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) \
     || defined(TARGET_MICROBLAZE) || defined(TARGET_UNICORE32) \
     || defined(TARGET_S390X) || defined(TARGET_OPENRISC) \
-    || defined(TARGET_TILEGX)
+    || defined(TARGET_TILEGX) || defined(TARGET_CSKY)
 
 #if defined(TARGET_SPARC)
 #define TARGET_SA_NOCLDSTOP    8u
@@ -587,6 +588,48 @@ int do_sigaction(int sig, const struct target_sigaction *act,
 #define TARGET_SIG_UNBLOCK	2	/* for unblocking signals */
 #define TARGET_SIG_SETMASK	3	/* for setting the signal mask */
 
+#elif defined(TARGET_CSKY)
+
+#define TARGET_SIGHUP		 1
+#define TARGET_SIGINT		 2
+#define TARGET_SIGQUIT		 3
+#define TARGET_SIGILL		 4
+#define TARGET_SIGTRAP		 5
+#define TARGET_SIGABRT		 6
+#define TARGET_SIGIOT		 6
+#define TARGET_SIGBUS		 7
+#define TARGET_SIGFPE		 8
+#define TARGET_SIGKILL		 9
+#define TARGET_SIGUSR1		10
+#define TARGET_SIGSEGV		11
+#define TARGET_SIGUSR2		12
+#define TARGET_SIGPIPE		13
+#define TARGET_SIGALRM		14
+#define TARGET_SIGTERM		15
+#define TARGET_SIGSTKFLT	16
+#define TARGET_SIGCHLD		17
+#define TARGET_SIGCONT		18
+#define TARGET_SIGSTOP		19
+#define TARGET_SIGTSTP		20
+#define TARGET_SIGTTIN		21
+#define TARGET_SIGTTOU		22
+#define TARGET_SIGURG		23
+#define TARGET_SIGXCPU		24
+#define TARGET_SIGXFSZ		25
+#define TARGET_SIGVTALRM	26
+#define TARGET_SIGPROF		27
+#define TARGET_SIGWINCH	28
+#define TARGET_SIGIO		29
+#define TARGET_SIGPOLL		TARGET_SIGIO
+#define TARGET_SIGPWR		30
+#define TARGET_SIGSYS		31
+#define TARGET_SIGUNUSED	31
+#define TARGET_SIGRTMIN	32
+
+#define TARGET_SIG_BLOCK          0	/* for blocking signals */
+#define TARGET_SIG_UNBLOCK        1	/* for unblocking signals */
+#define TARGET_SIG_SETMASK        2	/* for setting the signal mask */
+
 #else
 
 /* OpenRISC Using the general signals */
@@ -1290,7 +1333,7 @@ struct target_winsize {
 
 #if (defined(TARGET_I386) && defined(TARGET_ABI32)) \
     || (defined(TARGET_ARM) && defined(TARGET_ABI32)) \
-    || defined(TARGET_CRIS) || defined(TARGET_UNICORE32)
+    || defined(TARGET_CRIS) || defined(TARGET_UNICORE32) || defined(TARGET_CSKY)
 struct target_stat {
 	unsigned short st_dev;
 	unsigned short __pad1;
@@ -1334,9 +1377,17 @@ struct target_stat64 {
 	unsigned short	st_rdev;
 	unsigned char	__pad3[10];
 
+#if defined(TARGET_CSKYV1)
+  unsigned char __pad8[4];
+#endif
+
 	long long	st_size;
 	abi_ulong	st_blksize;
 
+#if defined(TARGET_CSKYV1)
+  unsigned char __pad9[4];
+#endif
+
 	abi_ulong	st_blocks;	/* Number 512-byte blocks allocated. */
 	abi_ulong	__pad4;		/* future possible st_blocks high bits */
 
@@ -1923,7 +1974,7 @@ struct target_stat {
     	abi_long	st_blocks;	/* Number 512-byte blocks allocated. */
 
 	abi_ulong	target_st_atime;
-	abi_ulong 	target_st_atime_nsec; 
+	abi_ulong 	target_st_atime_nsec;
 	abi_ulong	target_st_mtime;
 	abi_ulong	target_st_mtime_nsec;
 	abi_ulong	target_st_ctime;
@@ -2259,6 +2310,25 @@ struct target_statfs64 {
 #define TARGET_O_NOFOLLOW      0100000 /* don't follow links */
 #define TARGET_O_DIRECT        0200000 /* direct disk access hint */
 #define TARGET_O_LARGEFILE     0400000
+#elif defined (TARGET_CSKY)
+#define TARGET_O_ACCMODE         	0003
+#define TARGET_O_RDONLY            00
+#define TARGET_O_WRONLY           	01
+#define TARGET_O_RDWR               02
+#define TARGET_O_CREAT           	0100 /* not fcntl */
+#define TARGET_O_EXCL            	0200 /* not fcntl */
+#define TARGET_O_NOCTTY          	0400 /* not fcntl */
+#define TARGET_O_TRUNC           01000 /* not fcntl */
+#define TARGET_O_APPEND          02000
+#define TARGET_O_NONBLOCK        04000
+#define TARGET_O_NDELAY        	TARGET_O_NONBLOCK
+#define TARGET_O_SYNC           010000
+#define TARGET_FASYNC           020000 /* fcntl, for BSD compatibility */
+/* these 4 macros are csky-specific */
+#define TARGET_O_DIRECTORY      040000 /* must be a directory */
+#define TARGET_O_NOFOLLOW      0100000 /* don't follow links */
+#define TARGET_O_DIRECT        0200000 /* direct disk access hint */
+#define TARGET_O_LARGEFILE     0400000
 #elif defined(TARGET_MIPS)
 #define TARGET_O_APPEND         0x0008
 #define TARGET_O_DSYNC          0x0010
diff --git a/linux-user/uname.c b/linux-user/uname.c
index 313b79d..81b6901 100644
--- a/linux-user/uname.c
+++ b/linux-user/uname.c
@@ -63,6 +63,9 @@ const char *cpu_to_uname_machine(void *cpu_env)
         return "i586";
     }
     return "i686";
+#elif defined(TARGET_CSKY)
+    /* FIXME add by shangyh */
+    return "CSKY_CPU";
 #else
     /* default is #define-d in each arch/ subdir */
     return UNAME_MACHINE;
diff --git a/qemu-options.hx b/qemu-options.hx
index c534a2f..8e2e1ef 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -96,6 +96,64 @@ STEXI
 Select CPU model (@code{-cpu help} for list and additional feature selection)
 ETEXI
 
+DEF("cpu-prop", HAS_ARG, QEMU_OPTION_cpu_prop,
+    "-cpu-prop vdsp=vdsp[,pctrace=pctrace_num][,elrw=on|off]\n"
+    "                [,mem_prot=mmu|mgu|no][,mmu_default=on|off]\n"
+    "                [,tb_trace=on|off][,unaligned_access=on|off]\n"
+    "                set CSKY CPU's properties\n"
+    "                vdsp= could be 64 or 128, default vdsp=0\n"
+    "                default pctrace=0, recommend 32 or 64\n"
+    "                elrw= default is off\n"
+    "                mem_prot= ck610/ck807/ck810 default is mmu, else mgu\n"
+    "                mmu_default= default is off\n"
+    "                tb_trace= default is off\n"
+    "                unaligned_access= default is off\n"
+    , QEMU_ARCH_CSKY)
+STEXI
+@item -cpu-prop vdsp=@var{vdsp}[,pctrace=@var{pctrace}][,elrw=on|off][,mem_prot=mmu|mgu|no][,mmu_default=on|off][,tb_trace=on|off][,unaligned_access=on|off]
+@findex -cpu-prop
+
+Choose extend CPU properities. Valid options are:
+
+@table @option
+@item vdsp=@var{vdsp}
+This option defines is 0, means CPU does not support VDSP, CPU's vdsp is 64 or 128.
+@item pctrace=@var{pctrace}
+This option defines number of pctrace record, default is 0. Setting >0 to open pctrace. Should using with tb_trace=on.
+@item elrw=on|off
+This option defines if has elrw extend.
+@item mem_prot=mmu|mgu|no
+This option defines if need to select memory protect unit.
+@item mmu_default=on|off
+This option defines if need open MMU before elf load.
+@item tb_trace=on|off
+This option defines if trace beginning of all TranslationBlock's PC. To log it, type "-d tb_trace".
+@item unaligned_access=on|off
+This option defines if cpu need support unaligned data access.
+@end table
+ETEXI
+
+DEF("soc", HAS_ARG, QEMU_OPTION_soc,
+    "-soc shm=on|off[,xmlpath=path]\n"
+    "                -soc loads all CSKY's modules, \n"
+    "                setting shm= default is on.\n"
+    "                setting xmlpath= to point out where xml file is.[have not implemented]\n"
+    "                Note: if setting shm=on, ignores xmlpath= .\n"
+    , QEMU_ARCH_CSKY)
+STEXI
+@item -soc shm=on|off[,xmlpath=@var{path}]
+@findex -soc
+
+Loads all modules, and using shm to point out how to using modules. Valid options are:
+
+@table @option
+@item shm=on|off
+This option defines is on, get a description from cskysim to orgnize a dynsoc.
+@item xmlpath=@var{path}
+This option deparse xml to get a description to orgnize the dynsoc.
+@end table
+ETEXI
+
 DEF("smp", HAS_ARG, QEMU_OPTION_smp,
     "-smp [cpus=]n[,maxcpus=cpus][,cores=cores][,threads=threads][,sockets=sockets]\n"
     "                set the number of CPUs to 'n' [default=1]\n"
@@ -3650,7 +3708,7 @@ specified, the former is passed to semihosting as it always takes precedence.
 @end table
 ETEXI
 DEF("old-param", 0, QEMU_OPTION_old_param,
-    "-old-param      old param mode\n", QEMU_ARCH_ARM)
+    "-old-param      old param mode\n", QEMU_ARCH_ARM | QEMU_ARCH_CSKY)
 STEXI
 @item -old-param
 @findex -old-param (ARM)
diff --git a/rules.mak b/rules.mak
index f4839d2..d8b7b6c 100644
--- a/rules.mak
+++ b/rules.mak
@@ -87,6 +87,9 @@ LINK = $(call quiet-command, $(LINKPROG) $(QEMU_CFLAGS) $(CFLAGS) $(LDFLAGS) -o
 DSO_OBJ_CFLAGS := -fPIC -DBUILD_DSO
 module-common.o: CFLAGS += $(DSO_OBJ_CFLAGS)
 %$(DSOSUF): LDFLAGS += $(LDFLAGS_SHARED)
+ifdef CONFIG_WIN32
+%$(DSOSUF): LIBS += -L. -lqemu_sym
+endif
 %$(DSOSUF): %.mo
 	$(call LINK,$^)
 	@# Copy to build root so modules can be loaded when program started without install
@@ -101,6 +104,9 @@ LD_REL := $(CC) -nostdlib $(LD_REL_FLAGS)
 .PHONY: modules
 modules:
 
+ifdef CONFIG_WIN32
+%$(EXESUF): LDFLAGS += -Wl,--export-all-symbols,--out-implib,../libqemu_sym.a
+endif
 %$(EXESUF): %.o
 	$(call LINK,$(filter %.o %.a %.mo, $^))
 
diff --git a/scripts/create_config b/scripts/create_config
index e6929dd..acbec6b 100755
--- a/scripts/create_config
+++ b/scripts/create_config
@@ -24,6 +24,10 @@ case $line in
     # save for the next definitions
     eval "$name=\$define_value"
     ;;
+ CSKY_VERSION=*) # configuration
+    cskyversion=${line#*=}
+    echo "#define QEMU_CSKY_VERSION \"$cskyversion\""
+    ;;
  prefix=*)
     # save for the next definitions
     prefix=${line#*=}
diff --git a/target-arm/helper.h b/target-arm/helper.h
index 84aa637..37ade42 100644
--- a/target-arm/helper.h
+++ b/target-arm/helper.h
@@ -2,6 +2,7 @@ DEF_HELPER_FLAGS_1(clz, TCG_CALL_NO_RWG_SE, i32, i32)
 DEF_HELPER_FLAGS_1(sxtb16, TCG_CALL_NO_RWG_SE, i32, i32)
 DEF_HELPER_FLAGS_1(uxtb16, TCG_CALL_NO_RWG_SE, i32, i32)
 
+DEF_HELPER_2(tb_trace, void, env, i32)
 DEF_HELPER_3(add_setq, i32, env, i32, i32)
 DEF_HELPER_3(add_saturate, i32, env, i32, i32)
 DEF_HELPER_3(sub_saturate, i32, env, i32, i32)
diff --git a/target-arm/op_helper.c b/target-arm/op_helper.c
index cd94216..193943c 100644
--- a/target-arm/op_helper.c
+++ b/target-arm/op_helper.c
@@ -38,6 +38,11 @@ static void raise_exception(CPUARMState *env, uint32_t excp,
     cpu_loop_exit(cs);
 }
 
+void helper_tb_trace(CPUARMState *env, uint32_t tb_pc)
+{
+    qemu_log_mask(CPU_TB_TRACE, "0x%.8x\n", tb_pc);
+}
+
 static int exception_target_el(CPUARMState *env)
 {
     int target_el = MAX(1, arm_current_el(env));
diff --git a/target-arm/translate.c b/target-arm/translate.c
index 0ad9070..bcb6c46 100644
--- a/target-arm/translate.c
+++ b/target-arm/translate.c
@@ -11588,6 +11588,26 @@ static bool insn_crosses_page(CPUARMState *env, DisasContext *s)
     return false;
 }
 
+static void csky_tb_start(CPUARMState *env, TranslationBlock *tb)
+{
+    uint32_t tb_pc = (uint32_t)tb->pc;
+    TCGv t0 = tcg_temp_new();
+
+    t0 = tcg_const_tl(tb_pc);
+    gen_helper_tb_trace(cpu_env, t0);
+    tcg_temp_free(t0);
+}
+
+static void csky_dump_tb_map(CPUARMState *env, TranslationBlock *tb)
+{
+    uint32_t tb_pc = (uint32_t)tb->pc;
+    uint32_t tb_end =  tb_pc + (uint32_t)tb->size;
+    uint32_t icount = (uint32_t)tb->icount;
+
+    qemu_log_mask(CPU_TB_TRACE, "tb_map: 0x%.8x 0x%.8x %d\n",
+                  tb_pc, tb_end, icount);
+}
+
 /* generate intermediate code for basic block 'tb'.  */
 void gen_intermediate_code(CPUARMState *env, TranslationBlock *tb)
 {
@@ -11684,6 +11704,8 @@ void gen_intermediate_code(CPUARMState *env, TranslationBlock *tb)
 
     gen_tb_start(tb);
 
+    csky_tb_start(env, tb);
+
     tcg_clear_temp_count();
 
     /* A note on handling of the condexec (IT) bits:
@@ -11974,6 +11996,7 @@ done_generating:
 #endif
     tb->size = dc->pc - pc_start;
     tb->icount = num_insns;
+    csky_dump_tb_map(env, tb);
 }
 
 static const char *cpu_mode_names[16] = {
diff --git a/target-csky/Makefile.objs b/target-csky/Makefile.objs
new file mode 100644
index 0000000..2139406
--- /dev/null
+++ b/target-csky/Makefile.objs
@@ -0,0 +1,6 @@
+obj-y += mmu.o
+obj-y += gdbstub.o
+obj-y += helper.o
+obj-y += cpu.o
+obj-$(TARGET_CSKYV1) += translate_v1.o op_helper_v1.o
+obj-$(TARGET_CSKYV2) += translate_v2.o op_helper_v2.o op_vdsp.o op_dspv2.o
diff --git a/target-csky/cpu-qom.h b/target-csky/cpu-qom.h
new file mode 100644
index 0000000..fcc5010
--- /dev/null
+++ b/target-csky/cpu-qom.h
@@ -0,0 +1,51 @@
+/*
+ * CSKY CPU qom
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef QEMU_CSKY_CPU_QOM_H
+#define QEMU_CSKY_CPU_QOM_H
+
+#include "qom/cpu.h"
+
+#define TYPE_CSKY_CPU "csky-cpu"
+
+#define CSKY_CPU_CLASS(klass) \
+    OBJECT_CLASS_CHECK(CSKYCPUClass, (klass), TYPE_CSKY_CPU)
+#define CSKY_CPU(obj) \
+    OBJECT_CHECK(CSKYCPU, (obj), TYPE_CSKY_CPU)
+#define CSKY_CPU_GET_CLASS(obj) \
+    OBJECT_GET_CLASS(CSKYCPUClass, (obj), TYPE_CSKY_CPU)
+
+/**
+ * CSKYCPUClass:
+ * @parent_realize: The parent class' realize handler.
+ * @parent_reset: The parent class' reset handler.
+ *
+ * A CSKY model.
+ */
+typedef struct CSKYCPUClass {
+    /*< private >*/
+    CPUClass parent_class;
+    /*< public >*/
+
+    DeviceRealize parent_realize;
+    void (*parent_reset)(CPUState *cpu);
+} CSKYCPUClass;
+
+typedef struct CSKYCPU CSKYCPU;
+
+#endif
diff --git a/target-csky/cpu.c b/target-csky/cpu.c
new file mode 100644
index 0000000..59501bc
--- /dev/null
+++ b/target-csky/cpu.c
@@ -0,0 +1,919 @@
+/*
+ * CSKY CPU
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "cpu.h"
+#include "qemu-common.h"
+#include "migration/vmstate.h"
+#include "exec/exec-all.h"
+#include "qemu/option.h"
+#include "qemu/config-file.h"
+#include "qemu/error-report.h"
+
+
+static void csky_cpu_set_pc(CPUState *cs, vaddr value)
+{
+    CSKYCPU *cpu = CSKY_CPU(cs);
+
+    cpu->env.pc = value;
+}
+
+static bool csky_cpu_has_work(CPUState *cs)
+{
+    return cs->interrupt_request & CPU_INTERRUPT_HARD;
+}
+
+static inline void csky_set_feature(CPUCSKYState *env, uint64_t feature)
+{
+    env->features |= feature;
+}
+
+static inline bool csky_has_feature(CPUCSKYState *env, uint64_t feature)
+{
+    if (env->features & feature) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+static void csky_cpu_handle_opts(CPUCSKYState *env)
+{
+#ifndef CONFIG_USER_ONLY
+    QemuOpts *opts;
+    uint32_t n;
+    bool b;
+    char *str;
+    opts = qemu_opts_find(qemu_find_opts("cpu-prop"), NULL);
+    if (opts) {
+        n = qemu_opt_get_number(opts, "pctrace", 0);
+        if (n > 1024) {
+            error_report("pctrace bigger than 1024");
+            exit(1);
+        }
+        env->pctraces_max_num = n;
+
+        n = qemu_opt_get_number(opts, "vdsp", 0);
+        if (n != 0) {
+            if (!csky_has_feature(env, CPU_810)) {
+                error_report("only 810 support vdsp");
+                exit(1);
+            }
+
+            if (n == 64) {
+                csky_set_feature(env, ABIV2_VDSP64);
+            } else if (n == 128) {
+                csky_set_feature(env, ABIV2_VDSP128);
+            } else {
+                error_report("vdsp= only allow 64 or 128");
+                exit(1);
+            }
+        }
+
+        b = qemu_opt_get_bool(opts, "elrw", false);
+        if (b) {
+            csky_set_feature(env, ABIV2_ELRW);
+        }
+
+        str = qemu_opt_get_del(opts, "mem_prot");
+        if (str != NULL) {
+            if (!strcmp(str, "mmu")) {
+                env->features |= CSKY_MMU;
+                env->features &= ~CSKY_MGU;
+            } else if (!strcmp(str, "mgu")) {
+                env->features |= CSKY_MGU;
+                env->features &= ~CSKY_MMU;
+            } else if (!strcmp(str, "no")) {
+                env->features &= ~CSKY_MGU;
+                env->features &= ~CSKY_MMU;
+            } else {
+                error_report("mem_prot= only allow mmu/mgu/no");
+                exit(1);
+            }
+        }
+
+        b = qemu_opt_get_bool(opts, "mmu_default", false);
+        if (b) {
+            env->mmu_default = 1;
+        }
+
+        b = qemu_opt_get_bool(opts, "tb_trace", false);
+        if (b) {
+            env->tb_trace = 1;
+        }
+
+        b = qemu_opt_get_bool(opts, "unaligned_access", false);
+        if (b) {
+            csky_set_feature(env, UNALIGNED_ACCESS);
+        }
+    }
+#endif
+}
+
+struct csky_trace_info tb_trace_info[TB_TRACE_NUM];
+
+/* CPUClass::reset() */
+static void csky_cpu_reset(CPUState *s)
+{
+    CSKYCPU *cpu = CSKY_CPU(s);
+    CSKYCPUClass *mcc = CSKY_CPU_GET_CLASS(cpu);
+    CPUCSKYState *env = &cpu->env;
+    uint32_t cpidr;
+
+    mcc->parent_reset(s);
+
+    /* backup data before memset */
+    cpidr = env->cp0.cpidr[0];
+
+    memset(env, 0, offsetof(CPUCSKYState, features));
+
+    env->cp0.cpidr[0] = cpidr;
+    env->cp0.cpidr[1] = 0x17000000;
+    env->cp0.cpidr[2] = 0x2ff0f20c;
+    env->cp0.cpidr[3] = 0x30000000;
+
+#if defined(TARGET_CSKYV1)
+    env->cp1.fsr = 0x0;
+#endif
+
+#if defined(CONFIG_USER_ONLY)
+    env->cp0.psr = 0x140;
+#if defined(TARGET_CSKYV2)
+    env->sce_condexec_bits = 1;
+    env->sce_condexec_bits_bk = 1;
+#endif
+
+#else
+    if (csky_has_feature(env, ABIV2_TEE)) {
+        env->tee.nt_psr = 0x80000000;
+        env->tee.t_psr = 0xc0000000;
+        env->cp0.psr = env->tee.t_psr;
+        env->psr_t = PSR_T(env->cp0.psr);
+        env->mmu = env->t_mmu;
+    } else {
+        env->cp0.psr = 0x80000000;
+        env->mmu = env->nt_mmu;
+    }
+    env->psr_s = PSR_S(env->cp0.psr);
+#if defined(TARGET_CSKYV2)
+    env->psr_bm = PSR_BM(env->cp0.psr);
+    env->sce_condexec_bits = 1;
+    env->sce_condexec_bits_bk = 1;
+    env->mmu.msa0 = 0x1e;
+    env->mmu.msa1 = 0x16;
+#endif
+
+#ifdef TARGET_WORDS_BIGENDIAN
+    env->cp0.ccr = 0x80;
+#endif
+
+    csky_nommu_init(env);
+#endif
+
+    env->vfp.fp_status.flush_inputs_to_zero = 1;
+    s->exception_index = -1;
+    tlb_flush(s, 1);
+
+    env->trace_info = tb_trace_info;
+    env->trace_index = 0;
+    csky_cpu_handle_opts(env);
+}
+
+static void csky_cpu_disas_set_info(CPUState *s, disassemble_info *info)
+{
+#if defined(TARGET_CSKYV1)
+    info->print_insn = print_insn_csky_v1;
+#else
+    info->print_insn = print_insn_csky_v2;
+#endif
+}
+
+/* CPU models */
+static ObjectClass *csky_cpu_class_by_name(const char *cpu_model)
+{
+    ObjectClass *oc;
+    char *typename;
+
+    if (cpu_model == NULL) {
+        return NULL;
+    }
+
+    typename = g_strdup_printf("%s-" TYPE_CSKY_CPU, cpu_model);
+    oc = object_class_by_name(typename);
+    g_free(typename);
+    if (oc != NULL && (object_class_dynamic_cast(oc, TYPE_CSKY_CPU) == NULL ||
+                       object_class_is_abstract(oc))) {
+        return NULL;
+    }
+    return oc;
+}
+
+static void ck510_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV1);
+    csky_set_feature(env, CPU_510);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK510;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck520_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV1);
+    csky_set_feature(env, CPU_520);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK520;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck610_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV1);
+    csky_set_feature(env, CPU_610);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK610;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck610e_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV1);
+    csky_set_feature(env, CPU_610);
+    csky_set_feature(env, ABIV1_DSP);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK610;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck610f_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV1);
+    csky_set_feature(env, CPU_610);
+    csky_set_feature(env, ABIV1_FPU);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK610;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck610ef_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV1);
+    csky_set_feature(env, CPU_610);
+    csky_set_feature(env, ABIV1_DSP);
+    csky_set_feature(env, ABIV1_FPU);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK610;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck801_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_801);
+    csky_set_feature(env, ABIV2_ELRW);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK801;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck801t_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_801);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, ABIV2_ELRW);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK801;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck802_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_802);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK802;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck802j_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_802);
+    csky_set_feature(env, ABIV2_JAVA);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK802;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck802t_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_802);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK802;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803t_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803f_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_FPU_803S);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803e_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_DSP);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803et_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_DSP);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803ef_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_DSP);
+    csky_set_feature(env, ABIV2_FPU_803S);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803ft_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, ABIV2_FPU_803S);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803eft_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_DSP);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, ABIV2_FPU_803S);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803r1_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_803S_R1);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803tr1_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_803S_R1);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803fr1_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_803S_R1);
+    csky_set_feature(env, ABIV2_FPU_803S);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803er1_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_803S_R1);
+    csky_set_feature(env, ABIV2_EDSP);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803etr1_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_803S_R1);
+    csky_set_feature(env, ABIV2_EDSP);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803efr1_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_803S_R1);
+    csky_set_feature(env, ABIV2_EDSP);
+    csky_set_feature(env, ABIV2_FPU_803S);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803ftr1_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_803S_R1);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, ABIV2_FPU_803S);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck803eftr1_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_803S);
+    csky_set_feature(env, ABIV2_803S_R1);
+    csky_set_feature(env, ABIV2_EDSP);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, ABIV2_FPU_803S);
+    csky_set_feature(env, CSKY_MGU);
+    env->cpuid = CSKY_CPUID_CK803S;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck807_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_807);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK807;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck807f_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_807);
+    csky_set_feature(env, ABIV2_FPU);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK807;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck810_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_810);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK810;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck810v_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_810);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK810;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck810f_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_810);
+    csky_set_feature(env, ABIV2_FPU);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK810;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck810t_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_810);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK810;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck810fv_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_810);
+    csky_set_feature(env, ABIV2_FPU);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK810;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck810tv_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_810);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK810;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck810ft_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_810);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK810;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void ck810ftv_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_810);
+    csky_set_feature(env, ABIV2_DSP);
+    csky_set_feature(env, ABIV2_TEE);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK810;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+static void any_cpu_initfn(Object *obj)
+{
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+
+    csky_set_feature(env, CPU_ABIV2);
+    csky_set_feature(env, CPU_810);
+    csky_set_feature(env, ABIV2_DSP);
+    csky_set_feature(env, ABIV2_FPU);
+    csky_set_feature(env, ABIV2_VDSP128);
+    csky_set_feature(env, CSKY_MMU);
+    env->cpuid = CSKY_CPUID_CK810;
+    env->cp0.cpidr[0] = env->cpuid;
+}
+
+typedef struct CSKYCPUInfo {
+    const char *name;
+    void (*instance_init)(Object *obj);
+} CSKYCPUInfo;
+
+/*
+ * postfix is alphabetical order: c, e, f, h, j, m, t, v, x
+ * Crypto, Edsp, Float, sHield, Java, Memory, Trust, Vdsp, Xcore
+ */
+static const CSKYCPUInfo csky_cpus[] = {
+    { .name = "ck510",       .instance_init = ck510_cpu_initfn },
+    { .name = "ck520",       .instance_init = ck520_cpu_initfn },
+    { .name = "ck610",       .instance_init = ck610_cpu_initfn },
+    { .name = "ck610e",      .instance_init = ck610e_cpu_initfn },
+    { .name = "ck610f",      .instance_init = ck610f_cpu_initfn },
+    { .name = "ck610ef",     .instance_init = ck610ef_cpu_initfn },
+    { .name = "ck801",       .instance_init = ck801_cpu_initfn },
+    { .name = "ck801t",      .instance_init = ck801t_cpu_initfn },
+    { .name = "ck802",       .instance_init = ck802_cpu_initfn },
+    { .name = "ck802h",      .instance_init = ck802_cpu_initfn },
+    { .name = "ck802j",      .instance_init = ck802j_cpu_initfn },
+    { .name = "ck802t",      .instance_init = ck802t_cpu_initfn },
+    { .name = "ck802ht",     .instance_init = ck802t_cpu_initfn },
+    { .name = "ck803",       .instance_init = ck803_cpu_initfn },
+    { .name = "ck803h",      .instance_init = ck803_cpu_initfn },
+    { .name = "ck803t",      .instance_init = ck803t_cpu_initfn },
+    { .name = "ck803ht",     .instance_init = ck803t_cpu_initfn },
+    { .name = "ck803f",      .instance_init = ck803f_cpu_initfn },
+    { .name = "ck803fh",     .instance_init = ck803f_cpu_initfn },
+    { .name = "ck803e",      .instance_init = ck803e_cpu_initfn },
+    { .name = "ck803eh",     .instance_init = ck803e_cpu_initfn },
+    { .name = "ck803et",     .instance_init = ck803et_cpu_initfn },
+    { .name = "ck803eht",    .instance_init = ck803et_cpu_initfn },
+    { .name = "ck803ef",     .instance_init = ck803ef_cpu_initfn },
+    { .name = "ck803efh",    .instance_init = ck803ef_cpu_initfn },
+    { .name = "ck803ft",     .instance_init = ck803ft_cpu_initfn },
+    { .name = "ck803eft",    .instance_init = ck803eft_cpu_initfn },
+    { .name = "ck803efht",   .instance_init = ck803eft_cpu_initfn },
+    { .name = "ck803r1",     .instance_init = ck803r1_cpu_initfn },
+    { .name = "ck803hr1",    .instance_init = ck803r1_cpu_initfn },
+    { .name = "ck803tr1",    .instance_init = ck803tr1_cpu_initfn },
+    { .name = "ck803htr1",   .instance_init = ck803tr1_cpu_initfn },
+    { .name = "ck803fr1",    .instance_init = ck803fr1_cpu_initfn },
+    { .name = "ck803fhr1",   .instance_init = ck803fr1_cpu_initfn },
+    { .name = "ck803er1",    .instance_init = ck803er1_cpu_initfn },
+    { .name = "ck803ehr1",   .instance_init = ck803er1_cpu_initfn },
+    { .name = "ck803etr1",   .instance_init = ck803etr1_cpu_initfn },
+    { .name = "ck803ehtr1",  .instance_init = ck803etr1_cpu_initfn },
+    { .name = "ck803efr1",   .instance_init = ck803efr1_cpu_initfn },
+    { .name = "ck803efhr1",  .instance_init = ck803efr1_cpu_initfn },
+    { .name = "ck803ftr1",   .instance_init = ck803ftr1_cpu_initfn },
+    { .name = "ck803fhtr1",  .instance_init = ck803ftr1_cpu_initfn },
+    { .name = "ck803eftr1",  .instance_init = ck803eftr1_cpu_initfn },
+    { .name = "ck803efhtr1", .instance_init = ck803eftr1_cpu_initfn },
+    { .name = "ck803s",      .instance_init = ck803_cpu_initfn },
+    { .name = "ck803sf",     .instance_init = ck803f_cpu_initfn },
+    { .name = "ck803sef",    .instance_init = ck803ef_cpu_initfn },
+    { .name = "ck803st",     .instance_init = ck803t_cpu_initfn },
+    { .name = "ck807",       .instance_init = ck807_cpu_initfn },
+    { .name = "ck807e",      .instance_init = ck807_cpu_initfn },
+    { .name = "ck807f",      .instance_init = ck807f_cpu_initfn },
+    { .name = "ck807ef",     .instance_init = ck807f_cpu_initfn },
+    { .name = "ck810",       .instance_init = ck810_cpu_initfn },
+    { .name = "ck810v",      .instance_init = ck810v_cpu_initfn },
+    { .name = "ck810f",      .instance_init = ck810f_cpu_initfn },
+    { .name = "ck810t",      .instance_init = ck810t_cpu_initfn },
+    { .name = "ck810fv",     .instance_init = ck810fv_cpu_initfn },
+    { .name = "ck810tv",     .instance_init = ck810tv_cpu_initfn },
+    { .name = "ck810ft",     .instance_init = ck810ft_cpu_initfn },
+    { .name = "ck810ftv",    .instance_init = ck810ftv_cpu_initfn },
+    { .name = "ck810e",      .instance_init = ck810_cpu_initfn },
+    { .name = "ck810et",     .instance_init = ck810t_cpu_initfn },
+    { .name = "ck810ef",     .instance_init = ck810f_cpu_initfn },
+    { .name = "ck810efm",    .instance_init = ck810f_cpu_initfn },
+    { .name = "ck810eft",    .instance_init = ck810ft_cpu_initfn },
+    { .name = "any",         .instance_init = any_cpu_initfn },
+    { .name = NULL }
+};
+
+static void csky_cpu_realizefn(DeviceState *dev, Error **errp)
+{
+    CPUState *cs = CPU(dev);
+    /* CSKYCPU *cpu = CSKY_CPU(dev); */
+    CSKYCPUClass *cc = CSKY_CPU_GET_CLASS(dev);
+    Error *local_err = NULL;
+
+    cpu_exec_realizefn(cs, &local_err);
+    if (local_err != NULL) {
+        error_propagate(errp, local_err);
+        return;
+    }
+
+    /* csky_cpu_init_gdb(cpu); */
+
+    cpu_reset(cs);
+    qemu_init_vcpu(cs);
+
+    cc->parent_realize(dev, errp);
+}
+
+static void csky_cpu_initfn(Object *obj)
+{
+    CPUState *cs = CPU(obj);
+    CSKYCPU *cpu = CSKY_CPU(obj);
+    CPUCSKYState *env = &cpu->env;
+    static bool inited;
+
+    cs->env_ptr = env;
+
+    if (tcg_enabled() && !inited) {
+        inited = true;
+        csky_translate_init();
+    }
+}
+
+static const VMStateDescription vmstate_csky_cpu = {
+    .name = "cpu",
+    .unmigratable = 1,
+};
+
+static void csky_cpu_class_init(ObjectClass *c, void *data)
+{
+    CSKYCPUClass *mcc = CSKY_CPU_CLASS(c);
+    CPUClass *cc = CPU_CLASS(c);
+    DeviceClass *dc = DEVICE_CLASS(c);
+
+    mcc->parent_realize = dc->realize;
+    dc->realize = csky_cpu_realizefn;
+
+    mcc->parent_reset = cc->reset;
+    cc->reset = csky_cpu_reset;
+
+    cc->class_by_name = csky_cpu_class_by_name;
+    cc->has_work = csky_cpu_has_work;
+    cc->do_interrupt = csky_cpu_do_interrupt;
+    cc->do_unaligned_access = csky_cpu_do_unaligned_access;
+    cc->cpu_exec_interrupt = csky_cpu_exec_interrupt;
+    cc->dump_state = csky_cpu_dump_state;
+    cc->set_pc = csky_cpu_set_pc;
+    cc->gdb_read_register = csky_cpu_gdb_read_register;
+    cc->gdb_write_register = csky_cpu_gdb_write_register;
+#ifdef CONFIG_USER_ONLY
+    cc->handle_mmu_fault = csky_cpu_handle_mmu_fault;
+#else
+    cc->get_phys_page_debug = csky_cpu_get_phys_page_debug;
+#endif
+    cc->disas_set_info = csky_cpu_disas_set_info;
+
+    cc->gdb_num_core_regs = 188;
+
+    dc->vmsd = &vmstate_csky_cpu;
+}
+
+static void register_cpu_type(const CSKYCPUInfo *info)
+{
+    TypeInfo type_info = {
+        .parent = TYPE_CSKY_CPU,
+        .instance_init = info->instance_init,
+    };
+
+    type_info.name = g_strdup_printf("%s-" TYPE_CSKY_CPU, info->name);
+    type_register(&type_info);
+    g_free((void *)type_info.name);
+}
+
+static const TypeInfo csky_cpu_type_info = {
+    .name = TYPE_CSKY_CPU,
+    .parent = TYPE_CPU,
+    .instance_size = sizeof(CSKYCPU),
+    .instance_init = csky_cpu_initfn,
+    .abstract = true,
+    .class_size = sizeof(CSKYCPUClass),
+    .class_init = csky_cpu_class_init,
+};
+
+static void csky_cpu_register_types(void)
+{
+    int i;
+
+    type_register_static(&csky_cpu_type_info);
+    for (i = 0; i < ARRAY_SIZE(csky_cpus); i++) {
+        register_cpu_type(&csky_cpus[i]);
+    }
+}
+
+type_init(csky_cpu_register_types)
diff --git a/target-csky/cpu.h b/target-csky/cpu.h
new file mode 100644
index 0000000..9b5d6e2
--- /dev/null
+++ b/target-csky/cpu.h
@@ -0,0 +1,486 @@
+/*
+ * CSKY virtual CPU header
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef CSKY_CPU_H
+#define CSKY_CPU_H
+
+#define ALIGNED_ONLY
+
+#define CPUArchState struct CPUCSKYState
+
+/* target long bits */
+#define TARGET_LONG_BITS    32
+
+#define TARGET_PAGE_BITS    12
+
+#define TARGET_PHYS_ADDR_SPACE_BITS 32
+#define TARGET_VIRT_ADDR_SPACE_BITS 32
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "exec/cpu-defs.h"
+#include "cpu-qom.h"
+
+#include "fpu/softfloat.h"
+
+/* CSKY Exception definition */
+#define EXCP_NONE                   -1
+#define EXCP_CSKY_RESET             0
+#define EXCP_CSKY_ALIGN             1
+#define EXCP_CSKY_DATA_ABORT        2
+#define EXCP_CSKY_DIV               3
+#define EXCP_CSKY_UDEF              4
+#define EXCP_CSKY_PRIVILEGE         5
+#define EXCP_CSKY_TRACE             6
+#define EXCP_CSKY_BKPT              7
+#define EXCP_CSKY_URESTORE          8
+#define EXCP_CSKY_IDLY4             9
+#define EXCP_CSKY_IRQ               10
+#define EXCP_CSKY_FIQ               11
+#define EXCP_CSKY_HAI               12
+#define EXCP_CSKY_FP                13
+#define EXCP_CSKY_TLB_UNMATCH       14
+#define EXCP_CSKY_TLB_MODIFY        15
+#define EXCP_CSKY_TRAP0             16
+#define EXCP_CSKY_TRAP1             17
+#define EXCP_CSKY_TRAP2             18
+#define EXCP_CSKY_TRAP3             19
+#define EXCP_CSKY_TLB_READ_INVALID  20
+#define EXCP_CSKY_TLB_WRITE_INVALID 21
+#define EXCP_CSKY_FLOAT             30
+#define EXCP_CSKY_CPU_END           31
+
+#define CPU_INTERRUPT_FIQ   CPU_INTERRUPT_TGT_EXT_1
+
+#define NB_MMU_MODES 2
+
+#define TB_TRACE_NUM 4096
+struct csky_trace_info {
+    int tb_pc;
+};
+
+/* MMU Control Registers */
+struct CSKYMMU {
+   uint32_t mir;        /* CR0 */
+   uint32_t mrr;        /* CR1 */
+   uint32_t mel0;       /* CR2 */
+   uint32_t mel1;       /* CR3 */
+   uint32_t meh;        /* CR4 */
+   uint32_t mcr;        /* CR5 */
+   uint32_t mpr;        /* CR6 */
+   uint32_t mwr;        /* CR7 */
+   uint32_t mcir;       /* CR8 */
+   uint32_t cr9;        /* CR9 */
+   uint32_t cr10;       /* CR10 */
+   uint32_t cr11;       /* CR11 */
+   uint32_t cr12;       /* CR12 */
+   uint32_t cr13;       /* CR13 */
+   uint32_t cr14;       /* CR14 */
+   uint32_t cr15;       /* CR15 */
+   uint32_t cr16;       /* CR16 */
+   uint32_t mpar;       /* CR29 */
+   uint32_t msa0;       /* CR30 */
+   uint32_t msa1;       /* CR31 */
+};
+
+/* CSKY CPUCSKYState definition */
+typedef struct CPUCSKYState {
+    uint32_t regs[32];
+    /* target pc */
+    uint32_t pc;
+    /* C register PSR[0] */
+    uint32_t psr_c;
+    /* S register PSR[31] */
+    uint32_t psr_s;
+    /* T register PSR[30] */
+    uint32_t psr_t;
+    /* bm register PSR[10] */
+    uint32_t psr_bm;
+    /* TM register PSR[15:14] */
+    uint32_t psr_tm;
+    /* dsp control status register */
+    uint32_t dcsr_v;
+    /* dsp hi, lo, high_guard, lo_guard register */
+    uint32_t hi;
+    uint32_t lo;
+    uint32_t hi_guard;
+    uint32_t lo_guard;
+    /* Banked Registers */
+    uint32_t banked_regs[16];
+    /* Idly4 counter */
+    uint32_t idly4_counter;
+    /* which instructions sequences should be translation */
+    uint32_t sce_condexec_bits;
+    /* sce sequence may be interrupted */
+    uint32_t sce_condexec_bits_bk;
+    /* interface for intc */
+    struct {
+        uint32_t avec_b;
+        uint32_t fint_b;
+        uint32_t int_b;
+        uint32_t vec_b;
+        uint32_t iabr;
+        uint32_t isr;
+        uint32_t iptr;
+        uint32_t issr;
+    } intc_signals;
+
+    /* system control coprocessor (cp0) */
+    struct {
+        uint32_t psr;    /* CR0 */
+        uint32_t vbr;    /* CR1 */
+        uint32_t epsr;   /* CR2 */
+        uint32_t fpsr;   /* CR3 */
+        uint32_t epc;    /* CR4 */
+        uint32_t fpc;    /* CR5 */
+        uint32_t ss0;    /* CR6 */
+        uint32_t ss1;    /* CR7 */
+        uint32_t ss2;    /* CR8 */
+        uint32_t ss3;    /* CR9 */
+        uint32_t ss4;    /* CR10 */
+        uint32_t gcr;    /* CR11 */
+        uint32_t gsr;    /* CR12 */
+        uint32_t cpidr[4];  /* CSKYV2 have four physic CR13 register */
+        uint32_t cpidr_counter;
+        uint32_t dcsr;    /* CR14 */
+        uint32_t cpwr;    /* CR15 */
+        uint32_t dummy;   /* no CR16 */
+        uint32_t cfr;     /* CR17 */
+        uint32_t ccr;     /* CR18 */
+        uint32_t capr;    /* CR19 */
+        uint32_t pacr[8]; /* CR20 */
+        uint32_t prsr;    /* CR21 */
+    } cp0;
+
+    /* stack point, sp used now is put in regs[14].
+     * if cpu not has the feature ABIV2_TEE, only use nt_Xsp. */
+    struct {
+        uint32_t nt_usp;  /* Non-secured user sp */
+        uint32_t nt_ssp;  /* CR<6,3>, Non-secured supervisor sp */
+        uint32_t nt_asp;  /* AF = 1, Non-secured sp */
+        uint32_t t_usp;   /* CR<7,3>, Secured user sp */
+        uint32_t t_ssp;   /* Secured supervisor sp */
+        uint32_t t_asp;   /* AF = 1, Secured sp */
+    } stackpoint;
+
+    /* registers for tee */
+    struct {
+        uint32_t t_psr;   /* CR<0,0>, T_PSR */
+        uint32_t nt_psr;  /* CR<0,0>, CR<0,3>, NT_PSR */
+        uint32_t t_vbr;   /* CR<1,0>, T_VBR */
+        uint32_t nt_vbr;  /* CR<1,0>, CR<1,3>, NT_VBR */
+        uint32_t t_epsr;  /* CR<2,0>, T_EPSR */
+        uint32_t nt_epsr; /* CR<2,0>, CR<2,3>, NT_EPSR */
+        uint32_t t_epc;   /* CR<4,0>, T_EPC */
+        uint32_t nt_epc;  /* CR<4,0>, CR<4,3>, NT_EPC */
+        uint32_t t_dcr;   /* CR<8,3>, T_DCR */
+        uint32_t t_pcr;   /* CR<9,3>, T_PCR */
+        uint32_t t_ebr;   /* CR<1,1>, T_EBR */
+        uint32_t nt_ebr;  /* CR<1,1>, CR<10,3>, NT_EBR */
+    } tee;
+
+    /* FPU registers */
+    struct {
+        float32 fr[32];     /* FPU general registers */
+        uint32_t fpcid;     /* Provide the information about FPC. */
+        uint32_t fcr;       /* Control register of FPC */
+        uint32_t fsr;       /* Status register of FPC */
+        uint32_t fir;       /* Instruction register of FPC */
+        uint32_t fesr;      /* Status register for exception process */
+        uint32_t feinst1;   /* The exceptional instruction */
+        uint32_t feinst2;   /* The exceptional instruction */
+        float_status fp_status;
+        float_status standard_fp_status;
+    } cp1;
+
+    /* VFP coprocessor state.  */
+    struct {
+        union VDSP {
+            float64  fpu[2];
+            uint64_t udspl[2];
+            uint32_t udspi[4];
+            int32_t  dspi[4];
+            uint16_t udsps[8];
+            int16_t  dsps[8];
+            uint8_t  udspc[16];
+            int8_t   dspc[16];
+        } reg[16];
+        uint32_t fid;
+        uint32_t fcr;
+        uint32_t fesr;
+        /* fp_status is the "normal" fp status. standard_fp_status retains
+         * values corresponding to the ARM "Standard FPSCR Value", ie
+         * default-NaN, flush-to-zero, round-to-nearest and is used by
+         * any operations (generally Neon) which the architecture defines
+         * as controlled by the standard FPSCR value rather than the FPSCR.
+         *
+         * To avoid having to transfer exception bits around, we simply
+         * say that the FPSCR cumulative exception flags are the logical
+         * OR of the flags in the two fp statuses. This relies on the
+         * only thing which needs to read the exception flags being
+         * an explicit FPSCR read.
+         */
+        float_status fp_status;
+        float_status standard_fp_status;
+    } vfp;
+
+    struct CSKYMMU mmu;     /* mmu control registers used now. */
+    struct CSKYMMU nt_mmu;  /* Non-Trust mmu control registers. */
+    struct CSKYMMU t_mmu;   /* Non-Trust mmu control registers. */
+
+#if !defined(CONFIG_USER_ONLY)
+    struct CPUCSKYTLBContext *tlb_context;
+#endif
+
+    uint32_t tls_value;
+    CPU_COMMON
+
+    /* These fields after the common ones so they are preserved on reset.  */
+
+    /* Internal CPU feature flags.  */
+    uint64_t features;
+
+    /* pctrace */
+    uint32_t pctraces_max_num;
+
+    /* binstart */
+    uint32_t binstart;
+
+    uint32_t cpuid;
+
+    void *nvic;
+
+    uint32_t mmu_default;
+
+    uint32_t tb_trace;
+    uint32_t jcount_start;
+    uint32_t jcount_end;
+
+    struct csky_boot_info *boot_info;
+    struct csky_trace_info *trace_info;
+    uint32_t trace_index;
+} CPUCSKYState;
+
+/**
+ * CSKYCPU:
+ * @env: #CPUCSKYState
+ *
+ * A CSKY CPU.
+ */
+struct CSKYCPU {
+    /*< private >*/
+    CPUState parent_obj;
+    /*< public >*/
+
+    CPUCSKYState env;
+};
+
+static inline CSKYCPU *csky_env_get_cpu(CPUCSKYState *env)
+{
+    return container_of(env, CSKYCPU, env);
+}
+
+#define ENV_GET_CPU(e) CPU(csky_env_get_cpu(e))
+
+#define ENV_OFFSET offsetof(CSKYCPU, env)
+
+/* functions statement */
+CSKYCPU *cpu_csky_init(const char *cpu_model);
+void csky_translate_init(void);
+int csky_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,
+                              int mmu_idx);
+int cpu_csky_signal_handler(int host_signum, void *pinfo, void *puc);
+void csky_cpu_list(FILE *f, fprintf_function cpu_fprintf);
+
+void csky_cpu_do_unaligned_access(CPUState *cs, vaddr vaddr,
+                                  MMUAccessType access_type,
+                                  int mmu_idx, uintptr_t retaddr);
+int csky_cpu_gdb_read_register(CPUState *cs, uint8_t *mem_buf, int n);
+int csky_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n);
+void csky_cpu_do_interrupt(CPUState *cs);
+hwaddr csky_cpu_get_phys_page_debug(CPUState *env, vaddr addr);
+bool csky_cpu_exec_interrupt(CPUState *cs, int interrupt_request);
+void csky_nommu_init(CPUCSKYState *env);
+void csky_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,
+                         int flags);
+
+#define cpu_init(cpu_model) CPU(cpu_csky_init(cpu_model))
+#define cpu_signal_handler  cpu_csky_signal_handler
+#define cpu_list    csky_cpu_list
+
+/* FIXME MMU modes definitions */
+#define MMU_USER_IDX  0
+#define CSKY_USERMODE 0
+
+#include "exec/cpu-all.h"
+
+/* bit usage in tb flags field. */
+#define CSKY_TBFLAG_SCE_CONDEXEC_SHIFT  0
+#define CSKY_TBFLAG_SCE_CONDEXEC_MASK   (0x1F << CSKY_TBFLAG_SCE_CONDEXEC_SHIFT)
+#define CSKY_TBFLAG_PSR_S_SHIFT         5
+#define CSKY_TBFLAG_PSR_S_MASK          (0x1 << CSKY_TBFLAG_PSR_S_SHIFT)
+#define CSKY_TBFLAG_CPID_SHIFT          6
+#define CSKY_TBFLAG_CPID_MASK           (0xF << CSKY_TBFLAG_CPID_SHIFT)
+#define CSKY_TBFLAG_ASID_SHIFT          10
+#define CSKY_TBFLAG_ASID_MASK           (0xFF << CSKY_TBFLAG_ASID_SHIFT)
+#define CSKY_TBFLAG_PSR_BM_SHIFT        18
+#define CSKY_TBFLAG_PSR_BM_MASK         (0x1 << CSKY_TBFLAG_PSR_BM_SHIFT)
+#define CSKY_TBFLAG_PSR_TM_SHIFT        19
+#define CSKY_TBFLAG_PSR_TM_MASK         (0x3 << CSKY_TBFLAG_PSR_TM_SHIFT)
+#define CSKY_TBFLAG_PSR_T_SHIFT         21
+#define CSKY_TBFLAG_PSR_T_MASK          (0x1 << CSKY_TBFLAG_PSR_T_SHIFT)
+#define CSKY_TBFLAG_IDLY4_SHIFT         22
+#define CSKY_TBFLAG_IDLY4_MASK          (0x7 << CSKY_TBFLAG_IDLY4_SHIFT)
+/* TB flags[25:31] are unused */
+
+
+#define CSKY_TBFLAG_SCE_CONDEXEC(flag)  \
+    (((flag) & CSKY_TBFLAG_SCE_CONDEXEC_MASK) >> CSKY_TBFLAG_SCE_CONDEXEC_SHIFT)
+#define CSKY_TBFLAG_PSR_S(flag) \
+    (((flag) & CSKY_TBFLAG_PSR_S_MASK) >> CSKY_TBFLAG_PSR_S_SHIFT)
+#define CSKY_TBFLAG_PSR_BM(flag) \
+    (((flag) & CSKY_TBFLAG_PSR_BM_MASK) >> CSKY_TBFLAG_PSR_BM_SHIFT)
+#define CSKY_TBFLAG_CPID(flag)    \
+    (((flag) & CSKY_TBFLAG_CPID_MASK) >> CSKY_TBFLAG_CPID_SHIFT)
+#define CSKY_TBFLAG_PSR_TM(flag)    \
+    (((flag) & CSKY_TBFLAG_PSR_TM_MASK) >> CSKY_TBFLAG_PSR_TM_SHIFT)
+#define CSKY_TBFLAG_PSR_T(flag)    \
+    (((flag) & CSKY_TBFLAG_PSR_T_MASK) >> CSKY_TBFLAG_PSR_T_SHIFT)
+
+/* CPU id */
+#define CSKY_CPUID_CK510      0x00000000
+#define CSKY_CPUID_CK520      0x00000000
+#define CSKY_CPUID_CK610      0x1000f002
+
+#define CSKY_CPUID_CK801      0x04880003
+#define CSKY_CPUID_CK802      0x04880003
+#define CSKY_CPUID_CK803      0x04800003
+#define CSKY_CPUID_CK803S     0x04900003
+#define CSKY_CPUID_CK807      0x048c0203  /* default mmu */
+#define CSKY_CPUID_CK810      0x04840203  /* default mmu */
+
+/* cpu features flags */
+#define CPU_ABIV1               (1 << 0)
+#define CPU_ABIV2               (1 << 1)
+#define CPU_510                 (1 << 2)
+#define CPU_520                 (1 << 3)
+#define CPU_610                 (1 << 4)
+#define CPU_801                 (1 << 6)
+#define CPU_802                 (1 << 7)
+#define CPU_803                 (1 << 8)
+#define CPU_803S                (1 << 9)
+#define CPU_807                 (1 << 10)
+#define CPU_810                 (1 << 11)
+#define CSKY_MMU                (1 << 16)
+#define CSKY_MGU                (1 << 17)
+#define ABIV1_DSP               (1 << 18)
+#define ABIV1_FPU               (1 << 19)
+#define ABIV2_TEE               (1 << 20)
+#define ABIV2_DSP               (1 << 21)
+#define ABIV2_FPU               (1 << 22)
+#define ABIV2_FPU_803S          (1 << 23)
+#define ABIV2_EDSP              (1 << 24)
+#define ABIV2_803S_R1           (1 << 25)
+#define ABIV2_JAVA              (1 << 26)
+#define ABIV2_VDSP64            (1 << 27)
+#define ABIV2_VDSP128           (1 << 28)
+#define ABIV2_ELRW              (1 << 29)
+#define UNALIGNED_ACCESS        (1 << 30)
+
+#define ABIV2_FLOAT_S           (ABIV2_FPU_803S | ABIV2_FPU)
+#define ABIV2_FLOAT_D           (ABIV2_FPU)
+#define ABIV2_FLOAT_ALL         (ABIV2_FPU)
+
+/* get bit from psr */
+#define PSR_CPID_MASK   0x0f000000
+#define PSR_CPID(psr)   (((psr) & PSR_CPID_MASK) >> 24)
+#define PSR_IE_MASK     0x00000040
+#define PSR_IE(psr)     (((psr) & PSR_IE_MASK) >> 6)
+#define PSR_EE_MASK     0x00000100
+#define PSR_EE(psr)     (((psr) & PSR_EE_MASK) >> 8)
+#define PSR_FE_MASK     0x00000010
+#define PSR_FE(psr)     (((psr) & PSR_FE_MASK) >> 4)
+#define PSR_S_MASK      0x80000000
+#define PSR_S(psr)      (((psr) & PSR_S_MASK) >> 31)
+#define PSR_BM_MASK     0x00000400
+#define PSR_BM(psr)     (((psr) & PSR_BM_MASK) >> 10)
+#define PSR_C_MASK      0x00000001
+#define PSR_C(psr)      (((psr) & PSR_C_MASK) >> 0)
+#define PSR_TM_MASK     0x0000c000
+#define PSR_TM(psr)     (((psr) & PSR_TM_MASK) >> 14)
+#define PSR_TP_MASK     0x00002000
+#define PSR_TP(psr)     (((psr) & PSR_TP_MASK) >> 13)
+#define PSR_VEC_MASK    0x00ff0000
+#define PSR_VEC(psr)    (((psr) & PSR_VEC_MASK) >> 16)
+/* get bit from psr when has tee */
+#define PSR_T_MASK      0x40000000
+#define PSR_T(psr)      (((psr) & PSR_T_MASK) >> 30)
+#define PSR_SP_MASK     0x20000000
+#define PSR_SP(psr)     (((psr) & PSR_SP_MASK) >> 29)
+#define PSR_HS_MASK     0x10000000
+#define PSR_HS(psr)     (((psr) & PSR_HS_MASK) >> 28)
+#define PSR_SC_MASK     0x08000000
+#define PSR_SC(psr)     (((psr) & PSR_SC_MASK) >> 27)
+#define PSR_SD_MASK     0x04000000
+#define PSR_SD(psr)     (((psr) & PSR_SD_MASK) >> 26)
+#define PSR_ST_MASK     0x02000000
+#define PSR_ST(psr)     (((psr) & PSR_ST_MASK) >> 25)
+
+/* MMU MCIR bit MASK */
+#define CSKY_MCIR_TLBP_SHIFT        31
+#define CSKY_MCIR_TLBP_MASK         (1 << CSKY_MCIR_TLBP_SHIFT)
+#define CSKY_MCIR_TLBR_SHIFT        30
+#define CSKY_MCIR_TLBR_MASK         (1 << CSKY_MCIR_TLBR_SHIFT)
+#define CSKY_MCIR_TLBWI_SHIFT       29
+#define CSKY_MCIR_TLBWI_MASK        (1 << CSKY_MCIR_TLBWI_SHIFT)
+#define CSKY_MCIR_TLBWR_SHIFT       28
+#define CSKY_MCIR_TLBWR_MASK        (1 << CSKY_MCIR_TLBWR_SHIFT)
+#define CSKY_MCIR_TLBINV_SHIFT      27
+#define CSKY_MCIR_TLBINV_MASK       (1 << CSKY_MCIR_TLBINV_SHIFT)
+#define CSKY_MCIR_TLBINV_ALL_SHIFT  26
+#define CSKY_MCIR_TLBINV_ALL_MASK   (1 << CSKY_MCIR_TLBINV_ALL_SHIFT)
+#define CSKY_MCIR_TTLBINV_ALL_SHIFT 24
+#define CSKY_MCIR_TTLBINV_ALL_MASK  (1 << CSKY_MCIR_TTLBINV_ALL_SHIFT)
+
+static inline int cpu_mmu_index(CPUCSKYState *env, bool ifetch)
+{
+    return PSR_S(env->cp0.psr);
+}
+
+static inline void cpu_get_tb_cpu_state(CPUCSKYState *env, target_ulong *pc,
+        target_ulong *cs_base, uint32_t *flags)
+{
+    *pc = env->pc;
+    *cs_base = 0;
+#if defined(TARGET_CSKYV2)
+    *flags = (env->psr_s << CSKY_TBFLAG_PSR_S_SHIFT)
+        | (env->psr_bm << CSKY_TBFLAG_PSR_BM_SHIFT)
+        | (env->sce_condexec_bits << CSKY_TBFLAG_SCE_CONDEXEC_SHIFT)
+        | (env->mmu.meh & 0xff) << CSKY_TBFLAG_ASID_SHIFT
+        | (env->psr_tm << CSKY_TBFLAG_PSR_TM_SHIFT)
+        | (env->psr_t << CSKY_TBFLAG_PSR_T_SHIFT)
+        | (env->idly4_counter << CSKY_TBFLAG_IDLY4_SHIFT);
+#else
+    *flags = (PSR_CPID(env->cp0.psr) << CSKY_TBFLAG_CPID_SHIFT)
+        | (env->psr_s << CSKY_TBFLAG_PSR_S_SHIFT)
+        | (env->mmu.meh & 0xff) << CSKY_TBFLAG_ASID_SHIFT
+        | (env->psr_tm << CSKY_TBFLAG_PSR_TM_SHIFT)
+        | (env->idly4_counter << CSKY_TBFLAG_IDLY4_SHIFT);
+#endif
+}
+
+#endif /* CSKY_CPU_H */
diff --git a/target-csky/gdbstub.c b/target-csky/gdbstub.c
new file mode 100644
index 0000000..b9a275b
--- /dev/null
+++ b/target-csky/gdbstub.c
@@ -0,0 +1,434 @@
+/*
+ * CSKY gdb server stub
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "cpu.h"
+#include "translate.h"
+#include "exec/gdbstub.h"
+#include "exec/exec-all.h"
+#include "exec/helper-proto.h"
+
+#define NUM_CORE_REGS 144
+
+static int cskyv1cpu_gdb_read_register(CPUCSKYState *env,
+                                       uint8_t *mem_buf, int n)
+{
+    int ret = 0;
+    switch (n) {
+    case 0 ... 15:
+        /* Current general registers */
+        ret = gdb_get_reg32(mem_buf, env->regs[n]);
+        break;
+    case 20:
+        /* hi register */
+        ret = gdb_get_reg32(mem_buf, env->hi);
+        break;
+    case 21:
+        /* lo register */
+        ret = gdb_get_reg32(mem_buf, env->lo);
+        break;
+    case 24 ... 55:
+        /* cp1gr0 ~ cp1gr31 */
+        ret = gdb_get_reg32(mem_buf, env->cp1.fr[n - 24]);
+        break;
+    case 72:
+        /* pc register */
+        ret = gdb_get_reg32(mem_buf, env->pc);
+        break;
+#if !defined(CONFIG_USER_ONLY)
+    case 73 ... 88:
+        /* Banked registers */
+        ret = gdb_get_reg32(mem_buf, env->banked_regs[n - 73]);
+        break;
+    case 89:
+        ret = gdb_get_reg32(mem_buf, env->cp0.psr | (env->psr_s << 31) |
+                            env->psr_c);
+        break;
+    case 90 ... 101:
+        /* Cp0 CPU control registers */
+        ret = gdb_get_reg32(mem_buf, ((uint32_t *)&env->cp0.vbr)[n - 90]);
+        break;
+    case 102:
+        ret = gdb_get_reg32(mem_buf, env->cp0.cpidr_counter);
+        break;
+    case 103:
+        ret = gdb_get_reg32(mem_buf, env->cp0.dcsr | env->dcsr_v);
+        break;
+    case 104 ... 108:
+        ret = gdb_get_reg32(mem_buf, ((uint32_t *)&env->cp0.cpwr)[n - 104]);
+        break;
+    case 109:
+        /* pacr */
+        ret = gdb_get_reg32(mem_buf, env->cp0.pacr[env->cp0.prsr & 0x7]);
+        break;
+    case 110:
+        /* prsr */
+        ret = gdb_get_reg32(mem_buf, env->cp0.prsr);
+        break;
+    case 111 ... 120:
+#endif
+    case 121 ... 127:
+        /* cp1cr0 ~ cp1cr6 */
+        ret = gdb_get_reg32(mem_buf, 0);
+        break;
+    case 128 ... 136:
+        /* cp15cr0 ~ cp15cr8 */
+        ret = gdb_get_reg32(mem_buf, 0);
+        break;
+    default:
+        ret = gdb_get_reg32(mem_buf, 0);
+    }
+    return ret;
+}
+
+static int cskyv2cpu_gdb_read_register(CPUCSKYState *env,
+                                       uint8_t *mem_buf, int n)
+{
+    int ret = 0;
+    switch (n) {
+    case 0 ... 31:
+        /* Current general registers */
+        ret = gdb_get_reg32(mem_buf, env->regs[n]);
+        break;
+    case 36:
+        /* hi register */
+        ret = gdb_get_reg32(mem_buf, env->hi);
+        break;
+    case 37:
+        /* lo register */
+        ret = gdb_get_reg32(mem_buf, env->lo);
+        break;
+    case 40 ... 55:
+        /* fr0 ~ fr15 */
+        ret = gdb_get_reg64(mem_buf, env->vfp.reg[n - 40].fpu[0]);
+        break;
+    case 56 ... 71:
+        /* vr0 ~ vr15 */
+        memcpy(mem_buf, &(env->vfp.reg[n - 56].fpu[0]), 16);
+        ret = 16;
+        break;
+    case 72:
+        /* pc register */
+        ret = gdb_get_reg32(mem_buf, env->pc);
+        break;
+#if !defined(CONFIG_USER_ONLY)
+    case 73 ... 88:
+        /* Banked registers */
+        ret = gdb_get_reg32(mem_buf, env->banked_regs[n - 73]);
+        break;
+    case 89:
+        ret = gdb_get_reg32(mem_buf, env->cp0.psr | (env->psr_s << 31) |
+                      (env->psr_bm << 2) | env->psr_c);
+        break;
+    case 90 ... 101:
+        ret = gdb_get_reg32(mem_buf, ((uint32_t *)&env->cp0.vbr)[n - 90]);
+        break;
+    case 102:
+        {
+            uint32_t counter;
+
+            counter = env->cp0.cpidr_counter;
+            env->cp0.cpidr_counter = (counter + 1) % 4;
+            ret = gdb_get_reg32(mem_buf, env->cp0.cpidr[counter]);
+            break;
+        }
+    case  103 ... 108:
+        ret = gdb_get_reg32(mem_buf, ((uint32_t *)&env->cp0.dcsr)[n - 103]);
+        break;
+    case 109:
+        ret = gdb_get_reg32(mem_buf, env->cp0.pacr[env->cp0.prsr & 0x7]);
+        break;
+    case 110:
+        ret = gdb_get_reg32(mem_buf, env->cp0.prsr);
+        break;
+    case 111 ... 120:
+        ret = gdb_get_reg32(mem_buf, 0);
+        break;
+#endif
+    case 121 ... 123:
+        /* fid fcr fesr */
+        ret = gdb_get_reg32(mem_buf, ((uint32_t *)&env->vfp.fid)[n - 121]);
+        break;
+    case 127:
+        /* usp */
+        ret = gdb_get_reg32(mem_buf, env->stackpoint.nt_usp);
+        break;
+    case 128 ... 136:
+        /* cp15cr0 ~ cp15cr8 */
+        ret = gdb_get_reg32(mem_buf, 0);
+        break;
+    case 140 ... 188:
+        /* profcr0 ~ profxgr12 */
+        ret = gdb_get_reg32(mem_buf, 0);
+        break;
+    default:
+        ret = gdb_get_reg32(mem_buf, 0);
+    }
+    return ret;
+}
+
+int csky_cpu_gdb_read_register(CPUState *cs, uint8_t *mem_buf, int n)
+{
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+
+    if (env->features & CPU_ABIV1) {
+        return cskyv1cpu_gdb_read_register(env, mem_buf, n);
+    } else if (env->features & CPU_ABIV2) {
+        return cskyv2cpu_gdb_read_register(env, mem_buf, n);
+    } else {
+        g_assert(0);
+    }
+
+    return 0;
+}
+
+static int cskyv1cpu_gdb_write_register(CPUCSKYState *env,
+                                        uint8_t *mem_buf, int n)
+{
+#if !defined(CONFIG_USER_ONLY)
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+#endif
+    uint32_t tmp;
+
+    tmp = ldl_p(mem_buf);
+    switch (n) {
+    case 0 ... 15:
+        /* Current general registers */
+        env->regs[n] = tmp;
+        return 4;
+    case 20:
+        /* hi register */
+        env->hi = tmp;
+        return 4;
+    case 21:
+        /* lo register */
+        env->lo = tmp;
+        return 4;
+    case 24 ... 55:
+        /* cp1gr0 ~ cp1gr31 */
+        env->cp1.fr[n - 24] = tmp;
+        break;
+    case 72:
+        /* pc register */
+        env->pc = tmp;
+        return 4;
+#if !defined(CONFIG_USER_ONLY)
+    case 73 ... 88:
+        /* Banked registers */
+        env->banked_regs[n - 73] = tmp;
+        return 4;
+    case 89:
+        if ((env->cp0.psr & 0x2) != (tmp & 0x2)) {
+            helper_switch_regs(env);
+        }
+        env->cp0.psr = tmp;
+        env->psr_c = tmp & 0x1;
+        env->psr_s = (tmp & (1 << 31)) >> 31;
+        return 4;
+    case 90 ... 100:
+        /* Cp0 CPU control registers */
+        ((uint32_t *)&env->cp0.vbr)[n - 90] = tmp;
+        return 4;
+    case 103 ... 106:
+        ((uint32_t *)&env->cp0.dcsr)[n - 103] = tmp;
+        return 4;
+    case 107:
+         /* cr18 */
+        if ((env->cp0.ccr & 0x1) != (tmp & 0x1)) {
+            /* flush global QEMU TLB and tb_jmp_cache */
+            tlb_flush(cs, 1);
+
+            if (tmp & 0x1) { /* for mmu/mgu */
+                if (env->features & CSKY_MMU) {
+                    env->tlb_context->get_physical_address =
+                                     mmu_get_physical_address;
+                } else if (env->features & CSKY_MGU) {
+                    env->tlb_context->get_physical_address =
+                                     mgu_get_physical_address;
+                }
+            } else {
+                env->tlb_context->get_physical_address =
+                              nommu_get_physical_address;
+            }
+        }
+
+        env->cp0.ccr = tmp;
+        return 4;
+    case 108:
+         /* cr19 */
+         env->cp0.capr = tmp;
+         return 4;
+    case 109:
+        env->cp0.pacr[env->cp0.prsr & 0x7] = tmp;
+        return 4;
+    case 110:
+        env->cp0.prsr = tmp;
+        return 4;
+    case 111 ... 120:
+        return 4;
+#endif
+    case 121 ... 123:
+        /* fid fcr fesr */
+        ((uint32_t *)&env->vfp.fid)[n - 121] = tmp;
+        return 4;
+    case 127:
+        /* usp */
+        env->stackpoint.nt_usp = tmp;
+        return 4;
+    case 128 ... 136:
+        /* cp15cr0 ~ cp15cr8 */
+        break;
+    default:
+        return 4;
+    }
+
+    return 4;
+}
+
+static int cskyv2cpu_gdb_write_register(CPUCSKYState *env,
+                                        uint8_t *mem_buf, int n)
+{
+#if !defined(CONFIG_USER_ONLY)
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+#endif
+    uint32_t tmp;
+
+    tmp = ldl_p(mem_buf);
+    switch (n) {
+    case 0 ... 31:
+        /* Current general registers */
+        env->regs[n] = tmp;
+        return 4;
+    case 36:
+        /* hi register */
+        env->hi = tmp;
+        return 4;
+    case 37:
+        /* lo register */
+        env->lo = tmp;
+        return 4;
+    case 40 ... 55:
+        /* fr0 ~ fr15 */
+        env->vfp.reg[n - 40].fpu[0] = tmp;
+        return 8;
+        break;
+    case 56 ... 71:
+        /* vr0 ~ vr15 */
+        return 16;
+        break;
+    case 72:
+        /* pc register */
+        env->pc = tmp;
+        return 4;
+#if !defined(CONFIG_USER_ONLY)
+    case 73 ... 88:
+        /* Banked registers */
+        env->banked_regs[n - 73] = tmp;
+        return 4;
+    case 89:
+        if ((env->cp0.psr & 0x2) != (tmp & 0x2)) {
+            helper_switch_regs(env);
+        }
+        if (env->features & ABIV2_JAVA) {
+            env->cp0.psr = tmp;
+            env->psr_s = tmp >> 31;
+            env->psr_bm = (tmp >> 2) & 0x1;
+            env->psr_c = tmp & 0x1;
+        } else {
+            env->cp0.psr = tmp & (~0x400);
+            env->psr_s = tmp >> 31;
+            env->psr_bm = 0;
+            env->psr_c = tmp & 0x1;
+        }
+        return 4;
+    case 90 ... 100:
+        ((uint32_t *)&env->cp0.psr)[n - 89] = tmp;
+        return 4;
+    case 101:
+         /* GSR */
+    case 102:
+         /* CPUIDRR */
+        return 4;
+    case 103 ... 106:
+        ((uint32_t *)&env->cp0.dcsr)[n - 103] = tmp;
+        return 4;
+    case 107:
+         /* CR18 */
+        if ((env->cp0.ccr & 0x1) != (tmp & 0x1)) {
+            /* flush global QEMU TLB and tb_jmp_cache */
+            tlb_flush(cs, 1);
+
+            if (tmp & 0x1) {  /* enable mmu/mgu */
+                if (env->features & CSKY_MMU) {
+                    env->tlb_context->get_physical_address =
+                                    mmu_get_physical_address;
+                } else if (env->features & CSKY_MGU) {
+                    env->tlb_context->get_physical_address =
+                                    mgu_get_physical_address;
+                }
+            } else {
+                env->tlb_context->get_physical_address =
+                              nommu_get_physical_address;
+            }
+
+        }
+
+        env->cp0.ccr = tmp;
+        return 4;
+    case 108:
+         env->cp0.capr = tmp;
+         return 4;
+    case 109:
+         env->cp0.pacr[env->cp0.prsr & 0x7] = tmp;
+         return 4;
+    case 110:
+         env->cp0.prsr = tmp;
+         return 4;
+#endif
+    case 111 ... 120:
+    case 121 ... 127:
+        /* cp1cr0 ~ cp1cr6 */
+        break;
+    case 128 ... 136:
+        /* cp15cr0 ~ cp15cr8 */
+        break;
+    case 140 ... 188:
+        /* profcr0 ~ profxgr12 */
+        break;
+    default:
+        return 4;
+    }
+
+    return 4;
+}
+
+int csky_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)
+{
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+
+    if (env->features & CPU_ABIV1) {
+        return cskyv1cpu_gdb_write_register(env, mem_buf, n);
+    } else if (env->features & CPU_ABIV2) {
+        return cskyv2cpu_gdb_write_register(env, mem_buf, n);
+    } else {
+        g_assert(0);
+    }
+
+    return 0;
+}
diff --git a/target-csky/helper.c b/target-csky/helper.c
new file mode 100644
index 0000000..eb2779e
--- /dev/null
+++ b/target-csky/helper.c
@@ -0,0 +1,406 @@
+/*
+ * CSKY helper
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "cpu.h"
+#include "translate.h"
+#include "exec/gdbstub.h"
+#include "exec/cpu_ldst.h"
+#include "exec/helper-proto.h"
+#include "qemu-common.h"
+#include "qemu/host-utils.h"
+#include "exec/exec-all.h"
+#if !defined(CONFIG_USER_ONLY)
+#include "hw/loader.h"
+#endif
+
+/* Sort alphabetically, except for "any". */
+static gint csky_cpu_list_compare(gconstpointer a, gconstpointer b)
+{
+    ObjectClass *class_a = (ObjectClass *)a;
+    ObjectClass *class_b = (ObjectClass *)b;
+    const char *name_a, *name_b;
+
+    name_a = object_class_get_name(class_a);
+    name_b = object_class_get_name(class_b);
+    if (strcmp(name_a, "any-" TYPE_CSKY_CPU) == 0) {
+        return 1;
+    } else if (strcmp(name_b, "any-" TYPE_CSKY_CPU) == 0) {
+        return -1;
+    } else {
+        return strcasecmp(name_a, name_b);
+    }
+}
+
+static void csky_cpu_list_entry(gpointer data, gpointer user_data)
+{
+    ObjectClass *c = data;
+    CPUListState *s = user_data;
+    const char *typename;
+    char *name;
+
+    typename = object_class_get_name(c);
+    name = g_strndup(typename, strlen(typename) - strlen("-" TYPE_CSKY_CPU));
+    (*s->cpu_fprintf)(s->file, "%s\n", name);
+    g_free(name);
+}
+
+void csky_cpu_list(FILE *f, fprintf_function cpu_fprintf)
+{
+    CPUListState s = {
+        .file = f,
+        .cpu_fprintf = cpu_fprintf,
+    };
+    GSList *list;
+
+    list = object_class_get_list(TYPE_CSKY_CPU, false);
+    list = g_slist_sort(list, csky_cpu_list_compare);
+    (*cpu_fprintf)(f, "Available CPUs:\n");
+    g_slist_foreach(list, csky_cpu_list_entry, &s);
+    g_slist_free(list);
+}
+
+#if !defined(CONFIG_USER_ONLY)
+void csky_nommu_init(CPUCSKYState *env)
+{
+    env->tlb_context = g_malloc0(sizeof(CPUCSKYTLBContext));
+    if (env->features & ABIV2_TEE) {
+        env->tlb_context->tlb = env->tlb_context->t_tlb;
+        env->tlb_context->round_robin = env->tlb_context->t_round_robin;
+    } else {
+        env->tlb_context->tlb = env->tlb_context->nt_tlb;
+        env->tlb_context->round_robin = env->tlb_context->nt_round_robin;
+    }
+
+    /* mmu_get_physical_address */
+    env->tlb_context->get_physical_address = nommu_get_physical_address;
+    env->tlb_context->helper_tlbp = csky_tlbp;
+    env->tlb_context->helper_tlbwi = csky_tlbwi;
+    env->tlb_context->helper_tlbwr = csky_tlbwr;
+    env->tlb_context->helper_tlbr = csky_tlbr;
+
+}
+#endif
+
+CSKYCPU *cpu_csky_init(const char *cpu_model)
+{
+    return CSKY_CPU(cpu_generic_init(TYPE_CSKY_CPU, cpu_model));
+}
+
+void csky_cpu_do_unaligned_access(CPUState *cs, vaddr vaddr,
+                                  MMUAccessType access_type,
+                                  int mmu_idx, uintptr_t retaddr)
+{
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+
+    if ((env->features & UNALIGNED_ACCESS) == 0) {
+        cpu_restore_state(cs, retaddr);
+        helper_exception(env, EXCP_CSKY_ALIGN);
+    }
+}
+
+#if defined(CONFIG_USER_ONLY)
+
+/* the meaning of return value
+ *  < 0    not a MMU fault
+ * == 0    the MMU fault was handled without causing real CPU fault
+ *  > 0    a real cpu fault
+ */
+int csky_cpu_handle_mmu_fault(CPUState *cs, vaddr address,
+                              int rw, int mmu_idx)
+{
+    /* ??? which excep should we return */
+    cs->exception_index = EXCP_CSKY_DATA_ABORT;
+
+    return 1;
+}
+
+/* for user mode */
+void csky_cpu_do_interrupt(CPUState *cs)
+{
+    cs->exception_index = -1;
+}
+
+#else /* !defined(CONFIG_USER_ONLY) */
+
+static inline int cskycpu_need_respond_interrupts(CPUCSKYState *env)
+{
+    if (env->idly4_counter != 0) {
+        return 0;
+    }
+
+    if (env->intc_signals.fint_b && PSR_FE(env->cp0.psr)) {
+        return 1;
+    }
+
+    if (env->intc_signals.int_b && PSR_IE(env->cp0.psr)) {
+        return 1;
+    }
+
+    return 0;
+}
+
+static inline int cskycpu_excp_from_sig(CPUCSKYState *env)
+{
+    if (env->intc_signals.avec_b) {
+        if (env->intc_signals.fint_b) {
+            return EXCP_CSKY_FIQ;
+        } else {
+            return EXCP_CSKY_IRQ;
+        }
+    } else {
+        return env->intc_signals.vec_b;
+    }
+}
+
+#if defined(TARGET_CSKYV2)
+/* For system mode */
+/* For tee interrupts */
+static inline void do_helper_tee_interrupt(CPUState *cs, CPUCSKYState *env)
+{
+    helper_tee_save_cr(env);
+    if (env->psr_t &&
+        !(env->intc_signals.issr
+          & (1 << (cs->exception_index - 32)))) {
+        /* Trust world switch to Non-Trust world */
+        cpu_stl_data(env, env->stackpoint.t_ssp - 4, env->pc);
+        cpu_stl_data(env, env->stackpoint.t_ssp - 8, env->cp0.psr);
+        env->stackpoint.t_ssp -= 8;
+        /* save GPRs to trust-supervised stack. */
+        helper_tee_save_gpr(env);
+        env->tee.t_psr |= PSR_HS_MASK;
+        env->tee.nt_epsr = env->tee.nt_psr;
+        env->tee.nt_psr |= PSR_SP_MASK;
+        env->tee.nt_psr |= PSR_S_MASK;
+        env->cp0.psr = env->tee.nt_psr;
+    } else if (!env->psr_t &&
+               (env->intc_signals.issr
+                & (1 << (cs->exception_index - 32)))) {
+        /* Non-Trust world switch to Trust world */
+        cpu_stl_data(env, env->stackpoint.nt_ssp - 4, env->pc);
+        cpu_stl_data(env, env->stackpoint.nt_ssp - 8, env->cp0.psr);
+        env->stackpoint.nt_ssp -= 8;
+        env->tee.t_epsr = env->tee.t_psr;
+        env->tee.t_psr &= ~PSR_SP_MASK;
+        env->tee.t_psr &= ~PSR_SC_MASK;
+        env->tee.t_psr |= PSR_S_MASK;
+        env->cp0.psr = env->tee.t_psr;
+    } else {
+        env->cp0.epc = env->pc;
+        env->cp0.epsr = env->cp0.psr;
+    }
+    helper_record_psr_bits(env);
+    helper_tee_choose_cr(env);
+}
+
+/* Interface for interrupts and exceptions */
+void csky_cpu_do_interrupt(CPUState *cs)
+{
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+    int af_bk;
+
+    if ((cs->exception_index == EXCP_CSKY_TRACE)
+            && cs->interrupt_request
+            && cskycpu_need_respond_interrupts(env)) {
+        env->cp0.psr |= PSR_TP_MASK;
+        return;
+    }
+
+    if (unlikely(env->idly4_counter != 0)) {
+        /* Set the psr_c */
+        env->psr_c = 1;
+    }
+
+    /* FIXME  backup the sce_cond_bit to psr[cpidfiels] in cskyv2*/
+    helper_save_sp(env);
+    helper_update_psr(env);
+    af_bk = (env->cp0.psr & 0x2) >> 1;
+    if (unlikely(env->intc_signals.fint_b
+            && (cs->exception_index == EXCP_CSKY_FIQ
+                || cs->exception_index > EXCP_CSKY_CPU_END))) {
+        env->cp0.fpc = env->pc;
+        env->cp0.fpsr = env->cp0.psr;
+        /* clear FE bit */
+        env->cp0.psr &= ~PSR_FE_MASK;
+    } else if ((env->cp0.psr & PSR_EE_MASK) || env->intc_signals.int_b) {
+        if (env->features & ABIV2_TEE && (cs->exception_index >= 32)) {
+            /* tee interrupt */
+            do_helper_tee_interrupt(cs, env);
+        } else {
+            /* interrupt for cpu without tee, or exceptions. */
+            env->cp0.epc = env->pc;
+            env->cp0.epsr = env->cp0.psr;
+        }
+    } else {
+        cs->exception_index = EXCP_CSKY_URESTORE;
+    }
+
+    /* Set the vec in the psr */
+    env->cp0.psr &= ~(0xff << 16);
+    env->cp0.psr |= cs->exception_index << 16;
+    env->cp0.psr |= PSR_S_MASK;
+    env->cp0.psr &= ~PSR_TP_MASK;
+    env->cp0.psr &= ~PSR_EE_MASK;
+    env->cp0.psr &= ~PSR_IE_MASK;
+    env->cp0.psr &= ~PSR_TM_MASK;
+    helper_record_psr_bits(env);
+    env->pc = cpu_ldl_code(env, env->cp0.vbr + cs->exception_index * 4);
+
+    /* check the AF and pc. */
+    if (unlikely((env->pc & 0x1) != af_bk)) {
+        if (env->features & (CPU_807 | CPU_810)) {
+            qemu_log_mask(CPU_LOG_EXEC,
+                          "11.epc:%x:env->regs[2] = 0x%x:%x:%x:%x\n",
+                          env->cp0.epc, env->regs[2], env->banked_regs[2],
+                          env->cp0.psr, env->cp0.epsr);
+            helper_switch_regs(env);
+            env->cp0.psr &= ~0x1;
+            env->cp0.psr |= (env->pc & 0x1) << 1;
+        } else {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "Only CK610 CK807 CK810 have alternative registers");
+        }
+    }
+
+    helper_choose_sp(env);
+    env->pc &= ~0x1;
+    env->sce_condexec_bits_bk = env->sce_condexec_bits;
+    env->sce_condexec_bits = 1;
+    env->intc_signals.vec_b = 0;
+    env->intc_signals.avec_b = 0;
+    env->intc_signals.int_b = 0;
+    env->intc_signals.fint_b = 0;
+    cs->exception_index = -1;
+}
+#else
+/* For system mode */
+void csky_cpu_do_interrupt(CPUState *cs)
+{
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+
+    if ((cs->exception_index == EXCP_CSKY_TRACE)
+            && cs->interrupt_request
+            && cskycpu_need_respond_interrupts(env)) {
+        env->cp0.psr |= PSR_TP_MASK;
+        return;
+    }
+
+    if (unlikely(env->idly4_counter != 0)) {
+        /* Set the psr_c */
+        env->psr_c = 1;
+    }
+
+    /* Set the vec in the psr */
+    env->cp0.psr &= ~(0x7f << 16);
+    env->cp0.psr |= cs->exception_index << 16;
+
+    /* FIXME  backup the sce_cond_bit to psr[cpidfiels] in cskyv2*/
+    helper_update_psr(env);
+    if (unlikely(env->intc_signals.fint_b
+            && (cs->exception_index == EXCP_CSKY_FIQ
+                || cs->exception_index > EXCP_CSKY_CPU_END))) {
+        env->cp0.fpc = env->pc;
+        env->cp0.fpsr = env->cp0.psr;
+        /* clear FE bit */
+        env->cp0.psr &= ~PSR_FE_MASK;
+    } else if ((env->cp0.psr & PSR_EE_MASK) || env->intc_signals.int_b) {
+        env->cp0.epc = env->pc;
+        env->cp0.epsr = env->cp0.psr;
+    } else {
+        cs->exception_index = EXCP_CSKY_URESTORE;
+    }
+
+    env->psr_s = 1;
+    env->psr_tm = 0;
+    env->cp0.psr &= ~PSR_TP_MASK;
+    env->cp0.psr &= ~PSR_EE_MASK;
+    env->cp0.psr &= ~PSR_IE_MASK;
+
+    env->pc = cpu_ldl_code(env, env->cp0.vbr + cs->exception_index * 4);
+    if (unlikely((env->pc & 0x1) != ((env->cp0.psr & 0x2) >> 1))) {
+        if (env->features & CPU_610) {
+            qemu_log_mask(CPU_LOG_EXEC,
+                          "11.epc:%x:env->regs[2] = 0x%x:%x:%x:%x\n",
+                          env->cp0.epc, env->regs[2], env->banked_regs[2],
+                          env->cp0.psr, env->cp0.epsr);
+            helper_switch_regs(env);
+            env->cp0.psr |= (env->pc & 0x1) << 1;
+        } else {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "Only CK610 CK807 CK810 have alternative registers");
+        }
+    }
+
+    env->pc &= ~0x1;
+
+    cs->exception_index = -1;
+
+}
+#endif
+
+hwaddr csky_cpu_get_phys_page_debug(CPUState *cs, vaddr addr)
+{
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+
+    hwaddr phys_addr;
+    int prot;
+
+    if (env->tlb_context->get_physical_address(env, &phys_addr,
+                                               &prot, addr, 0) != 0) {
+        return -1;
+    }
+    return phys_addr;
+}
+
+#endif
+
+bool csky_cpu_exec_interrupt(CPUState *cs, int interrupt_request)
+{
+    CPUClass *cc = CPU_GET_CLASS(cs);
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+    bool next_tb = false;
+
+#if defined(CONFIG_USER_ONLY)
+    if (interrupt_request & CPU_INTERRUPT_FIQ
+        && !(PSR_FE(env->cp0.psr))) {
+        cs->exception_index = EXCP_CSKY_FIQ;
+        cc->do_interrupt(cs);
+        next_tb = true;
+    }
+
+    if (interrupt_request & CPU_INTERRUPT_HARD
+        && (!(PSR_IE(env->cp0.psr)))) {
+        cs->exception_index = EXCP_CSKY_IRQ;
+        cc->do_interrupt(cs);
+        next_tb = true;
+    }
+#else
+    if ((interrupt_request & CPU_INTERRUPT_HARD)
+        && cskycpu_need_respond_interrupts(env)) {
+        cs->exception_index = cskycpu_excp_from_sig(env);
+        cc->do_interrupt(cs);
+        next_tb = true;
+    }
+#endif
+    return next_tb;
+}
+
diff --git a/target-csky/helper.h b/target-csky/helper.h
new file mode 100644
index 0000000..e5853c3
--- /dev/null
+++ b/target-csky/helper.h
@@ -0,0 +1,411 @@
+/*
+ * CSKY helper
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+DEF_HELPER_2(exception, void, env, i32)
+DEF_HELPER_1(brev, i32, i32)
+DEF_HELPER_1(ff1, i32, i32)
+DEF_HELPER_2(tb_trace, void, env, i32)
+DEF_HELPER_3(jcount, void, env, i32, i32)
+
+#ifndef CONFIG_USER_ONLY
+DEF_HELPER_1(rte, void, env)
+DEF_HELPER_1(rfi, void, env)
+DEF_HELPER_1(stop, void, env)
+DEF_HELPER_1(wait, void, env)
+DEF_HELPER_1(doze, void, env)
+DEF_HELPER_2(psrclr, void, env, i32)
+DEF_HELPER_2(psrset, void, env, i32)
+
+DEF_HELPER_1(mfcr_cr0, i32, env)
+DEF_HELPER_1(mfcr_cr20, i32, env)
+DEF_HELPER_2(mtcr_cr0, void, env, i32)
+DEF_HELPER_2(mtcr_cr18, void, env, i32)
+DEF_HELPER_2(mtcr_cr20, void, env, i32)
+DEF_HELPER_2(meh_write, void, env, i32)
+DEF_HELPER_2(mcir_write, void, env, i32)
+#endif
+
+#if defined(TARGET_CSKYV1)
+DEF_HELPER_1(cprc, void, env)
+DEF_HELPER_1(cpwir, void, env)
+#else /* TARGET_CSKYV2* */
+
+#ifndef CONFIG_USER_ONLY
+DEF_HELPER_1(wsc, void, env)
+DEF_HELPER_1(tee_mfcr_cr19, i32, env)
+DEF_HELPER_2(tee_mtcr_cr19, void, env, i32)
+#endif
+
+DEF_HELPER_1(ff0, i32, i32)
+
+DEF_HELPER_3(xsr, i32, env, i32, i32)
+
+DEF_HELPER_1(vfp_update_fcr, void, env)
+DEF_HELPER_1(vfp_check_exception, void, env)
+
+DEF_HELPER_3(vfp_adds, f32, f32, f32, env)
+DEF_HELPER_3(vfp_addd, f64, f64, f64, env)
+DEF_HELPER_3(vfp_subs, f32, f32, f32, env)
+DEF_HELPER_3(vfp_subd, f64, f64, f64, env)
+DEF_HELPER_3(vfp_muls, f32, f32, f32, env)
+DEF_HELPER_3(vfp_muld, f64, f64, f64, env)
+DEF_HELPER_3(vfp_divs, f32, f32, f32, env)
+DEF_HELPER_3(vfp_divd, f64, f64, f64, env)
+DEF_HELPER_1(vfp_negs, f32, f32)
+DEF_HELPER_1(vfp_negd, f64, f64)
+DEF_HELPER_1(vfp_abss, f32, f32)
+DEF_HELPER_1(vfp_absd, f64, f64)
+DEF_HELPER_2(vfp_sqrts, f32, f32, env)
+DEF_HELPER_2(vfp_sqrtd, f64, f64, env)
+DEF_HELPER_2(vfp_recips, f32, f32, env)
+DEF_HELPER_2(vfp_recipd, f64, f64, env)
+
+DEF_HELPER_3(vfp_cmp_ges, void, f32, f32, env)
+DEF_HELPER_3(vfp_cmp_ged, void, f64, f64, env)
+DEF_HELPER_3(vfp_cmp_ls, void, f32, f32, env)
+DEF_HELPER_3(vfp_cmp_ld, void, f64, f64, env)
+DEF_HELPER_3(vfp_cmp_lss, void, f32, f32, env)
+DEF_HELPER_3(vfp_cmp_lsd, void, f64, f64, env)
+DEF_HELPER_3(vfp_cmp_nes, void, f32, f32, env)
+DEF_HELPER_3(vfp_cmp_ned, void, f64, f64, env)
+DEF_HELPER_3(vfp_cmp_isNANs, void, f32, f32, env)
+DEF_HELPER_3(vfp_cmp_isNANd, void, f64, f64, env)
+
+DEF_HELPER_4(vfp_fmovis, f32, i32, i32, i32, env)
+DEF_HELPER_4(vfp_fmovid, f64, i32, i32, i32, env)
+DEF_HELPER_2(vfp_tosirns, f32, f32, env)
+DEF_HELPER_2(vfp_tosirnd, f32, f64, env)
+DEF_HELPER_2(vfp_tosirzs, f32, f32, env)
+DEF_HELPER_2(vfp_tosirzd, f32, f64, env)
+DEF_HELPER_2(vfp_tosirpis, f32, f32, env)
+DEF_HELPER_2(vfp_tosirpid, f32, f64, env)
+DEF_HELPER_2(vfp_tosirnis, f32, f32, env)
+DEF_HELPER_2(vfp_tosirnid, f32, f64, env)
+DEF_HELPER_2(vfp_touirns, f32, f32, env)
+DEF_HELPER_2(vfp_touirnd, f32, f64, env)
+DEF_HELPER_2(vfp_touirzs, f32, f32, env)
+DEF_HELPER_2(vfp_touirzd, f32, f64, env)
+DEF_HELPER_2(vfp_touirpis, f32, f32, env)
+DEF_HELPER_2(vfp_touirpid, f32, f64, env)
+DEF_HELPER_2(vfp_touirnis, f32, f32, env)
+DEF_HELPER_2(vfp_touirnid, f32, f64, env)
+
+DEF_HELPER_2(vfp_uitos, f32, f32, env)
+DEF_HELPER_2(vfp_uitod, f64, f32, env)
+DEF_HELPER_2(vfp_sitos, f32, f32, env)
+DEF_HELPER_2(vfp_sitod, f64, f32, env)
+
+DEF_HELPER_2(vfp_tods, f64, f32, env)
+DEF_HELPER_2(vfp_tosd, f32, f64, env)
+
+DEF_HELPER_FLAGS_2(vdsp_vadd128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vadde128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcadd128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcadde128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vaddxsl128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vaddx128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vaddh128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vaddhr128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vadds128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsub128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsube128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsabs128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsabse128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsabsa128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsabsae128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsubx128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsubh128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsubhr128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsubs128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmul128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmule128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmula128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmulae128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmuls128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmulse128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshri128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshrir128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshr128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshrr128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshli128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshlis128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshl128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshls128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmphs128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmplt128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmpne128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmpnez128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmpltz128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmphsz128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmax128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmin128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmax128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmin128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vand128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vandn128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vor128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vnor128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vxor128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vtst128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmov128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmove128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmovl128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmovsl128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmovh128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmovrh128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vstousl128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vrev128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vdup128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcnt1128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vclz128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcls128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vbpermz128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vbperm128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vtrch128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vtrcl128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vich128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vicl128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vdch128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vdcl128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vabs128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vabss128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vneg128, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vnegs128, TCG_CALL_NO_RWG, void, env, i32)
+
+DEF_HELPER_FLAGS_2(vdsp_vadd64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vadde64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcadd64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcadde64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vaddxsl64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vaddx64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vaddh64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vaddhr64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vadds64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsub64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsube64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsabs64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsabse64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsabsa64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsabsae64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsubx64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsubh64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsubhr64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vsubs64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmul64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmule64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmula64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmulae64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmuls64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmulse64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshri64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshrir64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshr64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshrr64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshli64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshlis64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshl64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vshls64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmphs64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmplt64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmpne64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmpnez64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmpltz64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmphsz64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmax64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmin64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmax64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcmin64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vand64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vandn64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vor64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vnor64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vxor64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vtst64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmov64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmove64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmovl64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmovsl64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmovh64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmovrh64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vstousl64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vrev64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vdup64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcnt164, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vclz64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vcls64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vbpermz64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vbperm64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vtrch64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vtrcl64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vich64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vicl64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vdch64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vdcl64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vabs64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vabss64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vneg64, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vnegs64, TCG_CALL_NO_RWG, void, env, i32)
+
+DEF_HELPER_FLAGS_2(vdsp_vmfvru8, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmfvru16, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmfvru32, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmfvrs8, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vmfvrs16, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_2(vdsp_vmtvru8, void, env, i32)
+DEF_HELPER_2(vdsp_vmtvru16, void, env, i32)
+DEF_HELPER_2(vdsp_vmtvru32, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vins8, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vins16, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_2(vdsp_vins32, TCG_CALL_NO_RWG, void, env, i32)
+DEF_HELPER_FLAGS_3(vdsp_store, TCG_CALL_NO_RWG, void, i32, i64, env)
+DEF_HELPER_FLAGS_4(vdsp_store2, TCG_CALL_NO_RWG, void, i32, i64, i64, env)
+
+#ifndef CONFIG_USER_ONLY
+DEF_HELPER_1(mfcr_cr14, i32, env)
+DEF_HELPER_1(mfcr_cpidr, i32, env)
+
+DEF_HELPER_2(mtcr_cr14, void, env, i32)
+DEF_HELPER_2(mtcr_cr17, void, env, i32)
+#endif
+
+/* declear dsp v2.0 ISA helpers */
+DEF_HELPER_2(dspv2_padd_u8_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_padd_s8_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_padd_u16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_padd_s16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_add_u32_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_add_s32_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_psub_u8_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_psub_s8_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_psub_u16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_psub_s16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_sub_u32_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_sub_s32_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_paddh_u8, i32, i32, i32)
+DEF_HELPER_2(dspv2_paddh_s8, i32, i32, i32)
+DEF_HELPER_2(dspv2_paddh_u16, i32, i32, i32)
+DEF_HELPER_2(dspv2_paddh_s16, i32, i32, i32)
+DEF_HELPER_2(dspv2_psubh_u8, i32, i32, i32)
+DEF_HELPER_2(dspv2_psubh_s8, i32, i32, i32)
+DEF_HELPER_2(dspv2_psubh_u16, i32, i32, i32)
+DEF_HELPER_2(dspv2_psubh_s16, i32, i32, i32)
+DEF_HELPER_2(dspv2_add_u64_s, i64, i64, i64)
+DEF_HELPER_2(dspv2_add_s64_s, i64, i64, i64)
+DEF_HELPER_2(dspv2_sub_u64_s, i64, i64, i64)
+DEF_HELPER_2(dspv2_sub_s64_s, i64, i64, i64)
+DEF_HELPER_2(dspv2_pasx_u16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_pasx_s16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_psax_u16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_psax_s16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_pasxh_u16, i32, i32, i32)
+DEF_HELPER_2(dspv2_pasxh_s16, i32, i32, i32)
+DEF_HELPER_2(dspv2_psaxh_u16, i32, i32, i32)
+DEF_HELPER_2(dspv2_psaxh_s16, i32, i32, i32)
+DEF_HELPER_2(dspv2_pcmpne_8, i32, i32, i32)
+DEF_HELPER_2(dspv2_pcmpne_16, i32, i32, i32)
+DEF_HELPER_2(dspv2_pcmphs_u8, i32, i32, i32)
+DEF_HELPER_2(dspv2_pcmphs_s8, i32, i32, i32)
+DEF_HELPER_2(dspv2_pcmphs_u16, i32, i32, i32)
+DEF_HELPER_2(dspv2_pcmphs_s16, i32, i32, i32)
+DEF_HELPER_2(dspv2_pcmplt_u8, i32, i32, i32)
+DEF_HELPER_2(dspv2_pcmplt_s8, i32, i32, i32)
+DEF_HELPER_2(dspv2_pcmplt_u16, i32, i32, i32)
+DEF_HELPER_2(dspv2_pcmplt_s16, i32, i32, i32)
+DEF_HELPER_2(dspv2_pmax_u8, i32, i32, i32)
+DEF_HELPER_2(dspv2_pmax_s8, i32, i32, i32)
+DEF_HELPER_2(dspv2_pmin_u8, i32, i32, i32)
+DEF_HELPER_2(dspv2_pmin_s8, i32, i32, i32)
+DEF_HELPER_2(dspv2_psabsa_u8, i32, i32, i32)
+DEF_HELPER_3(dspv2_psabsaa_u8, i32, i32, i32, i32)
+DEF_HELPER_2(dspv2_lsli_u32_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_lsli_s32_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_lsl_u32_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_lsl_s32_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_plsli_u16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_plsli_s16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_plsl_u16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_plsl_s16_s, i32, i32, i32)
+DEF_HELPER_1(dspv2_pext_u8_e, i64, i32)
+DEF_HELPER_1(dspv2_pext_s8_e, i64, i32)
+DEF_HELPER_1(dspv2_pextx_u8_e, i64, i32)
+DEF_HELPER_1(dspv2_pextx_s8_e, i64, i32)
+DEF_HELPER_2(dspv2_narl, i32, i32, i32)
+DEF_HELPER_2(dspv2_narh, i32, i32, i32)
+DEF_HELPER_2(dspv2_narlx, i32, i32, i32)
+DEF_HELPER_2(dspv2_narhx, i32, i32, i32)
+DEF_HELPER_2(dspv2_clipi_u32, i32, i32, i32)
+DEF_HELPER_2(dspv2_clipi_s32, i32, i32, i32)
+DEF_HELPER_2(dspv2_clip_u32, i32, i32, i32)
+DEF_HELPER_2(dspv2_clip_s32, i32, i32, i32)
+DEF_HELPER_2(dspv2_pclipi_u16, i32, i32, i32)
+DEF_HELPER_2(dspv2_pclipi_s16, i32, i32, i32)
+DEF_HELPER_2(dspv2_pclip_u16, i32, i32, i32)
+DEF_HELPER_2(dspv2_pclip_s16, i32, i32, i32)
+DEF_HELPER_1(dspv2_pabs_s8_s, i32, i32)
+DEF_HELPER_1(dspv2_pabs_s16_s, i32, i32)
+DEF_HELPER_1(dspv2_abs_s32_s, i32, i32)
+DEF_HELPER_1(dspv2_pneg_s8_s, i32, i32)
+DEF_HELPER_1(dspv2_pneg_s16_s, i32, i32)
+DEF_HELPER_1(dspv2_neg_s32_s, i32, i32)
+DEF_HELPER_2(dspv2_dup_8, i32, i32, i32)
+DEF_HELPER_2(dspv2_dup_16, i32, i32, i32)
+DEF_HELPER_4(dspv2_mula_u32_s, i64, i32, i32, i32, i32)
+DEF_HELPER_4(dspv2_mula_s32_s, i64, i32, i32, i32, i32)
+DEF_HELPER_4(dspv2_muls_u32_s, i64, i32, i32, i32, i32)
+DEF_HELPER_4(dspv2_muls_s32_s, i64, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mula_32_l, i32, i32, i32, i32)
+DEF_HELPER_2(dspv2_rmul_s32_h, i32, i32, i32)
+DEF_HELPER_2(dspv2_rmul_s32_rh, i32, i32, i32)
+DEF_HELPER_3(dspv2_mula_s32_hs, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_muls_s32_hs, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mula_s32_rhs, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_muls_s32_rhs, i32, i32, i32, i32)
+DEF_HELPER_2(dspv2_rmulll_s16, i32, i32, i32)
+DEF_HELPER_2(dspv2_rmulhh_s16, i32, i32, i32)
+DEF_HELPER_2(dspv2_rmulhl_s16, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulall_s16_s, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulahh_s16_s, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulahl_s16_s, i32, i32, i32, i32)
+DEF_HELPER_4(dspv2_mulall_s16_e, i64, i32, i32, i32, i32)
+DEF_HELPER_4(dspv2_mulahh_s16_e, i64, i32, i32, i32, i32)
+DEF_HELPER_4(dspv2_mulahl_s16_e, i64, i32, i32, i32, i32)
+DEF_HELPER_2(dspv2_prmul_s16, i64, i32, i32)
+DEF_HELPER_2(dspv2_prmulx_s16, i64, i32, i32)
+DEF_HELPER_2(dspv2_prmul_s16_h, i32, i32, i32)
+DEF_HELPER_2(dspv2_prmul_s16_rh, i32, i32, i32)
+DEF_HELPER_2(dspv2_prmulx_s16_h, i32, i32, i32)
+DEF_HELPER_2(dspv2_prmulx_s16_rh, i32, i32, i32)
+DEF_HELPER_2(dspv2_rmulxl_s32, i32, i32, i32)
+DEF_HELPER_2(dspv2_rmulxl_s32_r, i32, i32, i32)
+DEF_HELPER_2(dspv2_rmulxh_s32, i32, i32, i32)
+DEF_HELPER_2(dspv2_rmulxh_s32_r, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulaxl_s32_s, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulaxl_s32_rs, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulaxh_s32_s, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulaxh_s32_rs, i32, i32, i32, i32)
+DEF_HELPER_2(dspv2_mulca_s16_s, i32, i32, i32)
+DEF_HELPER_2(dspv2_mulcax_s16_s, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulaca_s16_s, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulacax_s16_s, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulacs_s16_s, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulacsr_s16_s, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulacsx_s16_s, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulsca_s16_s, i32, i32, i32, i32)
+DEF_HELPER_3(dspv2_mulscax_s16_s, i32, i32, i32, i32)
+
+#endif /* TARGET_CSKYV* */
+
diff --git a/target-csky/mmu.c b/target-csky/mmu.c
new file mode 100644
index 0000000..18b6a83
--- /dev/null
+++ b/target-csky/mmu.c
@@ -0,0 +1,565 @@
+/*
+ * CSKY mmu
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "cpu.h"
+#include "translate.h"
+#include "exec/helper-proto.h"
+#include "exec/cpu_ldst.h"
+#include "exec/exec-all.h"
+
+#if !defined(CONFIG_USER_ONLY)
+/**************************** MMU ***************************/
+static int get_page_bits(CPUCSKYState *env)
+{
+    switch ((env->mmu.mpr >> 13) & 0xfff) {
+    case 0x0:
+        return 12;
+    case 0x3:
+        return 14;
+    case 0xf:
+        return 16;
+    case 0x3f:
+        return 18;
+    case 0xff:
+        return 20;
+    case 0x3ff:
+        return 22;
+    case 0xfff:
+        return 24;
+    default:
+        qemu_log_mask(CPU_LOG_MMU, "CSKY CPU does not support "
+                      "PageMask 0x%x!\n", env->mmu.mpr);
+        return 0;
+    }
+}
+
+void helper_ttlbinv_all(CPUCSKYState *env)
+{
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+    memset(env->tlb_context->t_tlb, 0,
+           sizeof(struct csky_tlb_t) * CSKY_TLB_MAX);
+    memset(env->tlb_context->nt_tlb, 0,
+           sizeof(struct csky_tlb_t) * CSKY_TLB_MAX);
+    tlb_flush(cs, 1);
+}
+
+void helper_tlbinv_all(CPUCSKYState *env)
+{
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+    memset(env->tlb_context->tlb, 0, sizeof(struct csky_tlb_t) * CSKY_TLB_MAX);
+    tlb_flush(cs, 1);
+}
+
+void helper_tlbinv(CPUCSKYState *env)
+{
+    csky_tlb_t *ptlb;
+    uint8_t asid;
+    int i;
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+
+    asid = env->mmu.meh & 0xff;
+    ptlb = &env->tlb_context->tlb[0];
+
+    for (i = 0; i < CSKY_TLB_MAX; ++i) {
+        if (ptlb->ASID == asid) {
+            ptlb->V0 = 0;
+            ptlb->V1 = 0;
+            int j;
+            for (j = ptlb->VPN; j <= (ptlb->VPN | env->mmu.mpr | 0x1000);
+                                                             j += 0x1000) {
+                tlb_flush_page(cs, j);
+            }
+        }
+        ptlb++;
+    }
+}
+
+void csky_tlbwi(CPUCSKYState *env)
+{
+    csky_tlb_t *ptlb;
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+
+    ptlb = &env->tlb_context->tlb[env->mmu.mir & 0x7f];
+
+    ptlb->VPN   = env->mmu.meh & ~(env->mmu.mpr | 0x1fff);
+    ptlb->ASID  = env->mmu.meh & 0xff;
+    ptlb->G     = env->mmu.mel0 & env->mmu.mel1 & 0x1;
+    ptlb->C0    = (env->mmu.mel0 >> 3) & 0x7;
+    ptlb->C1    = (env->mmu.mel1 >> 3) & 0x7;
+    ptlb->V0    = (env->mmu.mel0 >> 1) & 0x1;
+    ptlb->V1    = (env->mmu.mel1 >> 1) & 0x1;
+    ptlb->D0    = (env->mmu.mel0 >> 2) & 0x1;
+    ptlb->D1    = (env->mmu.mel1 >> 2) & 0x1;
+#if !defined(TARGET_CSKYV2)
+    ptlb->PFN[0] = (env->mmu.mel0 << 6) & ~((env->mmu.mpr >> 1) | 0xfff);
+    ptlb->PFN[1] = (env->mmu.mel1 << 6) & ~((env->mmu.mpr >> 1) | 0xfff);
+#else
+    ptlb->PFN[0] = env->mmu.mel0 & ~((env->mmu.mpr >> 1) | 0xfff);
+    ptlb->PFN[1] = env->mmu.mel1 & ~((env->mmu.mpr >> 1) | 0xfff);
+#endif
+#if !defined(TARGET_CSKYV2)
+    ptlb->PageMask = env->mmu.mpr;
+#endif
+
+    int j;
+    for (j = ptlb->VPN; j <= (ptlb->VPN | env->mmu.mpr | 0x1000); j += 0x1000) {
+        tlb_flush_page(cs, j);
+    }
+}
+
+void csky_tlbwr(CPUCSKYState *env)
+{
+    csky_tlb_t *ptlb;
+    uint32_t index;
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+
+    /* index = robin,VPN[18:13]   page size: 4KB*/
+    /* index = robin,VPN[20:15]   page size: 16KB*/
+    /* index = robin,VPN[22:17]   page size: 64KB*/
+    /* ... */
+    index = (env->mmu.meh >> (get_page_bits(env) + 1)) & 0x3f;
+    if (env->tlb_context->round_robin[index]) {
+        env->tlb_context->round_robin[index] = 0;
+        index = index + 64;
+    } else {
+        env->tlb_context->round_robin[index] = 1;
+    }
+    ptlb =  &env->tlb_context->tlb[index];
+
+    ptlb->VPN   = env->mmu.meh & ~(env->mmu.mpr | 0x1fff);
+    ptlb->ASID  = env->mmu.meh & 0xff;
+    ptlb->G     = env->mmu.mel0 & env->mmu.mel1 & 0x1;
+    ptlb->C0    = (env->mmu.mel0 >> 3) & 0x7;
+    ptlb->C1    = (env->mmu.mel1 >> 3) & 0x7;
+    ptlb->V0    = (env->mmu.mel0 >> 1) & 0x1;
+    ptlb->V1    = (env->mmu.mel1 >> 1) & 0x1;
+    ptlb->D0    = (env->mmu.mel0 >> 2) & 0x1;
+    ptlb->D1    = (env->mmu.mel1 >> 2) & 0x1;
+#if !defined(TARGET_CSKYV2)
+    ptlb->PFN[0] = (env->mmu.mel0 << 6) & ~((env->mmu.mpr >> 1) | 0xfff);
+    ptlb->PFN[1] = (env->mmu.mel1 << 6) & ~((env->mmu.mpr >> 1) | 0xfff);
+#else
+    ptlb->PFN[0] = env->mmu.mel0 & ~((env->mmu.mpr >> 1) | 0xfff);
+    ptlb->PFN[1] = env->mmu.mel1 & ~((env->mmu.mpr >> 1) | 0xfff);
+#endif
+#if !defined(TARGET_CSKYV2)
+    ptlb->PageMask = env->mmu.mpr;
+#endif
+
+    int j;
+    for (j = ptlb->VPN; j <= (ptlb->VPN | env->mmu.mpr | 0x1000); j += 0x1000) {
+        tlb_flush_page(cs, j);
+    }
+}
+
+void csky_tlbp(CPUCSKYState *env)
+{
+    csky_tlb_t *ptlb;
+    uint32_t index;
+
+    /* index = robin,VPN[18:13]*/
+    index = (env->mmu.meh >> (get_page_bits(env) + 1)) & 0x3f;
+    ptlb =  &env->tlb_context->tlb[index];
+
+    if (ptlb->VPN == (env->mmu.meh & ~(env->mmu.mpr | 0x1fff))
+            && ptlb->ASID == (env->mmu.meh & 0xff)) {
+        env->mmu.mir = index;
+        return;
+    }
+
+    index += 64;
+    ptlb =  &env->tlb_context->tlb[index];
+    if (ptlb->VPN == (env->mmu.meh & ~(env->mmu.mpr | 0x1fff))
+            && ptlb->ASID == (env->mmu.meh & 0xff)) {
+        env->mmu.mir = index;
+        return;
+    }
+
+    /* if not found, set P bit */
+    env->mmu.mir |= (1 << 31);
+}
+
+void csky_tlbr(CPUCSKYState *env)
+{
+    /* FIXME */
+    csky_tlb_t *ptlb;
+
+    ptlb = &env->tlb_context->tlb[env->mmu.mir & 0x7f];
+
+    env->mmu.meh = ptlb->VPN | ptlb->ASID;
+#if !defined(TARGET_CSKYV2)
+    env->mmu.mel0 = ptlb->PFN[0] >> 6 | ptlb->C0 << 3
+                    | ptlb->D0 << 2 | ptlb->V0 << 1 | ptlb->G;
+
+    env->mmu.mel1 = ptlb->PFN[1] >> 6 | ptlb->C1 << 3
+                    | ptlb->D1 << 2 | ptlb->V1 << 1 | ptlb->G;
+#else
+    env->mmu.mel0 = ptlb->PFN[0]  | ptlb->C0 << 3
+                    | ptlb->D0 << 2 | ptlb->V0 << 1 | ptlb->G;
+
+    env->mmu.mel1 = ptlb->PFN[1]  | ptlb->C1 << 3
+                    | ptlb->D1 << 2 | ptlb->V1 << 1 | ptlb->G;
+#endif
+#if !defined(TARGET_CSKYV2)
+    env->mmu.mpr = ptlb->PageMask;
+#endif
+}
+
+/* ----------------------------- */
+
+enum {
+    TLBRET_ABORT = -5,
+    TLBRET_DIRTY = -4,
+    TLBRET_INVALID = -3,
+    TLBRET_NOMATCH = -2,
+    TLBRET_BADADDR = -1,
+    TLBRET_MATCH = 0
+};
+
+void tlb_fill(CPUState *cs, target_ulong addr, MMUAccessType access_type,
+              int mmu_idx, uintptr_t retaddr)
+{
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+    int ret;
+
+    ret = csky_cpu_handle_mmu_fault(cs, addr, access_type, mmu_idx);
+    if (unlikely(ret)) {
+        if (retaddr) {
+            cpu_restore_state(cs, retaddr);
+        }
+        helper_exception(env, cs->exception_index);
+    }
+}
+
+int csky_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,
+                              int mmu_idx)
+{
+    hwaddr physical;
+    int prot;
+    int ret = 0;
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+
+    rw &= 1;
+    ret = env->tlb_context->get_physical_address(env, &physical,
+                                                 &prot, address, rw);
+
+    if (ret == TLBRET_MATCH) {
+        tlb_set_page(cs, address & TARGET_PAGE_MASK,
+                physical & TARGET_PAGE_MASK, prot | PAGE_EXEC,
+                mmu_idx, TARGET_PAGE_SIZE);
+    } else if (ret < 0) {
+        /* Set the BADVPN Register */
+        env->mmu.meh &= ~(0xfffff << 12);
+        env->mmu.meh |= address & ~((1 << get_page_bits(env)) - 1);
+
+        switch (ret) {
+        case TLBRET_ABORT:
+            cs->exception_index = EXCP_CSKY_DATA_ABORT;
+            break;
+        case TLBRET_DIRTY:
+            cs->exception_index = EXCP_CSKY_TLB_MODIFY;
+            break;
+        case TLBRET_INVALID:
+            if (rw) {
+                cs->exception_index = EXCP_CSKY_TLB_WRITE_INVALID;
+            } else {
+                cs->exception_index = EXCP_CSKY_TLB_READ_INVALID;
+            }
+            break;
+        case TLBRET_NOMATCH:
+            cs->exception_index = EXCP_CSKY_TLB_UNMATCH;
+            break;
+        case TLBRET_BADADDR:
+            cs->exception_index = EXCP_CSKY_DATA_ABORT;
+            break;
+        default:
+            cs->exception_index = EXCP_CSKY_DATA_ABORT;
+            break;
+        }
+        ret = 1;
+    }
+    return ret;
+}
+
+int mmu_get_physical_address(struct CPUCSKYState *env,
+                             hwaddr *physical,
+                             int *prot, target_ulong address, int rw)
+{
+    uint32_t index;
+    uint32_t super_mode;
+    csky_tlb_t *ptlb;
+    uint8_t odd;
+    uint8_t ASID;
+    int page_bits;
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+
+    page_bits = get_page_bits(env);
+
+    super_mode = env->psr_s;
+
+    if (address >= 0x80000000 && address < 0xa0000000) {
+        if (super_mode) {
+#if !defined(TARGET_CSKYV2)
+            *physical = address - 0x80000000;
+            *prot = PAGE_READ | PAGE_WRITE;
+            return TLBRET_MATCH;
+#else
+            if (!(env->mmu.msa0 & 0x2)) {
+                return TLBRET_INVALID;
+            }
+            if (rw == 0 || env->mmu.msa0 & 0x4) {
+                *physical = address - 0x80000000 + (env->mmu.msa0 & 0xe0000000);
+                *prot = PAGE_READ;
+                if (env->mmu.msa0 & 0x4) {
+                    *prot |= PAGE_WRITE;
+                }
+                return TLBRET_MATCH;
+            }
+            return TLBRET_DIRTY;
+#endif
+        }
+        return TLBRET_BADADDR;
+    } else if (address >= 0xa0000000 && address < 0xc0000000) {
+        if (super_mode) {
+#if !defined(TARGET_CSKYV2)
+            *physical = address - 0xa0000000;
+            *prot = PAGE_READ | PAGE_WRITE;
+            return TLBRET_MATCH;
+#else
+            if (!(env->mmu.msa1 & 0x2)) {
+                return TLBRET_INVALID;
+            }
+            if (rw == 0 || env->mmu.msa1 & 0x4) {
+                *physical = address - 0xa0000000 + (env->mmu.msa1 & 0xe0000000);
+                *prot = PAGE_READ;
+                if (env->mmu.msa1 & 0x4) {
+                    *prot |= PAGE_WRITE;
+                }
+                return TLBRET_MATCH;
+            }
+            return TLBRET_DIRTY;
+#endif
+        }
+        return TLBRET_BADADDR;
+    } else if (address >= 0xc0000000) {
+        if (super_mode) {
+            goto do_map;
+        }
+        return TLBRET_BADADDR;
+    }
+
+do_map:
+    /* MMU is enable */
+    ASID = env->mmu.meh & 0xff;
+    odd = (address >> page_bits) & 0x1;
+    /* */
+    index = (address >> (page_bits + 1)) & 0x3f;
+    ptlb =  &env->tlb_context->tlb[index];
+
+    if (((address & ~(env->mmu.mpr | 0x1fff)) == 0) &&
+        !(odd ? ptlb->V1 : ptlb->V0)) {
+        goto hard_refill;
+    }
+
+    if ((ptlb->G == 1 || ptlb->ASID == ASID) &&
+       ptlb->VPN == (address & ~(env->mmu.mpr | 0x1fff))) {
+        if (!(odd ? ptlb->V1 : ptlb->V0)) {
+            return TLBRET_INVALID;
+        }
+        if (rw == 0 || (odd ? ptlb->D1 : ptlb->D0)) {
+            *physical = ptlb->PFN[odd] | (address & ((1 << page_bits) - 1));
+            *prot = PAGE_READ;
+            if ((odd ? ptlb->D1 : ptlb->D0)) {
+                *prot |= PAGE_WRITE;
+            }
+            return TLBRET_MATCH;
+        }
+        return TLBRET_DIRTY;
+    }
+
+    index += 64;
+    ptlb = &env->tlb_context->tlb[index];
+
+    if ((ptlb->G == 1 || ptlb->ASID == ASID) &&
+        ptlb->VPN == (address & ~(env->mmu.mpr | 0x1fff))) {
+        if (!(odd ? ptlb->V1 : ptlb->V0)) {
+            return TLBRET_INVALID;
+        }
+        if (rw == 0 || (odd ? ptlb->D1 : ptlb->D0)) {
+            *physical = ptlb->PFN[odd] | (address & ((1 << page_bits) - 1));
+            *prot = PAGE_READ;
+            if ((odd ? ptlb->D1 : ptlb->D0)) {
+                *prot |= PAGE_WRITE;
+            }
+            return TLBRET_MATCH;
+        }
+        return TLBRET_DIRTY;
+    }
+    /* FIXME add cskyv2 hard_tlb_refill*/
+hard_refill:
+    if (((env->mmu.mpr >> 13) & 0xfff) == 0x0) {
+        uint32_t tlb_phy_addr_0, tlb_phy_addr_1;
+        /* Get current pgd table base */
+        tlb_phy_addr_0 = env->mmu.mpar & (~0xfff);
+
+#define PGDIR_SHIFT    22
+#define PTE_INDX_SHIFT  10
+
+        tlb_phy_addr_0 += (address >> PGDIR_SHIFT) << 2;
+        /* Get pte table base */
+        tlb_phy_addr_0 = ldl_phys(cs->as, tlb_phy_addr_0);
+
+        tlb_phy_addr_0 += (address >> PTE_INDX_SHIFT) & 0xff8;
+
+        tlb_phy_addr_1 = ldl_phys(cs->as, tlb_phy_addr_0 + 4);
+
+        tlb_phy_addr_0 = ldl_phys(cs->as, tlb_phy_addr_0);
+
+        odd = (address >> 12) & 0x1;
+        index = (address >> 13) & 0x3f;
+
+        if (env->tlb_context->round_robin[index]) {
+            env->tlb_context->round_robin[index] = 0;
+            index = index + 64;
+        } else {
+            env->tlb_context->round_robin[index] = 1;
+        }
+        ptlb = &env->tlb_context->tlb[index];
+
+        ptlb->VPN   = address & ~0x1fff;
+        ptlb->ASID  = env->mmu.meh & 0xff;
+#if !defined(TARGET_CSKYV2)
+        ptlb->G     = (tlb_phy_addr_0 >> 6) & (tlb_phy_addr_1 >> 6) & 0X1;
+        ptlb->C0    = (tlb_phy_addr_0 >> 9) & 0x7;
+        ptlb->C1    = (tlb_phy_addr_1 >> 9) & 0x7;
+        ptlb->V0    = (tlb_phy_addr_0 >> 7) & 0x1;
+        ptlb->V1    = (tlb_phy_addr_1 >> 7) & 0x1;
+        ptlb->D0    = (tlb_phy_addr_0 >> 8) & 0x1;
+        ptlb->D1    = (tlb_phy_addr_1 >> 8) & 0x1;
+#else
+        ptlb->G     = tlb_phy_addr_0 & tlb_phy_addr_1 & 0X1;
+        ptlb->C0    = (tlb_phy_addr_0 >> 3) & 0x7;
+        ptlb->C1    = (tlb_phy_addr_1 >> 3) & 0x7;
+        ptlb->V0    = (tlb_phy_addr_0 >> 1) & 0x1;
+        ptlb->V1    = (tlb_phy_addr_1 >> 1) & 0x1;
+        ptlb->D0    = (tlb_phy_addr_0 >> 2) & 0x1;
+        ptlb->D1    = (tlb_phy_addr_1 >> 2) & 0x1;
+#endif
+
+        ptlb->PFN[0] = tlb_phy_addr_0 & ~0xfff;
+        ptlb->PFN[1] = tlb_phy_addr_1 & ~0xfff;
+
+        ptlb->PageMask = env->mmu.mpr;
+
+        if (!(odd ? ptlb->V1 : ptlb->V0)) {
+            return TLBRET_INVALID;
+        }
+        if (rw == 0 || (odd ? ptlb->D1 : ptlb->D0)) {
+            *physical = ptlb->PFN[odd] | (address & 0xfff);
+            *prot = PAGE_READ;
+            if ((odd ? ptlb->D1 : ptlb->D0)) {
+                *prot |= PAGE_WRITE;
+            }
+            return TLBRET_MATCH;
+        }
+        return TLBRET_DIRTY;
+    }
+
+    return TLBRET_NOMATCH;
+}
+
+int nommu_get_physical_address(struct CPUCSKYState *env,
+                               hwaddr *physical,
+                               int *prot, target_ulong address, int rw)
+{
+    *physical = address;
+    *prot = PAGE_READ | PAGE_WRITE;
+    return TLBRET_MATCH;
+}
+
+int mgu_get_physical_address(struct CPUCSKYState *env,
+                             hwaddr *physical,
+                             int *prot, target_ulong address, int rw)
+{
+    int i, t, base, size;
+    int j = 0;
+
+    for (i = 7; i >= 0; i--) {
+        if (env->cp0.pacr[i] & 0x1) {
+            if (((env->cp0.pacr[i] >> 1) & 0x1f) == 0x1f) {
+                size = 0xffffffff;
+            } else {
+                size = (1 << (((env->cp0.pacr[i] >> 1) & 0x1f) + 1)) - 1;
+            }
+            base = env->cp0.pacr[i] & ~size; /* page align */
+            if ((base <= address) && (address <= (base + size))) {
+                t = (env->cp0.capr >> (8 + i * 2)) & 0x3;
+                if (env->features & ABIV2_TEE) {
+                    /* if the area config Trusted, but now world is Non-Trust
+                     * can not access the area. */
+                    if (!env->psr_t && (env->cp0.capr & (1 << (i + 24)))) {
+                        j = 2;
+                        break;
+                    }
+                }
+                if (env->cp0.psr & 0x80000000) {
+                    if (t == 0) {
+                        j = 2;
+                        break;
+                    } else {
+                        j = 0;
+                        break;
+                    }
+                } else {
+                    if (t < 2) {
+                        j = 2;
+                        break;
+                    } else if (t == 2) {
+                        if (rw == 0) {
+                            j = 1;
+                            break;
+                        } else {
+                            j = 2;
+                            break;
+                        }
+                    } else {
+                        j = 0;
+                        break;
+                    }
+                }
+            } else {
+                j = 2;
+                continue;
+            }
+        }
+    }
+    if (j == 0) {
+        *physical = address;
+        *prot = PAGE_READ | PAGE_WRITE;
+        return TLBRET_MATCH;
+    } else if (j == 1) {
+        *physical = address;
+        *prot = PAGE_READ;
+        return TLBRET_MATCH;
+    } else {
+        return TLBRET_ABORT;
+    }
+}
+
+#endif
diff --git a/target-csky/op_dspv2.c b/target-csky/op_dspv2.c
new file mode 100644
index 0000000..8b8edc6
--- /dev/null
+++ b/target-csky/op_dspv2.c
@@ -0,0 +1,1687 @@
+/*
+ *  CSKY helper routines
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "cpu.h"
+#include "translate.h"
+#include "exec/helper-proto.h"
+#include "exec/cpu_ldst.h"
+#include <math.h>
+#define SIGNBIT64  0x8000000000000000
+
+static inline uint32_t helper_sig_sat_add(uint32_t x, uint32_t y, uint32_t len)
+{
+    /* rz = rx + ry, signed & saturated add for len bits operands, len <= 32 */
+    uint32_t res = x + y;
+    uint32_t signbit = 1 << (len - 1);
+    uint32_t mask = 0xffffffff >> (32 - len);
+    if (((res ^ x) & signbit) && !((x ^ y) & signbit)) {
+        res = ~(((int32_t)(x << (32 - len)) >> 31) ^ signbit);
+    }
+    return res & mask;
+}
+
+static inline uint32_t helper_unsig_sat_add(uint32_t x,
+                                            uint32_t y, uint32_t len)
+{
+    /* rz = rx + ry, unsigned & saturated add for len bits operands. */
+    uint32_t mask = 0xffffffff >> (32 - len);
+    uint32_t res = (x + y) & mask;
+    if (res < x || res < y) {
+        res = mask;
+    }
+    return res;
+}
+
+static inline uint32_t helper_sig_sat_sub(uint32_t x, uint32_t y, uint32_t len)
+{
+    /* rz = rx - ry, signed & saturated sub for len bits operands, len <= 32 */
+    uint32_t res = x - y;
+    uint32_t signbit = 1 << (len - 1);
+    uint32_t mask = 0xffffffff >> (32 - len);
+    if (((res ^ x) & signbit) && ((x ^ y) & signbit)) {
+        res = ~(((int32_t)(x << (32 - len)) >> 31) ^ signbit);
+    }
+    return res & mask;
+}
+
+static inline uint32_t helper_unsig_sat_sub(uint32_t x,
+                                            uint32_t y, uint32_t len)
+{
+    /* rz = rx + ry, unsigned & saturated add for len bits operands. */
+    uint32_t mask = 0xffffffff >> (32 - len);
+    uint32_t res = (x - y) & mask;
+    if (res > x) {
+        res = 0;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(add_s32_s)(uint32_t x, uint32_t y)
+{
+    /* rz = rx + ry, signed & saturated */
+    return helper_sig_sat_add(x, y, 32);
+}
+
+uint32_t DSPV2_HELPER(add_u32_s)(uint32_t x, uint32_t y)
+{
+    /* rz = rx + ry, signed & saturated */
+    return helper_unsig_sat_add(x, y, 32);
+}
+
+uint32_t DSPV2_HELPER(padd_s8_s)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = rx[7:0] + ry[7:0]*/
+    /* rz[15:8] = rx[15:8] + ry[15:8]*/
+    /* rz[23:16] = rx[23:16] + ry[23:16]*/
+    /* rz[31:24] = rx[31:24] + ry[31:24], signed & saturated. */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = helper_sig_sat_add(x & 0xff, y & 0xff, 8);
+    byte1 = helper_sig_sat_add((x & 0xff00) >> 8, (y & 0xff00) >> 8, 8);
+    byte2 = helper_sig_sat_add((x & 0xff0000) >> 16, (y & 0xff0000) >> 16, 8);
+    byte3 = helper_sig_sat_add((x & 0xff000000) >> 24,
+                               (y & 0xff000000) >> 24, 8);
+    return (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(padd_u8_s)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = rx[7:0] + ry[7:0]*/
+    /* rz[15:8] = rx[15:8] + ry[15:8]*/
+    /* rz[23:16] = rx[23:16] + ry[23:16]*/
+    /* rz[31:24] = rx[31:24] + ry[31:24], unsigned & saturated. */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = helper_unsig_sat_add(x & 0xff, y & 0xff, 8);
+    byte1 = helper_unsig_sat_add((x & 0xff00) >> 8, (y & 0xff00) >> 8, 8);
+    byte2 = helper_unsig_sat_add((x & 0xff0000) >> 16,
+                                 (y & 0xff0000) >> 16, 8);
+    byte3 = helper_unsig_sat_add((x & 0xff000000) >> 24,
+                                 (y & 0xff000000) >> 24, 8);
+    return (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(padd_s16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = rx[15:0] + ry[15:0],
+     * rz[31:16] = rx[31:16] + ry[31:16], signed & saturated */
+    uint32_t lo, hi;
+    lo  = helper_sig_sat_add(x & 0xffff, y & 0xffff, 16);
+    hi  = helper_sig_sat_add((x & 0xffff0000) >> 16,
+                             (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(padd_u16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = rx[15:0] + ry[15:0],
+     * rz[31:16] = rx[31:16] + ry[31:16], unsigned & saturated */
+    uint32_t lo, hi;
+    lo  = helper_unsig_sat_add(x & 0xffff, y & 0xffff, 16);
+    hi  = helper_unsig_sat_add((x & 0xffff0000) >> 16,
+                               (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(sub_s32_s)(uint32_t x, uint32_t y)
+{
+    /* rz = rx - ry, signed & saturated */
+    return helper_sig_sat_sub(x, y, 32);
+}
+
+uint32_t DSPV2_HELPER(sub_u32_s)(uint32_t x, uint32_t y)
+{
+    /* rz = rx - ry, unsigned & saturated */
+    return helper_unsig_sat_sub(x, y, 32);
+}
+
+uint32_t DSPV2_HELPER(psub_s8_s)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = rx[7:0] - ry[7:0]*/
+    /* rz[15:8] = rx[15:8] - ry[15:8]*/
+    /* rz[23:16] = rx[23:16] - ry[23:16]*/
+    /* rz[31:24] = rx[31:24] - ry[31:24], signed & saturated. */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = helper_sig_sat_sub(x & 0xff, y & 0xff, 8);
+    byte1 = helper_sig_sat_sub((x & 0xff00) >> 8, (y & 0xff00) >> 8, 8);
+    byte2 = helper_sig_sat_sub((x & 0xff0000) >> 16,
+                               (y & 0xff0000) >> 16, 8);
+    byte3 = helper_sig_sat_sub((x & 0xff000000) >> 24,
+                               (y & 0xff000000) >> 24, 8);
+    return (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(psub_u8_s)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = rx[7:0] - ry[7:0]*/
+    /* rz[15:8] = rx[15:8] - ry[15:8]*/
+    /* rz[23:16] = rx[23:16] - ry[23:16]*/
+    /* rz[31:24] = rx[31:24] - ry[31:24], unsigned & saturated. */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = helper_unsig_sat_sub(x & 0xff, y & 0xff, 8);
+    byte1 = helper_unsig_sat_sub((x & 0xff00) >> 8, (y & 0xff00) >> 8, 8);
+    byte2 = helper_unsig_sat_sub((x & 0xff0000) >> 16,
+                                 (y & 0xff0000) >> 16, 8);
+    byte3 = helper_unsig_sat_sub((x & 0xff000000) >> 24,
+                                 (y & 0xff000000) >> 24, 8);
+    return (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(psub_s16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = rx[15:0] - ry[15:0],
+     * rz[31:16] = rx[31:16] - ry[31:16], signed & saturated */
+    uint32_t lo, hi;
+    lo  = helper_sig_sat_sub(x & 0xffff, y & 0xffff, 16);
+    hi  = helper_sig_sat_sub((x & 0xffff0000) >> 16,
+                             (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(psub_u16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = rx[15:0] - ry[15:0],
+     * rz[31:16] = rx[31:16] - ry[31:16], unsigned & saturated */
+    uint32_t lo, hi;
+    lo  = helper_unsig_sat_sub(x & 0xffff, y & 0xffff, 16);
+    hi  = helper_unsig_sat_sub((x & 0xffff0000) >> 16,
+                               (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(paddh_s8)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = (rx[7:0] + ry[7:0])/2,
+     * rz[15:8] = (rx[15:8] + ry[15:8])/2,
+     * rz[23:16] = (rx[23:16] + ry[23:16])/2,
+     * rz[31:24] = (rx[31:24] + ry[31:24])/2, signed */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = ((int32_t)(int8_t)x + (int32_t)(int8_t)y) >> 1;
+    byte0 &= 0xff;
+    byte1 = ((int32_t)(int8_t)(x >> 8) + (int32_t)(int8_t)(y >> 8)) >> 1;
+    byte1 &= 0xff;
+    byte2 = ((int32_t)(int8_t)(x >> 16) + (int32_t)(int8_t)(y >> 16)) >> 1;
+    byte2 &= 0xff;
+    byte3 = ((int32_t)(int8_t)(x >> 24) + (int32_t)(int8_t)(y >> 24)) >> 1;
+    byte3 &= 0xff;
+    return (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(paddh_u8)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = (rx[7:0] + ry[7:0])/2,
+     * rz[15:8] = (rx[15:8] + ry[15:8])/2,
+     * rz[23:16] = (rx[23:16] + ry[23:16])/2,
+     * rz[31:24] = (rx[31:24] + ry[31:24])/2, unsigned */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = ((x & 0xff) + (y & 0xff)) >> 1;
+    byte1 = (((x & 0xff00) + (y & 0xff00)) >> 1) & 0xff00;
+    byte2 = (((x & 0xff0000) + (y & 0xff0000)) >> 1) & 0xff0000;
+    byte3 = (((x & 0xff000000) >> 1) + ((y & 0xff000000) >> 1)) & 0xff000000;
+    return byte3 | byte2 | byte1 | byte0;
+}
+
+uint32_t DSPV2_HELPER(paddh_s16)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = (rx[15:0] + ry[15:0])/2,
+     * rz[31:16] = (rx[31:16] + ry[31:16])/2, signed */
+    uint32_t lo, hi;
+    lo = ((int32_t)(int16_t)x + (int32_t)(int16_t)y) >> 1;
+    hi = (((int32_t)x >> 16) + ((int32_t)y >> 16)) >> 1;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(paddh_u16)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = (rx[15:0] + ry[15:0])/2,
+     * rz[31:16] = (rx[31:16] + ry[31:16])/2, unsigned */
+    uint32_t lo, hi;
+    lo = ((x & 0xffff) + (y & 0xffff)) >> 1;
+    hi = ((x >> 16) + (y >> 16)) >> 1;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(psubh_s8)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = (rx[7:0] - ry[7:0])/2,
+     * rz[15:8] = (rx[15:8] - ry[15:8])/2,
+     * rz[23:16] = (rx[23:16] - ry[23:16])/2,
+     * rz[31:24] = (rx[31:24] - ry[31:24])/2, signed */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = ((int32_t)(int8_t)x - (int32_t)(int8_t)y) >> 1;
+    byte0 &= 0xff;
+    byte1 = ((int32_t)(int8_t)(x >> 8) - (int32_t)(int8_t)(y >> 8)) >> 1;
+    byte1 &= 0xff;
+    byte2 = ((int32_t)(int8_t)(x >> 16) - (int32_t)(int8_t)(y >> 16)) >> 1;
+    byte2 &= 0xff;
+    byte3 = ((int32_t)(int8_t)(x >> 24) - (int32_t)(int8_t)(y >> 24)) >> 1;
+    byte3 &= 0xff;
+    return (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(psubh_u8)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = (rx[7:0] - ry[7:0])/2,
+     * rz[15:8] = (rx[15:8] - ry[15:8])/2,
+     * rz[23:16] = (rx[23:16] - ry[23:16])/2,
+     * rz[31:24] = (rx[31:24] - ry[31:24])/2, unsigned */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = (((x & 0xff) - (y & 0xff)) >> 1) & 0xff;
+    byte1 = (((x & 0xff00) - (y & 0xff00)) >> 1) & 0xff00;
+    byte2 = (((x & 0xff0000) - (y & 0xff0000)) >> 1) & 0xff0000;
+    byte3 = (((x & 0xff000000) >> 1) - ((y & 0xff000000) >> 1)) & 0xff000000;
+    return byte3 | byte2 | byte1 | byte0;
+}
+
+uint32_t DSPV2_HELPER(psubh_s16)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = (rx[15:0] - ry[15:0])/2,
+     * rz[31:16] = (rx[31:16] - ry[31:16])/2, signed */
+    uint32_t lo, hi;
+    lo = ((int32_t)(int16_t)x - (int32_t)(int16_t)y) >> 1;
+    hi = (((int32_t)x >> 16) - ((int32_t)y >> 16)) >> 1;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(psubh_u16)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = (rx[15:0] - ry[15:0])/2,
+     * rz[31:16] = (rx[31:16] - ry[31:16])/2, unsigned */
+    uint32_t lo, hi;
+    lo = ((x & 0xffff) - (y & 0xffff)) >> 1;
+    hi = ((x >> 16) - (y >> 16)) >> 1;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(pasx_s16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = rx[31:16] + ry[15:0],
+     * rz[15:0] = rx[15:0] - ry[31:16], signed & saturated */
+    uint32_t lo, hi;
+    hi  = helper_sig_sat_add((x & 0xffff0000) >> 16, y & 0xffff, 16);
+    lo  = helper_sig_sat_sub(x & 0xffff, (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(pasx_u16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = rx[31:16] + ry[15:0],
+     * rz[15:0] = rx[15:0] - ry[31:16], unsigned & saturated */
+    uint32_t lo, hi;
+    hi  = helper_unsig_sat_add((x & 0xffff0000) >> 16, y & 0xffff, 16);
+    lo  = helper_unsig_sat_sub(x & 0xffff, (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(psax_s16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = rx[31:16] - ry[15:0],
+     * rz[15:0] = rx[15:0] + ry[31:16], signed & saturated */
+    uint32_t lo, hi;
+    hi  = helper_sig_sat_sub((x & 0xffff0000) >> 16, y & 0xffff, 16);
+    lo  = helper_sig_sat_add(x & 0xffff, (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(psax_u16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = rx[31:16] - ry[15:0],
+     * rz[15:0] = rx[15:0] + ry[31:16], unsigned & saturated */
+    uint32_t lo, hi;
+    hi  = helper_unsig_sat_sub((x & 0xffff0000) >> 16, y & 0xffff, 16);
+    lo  = helper_unsig_sat_add(x & 0xffff, (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(pasxh_s16)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = (rx[31:16] + ry[31:16])/2,
+     * rz[15:0] = (rx[15:0] - ry[15:0])/2, signed */
+    uint32_t lo, hi;
+    lo = ((int32_t)(int16_t)x - ((int32_t)y >> 16)) >> 1;
+    hi = (((int32_t)x >> 16) + (int32_t)(int16_t)y) >> 1;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(pasxh_u16)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = (rx[31:16] + ry[31:16])/2,
+     * rz[15:0] = (rx[15:0] - ry[15:0])/2, unsigned */
+    uint32_t lo, hi;
+    lo = ((x & 0xffff) - (y >> 16)) >> 1;
+    hi = ((x >> 16) + (y & 0xffff)) >> 1;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(psaxh_s16)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = (rx[31:16] - ry[15:0])/2,
+     * rz[15:0] = (rx[15:0] + ry[31:16])/2, signed */
+    uint32_t lo, hi;
+    lo = ((int32_t)(int16_t)x + ((int32_t)y >> 16)) >> 1;
+    hi = (((int32_t)x >> 16) - (int32_t)(int16_t)y) >> 1;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(psaxh_u16)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = (rx[31:16] - ry[31:16])/2,
+     * rz[15:0] = (rx[15:0] + ry[15:0])/2, unsigned */
+    uint32_t lo, hi;
+    lo = ((x & 0xffff) + (y >> 16)) >> 1;
+    hi = ((x >> 16) - (y & 0xffff)) >> 1;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint64_t DSPV2_HELPER(add_s64_s)(uint64_t x, uint64_t y)
+{
+    /* rz = rx + ry, signed & saturated */
+    uint64_t res = x + y;
+    if (((res ^ x) & SIGNBIT64) && !((x ^ y) & SIGNBIT64)) {
+        res = ~(((int64_t)x >> 63) ^ SIGNBIT64);
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(add_u64_s)(uint64_t x, uint64_t y)
+{
+    /* rz = rx + ry, unsigned & saturated */
+    uint64_t res = x + y;
+    if (res < x || res < y) {
+        res = 0xffffffffffffffff;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(sub_s64_s)(uint64_t x, uint64_t y)
+{
+    /* rz = rx - ry, signed & saturated */
+    uint64_t res = x - y;
+    if (((res ^ x) & SIGNBIT64) && ((x ^ y) & SIGNBIT64)) {
+        res = ~(((int64_t)x >> 63) ^ SIGNBIT64);
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(sub_u64_s)(uint64_t x, uint64_t y)
+{
+    /* rz = rx + ry, unsigned & saturated */
+    uint64_t res = x - y;
+    if (res > x) {
+        res = 0;
+    }
+    return res;
+}
+
+static inline uint32_t helper_unsig_sat_lsl_32(uint32_t x, uint32_t n)
+{
+    /* unsigned & saturated add for len bits operands */
+    if (n > 31) {
+        return 0xffffffff;
+    }
+    uint32_t res = x << n;
+    uint64_t exp_res = (uint64_t)x << n;
+    if ((uint64_t)res != exp_res) {
+        res = 0xffffffff;
+    }
+    return res;
+ }
+
+static inline uint32_t helper_sig_sat_lsl_32(uint32_t x, uint32_t n)
+{
+    /* signed & saturated add for len bits operands */
+    if (n > 31 && (int32_t)x < 0) {
+        return 0x80000000;
+    }
+    if (n > 31 && (int32_t)x > 0) {
+        return 0x7fffffff;
+    }
+
+    int32_t res = x << n;
+    int64_t exp_res = (int64_t)(int32_t)x << n;
+    if ((int64_t)res != exp_res) {
+        res = (exp_res < 0) ? 0x80000000 : 0x7fffffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(lsli_u32_s)(uint32_t x, uint32_t imm)
+{
+    /* Rz[31:0] <- Satur(Rx[31:0] << imm[4:0]) */
+    return helper_unsig_sat_lsl_32(x, imm);
+}
+
+uint32_t DSPV2_HELPER(lsli_s32_s)(uint32_t x, uint32_t imm)
+{
+    /* Rz[31:0] <- Satur(Rx[31:0] << imm[4:0]) */
+    return helper_sig_sat_lsl_32(x, imm);
+}
+
+uint32_t DSPV2_HELPER(lsl_u32_s)(uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] <- Satur(Rx[31:0] << ry[5:0]) */
+    return helper_unsig_sat_lsl_32(x, y);
+}
+
+uint32_t DSPV2_HELPER(lsl_s32_s)(uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] <- Satur(Rx[31:0] << ry[5:0]) */
+    return helper_sig_sat_lsl_32(x, y);
+}
+
+static inline uint32_t helper_unsig_sat_lsl_16(uint32_t x, uint32_t y)
+{
+    if (y > 16) {
+        return 0xffff;
+    }
+    uint32_t exp_res = (x & 0xffff) << y;
+    uint16_t res = x << y;
+    if ((uint32_t)res != exp_res) {
+        res = 0xffff;
+    }
+    return (uint32_t)res;
+}
+
+static inline uint32_t helper_sig_sat_lsl_16(uint32_t x, uint32_t y)
+{
+    if (y > 16 && (int16_t)x < 0) {
+        return 0x8000;
+    }
+    if (y > 16 && (int16_t)x > 0) {
+        return 0x7fff;
+    }
+    int32_t exp_res = (int32_t)(int16_t)x << y;
+    int16_t res = x << y;
+    if ((int32_t)res != exp_res) {
+        res = (x & 0x8000) ? 0x8000 : 0x7fff;
+    }
+    return (uint32_t)(uint16_t)res;
+}
+
+uint32_t DSPV2_HELPER(plsli_u16_s)(uint32_t x, uint32_t imm)
+{
+    /* Rz[31:16] <- Saturate(Rx[31:16] << oimm[3:0]),
+     * Rz[15:0] <- Saturate(Rx[15:0] << oimm[3:0]) */
+    uint32_t hi, lo;
+    hi = helper_unsig_sat_lsl_16((x & 0xffff0000) >> 16, imm);
+    lo = helper_unsig_sat_lsl_16(x & 0xffff, imm);
+    return hi << 16 | lo;
+}
+
+uint32_t DSPV2_HELPER(plsli_s16_s)(uint32_t x, uint32_t imm)
+{
+    /* Rz[31:16] <- Saturate(Rx[31:16] << oimm[3:0]),
+     * Rz[15:0] <- Saturate(Rx[15:0] << oimm[3:0]) */
+    uint32_t hi, lo;
+    hi = helper_sig_sat_lsl_16((x & 0xffff0000) >> 16, imm);
+    lo = helper_sig_sat_lsl_16(x & 0xffff, imm);
+    return hi << 16 | lo;
+}
+
+uint32_t DSPV2_HELPER(plsl_u16_s)(uint32_t x, uint32_t y)
+{
+    /* Rz[31:16] <- Saturate(Rx[31:16] << ry[3:0]),
+     * Rz[15:0] <- Saturate(Rx[15:0] << ry[3:0]) */
+    uint32_t hi, lo;
+    hi = helper_unsig_sat_lsl_16((x & 0xffff0000) >> 16, y);
+    lo = helper_unsig_sat_lsl_16(x & 0xffff, y);
+    return hi << 16 | lo;
+}
+
+uint32_t DSPV2_HELPER(plsl_s16_s)(uint32_t x, uint32_t y)
+{
+    /* Rz[31:16] <- Saturate(Rx[31:16] << ry[3:0]),
+     * Rz[15:0] <- Saturate(Rx[15:0] << ry[3:0]) */
+    uint32_t hi, lo;
+    hi = helper_sig_sat_lsl_16((x & 0xffff0000) >> 16, y);
+    lo = helper_sig_sat_lsl_16(x & 0xffff, y);
+    return hi << 16 | lo;
+}
+
+uint32_t DSPV2_HELPER(pcmpne_8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        res |= ((x & mask) != (y & mask)) ? mask : 0;
+        mask = mask << 8;
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmpne_16)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xffff;
+    uint32_t res = 0;
+    res |= ((x & mask) != (y & mask)) ? mask : 0;
+    mask = mask << 16;
+    res |= ((x & mask) != (y & mask)) ? mask : 0;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmphs_u8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        res |= ((x & mask) >= (y & mask)) ? mask : 0;
+        mask = mask << 8;
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmphs_s8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        int8_t byte_x, byte_y;
+        byte_x = (x >> (i * 8)) & mask;
+        byte_y = (y >> (i * 8)) & mask;
+        res |= (byte_x >= byte_y) ? (mask << (i * 8)) : 0;
+        i++;
+    }
+    return res;
+}
+
+
+uint32_t DSPV2_HELPER(pcmphs_u16)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xffff;
+    uint32_t res = 0;
+    res |= ((x & mask) >= (y & mask)) ? mask : 0;
+    mask = mask << 16;
+    res |= ((x & mask) >= (y & mask)) ? mask : 0;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmphs_s16)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xffff;
+    uint32_t res = 0;
+    res |= ((int16_t)(x & mask) >= (int16_t)(y & mask)) ? mask : 0;
+    mask = mask << 16;
+    res |= ((int32_t)(x & mask) >= (int32_t)(y & mask)) ? mask : 0;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmplt_u8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        res |= ((x & mask) < (y & mask)) ? mask : 0;
+        mask = mask << 8;
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmplt_s8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        int8_t byte_x, byte_y;
+        byte_x = (x >> (i * 8)) & mask;
+        byte_y = (y >> (i * 8)) & mask;
+        res |= (byte_x < byte_y) ? (mask << (i * 8)) : 0;
+        i++;
+    }
+    return res;
+}
+
+
+uint32_t DSPV2_HELPER(pcmplt_u16)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xffff;
+    uint32_t res = 0;
+    res |= ((x & mask) < (y & mask)) ? mask : 0;
+    mask = mask << 16;
+    res |= ((x & mask) < (y & mask)) ? mask : 0;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmplt_s16)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xffff;
+    uint32_t res = 0;
+    res |= ((int16_t)(x & mask) < (int16_t)(y & mask)) ? mask : 0;
+    mask = mask << 16;
+    res |= ((int32_t)(x & mask) < (int32_t)(y & mask)) ? mask : 0;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pmax_s8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        int8_t byte_x, byte_y;
+        byte_x = (x >> (i * 8)) & mask;
+        byte_y = (y >> (i * 8)) & mask;
+        res |= (byte_x > byte_y) ? ((uint8_t)byte_x << (i * 8))
+            : ((uint8_t)byte_y << (i * 8));
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pmax_u8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        res |= ((x & mask) > (y & mask)) ? (x & mask) : (y & mask);
+        mask = mask << 8;
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pmin_s8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        int8_t byte_x, byte_y;
+        byte_x = (x >> (i * 8)) & mask;
+        byte_y = (y >> (i * 8)) & mask;
+        res |= (byte_x < byte_y) ? ((uint8_t)byte_x << (i * 8))
+            : ((uint8_t)byte_y << (i * 8));
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pmin_u8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        res |= ((x & mask) < (y & mask)) ? (x & mask) : (y & mask);
+        mask = mask << 8;
+        i++;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pext_u8_e)(uint32_t x)
+{
+    uint8_t byte_x;
+    uint32_t i = 0;
+    uint64_t res = 0;
+    while (i < 4) {
+        byte_x = (x >> (i * 8)) & 0xff;
+        res |= ((uint64_t)byte_x) << (i * 16);
+        i++;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pext_s8_e)(uint32_t x)
+{
+    int8_t byte_x;
+    uint32_t i = 0;
+    uint64_t res = 0;
+    while (i < 4) {
+        byte_x = (x >> (i * 8)) & 0xff;
+        res |= (((int64_t)byte_x) & 0xffff) << (i * 16);
+        i++;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pextx_u8_e)(uint32_t x)
+{
+    uint64_t res = 0;
+    res |= (uint64_t)x & 0xff;
+    res |= (uint64_t)x & 0xff0000;
+    res |= (uint64_t)(x & 0xff00) << 24;
+    res |= (uint64_t)(x & 0xff000000) << 24;
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pextx_s8_e)(uint32_t x)
+{
+    int8_t byte_x;
+    uint64_t res = 0;
+    byte_x = (x & 0xff);
+    res |= ((int64_t)byte_x & 0xffff);
+    byte_x = (x >> 8) & 0xff;
+    res |= ((int64_t)byte_x & 0xffff) << 32;
+    byte_x = (x >> 16) & 0xff;
+    res |= ((int64_t)byte_x & 0xffff) << 16;
+    byte_x = (x >> 24) & 0xff;
+    res |= ((int64_t)byte_x & 0xffff) << 48;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(narl)(uint32_t x, uint32_t y)
+{
+    uint32_t mask_0 = 0xff;
+    uint32_t mask_2 = 0xff0000;
+
+    uint32_t res = 0;
+    res |= x & mask_0;
+    res |= (x & mask_2) >> 8;
+    res |= (y & mask_0) << 16;
+    res |= (y & mask_2) << 8;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(narh)(uint32_t x, uint32_t y)
+{
+    uint32_t mask_1 = 0xff00;
+    uint32_t mask_3 = 0xff000000;
+
+    uint32_t res = 0;
+    res |= (x & mask_1) >> 8;
+    res |= (x & mask_3) >> 16;
+    res |= (y & mask_1) << 8;
+    res |= y & mask_3;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(narlx)(uint32_t x, uint32_t y)
+{
+    uint32_t mask_02 = 0xff00ff;
+
+    uint32_t res = 0;
+    res |= x & mask_02;
+    res |= (y & mask_02) << 8;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(narhx)(uint32_t x, uint32_t y)
+{
+    uint32_t mask_13 = 0xff00ff00;
+
+    uint32_t res = 0;
+    res |= (x & mask_13) >> 8;
+    res |= y & mask_13;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(clipi_u32)(uint32_t x, uint32_t imm)
+{
+    uint32_t max = (1 << imm) - 1;
+    uint32_t res = 0;
+    if (x > max) {
+        res = max;
+    } else {
+        res = x;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(clipi_s32)(uint32_t x, uint32_t imm)
+{
+    int32_t max = (1 << imm) - 1;
+    int32_t min = -(1 << imm);
+    uint32_t res = 0;
+    if ((int32_t)x > max) {
+        res = max;
+    } else if ((int32_t)x < min) {
+        res = min;
+    } else {
+        res = x;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(clip_u32)(uint32_t x, uint32_t y)
+{
+    if (y > 31) {
+        return x;
+    }
+    uint32_t max = (1 << (y & 0x1f)) - 1;
+    uint32_t res = 0;
+    if (x > max) {
+        res = max;
+    } else {
+        res = x;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(clip_s32)(uint32_t x, uint32_t y)
+{
+    if (y > 32) {
+        return x;
+    }
+    if (y < 1) {
+        return 0;
+    }
+    int32_t max = (1 << ((y & 0x1f) - 1)) - 1;
+    int32_t min = -(1 << ((y & 0x1f) - 1));
+    uint32_t res = 0;
+    if ((int32_t)x > max) {
+        res = max;
+    } else if ((int32_t)x < min) {
+        res = min;
+    } else {
+        res = x;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pclipi_u16)(uint32_t x, uint32_t imm)
+{
+    uint16_t max = (1 << imm) - 1;
+    uint32_t res = 0;
+    uint16_t hword = x & 0xffff;
+    if (hword > max) {
+        hword = max;
+    }
+    res |= hword & 0xffff;
+    hword = x >> 16;
+    if (hword > max) {
+        hword = max;
+    }
+    res |= hword << 16;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pclipi_s16)(uint32_t x, uint32_t imm)
+{
+    int16_t max = (1 << imm) - 1;
+    int16_t min = -(1 << imm);
+    uint32_t res = 0;
+    int16_t hword = x & 0xffff;
+    if (hword > max) {
+        hword = max;
+    } else if (hword < min) {
+        hword = min;
+    }
+    res |= hword & 0xffff;
+    hword = x >> 16;
+    if (hword > max) {
+        hword = max;
+    } else if (hword < min) {
+        hword = min;
+    }
+    res |= hword << 16;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pclip_u16)(uint32_t x, uint32_t y)
+{
+    if (y > 15) {
+        return x;
+    }
+    uint16_t max = (1 << (y & 0xf)) - 1;
+    uint32_t res = 0;
+    uint16_t hword = x & 0xffff;
+    if (hword > max) {
+        hword = max;
+    }
+    res |= hword & 0xffff;
+    hword = x >> 16;
+    if (hword > max) {
+        hword = max;
+    }
+    res |= hword << 16;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pclip_s16)(uint32_t x, uint32_t y)
+{
+    if (y > 32) {
+        return x;
+    }
+    if (y < 1) {
+        return 0;
+    }
+    int16_t max = (1 << ((y - 1) & 0xf)) - 1;
+    int16_t min = -(1 << ((y - 1) & 0xf));
+    uint32_t res = 0;
+    int16_t hword = x & 0xffff;
+    if (hword > max) {
+        hword = max;
+    } else if (hword < min) {
+        hword = min;
+    }
+    res |= hword & 0xffff;
+    hword = x >> 16;
+    if (hword > max) {
+        hword = max;
+    } else if (hword < min) {
+        hword = min;
+    }
+    res |= hword << 16;
+    return res;
+}
+
+
+uint32_t DSPV2_HELPER(pabs_s8_s)(uint32_t x)
+{
+    /* Rz[31:24] = Saturate(abs(Rx[31:24]))
+     * Rz[23:16] = Saturate(abs(Rx[23:16]))
+     * Rz[15:8] = Saturate(abs(Rx[15:8]))
+     * Rz[7:0] = Saturate(abs(Rx[7:0])) */
+    int8_t byte_x;
+    uint32_t i = 0;
+    uint64_t res = 0;
+    while (i < 4) {
+        byte_x = (x >> (i * 8)) & 0xff;
+        if (byte_x == (int8_t)0x80) {
+            byte_x = 0x7f;
+        } else if (byte_x < 0) {
+            byte_x = -byte_x;
+        }
+        res |= byte_x << (i * 8);
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pabs_s16_s)(uint32_t x)
+{
+    /* rz[15:0] = | rx[15:0] |, rz[31:16] = | rx[31:16] |, signed */
+    int16_t lo, hi;
+    lo = (int16_t)x;
+    hi = (int16_t)(x >> 16);
+    lo = lo > 0 ? lo : -lo;
+    hi = hi > 0 ? hi : -hi;
+    if (lo == (int16_t)0x8000) {
+        lo = 0x7fff;
+    }
+    if (hi == (int16_t)0x8000) {
+        hi = 0x7fff;
+    }
+    return (lo & 0xffff) | (hi << 16);
+}
+
+uint32_t DSPV2_HELPER(abs_s32_s)(uint32_t x)
+{
+    /* rz[31:0] = Saturate(abs(Rx[31:0])), signed */
+    uint32_t res;
+    if ((int32_t)x >= 0) {
+        res = x;
+    } else if (x == 0x80000000) {
+        res = 0x7fffffff;
+    } else {
+        res = -x;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pneg_s8_s)(uint32_t x)
+{
+    /* Rz[31:24] = Saturate(neg(Rx[31:24]))
+     * Rz[23:16] = Saturate(neg(Rx[23:16]))
+     * Rz[15:8] = Saturate(neg(Rx[15:8]))
+     * Rz[7:0] = Saturate(neg(Rx[7:0])) */
+    int8_t byte_x;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        byte_x = -((x >> (i * 8)) & 0xff);
+        if (byte_x == (int8_t)0x80) {
+            byte_x = 0x7f;
+        }
+        res |= (uint8_t)byte_x << (i * 8);
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pneg_s16_s)(uint32_t x)
+{
+    /* rz[15:0] = !rx[15:0], rz[31:16] = !rx[31:16] */
+    int16_t lo, hi;
+    lo = x & 0xffff;
+    hi = x >> 16;
+    lo = -lo;
+    hi = -hi;
+    if (lo == (int16_t)0x8000) {
+        lo = 0x7fff;
+    }
+    if (hi == (int16_t)0x8000) {
+        hi = 0x7fff;
+    }
+    return (lo & 0xffff) | (hi << 16);
+}
+
+uint32_t DSPV2_HELPER(neg_s32_s)(uint32_t x)
+{
+    /* Rz[31:0] = Saturate(neg(Rx[31:0])) */
+    int32_t res = -((int32_t)x);
+    if (res == (int32_t)0x80000000) {
+        res = 0x7fffffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(dup_8)(uint32_t x, uint32_t index)
+{
+    uint32_t res;
+    uint32_t byte_x = (x >> (index * 8)) & 0xff;
+    res = byte_x | (byte_x << 8) | (byte_x << 16) | (byte_x << 24);
+    return res;
+}
+
+uint32_t DSPV2_HELPER(dup_16)(uint32_t x, uint32_t index)
+{
+    uint32_t res;
+    uint32_t byte_x = (x >> (index * 16)) & 0xffff;
+    res = byte_x | (byte_x << 16);
+    return res;
+}
+
+uint32_t DSPV2_HELPER(rmul_s32_h)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[31:0] == 32’h8000 0000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[31:0]}[62:31] */
+    int64_t res;
+    if ((x == 0x80000000) && (y == 0x80000000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)(int32_t)y;
+        return res >> 31;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmul_s32_rh)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[31:0] == 32’h8000 0000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[31:0]}[62:31] */
+    int64_t res;
+    if ((x == 0x80000000) && (y == 0x80000000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)(int32_t)y + 0x40000000;
+        return res >> 31;
+    }
+}
+
+uint64_t DSPV2_HELPER(mula_s32_s)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( {Rz[31:0],Rz+1[31:0]}
+     * + {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int64_t res, xy;
+    int64_t z_long = ((uint64_t)z1 << 32) + z;
+    xy = (int64_t)(int32_t)x * (int64_t)(int32_t)y;
+    res = xy + z_long;
+    if (((res ^ z_long) & SIGNBIT64) && !((xy ^ z_long) & SIGNBIT64)) {
+        res = ~(((int64_t)z_long >> 63) ^ SIGNBIT64);
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(mula_u32_s)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( {Rz[31:0],Rz+1[31:0]}
+     * + {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    uint64_t res, xy;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    xy = (uint64_t)x * (uint64_t)y;
+    res = xy + z_long;
+    if (res < xy || res < z_long) {
+        res = 0xffffffffffffffff;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(muls_s32_s)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( {Rz[31:0],Rz+1[31:0]}
+     * - {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int64_t res, xy;
+    int64_t z_long = ((uint64_t)z1 << 32) + z;
+    xy = (int64_t)(int32_t)x * (int64_t)(int32_t)y;
+    res = z_long - xy;
+    if (((res ^ z_long) & SIGNBIT64) && ((xy ^ z_long) & SIGNBIT64)) {
+        res = ~(((int64_t)z_long >> 63) ^ SIGNBIT64);
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(muls_u32_s)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( {Rz[31:0],Rz+1[31:0]}
+     * - {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    uint64_t res, xy;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    xy = (uint64_t)x * (uint64_t)y;
+    res = z_long - xy;
+    if (res > z_long) {
+        res = 0;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mula_32_l)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] =  Rz[31:0] + {Rx[31:0] X Ry[31:0]}[31:0] ) */
+    return z + x * y;
+}
+
+uint32_t DSPV2_HELPER(mula_s32_hs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)(int32_t)y) >> 32;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(muls_s32_hs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)(int32_t)y) >> 32;
+    return helper_sig_sat_sub(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mula_s32_rhs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[31:0]
+     * + 32’h80000000}[63:32] ) */
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)(int32_t)y
+                  + 0x80000000) >> 32;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(muls_s32_rhs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[31:0]
+     * + 32’h80000000}[63:32] ) */
+    int64_t xy = (int64_t)(int32_t)x * (int64_t)(int32_t)y - 0x80000000;
+    int64_t z_long = (uint64_t)z << 32;
+    int64_t res = z_long - xy;
+    if (((res ^ z_long) & SIGNBIT64) && ((xy ^ z_long) & SIGNBIT64)) {
+        res = ~(((int64_t)z_long >> 63) ^ SIGNBIT64);
+    }
+    return res >> 32;
+}
+
+uint32_t DSPV2_HELPER(rmulxl_s32)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[15:0] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[15:0]}[46:15] */
+    int64_t res;
+    int16_t tmp_y = y & 0xffff;
+    if ((x == 0x80000000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)tmp_y;
+        return res >> 15;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmulxl_s32_r)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[15:0] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[15:0]}[46:15] */
+    int64_t res;
+    int16_t tmp_y = y & 0xffff;
+    if ((x == 0x80000000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)tmp_y + 0x4000;
+        return res >> 15;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmulxh_s32)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[31:16] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[31:16]}[46:15] */
+    int64_t res;
+    int16_t tmp_y = y >> 16;
+    if ((x == 0x80000000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)tmp_y;
+        return res >> 15;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmulxh_s32_r)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[31:16] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[31:16]}[46:15] */
+    int64_t res;
+    int16_t tmp_y = y >> 16;
+    if ((x == 0x80000000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)tmp_y + 0x4000;
+        return res >> 15;
+    }
+}
+
+uint32_t DSPV2_HELPER(mulaxl_s32_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[15:0]}[47:16] ) */
+    int16_t tmp_y = y & 0xffff;
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)tmp_y) >> 16;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mulaxl_s32_rs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_y = y & 0xffff;
+    int32_t xy = ((int64_t)x * (int64_t)tmp_y + 0x8000) >> 16;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mulaxh_s32_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[31:16]}[47:16] ) */
+    int16_t tmp_y = y >> 16;
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)tmp_y) >> 16;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mulaxh_s32_rs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_y = y >> 16;
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)tmp_y + 0x8000) >> 16;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(rmulll_s16)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[15:0] == 32’h8000 && Ry[15:0] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[15:0] X Ry[15:0]} << 1 */
+    int16_t tmp_x = x & 0xffff;
+    int16_t tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        return ((int32_t)tmp_x * (int32_t)tmp_y) << 1;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmulhh_s16)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:16] == 32’h8000 && Ry[31:16] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:16] X Ry[31:16]} << 1 */
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        return ((int32_t)tmp_x * (int32_t)tmp_y) << 1;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmulhl_s16)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:16] == 32’h8000 && Ry[15:0] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:16] X Ry[15:0]} << 1 */
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        return ((int32_t)tmp_x * (int32_t)tmp_y) << 1;
+    }
+}
+
+uint32_t DSPV2_HELPER(mulall_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate(Rz[31:0] + Rx[15:0] X Ry[15:0]) */
+    int16_t tmp_x = x & 0xffff;
+    int16_t tmp_y = y & 0xffff;
+    int32_t xy = (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mulahh_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate(Rz[31:0] + Rx[31:16] X Ry[31:16]) */
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    int32_t xy = (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mulahl_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate(Rz[31:0] + Rx[31:16] X Ry[15:0]) */
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    int32_t xy = (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint64_t DSPV2_HELPER(mulall_s16_e)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    /* {Rz+1[31:0],Rz[31:0]} = {Rz+1[31:0],Rz[31:0]} + Rx[15:0] X Ry[15:0] */
+    int64_t res = ((uint64_t)z1 << 32) + z;
+    int16_t tmp_x = x & 0xffff;
+    int16_t tmp_y = y & 0xffff;
+    int64_t xy = (int64_t)tmp_x * (int64_t)tmp_y;
+    return res + xy;
+}
+
+uint64_t DSPV2_HELPER(mulahh_s16_e)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    /* {Rz+1[31:0],Rz[31:0]} = {Rz+1[31:0],Rz[31:0]} + Rx[31:16] X Ry[31:16] */
+    int64_t res = ((uint64_t)z1 << 32) + z;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    int64_t xy = (int64_t)tmp_x * (int64_t)tmp_y;
+    return res + xy;
+}
+
+uint64_t DSPV2_HELPER(mulahl_s16_e)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    /* {Rz+1[31:0],Rz[31:0]} = {Rz+1[31:0],Rz[31:0]} + Rx[31:16] X Ry[15:0] */
+    int64_t res = ((uint64_t)z1 << 32) + z;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    int64_t xy = (int64_t)tmp_x * (int64_t)tmp_y;
+    return res + xy;
+}
+
+uint64_t DSPV2_HELPER(prmul_s16)(uint32_t x, uint32_t y)
+{
+    uint64_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= (uint64_t)0x7fffffff << 32;
+    } else {
+        res |= (uint64_t)((int32_t)tmp_x * (int32_t)tmp_y) << 33;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fffffff;
+    } else {
+        res |= (((int64_t)tmp_x * (int64_t)tmp_y) << 1) & 0xffffffff;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(prmulx_s16)(uint32_t x, uint32_t y)
+{
+    uint64_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= (uint64_t)0x7fffffff << 32;
+    } else {
+        res |= (uint64_t)((int32_t)tmp_x * (int32_t)tmp_y) << 33;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fffffff;
+    } else {
+        res |= (((int64_t)tmp_x * (int64_t)tmp_y) << 1) & 0xffffffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(prmul_s16_h)(uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff0000;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y) << 1) & 0xffff0000;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y) >> 15) & 0xffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(prmul_s16_rh)(uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff0000;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y + 0x4000) << 1) & 0xffff0000;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y + 0x4000) >> 15) & 0xffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(prmulx_s16_h)(uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff0000;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y) << 1) & 0xffff0000;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y) >> 15) & 0xffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(prmulx_s16_rh)(uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff0000;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y + 0x4000) << 1) & 0xffff0000;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y + 0x4000) >> 15) & 0xffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mulca_s16_s)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    if ((x == 0x80008000) && (y == 0x80008000)) {
+        res = 0x7fffffff;
+    } else {
+        tmp_x = x & 0xffff;
+        tmp_y = y & 0xffff;
+        res = ((int32_t)x >> 16) * ((int32_t)y >> 16)
+            + (int32_t)tmp_x * (int32_t)tmp_y;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mulcax_s16_s)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    if ((x == 0x80008000) && (y == 0x80008000)) {
+        res = 0x7fffffff;
+    } else {
+        tmp_x = x & 0xffff;
+        tmp_y = y & 0xffff;
+        res = ((int32_t)x >> 16) * (int32_t)tmp_y
+            + (int32_t)tmp_x * ((int32_t)y >> 16);
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mulaca_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * ((int32_t)y >> 16)
+        + (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulacax_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * (int32_t)tmp_y
+        + (int32_t)tmp_x * ((int32_t)y >> 16);
+    return helper_sig_sat_add(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulacs_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = (int32_t)tmp_x * (int32_t)tmp_y
+        - ((int32_t)x >> 16) * ((int32_t)y >> 16);
+    return helper_sig_sat_add(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulacsr_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * ((int32_t)y >> 16)
+        - (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulacsx_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = (int32_t)tmp_x * ((int32_t)y >> 16)
+        - ((int32_t)x >> 16) * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulsca_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * ((int32_t)y >> 16)
+        + (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_sub(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulscax_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * (int32_t)tmp_y
+        + (int32_t)tmp_x * ((int32_t)y >> 16);
+    return helper_sig_sat_sub(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(psabsa_u8)(uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    uint32_t i = 0;
+    int32_t tmp_sub;
+    while (i < 4) {
+        tmp_sub = ((x >> (i * 8)) & 0xff) - ((y >> (i * 8)) & 0xff);
+        res += (tmp_sub > 0) ? tmp_sub : -tmp_sub;
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(psabsaa_u8)(uint32_t z, uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    uint32_t i = 0;
+    int32_t tmp_sub;
+    while (i < 4) {
+        tmp_sub = ((x >> (i * 8)) & 0xff) - ((y >> (i * 8)) & 0xff);
+        res += (tmp_sub > 0) ? tmp_sub : -tmp_sub;
+        i++;
+    }
+    return res + z;
+}
+
diff --git a/target-csky/op_helper_v1.c b/target-csky/op_helper_v1.c
new file mode 100644
index 0000000..3a867be
--- /dev/null
+++ b/target-csky/op_helper_v1.c
@@ -0,0 +1,1636 @@
+/*
+ *  C-sky_v1 helper routines
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "cpu.h"
+#include "translate.h"
+#include "exec/helper-proto.h"
+#include "exec/cpu_ldst.h"
+#include "exec/exec-all.h"
+
+void helper_exception(CPUCSKYState *env, uint32_t excp)
+{
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+    cs->exception_index = excp;
+    cpu_loop_exit(cs);
+}
+
+void helper_tb_trace(CPUCSKYState *env, uint32_t tb_pc)
+{
+    int trace_index = env->trace_index % TB_TRACE_NUM;
+    env->trace_info[trace_index].tb_pc = tb_pc;
+    env->trace_index++;
+    qemu_log_mask(CPU_TB_TRACE, "0x%.8x\n", tb_pc);
+}
+
+#ifdef CONFIG_USER_ONLY
+extern long long total_jcount;
+void helper_jcount(CPUCSKYState *env, uint32_t tb_pc, uint32_t icount)
+{
+    if ((tb_pc >= env->jcount_start) && (tb_pc < env->jcount_end)) {
+        total_jcount += icount;
+    }
+}
+#else
+void helper_jcount(CPUCSKYState *env, uint32_t tb_pc, uint32_t icount)
+{
+}
+#endif
+
+uint32_t helper_brev(uint32_t a)
+{
+    uint32_t r = 0;
+    char  i;
+    for (i = 0; i < 32; i++) {
+        r |= (a & 0x1) << (31 - i);
+        a >>= 1;
+    }
+    return r;
+}
+
+uint32_t helper_ff1(uint32_t a)
+{
+    if (a == 0) {
+        return 32;
+    } else {
+        return __builtin_clz(a);
+    }
+}
+
+#if !defined(CONFIG_USER_ONLY)
+void helper_rte(CPUCSKYState *env)
+{
+    if ((env->cp0.psr & 0x2) != (env->cp0.epsr & 0x2)) {
+        helper_switch_regs(env);
+    }
+    env->cp0.psr = env->cp0.epsr & ~(0x7f << 16);
+    env->psr_s = PSR_S(env->cp0.psr);
+    env->psr_c = PSR_C(env->cp0.psr);
+    env->psr_tm = PSR_TM(env->cp0.psr);
+
+    if (unlikely(PSR_TP(env->cp0.epsr))) {
+        env->cp0.psr |= EXCP_CSKY_TRACE << 16;
+        env->cp0.epsr = (env->cp0.psr & ~0x8000e001)    /* clear TP in EPSR */
+            | (env->psr_s << 31)
+            | (env->psr_c)
+            | (env->psr_tm << 14);
+        env->psr_s = 1;
+        env->psr_tm = 0;
+        env->cp0.psr &= ~PSR_TP_MASK;
+        env->cp0.psr &= ~PSR_EE_MASK;
+        env->cp0.psr &= ~PSR_IE_MASK;
+
+        env->pc = cpu_ldl_code(env, env->cp0.vbr + EXCP_CSKY_TRACE * 4);
+        if (unlikely((env->pc & 0x1) != ((env->cp0.psr & 0x2) >> 1))) {
+            helper_switch_regs(env);
+            env->cp0.psr |= (env->pc & 0x1) << 1;
+        }
+        env->pc &= ~0x1;
+    } else {
+        env->pc = env->cp0.epc;
+    }
+
+}
+
+void helper_rfi(CPUCSKYState *env)
+{
+    if ((env->cp0.psr & 0x2) != (env->cp0.fpsr & 0x2)) {
+        helper_switch_regs(env);
+    }
+    env->cp0.psr = env->cp0.fpsr & ~(0x7f << 16);
+    env->psr_s = PSR_S(env->cp0.psr);
+    env->psr_c = PSR_C(env->cp0.psr);
+    env->psr_tm = PSR_TM(env->cp0.psr);
+    if (unlikely(PSR_TP(env->cp0.fpsr))) {
+        env->cp0.psr |= EXCP_CSKY_TRACE << 16;
+        env->cp0.epsr = (env->cp0.psr & ~0x8000e001)   /* clear TP in FPSR */
+            | (env->psr_s << 31)
+            | (env->psr_c)
+            | (env->psr_tm << 14);
+        env->psr_s = 1;
+        env->psr_tm = 0;
+        env->cp0.psr &= ~PSR_TP_MASK;
+        env->cp0.psr &= ~PSR_EE_MASK;
+        env->cp0.psr &= ~PSR_IE_MASK;
+
+        env->pc = cpu_ldl_code(env, env->cp0.vbr + EXCP_CSKY_TRACE * 4);
+        if (unlikely((env->pc & 0x1) != ((env->cp0.psr & 0x2) >> 1))) {
+            helper_switch_regs(env);
+            env->cp0.psr |= (env->pc & 0x1) << 1;
+        }
+        env->pc &= ~0x1;
+    } else {
+        env->pc = env->cp0.fpc;
+    }
+}
+
+
+void helper_psrclr(CPUCSKYState *env, uint32_t imm)
+{
+    /* AF bit */
+    if (!imm && (env->cp0.psr & 0x2)) {
+        env->cp0.psr &= ~0x2;
+        helper_switch_regs(env);
+    }
+    /* IE bit */
+    if (imm & 0x1) {
+        env->cp0.psr &= ~0x40;
+    }
+    /* FE bit */
+    if (imm & 0x2) {
+        env->cp0.psr &= ~0x10;
+    }
+    /* EE bit */
+    if (imm & 0x4) {
+        env->cp0.psr &= ~0x100;
+    }
+}
+
+
+void helper_psrset(CPUCSKYState *env, uint32_t imm)
+{
+    /* AF bit */
+    if (!imm && !(env->cp0.psr & 0x2)) {
+        env->cp0.psr |= 0x2;
+        helper_switch_regs(env);
+    }
+    /* IE bit */
+    if (imm & 0x1) {
+        env->cp0.psr |= 0x40;
+    }
+    /* FE bit */
+    if (imm & 0x2) {
+        env->cp0.psr |= 0x10;
+    }
+    /* EE bit */
+    if (imm & 0x4) {
+        env->cp0.psr |= 0x100;
+    }
+}
+
+void helper_stop(CPUCSKYState *env)
+{
+    CPUState *cs;
+    cs = CPU(csky_env_get_cpu(env));
+    cs->halted = 1;
+    helper_exception(env, EXCP_HLT);
+}
+
+void helper_wait(CPUCSKYState *env)
+{
+    CPUState *cs;
+    cs = CPU(csky_env_get_cpu(env));
+    cs->halted = 1;
+    helper_exception(env, EXCP_HLT);
+}
+
+void helper_doze(CPUCSKYState *env)
+{
+    CPUState *cs;
+    cs = CPU(csky_env_get_cpu(env));
+    cs->halted = 1;
+    helper_exception(env, EXCP_HLT);
+}
+#endif
+
+void helper_cprc(CPUCSKYState *env)
+{
+    env->psr_c = PSR_C(env->cp1.fsr);
+}
+
+#define SETFC (env->cp1.fsr = env->cp1.fsr | 0x1)
+
+#define CLEARFC  (env->cp1.fsr = env->cp1.fsr & (~0x1))
+
+#define getfloat64(env, n) ((float64)(env->cp1.fr[n]) | \
+                      ((float64)(env->cp1.fr[n + 1]) << 32))
+
+static void cmp_ge_s(CPUCSKYState *env, float32 a, float32 b)
+{
+    switch (float32_compare_quiet(a, b, &env->cp1.fp_status)) {
+    case 0:
+        SETFC;
+        break;
+    case -1:
+        CLEARFC;
+        break;
+    case 1:
+        SETFC;
+        break;
+    case 2:
+    default:
+        CLEARFC;
+        break;
+    }
+}
+
+static void cmp_ge_d(CPUCSKYState *env, float64 a, float64 b)
+{
+    switch (float64_compare_quiet(a, b, &env->cp1.fp_status)) {
+    case 0:
+        SETFC;
+        break;
+    case -1:
+        CLEARFC;
+        break;
+    case 1:
+        SETFC;
+        break;
+    case 2:
+    default:
+        CLEARFC;
+        break;
+    }
+}
+
+static void fcmpzhsd(CPUCSKYState *env, int src0)
+{
+    float64 src1 = 0;
+    cmp_ge_d(env, getfloat64(env, src0), src1);
+}
+
+static void fcmpzhss(CPUCSKYState *env, int src0)
+{
+    float32 src1 = 0;
+    cmp_ge_s(env, env->cp1.fr[src0], src1);
+}
+
+static void fcmphss(CPUCSKYState *env, int src0, int src1)
+{
+    cmp_ge_s(env, env->cp1.fr[src0], env->cp1.fr[src1]);
+}
+
+static void fcmphsd(CPUCSKYState *env, int src0, int src1)
+{
+    cmp_ge_d(env, getfloat64(env, src0), getfloat64(env, src1));
+}
+
+static void cmp_l_s(CPUCSKYState *env, float32 a, float32 b)
+{
+    switch (float32_compare_quiet(a, b, &env->cp1.fp_status)) {
+    case 0:
+        CLEARFC;
+        break;
+    case -1:
+        SETFC;
+        break;
+    case 1:
+        CLEARFC;
+        break;
+    case 2:
+    default:
+        CLEARFC;
+        break;
+    }
+}
+
+static void cmp_l_d(CPUCSKYState *env, float64 a, float64 b)
+{
+    switch (float64_compare_quiet(a, b, &env->cp1.fp_status)) {
+    case 0:
+        CLEARFC;
+        break;
+    case -1:
+        SETFC;
+        break;
+    case 1:
+        CLEARFC;
+        break;
+    case 2:
+    default:
+        CLEARFC;
+        break;
+    }
+}
+
+static void fcmpzltd(CPUCSKYState *env, int src0)
+{
+    float64 src1 = 0;
+    cmp_l_d(env, getfloat64(env, src0), src1);
+}
+
+static void fcmpzlts(CPUCSKYState *env, int src0)
+{
+    float32 src1 = 0;
+    cmp_l_s(env, env->cp1.fr[src0], src1);
+}
+
+static void fcmplts(CPUCSKYState *env, int src0, int src1)
+{
+    cmp_l_s(env, env->cp1.fr[src0], env->cp1.fr[src1]);
+}
+
+static void fcmpltd(CPUCSKYState *env, int src0, int src1)
+{
+    cmp_l_d(env, getfloat64(env, src0), getfloat64(env, src1));
+}
+
+static void cmp_ne_s(CPUCSKYState *env, float32 a, float32 b)
+{
+    switch (float32_compare_quiet(a, b, &env->cp1.fp_status)) {
+    case 0:
+        CLEARFC;
+        break;
+    case -1:
+        SETFC;
+        break;
+    case 1:
+        SETFC;
+        break;
+    case 2:
+    default:
+        SETFC;
+        break;
+    }
+}
+
+static void cmp_ne_d(CPUCSKYState *env, float64 a, float64 b)
+{
+    switch (float64_compare_quiet(a, b, &env->cp1.fp_status)) {
+    case 0:
+        CLEARFC;
+        break;
+    case -1:
+        SETFC;
+        break;
+    case 1:
+        SETFC;
+        break;
+    case 2:
+    default:
+        SETFC;
+        break;
+    }
+}
+
+static void fcmpzned(CPUCSKYState *env, int src0)
+{
+    float64 src1 = 0;
+    cmp_ne_d(env, getfloat64(env, src0), src1);
+}
+
+static void fcmpznes(CPUCSKYState *env, int src0)
+{
+    float32 src1 = 0;
+    cmp_ne_s(env, env->cp1.fr[src0], src1);
+
+}
+
+static void fcmpnes(CPUCSKYState *env, int src0, int src1)
+{
+    cmp_ne_s(env, env->cp1.fr[src0], env->cp1.fr[src1]);
+}
+
+static void fcmpned(CPUCSKYState *env, int src0, int src1)
+{
+    cmp_ne_d(env, getfloat64(env, src0), getfloat64(env, src1));
+}
+
+static void cmp_isNAN_s(CPUCSKYState *env, float32 a, float32 b)
+{
+    switch (float32_compare_quiet(a, b, &env->cp1.fp_status)) {
+    case 0:
+        CLEARFC;
+        break;
+    case -1:
+        CLEARFC;
+        break;
+    case 1:
+        CLEARFC;
+        break;
+    case 2:
+    default:
+        SETFC;
+        break;
+    }
+}
+
+static void cmp_isNAN_d(CPUCSKYState *env, float64 a,  float64 b)
+{
+    switch (float64_compare_quiet(a, b, &env->cp1.fp_status)) {
+    case 0:
+        CLEARFC;
+        break;
+    case -1:
+        CLEARFC;
+        break;
+    case 1:
+        CLEARFC;
+        break;
+    case 2:
+    default:
+        SETFC;
+        break;
+    }
+}
+
+static void fcmpzuod(CPUCSKYState *env, int src0)
+{
+    float64 src1 = 0;
+    cmp_isNAN_d(env, getfloat64(env, src0), src1);
+}
+
+static void fcmpzuos(CPUCSKYState *env, int src0)
+{
+    float32 src1 = 0;
+    cmp_isNAN_s(env, env->cp1.fr[src0], src1);
+}
+
+static void fcmpuos(CPUCSKYState *env, int src0, int src1)
+{
+    cmp_isNAN_s(env, env->cp1.fr[src0], env->cp1.fr[src1]);
+}
+
+static void fcmpuod(CPUCSKYState *env, int src0, int src1)
+{
+    cmp_isNAN_d(env, getfloat64(env, src0), getfloat64(env, src1));
+}
+
+
+/* floating point conversion */
+static float64 stod(CPUCSKYState *env, float32 x)
+{
+    float64 r = float32_to_float64(x, &env->cp1.fp_status);
+    /* ARM requires that S<->D conversion of any kind of NaN generates
+     * a quiet NaN by forcing the most significant frac bit to 1.
+     */
+    return float64_maybe_silence_nan(r, &env->cp1.fp_status);
+}
+
+static float32 dtos(CPUCSKYState *env, float64 x)
+{
+    float32 r =  float64_to_float32(x, &env->cp1.fp_status);
+    /* ARM requires that S<->D conversion of any kind of NaN generates
+     * a quiet NaN by forcing the most significant frac bit to 1.
+     */
+    return float32_maybe_silence_nan(r, &env->cp1.fp_status);
+}
+
+#define getfloat32lo(dst, x) (env->cp1.fr[dst] = (float32)(x & 0xffffffff))
+#define getfloat32hi(dst, x) (env->cp1.fr[dst + 1] = (float32)(x >> 32))
+
+static void fstod(CPUCSKYState *env, int dst, int src)
+{
+    float64 x;
+    x = stod(env, env->cp1.fr[src]);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fdtos(CPUCSKYState *env, int dst, int src)
+{
+    float64 x;
+    x = getfloat64(env, src);
+    env->cp1.fr[dst] = dtos(env, x);
+}
+
+/* Helper routines to perform bitwise copies between float and int.  */
+static inline float32 vfp_itos(uint32_t i)
+{
+    union {
+        uint32_t i;
+        float32 s;
+    } v;
+
+    v.i = i;
+    return v.s;
+}
+
+static inline uint32_t vfp_stoi(float32 s)
+{
+    union {
+        uint32_t i;
+        float32 s;
+    } v;
+
+    v.s = s;
+    return v.i;
+}
+
+static inline float64 vfp_itod(uint64_t i)
+{
+    union {
+        uint64_t i;
+        float64 d;
+    } v;
+
+    v.i = i;
+    return v.d;
+}
+
+static inline uint64_t vfp_dtoi(float64 d)
+{
+    union {
+        uint64_t i;
+        float64 d;
+    } v;
+
+    v.d = d;
+    return v.i;
+}
+
+/* Integer to float conversion.  */
+static float32 uitos(CPUCSKYState *env, float32 x)
+{
+    return uint32_to_float32(vfp_stoi(x), &env->cp1.fp_status);
+}
+
+static float64 uitod(CPUCSKYState *env, float32 x)
+{
+    return uint32_to_float64(vfp_stoi(x), &env->cp1.fp_status);
+}
+
+static float32 sitos(CPUCSKYState *env, float32 x)
+{
+    return int32_to_float32(vfp_stoi(x), &env->cp1.fp_status);
+}
+
+static float64 sitod(CPUCSKYState *env, float32 x)
+{
+    return int32_to_float64(vfp_stoi(x), &env->cp1.fp_status);
+}
+
+static void fsitod(CPUCSKYState *env, int dst, int src)
+{
+    float64 x = sitod(env, env->cp1.fr[src]);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fsitos(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = sitos(env, env->cp1.fr[src]);
+}
+
+static void fuitod(CPUCSKYState *env, int dst, int src)
+{
+    float64 x = uitod(env, env->cp1.fr[src]);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fuitos(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = uitos(env, env->cp1.fr[src]);
+}
+
+static void fabsd(CPUCSKYState *env, int dst, int src)
+{
+    float64 x = getfloat64(env, src);
+    x = float64_abs(x);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fabss(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = float32_abs(env->cp1.fr[src]);
+}
+
+static void fnegd(CPUCSKYState *env, int dst, int src)
+{
+    float64 x = getfloat64(env, src);
+    x = float64_chs(x);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fnegs(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = float32_chs(env->cp1.fr[src]);
+}
+
+static void fsqrtd(CPUCSKYState *env, int dst, int src)
+{
+    float64 x = getfloat64(env, src);
+    x = float64_sqrt(x, &env->cp1.fp_status);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fsqrts(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = float32_sqrt(env->cp1.fr[src], &env->cp1.fp_status);
+}
+
+static float32 recips(CPUCSKYState *env, float32 a)
+{
+    float_status *s = &env->cp1.fp_status;
+    float32 one = int32_to_float32(1, s);
+    return float32_div(one, a, s);
+}
+
+static float64 recipd(CPUCSKYState *env, float64 a)
+{
+    float_status *s = &env->cp1.fp_status;
+    float64 one = int32_to_float64(1, s);
+    return float64_div(one, a, s);
+}
+
+static void frecipd(CPUCSKYState *env, int dst, int src)
+{
+    float64 x = getfloat64(env, src);
+    x = recipd(env, x);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void frecips(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = recips(env, env->cp1.fr[src]);
+}
+
+static void fabsm(CPUCSKYState *env, int dst, int src)
+{
+    fabss(env, dst, src);
+    fabss(env, dst + 1, src + 1);
+}
+
+static void fnegm(CPUCSKYState *env, int dst, int src)
+{
+    fnegs(env, dst, src);
+    fnegs(env, dst + 1, src + 1);
+}
+
+
+static void fmovd(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = env->cp1.fr[src];
+    env->cp1.fr[dst + 1] = env->cp1.fr[src + 1];
+}
+
+static void fmovs(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = env->cp1.fr[src];
+}
+
+static float32 stosirn(CPUCSKYState *env, float32 x)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float32_to_int32(x, &env->cp1.fp_status));
+}
+
+static void fstosirn(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = stosirn(env, env->cp1.fr[src]);
+}
+
+static float32 stosirz(CPUCSKYState *env, float32 x)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float32_to_int32_round_to_zero(x, &env->cp1.fp_status));
+}
+
+static void fstosirz(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = stosirz(env, env->cp1.fr[src]);
+}
+
+static float32 stosirpi(CPUCSKYState *env, float32 x)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float32_to_int32_round_to_zero(x,
+                                &env->cp1.fp_status) + 1);
+    } else {
+        return vfp_itos(float32_to_int32_round_to_zero(x,
+                                    &env->cp1.fp_status));
+    }
+}
+
+static void fstosirpi(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = stosirpi(env, env->cp1.fr[src]);
+}
+
+static float32 stosirni(CPUCSKYState *env, float32 x)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float32_to_int32_round_to_zero(x,
+                                    &env->cp1.fp_status));
+    } else {
+        return vfp_itos(float32_to_int32_round_to_zero(x,
+                                &env->cp1.fp_status) - 1);
+    }
+}
+
+static void fstosirni(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = stosirni(env, env->cp1.fr[src]);
+}
+
+static float32 dtosirn(CPUCSKYState *env, float64 x)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float64_to_int32(x, &env->cp1.fp_status));
+}
+
+static void fdtosirn(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = dtosirn(env, getfloat64(env, src));
+}
+
+static float32 dtosirz(CPUCSKYState *env, float64 x)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float64_to_int32_round_to_zero(x, &env->cp1.fp_status));
+}
+
+static void fdtosirz(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = dtosirz(env, getfloat64(env, src));
+}
+
+static float32 dtosirpi(CPUCSKYState *env, float64 x)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float64_to_int32_round_to_zero(x,
+                                &env->cp1.fp_status) + 1);
+    } else {
+        return vfp_itos(float64_to_int32_round_to_zero(x,
+                                    &env->cp1.fp_status));
+    }
+}
+
+static void fdtosirpi(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = dtosirpi(env, getfloat64(env, src));
+}
+
+static float32 dtosirni(CPUCSKYState *env, float64 x)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float64_to_int32_round_to_zero(x,
+                                    &env->cp1.fp_status));
+    } else {
+        return vfp_itos(float64_to_int32_round_to_zero(x,
+                               &env->cp1.fp_status) - 1);
+    }
+}
+
+static void fdtosirni(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = dtosirni(env, getfloat64(env, src));
+}
+
+static float32 stouirn(CPUCSKYState *env, float32 x)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float32_to_uint32(x, &env->cp1.fp_status));
+}
+
+static void fstouirn(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = stouirn(env, env->cp1.fr[src]);
+}
+
+static float32 stouirz(CPUCSKYState *env, float32 x)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float32_to_uint32_round_to_zero(x, &env->cp1.fp_status));
+}
+
+static void fstouirz(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = stouirz(env, env->cp1.fr[src]);
+}
+
+static float32 stouirpi(CPUCSKYState *env, float32 x)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float32_to_uint32_round_to_zero(x,
+                                 &env->cp1.fp_status) + 1);
+    } else {
+        return vfp_itos(float32_to_uint32_round_to_zero(x,
+                                     &env->cp1.fp_status));
+    }
+}
+
+static void fstouirpi(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = stouirpi(env, env->cp1.fr[src]);
+}
+
+static float32 stouirni(CPUCSKYState *env, float32 x)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float32_to_uint32_round_to_zero(x,
+                                     &env->cp1.fp_status));
+    } else {
+        return vfp_itos(float32_to_uint32_round_to_zero(x,
+                                 &env->cp1.fp_status) - 1);
+    }
+}
+
+static void fstouirni(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = stouirni(env, env->cp1.fr[src]);
+}
+
+static float32 dtouirn(CPUCSKYState *env, float64 x)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float64_to_uint32(x, &env->cp1.fp_status));
+
+}
+
+static void fdtouirn(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = dtouirn(env, getfloat64(env, src));
+}
+
+static float32 dtouirz(CPUCSKYState *env, float64 x)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float64_to_uint32_round_to_zero(x, &env->cp1.fp_status));
+
+}
+
+static void fdtouirz(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = dtouirz(env, getfloat64(env, src));
+}
+
+static float32 dtouirpi(CPUCSKYState *env, float64 x)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float64_to_uint32_round_to_zero(x,
+                                 &env->cp1.fp_status) + 1);
+    } else {
+        return vfp_itos(float64_to_uint32_round_to_zero(x,
+                                     &env->cp1.fp_status));
+    }
+}
+
+static void fdtouirpi(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = dtouirpi(env, getfloat64(env, src));
+}
+
+static float32 dtouirni(CPUCSKYState *env, float64 x)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float64_to_uint32_round_to_zero(x,
+                                     &env->cp1.fp_status));
+    } else {
+        return vfp_itos(float64_to_uint32_round_to_zero(x,
+                                 &env->cp1.fp_status) - 1);
+    }
+}
+
+static void fdtouirni(CPUCSKYState *env, int dst, int src)
+{
+    env->cp1.fr[dst] = dtouirni(env, getfloat64(env, src));
+}
+
+#define VFP(name, p) (glue(name, p))
+
+#define VFP_BINOP(name) \
+static float32 VFP(name, s)(float32 a, float32 b, CPUCSKYState *env) \
+{ \
+    return float32_ ## name(a, b, &env->cp1.fp_status); \
+} \
+static float64 VFP(name, d)(float64 a, float64 b, CPUCSKYState *env) \
+{ \
+    return float64_ ## name(a, b, &env->cp1.fp_status); \
+}
+VFP_BINOP(add)
+VFP_BINOP(sub)
+VFP_BINOP(mul)
+VFP_BINOP(div)
+#undef VFP_BINOP
+
+static void faddd(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    float64 x = addd(getfloat64(env, src0), getfloat64(env, src1), env);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fadds(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    env->cp1.fr[dst] = adds(env->cp1.fr[src0], env->cp1.fr[src1], env);
+}
+
+static void fsubd(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    float64 x = subd(getfloat64(env, src0), getfloat64(env, src1), env);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fsubs(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    env->cp1.fr[dst] = subs(env->cp1.fr[src0], env->cp1.fr[src1], env);
+}
+
+static void fmuld(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    float64 x = muld(getfloat64(env, src0), getfloat64(env, src1), env);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fmuls(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    env->cp1.fr[dst] = muls(env->cp1.fr[src0], env->cp1.fr[src1], env);
+}
+
+static void fdivd(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    float64 x = divd(getfloat64(env, src0), getfloat64(env, src1), env);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fdivs(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    env->cp1.fr[dst] = divs(env->cp1.fr[src0], env->cp1.fr[src1], env);
+}
+
+static void fmacd(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    float64 x = addd(getfloat64(env, dst), muld(getfloat64(env, src0),
+                                           getfloat64(env, src1), env), env);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fmacs(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    env->cp1.fr[dst] = adds(env->cp1.fr[dst], muls(env->cp1.fr[src0],
+                                        env->cp1.fr[src1], env), env);
+}
+
+static void fmscd(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    float64 x = subd(muld(getfloat64(env, src0), getfloat64(env, src1), env),
+                                            getfloat64(env, dst), env);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fmscs(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    env->cp1.fr[dst] = subs(muls(env->cp1.fr[src0],
+                                 env->cp1.fr[src1], env),
+                                 env->cp1.fr[dst], env);
+}
+
+static void fnmacd(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    float64 x = subd(getfloat64(env, dst), muld(getfloat64(env, src0),
+                                getfloat64(env, src1), env), env);
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fnmacs(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    env->cp1.fr[dst] = subs(env->cp1.fr[dst], muls(env->cp1.fr[src0],
+                                        env->cp1.fr[src1], env), env);
+}
+
+static void fnmscd(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    float64 x = float64_chs(addd(muld(getfloat64(env, src0),
+                                      getfloat64(env, src1), env),
+                                      getfloat64(env, dst), env));
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fnmscs(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    env->cp1.fr[dst] = float32_chs(adds(muls(env->cp1.fr[src0],
+                                             env->cp1.fr[src1], env),
+                                             env->cp1.fr[dst], env));
+}
+
+static void fnmuld(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    float64 x = float64_chs(muld(getfloat64(env, src0),
+                                 getfloat64(env, src1), env));
+    getfloat32lo(dst, x);
+    getfloat32hi(dst, x);
+}
+
+static void fnmuls(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    env->cp1.fr[dst] = float32_chs(muls(env->cp1.fr[src0],
+                                        env->cp1.fr[src1], env));
+}
+
+static void faddm(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    fadds(env, dst, src0, src1);
+    fadds(env, dst + 1, src0 + 1, src1 + 1);
+}
+
+static void fsubm(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    fsubs(env, dst, src0, src1);
+    fsubs(env, dst + 1, src0 + 1, src1 + 1);
+}
+
+static void fmulm(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    fmuls(env, dst, src0, src1);
+    fmuls(env, dst + 1, src0 + 1, src1 + 1);
+}
+
+static void fmacm(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    fmacs(env, dst, src0, src1);
+    fmacs(env, dst + 1, src0 + 1, src1 + 1);
+}
+
+static void fmscm(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    fmscs(env, dst, src0, src1);
+    fmscs(env, dst + 1, src0 + 1, src1 + 1);
+}
+
+static void fnmacm(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    fnmacs(env, dst, src0, src1);
+    fnmacs(env, dst + 1, src0 + 1, src1 + 1);
+}
+
+static void fnmscm(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    fnmscs(env, dst, src0, src1);
+    fnmscs(env, dst + 1, src0 + 1, src1 + 1);
+}
+
+static void fnmulm(CPUCSKYState *env, int dst, int src0, int src1)
+{
+    fnmuls(env, dst, src0, src1);
+    fnmuls(env, dst + 1, src0 + 1, src1 + 1);
+}
+
+void helper_cpwir(CPUCSKYState *env)
+{
+    unsigned int insn, op1, op2, op3, src0, src1, dst, round_mode;
+
+    insn = env->cp1.fir;
+    op1 = (insn >> 15) & 0x3f;
+    op2 = (insn >> 10) & 0x1f;
+    op3 = (insn >> 5)  & 0x1f;
+
+    switch (op1) {
+    case 0x0:
+        switch (op2) {
+        case 0x1:
+            src0 = insn & 0x1f;
+            switch (op3) {
+            case 0x0:/* fcmpzhsd */
+                fcmpzhsd(env, src0);
+                break;
+            case 0x4:/* fcmpzltd */
+                fcmpzltd(env, src0);
+                break;
+            case 0x8:/* fcmpzned */
+                fcmpzned(env, src0);
+                break;
+            case 0xc:/* fcmpzuod */
+                fcmpzuod(env, src0);
+                break;
+            case 0x10:/* fcmpzhss */
+                fcmpzhss(env, src0);
+                break;
+            case 0x14:/* fcmpzlts */
+                fcmpzlts(env, src0);
+                break;
+            case 0x18:/* fcmpznes */
+                fcmpznes(env, src0);
+                break;
+            case 0x1c:/* fcmpzuos */
+                fcmpzuos(env, src0);
+                break;
+            default:
+                goto wrong;
+                break;
+            }
+            break;
+        case 0x2:/* fcmphsd */
+            src0 = insn & 0x1f;
+            src1 = (insn >> 5) & 0x1f;
+            fcmphsd(env, src0, src1);
+            break;
+        case 0x3:/* fcmpltd */
+            src0 = insn & 0x1f;
+            src1 = (insn >> 5) & 0x1f;
+            fcmpltd(env, src0, src1);
+            break;
+        case 0x4:/* fcmpned */
+            src0 = insn & 0x1f;
+            src1 = (insn >> 5) & 0x1f;
+            fcmpned(env, src0, src1);
+            break;
+        case 0x5:/* fcmpuod */
+            src0 = insn & 0x1f;
+            src1 = (insn >> 5) & 0x1f;
+            fcmpuod(env, src0, src1);
+            break;
+        case 0x6:/* fcmphss */
+            src0 = insn & 0x1f;
+            src1 = (insn >> 5) & 0x1f;
+            fcmphss(env, src0, src1);
+            break;
+        case 0x7:/* fcmplts */
+            src0 = insn & 0x1f;
+            src1 = (insn >> 5) & 0x1f;
+            fcmplts(env, src0, src1);
+            break;
+        case 0x8:/* fcmpnes */
+            src0 = insn & 0x1f;
+            src1 = (insn >> 5) & 0x1f;
+            fcmpnes(env, src0, src1);
+            break;
+        case 0x9:/* fcmpuos */
+            src0 = insn & 0x1f;
+            src1 = (insn >> 5) & 0x1f;
+            fcmpuos(env, src0, src1);
+            break;
+        case 0xa:/* fstod */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fstod(env, dst, src0);
+            break;
+        case 0xb:/* fdtos */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fdtos(env, dst, src0);
+            break;
+        case 0xc:/* fsitod */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fsitod(env, dst, src0);
+            break;
+        case 0xd:/* fsitos */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fsitos(env, dst, src0);
+            break;
+        case 0xe:/* fuitod */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fuitod(env, dst, src0);
+            break;
+        case 0xf:/* fuitos */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fuitos(env, dst, src0);
+            break;
+        case 0x10:/* fabsd */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fabsd(env, dst, src0);
+            break;
+        case 0x11:/* fabss */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fabss(env, dst, src0);
+            break;
+        case 0x12:/* fnegd */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fnegd(env, dst, src0);
+            break;
+        case 0x13:/* fnegs */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fnegs(env, dst, src0);
+            break;
+        case 0x14:/* fsqrtd */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fsqrtd(env, dst, src0);
+            break;
+        case 0x15:/* fsqrts */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fsqrts(env, dst, src0);
+            break;
+        case 0x16:/* frecipd */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            frecipd(env, dst, src0);
+            break;
+        case 0x17:/* frecips */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            frecips(env, dst, src0);
+            break;
+        case 0x18:/* fabsm */
+            src0 = insn & 0x1e;
+            dst = (insn >> 5) & 0x1e;
+            fabsm(env, dst, src0);
+            break;
+        case 0x19:/* fnegm */
+            src0 = insn & 0x1e;
+            dst = (insn >> 5) & 0x1e;
+            fnegm(env, dst, src0);
+            break;
+        case 0x1a:/* fmovd */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fmovd(env, dst, src0);
+            break;
+        case 0x1b:/* fmovs */
+            src0 = insn & 0x1f;
+            dst = (insn >> 5) & 0x1f;
+            fmovs(env, dst, src0);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case 0x1:/* fdtosi */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        round_mode = (insn >> 13) & 0x3;
+        switch (round_mode) {
+        case 0x0:
+            fdtosirn(env, dst, src0);
+            break;
+        case 0x1:
+            fdtosirz(env, dst, src0);
+            break;
+        case 0x2:
+            fdtosirpi(env, dst, src0);
+            break;
+        case 0x3:
+            fdtosirni(env, dst, src0);
+            break;
+        }
+        break;
+    case 0x2:/* fstosi */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        round_mode = (insn >> 13) & 0x3;
+        switch (round_mode) {
+        case 0x0:
+            fstosirn(env, dst, src0);
+            break;
+        case 0x1:
+            fstosirz(env, dst, src0);
+            break;
+        case 0x2:
+            fstosirpi(env, dst, src0);
+            break;
+        case 0x3:
+            fstosirni(env, dst, src0);
+            break;
+        }
+        break;
+    case 0x3:/* fdtoui */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        round_mode = (insn >> 13) & 0x3;
+        switch (round_mode) {
+        case 0x0:
+            fdtouirn(env, dst, src0);
+            break;
+        case 0x1:
+            fdtouirz(env, dst, src0);
+            break;
+        case 0x2:
+            fdtouirpi(env, dst, src0);
+            break;
+        case 0x3:
+            fdtouirni(env, dst, src0);
+            break;
+        }
+        break;
+    case 0x4:/* fstoui */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        round_mode = (insn >> 13) & 0x3;
+        switch (round_mode) {
+        case 0x0:
+            fstouirn(env, dst, src0);
+            break;
+        case 0x1:
+            fstouirz(env, dst, src0);
+            break;
+        case 0x2:
+            fstouirpi(env, dst, src0);
+            break;
+        case 0x3:
+            fstouirni(env, dst, src0);
+            break;
+        }
+        break;
+    case 0x6:/* faddd */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        faddd(env, dst, src0, src1);
+        break;
+    case 0x7:/* fadds */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fadds(env, dst, src0, src1);
+        break;
+    case 0x8:/* fsubd */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fsubd(env, dst, src0, src1);
+        break;
+    case 0x9:/* fsubs */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fsubs(env, dst, src0, src1);
+        break;
+    case 0xa:/* fmacd */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fmacd(env, dst, src0, src1);
+        break;
+    case 0xb:/* fmacs */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fmacs(env, dst, src0, src1);
+        break;
+    case 0xc:/* fmscd */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fmscd(env, dst, src0, src1);
+        break;
+    case 0xd:/* fmscs */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fmscs(env, dst, src0, src1);
+        break;
+    case 0xe:/* fmuld */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fmuld(env, dst, src0, src1);
+        break;
+    case 0xf:/* fmuls */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fmuls(env, dst, src0, src1);
+        break;
+    case 0x10:/* fdivd */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fdivd(env, dst, src0, src1);
+        break;
+    case 0x11:/* fdivs */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fdivs(env, dst, src0, src1);
+        break;
+    case 0x12:/* fnmacd */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fnmacd(env, dst, src0, src1);
+        break;
+    case 0x13:/* fnmacs */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fnmacs(env, dst, src0, src1);
+        break;
+    case 0x14:/* fnmscd */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fnmscd(env, dst, src0, src1);
+        break;
+    case 0x15:/* fnmscs */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fnmscs(env, dst, src0, src1);
+        break;
+    case 0x16:/* fnmuld */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fnmuld(env, dst, src0, src1);
+        break;
+    case 0x17:/* fnmuls */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1f;
+        src1 = (insn >> 10) & 0x1f;
+        fnmuls(env, dst, src0, src1);
+        break;
+    case 0x18:/* faddm */
+        src0 = insn & 0x1e;
+        dst = (insn >> 5) & 0x1e;
+        src1 = (insn >> 10) & 0x1e;
+        faddm(env, dst, src0, src1);
+        break;
+    case 0x19:/* fsubm */
+        src0 = insn & 0x1f;
+        dst = (insn >> 5) & 0x1e;
+        src1 = (insn >> 10) & 0x1e;
+        fsubm(env, dst, src0, src1);
+        break;
+    case 0x1a:/* fmulm */
+        src0 = insn & 0x1e;
+        dst = (insn >> 5) & 0x1e;
+        src1 = (insn >> 10) & 0x1e;
+        fmulm(env, dst, src0, src1);
+        break;
+    case 0x1b:/* fmacm */
+        src0 = insn & 0x1e;
+        dst = (insn >> 5) & 0x1e;
+        src1 = (insn >> 10) & 0x1e;
+        fmacm(env, dst, src0, src1);
+        break;
+    case 0x1c:/* fmscm */
+        src0 = insn & 0x1e;
+        dst = (insn >> 5) & 0x1e;
+        src1 = (insn >> 10) & 0x1e;
+        fmscm(env, dst, src0, src1);
+        break;
+    case 0x1d:/* fnmacm */
+        src0 = insn & 0x1e;
+        dst = (insn >> 5) & 0x1e;
+        src1 = (insn >> 10) & 0x1e;
+        fnmacm(env, dst, src0, src1);
+        break;
+    case 0x1e:/* fnmscm */
+        src0 = insn & 0x1e;
+        dst = (insn >> 5) & 0x1e;
+        src1 = (insn >> 10) & 0x1e;
+        fnmscm(env, dst, src0, src1);
+        break;
+    case 0x1f:/* fnmulm */
+        src0 = insn & 0x1e;
+        dst = (insn >> 5) & 0x1e;
+        src1 = (insn >> 10) & 0x1e;
+        fnmulm(env, dst, src0, src1);
+        break;
+    default:
+        wrong:  printf("wrong fpu insn: %d", insn);
+        break;
+    }
+
+}
+
+#if !defined(CONFIG_USER_ONLY)
+uint32_t helper_mfcr_cr0(CPUCSKYState *env)
+{
+    env->cp0.psr &= ~0x8000c001;
+    env->cp0.psr |= env->psr_s << 31;
+    env->cp0.psr |= env->psr_c;
+    env->cp0.psr |= env->psr_tm << 14;
+
+    return env->cp0.psr;
+}
+
+uint32_t helper_mfcr_cr20(CPUCSKYState *env)
+{
+    return env->cp0.pacr[env->cp0.prsr & 0x7];
+}
+
+void helper_mtcr_cr0(CPUCSKYState *env, uint32_t rx)
+{
+    if ((env->cp0.psr & 0x2) != (rx & 0x2)) {
+        helper_switch_regs(env);
+    }
+    env->cp0.psr = rx;
+    env->psr_s = PSR_S(rx);
+    env->psr_c = PSR_C(rx);
+    env->psr_tm = PSR_TM(rx);
+}
+
+void helper_mtcr_cr18(CPUCSKYState *env, uint32_t rx)
+{
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+    if ((env->cp0.ccr & 0x1) != (rx & 0x1)) {
+        /* flush global QEMU TLB and tb_jmp_cache */
+        tlb_flush(cs, 1);
+
+        if (rx & 0x1) { /* for mmu/mgu */
+            if (env->features & CSKY_MMU) {
+                env->tlb_context->get_physical_address =
+                                mmu_get_physical_address;
+            } else if (env->features & CSKY_MGU) {
+                env->tlb_context->get_physical_address =
+                                mgu_get_physical_address;
+            }
+        } else {
+            env->tlb_context->get_physical_address =
+                          nommu_get_physical_address;
+        }
+
+    }
+
+    env->cp0.ccr = rx;
+}
+
+void helper_mtcr_cr20(CPUCSKYState *env, uint32_t rx)
+{
+    env->cp0.pacr[env->cp0.prsr & 0x7] = rx;
+}
+
+void helper_meh_write(CPUCSKYState *env, uint32_t rx)
+{
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+    /* if ASID is Changed, QEMU TLB must be flush */
+    if ((env->mmu.meh & 0xff) != (rx & 0xff)) {
+        tlb_flush(cs, 1);
+    }
+
+    env->mmu.meh = rx;
+}
+
+void helper_mcir_write(CPUCSKYState *env, uint32_t rx)
+{
+    /* Note: when more than one of the most significant
+       bits are asserted at the same time, these operations
+       are implemented according to the priority as follows:
+           Tlb invalid all operation
+           Tlb invalid operation
+           Tlb probe operation
+           Tlb writing index operation
+           Tlb writing random operation
+           Tlb reading operation
+    */
+
+    if (rx & CSKY_MCIR_TLBINV_MASK) {
+        helper_tlbinv(env);
+    } else if (rx & CSKY_MCIR_TLBP_MASK) {
+        env->tlb_context->helper_tlbp(env);
+    } else if (rx & CSKY_MCIR_TLBWI_MASK) {
+        env->tlb_context->helper_tlbwi(env);
+    } else if (rx & CSKY_MCIR_TLBWR_MASK) {
+        env->tlb_context->helper_tlbwr(env);
+    } else if (rx & CSKY_MCIR_TLBR_MASK) {
+        env->tlb_context->helper_tlbr(env);
+    }
+}
+
+#endif
+
diff --git a/target-csky/op_helper_v2.c b/target-csky/op_helper_v2.c
new file mode 100644
index 0000000..73ae76a
--- /dev/null
+++ b/target-csky/op_helper_v2.c
@@ -0,0 +1,1226 @@
+/*
+ *  CSKY helper routines
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "cpu.h"
+#include "translate.h"
+#include "exec/helper-proto.h"
+#include "exec/cpu_ldst.h"
+#include "exec/exec-all.h"
+
+void helper_exception(CPUCSKYState *env, uint32_t excp)
+{
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+    cs->exception_index = excp;
+    cpu_loop_exit(cs);
+}
+
+void helper_tb_trace(CPUCSKYState *env, uint32_t tb_pc)
+{
+    int trace_index = env->trace_index % TB_TRACE_NUM;
+    env->trace_info[trace_index].tb_pc = tb_pc;
+    env->trace_index++;
+    qemu_log_mask(CPU_TB_TRACE, "0x%.8x\n", tb_pc);
+}
+
+#ifdef CONFIG_USER_ONLY
+extern long long total_jcount;
+void helper_jcount(CPUCSKYState *env, uint32_t tb_pc, uint32_t icount)
+{
+    if ((tb_pc >= env->jcount_start) && (tb_pc < env->jcount_end)) {
+        total_jcount += icount;
+    }
+}
+#else
+void helper_jcount(CPUCSKYState *env, uint32_t tb_pc, uint32_t icount)
+{
+}
+#endif
+
+uint32_t helper_xsr(CPUCSKYState *env, uint32_t a, uint32_t b)
+{
+     uint64_t t0, t1;
+     uint32_t n0, n1;
+
+     t0 = a;
+     t1 = t0 << 32 | env->psr_c << 31;
+     t1 >>= b;
+     n0 = t1 & 0xffffffff;
+     n1 = (t1 >> 32) & 0xffffffff;
+     env->psr_c = (n0 >> 31) & 0x1;
+     return (n0 << 1) | n1;
+}
+
+uint32_t helper_brev(uint32_t a)
+{
+    uint32_t r = 0;
+    char  i;
+    for (i = 0; i < 32; i++) {
+        r |= (a & 0x1) << (31 - i);
+        a >>= 1;
+    }
+    return r;
+}
+
+uint32_t helper_ff1(uint32_t a)
+{
+    if (a == 0) {
+        return 32;
+    } else {
+        return __builtin_clz(a);
+    }
+}
+
+uint32_t helper_ff0(uint32_t a)
+{
+    a =  ~a;
+    if (a == 0) {
+        return 32;
+    } else {
+        return __builtin_clz(a);
+    }
+}
+
+/* VFP support.  We follow the convention used for VFP instrunctions:
+   Single precition routines have a "s" suffix, double precision a
+   "d" suffix.  */
+
+void HELPER(vfp_update_fcr)(CPUCSKYState *env)
+{
+    if ((env->vfp.fcr >> 27) & 0x1) {
+        env->vfp.fp_status.flush_inputs_to_zero = 0;
+    } else {
+        env->vfp.fp_status.flush_inputs_to_zero = 1;
+    }
+    switch ((env->vfp.fcr >> 24) & 0x3) {
+    case 0:
+        env->vfp.fp_status.float_rounding_mode = float_round_nearest_even;
+        break;
+    case 1:
+        env->vfp.fp_status.float_rounding_mode = float_round_to_zero;
+        break;
+    case 2:
+        env->vfp.fp_status.float_rounding_mode = float_round_up;
+        break;
+    case 3:
+        env->vfp.fp_status.float_rounding_mode = float_round_down;
+        break;
+    default:
+        break;
+    }
+}
+
+void HELPER(vfp_check_exception)(CPUCSKYState *env)
+{
+    env->vfp.fesr &= 0xffffff00;
+    if (env->vfp.fp_status.float_exception_flags & float_flag_invalid) {
+        if (env->vfp.fcr & 0x1) {
+            env->vfp.fesr |= 0x81;
+        } else {
+            env->vfp.fesr |= 0x8181;
+            /* FIXME: if IOE(FCR[0]) = 0, return qNaN
+             * or Special Value to dest register. */
+        }
+    }
+    if (env->vfp.fp_status.float_exception_flags & float_flag_divbyzero) {
+        if (env->vfp.fcr & 0x2) {
+            env->vfp.fesr |= 0x82;
+        } else {
+            env->vfp.fesr |= 0x8282;
+            /* FIXME: return a signed INF to dest register. */
+        }
+    }
+    if (env->vfp.fp_status.float_exception_flags & float_flag_overflow) {
+        if (env->vfp.fcr & 0x4) {
+            env->vfp.fesr |= 0x94;
+        } else {
+            env->vfp.fesr |= 0x9494;
+            /* FIXME: According to RM(fcr[25:24]), roundoff the result. */
+        }
+    }
+    if (env->vfp.fp_status.float_exception_flags & float_flag_underflow) {
+        if (env->vfp.fcr & 0x8) {
+            env->vfp.fesr |= 0x98;
+        } else {
+            env->vfp.fesr |= 0x9898;
+            /* FIXME: According to FM(fcr[27]), return zero or
+             * Minimum finite Number to dest register. */
+        }
+    }
+    if (env->vfp.fp_status.float_exception_flags & float_flag_inexact) {
+        if (env->vfp.fcr & 0x10) {
+            env->vfp.fesr |= 0x90;
+        } else {
+            env->vfp.fesr |= 0x9090;
+            /* FIXME: According to RM(fcr[25:24]), return a signed INF or
+             * Maximum finite Number to dest register. */
+        }
+    }
+    if (env->vfp.fp_status.float_exception_flags & float_flag_input_denormal) {
+        if (env->vfp.fcr & 0x20) {
+            env->vfp.fesr |= 0xa0;
+        } else {
+            env->vfp.fesr |= 0xa0a0;
+            /* FIXME: According to FM(fcr[27]), flush the denormalized number
+             * to Minimum finite Number or zero, do the instruction again. */
+        }
+    }
+    env->vfp.fp_status.float_exception_flags = 0;
+    /* if exception is enable, throw an exception. */
+    if ((env->vfp.fcr & env->vfp.fesr) & 0x3f) {
+        helper_exception(env, EXCP_CSKY_FLOAT);
+    }
+}
+
+#define VFP_HELPER(name, p) HELPER(glue(glue(vfp_, name), p))
+
+float32 VFP_HELPER(add, s)(float32 a, float32 b, CPUCSKYState *env)
+{
+    return float32_add(a, b , &env->vfp.fp_status);
+}
+
+float64 VFP_HELPER(add, d)(float64 a, float64 b, CPUCSKYState *env)
+{
+    return float64_add(a, b , &env->vfp.fp_status);
+}
+
+float32 VFP_HELPER(sub, s)(float32 a, float32 b, CPUCSKYState *env)
+{
+    return float32_sub(a, b , &env->vfp.fp_status);
+}
+
+float64 VFP_HELPER(sub, d)(float64 a, float64 b, CPUCSKYState *env)
+{
+    return float64_sub(a, b , &env->vfp.fp_status);
+}
+
+float32 VFP_HELPER(mul, s)(float32 a, float32 b, CPUCSKYState *env)
+{
+    return float32_mul(a, b , &env->vfp.fp_status);
+}
+
+float64 VFP_HELPER(mul, d)(float64 a, float64 b, CPUCSKYState *env)
+{
+    return float64_mul(a, b , &env->vfp.fp_status);
+}
+
+
+float32 VFP_HELPER(div, s)(float32 a, float32 b, CPUCSKYState *env)
+{
+    return float32_div(a, b , &env->vfp.fp_status);
+}
+
+float64 VFP_HELPER(div, d)(float64 a, float64 b, CPUCSKYState *env)
+{
+    return float64_div(a, b , &env->vfp.fp_status);
+}
+
+float32 VFP_HELPER(neg, s)(float32 a)
+{
+    return float32_chs(a);
+}
+
+float64 VFP_HELPER(neg, d)(float64 a)
+{
+    return float64_chs(a);
+}
+
+float32 VFP_HELPER(abs, s)(float32 a)
+{
+    return float32_abs(a);
+}
+
+float64 VFP_HELPER(abs, d)(float64 a)
+{
+    return float64_abs(a);
+}
+
+float32 VFP_HELPER(sqrt, s)(float32 a, CPUCSKYState *env)
+{
+    return float32_sqrt(a, &env->vfp.fp_status);
+}
+
+float64 VFP_HELPER(sqrt, d)(float64 a, CPUCSKYState *env)
+{
+    return float64_sqrt(a, &env->vfp.fp_status);
+}
+
+float32 VFP_HELPER(recip, s)(float32 a, CPUCSKYState *env)
+{
+    float_status *s = &env->vfp.fp_status;
+    float32 one = int32_to_float32(1, s);
+    return float32_div(one, a, s);
+}
+
+float64 VFP_HELPER(recip, d)(float64 a, CPUCSKYState *env)
+{
+    float_status *s = &env->vfp.fp_status;
+    float64 one = int32_to_float64(1, s);
+    return float64_div(one, a, s);
+}
+
+void VFP_HELPER(cmp_ge, s)(float32 a, float32 b, CPUCSKYState *env)
+{
+    switch (float32_compare(a, b, &env->vfp.fp_status)) {
+    case 0:
+        env->psr_c = 1;
+        break;
+    case -1:
+        env->psr_c = 0;
+        break;
+    case 1:
+        env->psr_c = 1;
+        break;
+    case 2:
+    default:
+        env->psr_c = 0;
+        break;
+    }
+}
+
+void VFP_HELPER(cmp_ge, d)(float64 a, float64 b, CPUCSKYState *env)
+{
+    switch (float64_compare(a, b, &env->vfp.fp_status)) {
+    case 0:
+        env->psr_c = 1;
+        break;
+    case -1:
+        env->psr_c = 0;
+        break;
+    case 1:
+        env->psr_c = 1;
+        break;
+    case 2:
+    default:
+        env->psr_c = 0;
+        break;
+    }
+}
+
+void VFP_HELPER(cmp_l, s)(float32 a, float32 b, CPUCSKYState *env)
+{
+    switch (float32_compare(a, b, &env->vfp.fp_status)) {
+    case 0:
+        env->psr_c = 0;
+        break;
+    case -1:
+        env->psr_c = 1;
+        break;
+    case 1:
+        env->psr_c = 0;
+        break;
+    case 2:
+    default:
+        env->psr_c = 0;
+        break;
+    }
+}
+
+void VFP_HELPER(cmp_l, d)(float64 a, float64 b, CPUCSKYState *env)
+{
+    switch (float64_compare(a, b, &env->vfp.fp_status)) {
+    case 0:
+        env->psr_c = 0;
+        break;
+    case -1:
+        env->psr_c = 1;
+        break;
+    case 1:
+        env->psr_c = 0;
+        break;
+    case 2:
+    default:
+        env->psr_c = 0;
+        break;
+    }
+}
+
+void VFP_HELPER(cmp_ls, s)(float32 a, float32 b, CPUCSKYState *env)
+{
+    switch (float32_compare(a, b, &env->vfp.fp_status)) {
+    case 0:
+        env->psr_c = 1;
+        break;
+    case -1:
+        env->psr_c = 1;
+        break;
+    case 1:
+        env->psr_c = 0;
+        break;
+    case 2:
+    default:
+        env->psr_c = 0;
+        break;
+    }
+}
+
+void VFP_HELPER(cmp_ls, d)(float64 a, float64 b, CPUCSKYState *env)
+{
+    switch (float64_compare(a, b, &env->vfp.fp_status)) {
+    case 0:
+        env->psr_c = 1;
+        break;
+    case -1:
+        env->psr_c = 1;
+        break;
+    case 1:
+        env->psr_c = 0;
+        break;
+    case 2:
+    default:
+        env->psr_c = 0;
+        break;
+    }
+}
+
+void VFP_HELPER(cmp_ne, s)(float32 a, float32 b, CPUCSKYState *env)
+{
+    switch (float32_compare(a, b, &env->vfp.fp_status)) {
+    case 0:
+        env->psr_c = 0;
+        break;
+    case -1:
+        env->psr_c = 1;
+        break;
+    case 1:
+        env->psr_c = 1;
+        break;
+    case 2:
+    default:
+        env->psr_c = 1;
+        break;
+    }
+}
+
+void VFP_HELPER(cmp_ne, d)(float64 a, float64 b, CPUCSKYState *env)
+{
+    switch (float64_compare(a, b, &env->vfp.fp_status)) {
+    case 0:
+        env->psr_c = 0;
+        break;
+    case -1:
+        env->psr_c = 1;
+        break;
+    case 1:
+        env->psr_c = 1;
+        break;
+    case 2:
+    default:
+        env->psr_c = 1;
+        break;
+    }
+}
+
+
+void VFP_HELPER(cmp_isNAN, s)(float32 a, float32 b, CPUCSKYState *env)
+{
+    switch (float32_compare(a, b, &env->vfp.fp_status)) {
+    case 0:
+        env->psr_c = 0;
+        break;
+    case -1:
+        env->psr_c = 0;
+        break;
+    case 1:
+        env->psr_c = 0;
+        break;
+    case 2:
+    default:
+        env->psr_c = 1;
+        break;
+    }
+}
+
+void VFP_HELPER(cmp_isNAN, d)(float64 a,  float64 b, CPUCSKYState *env)
+{
+    switch (float64_compare(a, b, &env->vfp.fp_status)) {
+    case 0:
+        env->psr_c = 0;
+        break;
+    case -1:
+        env->psr_c = 0;
+        break;
+    case 1:
+        env->psr_c = 0;
+        break;
+    case 2:
+    default:
+        env->psr_c = 1;
+        break;
+    }
+}
+
+
+/* Helper routines to perform bitwise copies between float and int.  */
+static inline float32 vfp_itos(uint32_t i)
+{
+    union {
+        uint32_t i;
+        float32 s;
+    } v;
+
+    v.i = i;
+    return v.s;
+}
+
+static inline uint32_t vfp_stoi(float32 s)
+{
+    union {
+        uint32_t i;
+        float32 s;
+    } v;
+
+    v.s = s;
+    return v.i;
+}
+
+float32 VFP_HELPER(fmovi, s)(uint32_t imm, uint32_t pos, uint32_t aSign,
+                              CPUCSKYState *env)
+{
+    int32_t a;
+    uint32_t aSig, aExp;
+    if (aSign == 0) {
+        a = imm;
+    } else {
+        a = ~imm + 1;
+    }
+
+    float32 tmp = int32_to_float32(a, &env->vfp.fp_status);
+    aSig = float32_val(tmp) & 0x007FFFFF;
+    aExp = ((float32_val(tmp) >> 23) & 0xFF) - pos;
+    return (aSign << 31) | aSig | (aExp << 23);
+}
+
+float64 VFP_HELPER(fmovi, d)(uint32_t imm, uint32_t pos, uint32_t aSign,
+                              CPUCSKYState *env)
+{
+    int64_t a;
+    uint64_t aSig, aExp;
+    if (aSign == 0) {
+        a = imm;
+    } else {
+        a = ~imm + 1;
+    }
+
+    float64 tmp = int32_to_float64(a, &env->vfp.fp_status);
+    aSig = float64_val(tmp) & 0x000FFFFFFFFFFFFF;
+    aExp = ((float64_val(tmp) >> 52) & 0x7FF) - pos;
+    return ((uint64_t)aSign << 63) | aSig | (aExp << 52);
+}
+
+float32 VFP_HELPER(tosirn, s)(float32 x, CPUCSKYState *env)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float32_to_int32(x, &env->vfp.fp_status));
+}
+
+float32 VFP_HELPER(tosirz, s)(float32 x, CPUCSKYState *env)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float32_to_int32_round_to_zero(x, &env->vfp.fp_status));
+}
+
+float32 VFP_HELPER(tosirpi, s)(float32 x, CPUCSKYState *env)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float32_to_int32_round_to_zero
+                        (x, &env->vfp.fp_status) + 1);
+    } else {
+        return vfp_itos(float32_to_int32_round_to_zero(x, &env->vfp.fp_status));
+    }
+}
+
+float32 VFP_HELPER(tosirni, s)(float32 x, CPUCSKYState *env)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float32_to_int32_round_to_zero(x, &env->vfp.fp_status));
+    } else {
+        return vfp_itos(float32_to_int32_round_to_zero
+                        (x, &env->vfp.fp_status) - 1);
+    }
+}
+
+float32 VFP_HELPER(tosirn, d)(float64 x, CPUCSKYState *env)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float64_to_int32(x, &env->vfp.fp_status));
+}
+
+float32 VFP_HELPER(tosirz, d)(float64 x, CPUCSKYState *env)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float64_to_int32_round_to_zero(x, &env->vfp.fp_status));
+}
+
+float32 VFP_HELPER(tosirpi, d)(float64 x, CPUCSKYState *env)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float64_to_int32_round_to_zero
+                        (x, &env->vfp.fp_status) + 1);
+    } else {
+        return vfp_itos(float64_to_int32_round_to_zero(x, &env->vfp.fp_status));
+    }
+}
+
+float32 VFP_HELPER(tosirni, d)(float64 x, CPUCSKYState *env)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float64_to_int32_round_to_zero
+                        (x, &env->vfp.fp_status));
+    } else {
+        return vfp_itos(float64_to_int32_round_to_zero
+                        (x, &env->vfp.fp_status) - 1);
+    }
+}
+
+
+float32 VFP_HELPER(touirn, s)(float32 x, CPUCSKYState *env)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float32_to_uint32(x, &env->vfp.fp_status));
+}
+
+float32 VFP_HELPER(touirz, s)(float32 x, CPUCSKYState *env)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    return vfp_itos(float32_to_uint32_round_to_zero(x, &env->vfp.fp_status));
+}
+
+float32 VFP_HELPER(touirpi, s)(float32 x, CPUCSKYState *env)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float32_to_uint32_round_to_zero
+                        (x, &env->vfp.fp_status) + 1);
+    } else {
+        return vfp_itos(float32_to_uint32_round_to_zero
+                        (x, &env->vfp.fp_status));
+    }
+}
+
+float32 VFP_HELPER(touirni, s)(float32 x, CPUCSKYState *env)
+{
+    if (float32_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float32_to_uint32_round_to_zero
+                        (x, &env->vfp.fp_status));
+    } else {
+        return vfp_itos(float32_to_uint32_round_to_zero
+                        (x, &env->vfp.fp_status) - 1);
+    }
+}
+
+float32 VFP_HELPER(touirn, d)(float64 x, CPUCSKYState *env)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+
+    return vfp_itos(float64_to_uint32(x, &env->vfp.fp_status));
+}
+
+float32 VFP_HELPER(touirz, d)(float64 x, CPUCSKYState *env)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+
+    return vfp_itos(float64_to_uint32_round_to_zero(x, &env->vfp.fp_status));
+}
+
+float32 VFP_HELPER(touirpi, d)(float64 x, CPUCSKYState *env)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float64_to_uint32_round_to_zero
+                        (x, &env->vfp.fp_status) + 1);
+    } else {
+        return vfp_itos(float64_to_uint32_round_to_zero
+                        (x, &env->vfp.fp_status));
+    }
+}
+
+float32 VFP_HELPER(touirni, d)(float64 x, CPUCSKYState *env)
+{
+    if (float64_is_any_nan(x)) {
+        return float32_zero;
+    }
+    if (x > 0) {
+        return vfp_itos(float64_to_uint32_round_to_zero
+                        (x, &env->vfp.fp_status));
+    } else {
+        return vfp_itos(float64_to_uint32_round_to_zero
+                        (x, &env->vfp.fp_status) - 1);
+    }
+}
+
+
+
+/* Integer to float conversion.  */
+float32 VFP_HELPER(uito, s)(float32 x, CPUCSKYState *env)
+{
+    return uint32_to_float32(vfp_stoi(x), &env->vfp.fp_status);
+}
+
+float64 VFP_HELPER(uito, d)(float32 x, CPUCSKYState *env)
+{
+    return uint32_to_float64(vfp_stoi(x), &env->vfp.fp_status);
+}
+
+float32 VFP_HELPER(sito, s)(float32 x, CPUCSKYState *env)
+{
+    return int32_to_float32(vfp_stoi(x), &env->vfp.fp_status);
+}
+
+float64 VFP_HELPER(sito, d)(float32 x, CPUCSKYState *env)
+{
+    return int32_to_float64(vfp_stoi(x), &env->vfp.fp_status);
+}
+
+
+
+/* floating point conversion */
+float64 VFP_HELPER(tod, s)(float32 x, CPUCSKYState *env)
+{
+    float64 r = float32_to_float64(x, &env->vfp.fp_status);
+    /* ARM requires that S<->D conversion of any kind of NaN generates
+     * a quiet NaN by forcing the most significant frac bit to 1.
+     */
+    return float64_maybe_silence_nan(r, &env->vfp.fp_status);
+}
+
+float32 VFP_HELPER(tos, d)(float64 x, CPUCSKYState *env)
+{
+    float32 r =  float64_to_float32(x, &env->vfp.fp_status);
+    /* ARM requires that S<->D conversion of any kind of NaN generates
+     * a quiet NaN by forcing the most significant frac bit to 1.
+     */
+    return float32_maybe_silence_nan(r, &env->vfp.fp_status);
+}
+
+void VDSP_HELPER(store)(uint32_t rz, uint64_t tmp1, CPUCSKYState *env)
+{
+    env->vfp.reg[rz].udspl[0] = tmp1;
+}
+
+void VDSP_HELPER(store2)(uint32_t rz, uint64_t tmp1, uint64_t tmp2,
+                         CPUCSKYState *env)
+{
+    env->vfp.reg[rz].udspl[0] = tmp1;
+    env->vfp.reg[rz].udspl[1] = tmp2;
+}
+
+#ifndef CONFIG_USER_ONLY
+uint32_t helper_mfcr_cr0(CPUCSKYState *env)
+{
+    helper_update_psr(env);
+    return env->cp0.psr;
+}
+
+void helper_mtcr_cr0(CPUCSKYState *env, uint32_t rx)
+{
+    if (!(env->features & ABIV2_JAVA)) {
+        rx &= ~0x400;
+    }
+
+    helper_save_sp(env);
+    if (env->features & ABIV2_TEE) {
+        helper_tee_save_cr(env);
+        /* save psr */
+        if (env->psr_t) {
+            env->tee.t_psr = env->cp0.psr;
+        } else {
+            env->tee.nt_psr = env->cp0.psr;
+        }
+
+        env->cp0.psr = rx;
+        helper_record_psr_bits(env);
+        helper_tee_choose_cr(env);
+    } else {
+        env->cp0.psr = rx;
+        helper_record_psr_bits(env);
+    }
+
+    if ((env->cp0.psr & 0x2) != (rx & 0x2)) {
+        if (env->features & (CPU_610 | CPU_807 | CPU_810)) {
+            helper_switch_regs(env);
+        } else {
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "Only CK610 CK807 CK810 have alternative registers");
+        }
+    }
+    helper_choose_sp(env);
+}
+
+void helper_mtcr_cr14(CPUCSKYState *env, uint32_t rx)
+{
+    env->stackpoint.nt_usp = rx;
+}
+
+uint32_t helper_mfcr_cr14(CPUCSKYState *env)
+{
+    return env->stackpoint.nt_usp;
+}
+
+void helper_mtcr_cr17(CPUCSKYState *env, uint32_t rx)
+{
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+    env->cp0.cfr = rx;
+
+    /* Invaild inst cache */
+    if ((rx & 0x1) && (rx & 0x10)) {
+        tb_flush(cs);
+        cpu_loop_exit(cs);
+    }
+}
+
+void helper_mtcr_cr18(CPUCSKYState *env, uint32_t rx)
+{
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+
+    if ((env->cp0.ccr & 0x1) != (rx & 0x1)) {
+        /* flush global QEMU TLB and tb_jmp_cache */
+        tlb_flush(cs, 1);
+
+        if (rx & 0x1) {  /* enable mmu/mgu */
+            if (env->features & CSKY_MMU)  {
+                env->tlb_context->get_physical_address =
+                    mmu_get_physical_address;
+            } else {
+                env->tlb_context->get_physical_address =
+                    mgu_get_physical_address;
+            }
+        } else {
+            env->tlb_context->get_physical_address = nommu_get_physical_address;
+        }
+    }
+
+    env->cp0.ccr = rx;
+}
+
+void helper_psrclr(CPUCSKYState *env, uint32_t imm)
+{
+    /* AF bit */
+    if ((imm & 0x1)  && (env->cp0.psr & 0x2)) {
+        env->cp0.psr &= ~0x2;
+        helper_switch_regs(env);
+    }
+    /* FE bit */
+    if (imm & 0x2) {
+        env->cp0.psr &= ~0x10;
+    }
+    /* IE bit */
+    if (imm & 0x4) {
+        env->cp0.psr &= ~0x40;
+    }
+    /* EE bit */
+    if (imm & 0x8) {
+        env->cp0.psr &= ~0x100;
+    }
+}
+
+
+void helper_psrset(CPUCSKYState *env, uint32_t imm)
+{
+    /* AF bit */
+    if ((imm & 0x1) && !(env->cp0.psr & 0x2)) {
+        env->cp0.psr |= 0x2;
+        helper_switch_regs(env);
+    }
+    /* FE bit */
+    if (imm & 0x2) {
+        env->cp0.psr |= 0x10;
+    }
+    /* IE bit */
+    if (imm & 0x4) {
+        env->cp0.psr |= 0x40;
+    }
+    /* EE bit */
+    if (imm & 0x8) {
+        env->cp0.psr |= 0x100;
+    }
+}
+
+void helper_stop(CPUCSKYState *env)
+{
+    CPUState *cs;
+    cs = CPU(csky_env_get_cpu(env));
+    cs->halted = 1;
+    helper_exception(env, EXCP_HLT);
+}
+
+void helper_wait(CPUCSKYState *env)
+{
+    CPUState *cs;
+    cs = CPU(csky_env_get_cpu(env));
+    cs->halted = 1;
+    helper_exception(env, EXCP_HLT);
+}
+
+void helper_doze(CPUCSKYState *env)
+{
+    CPUState *cs;
+    cs = CPU(csky_env_get_cpu(env));
+    cs->halted = 1;
+    helper_exception(env, EXCP_HLT);
+}
+
+void helper_wsc(CPUCSKYState *env)
+{
+    helper_save_sp(env);
+    helper_tee_save_cr(env);
+    if (env->psr_t) {
+        /* Secured world switch to Non-secured world. */
+        cpu_stl_data(env, env->stackpoint.t_ssp - 4, env->pc + 4);
+        cpu_stl_data(env, env->stackpoint.t_ssp - 8, env->cp0.psr);
+        env->stackpoint.t_ssp -= 8;
+
+        env->tee.t_psr = env->cp0.psr;
+        env->tee.t_psr &= ~PSR_HS_MASK;
+        env->tee.nt_psr |= PSR_SP_MASK;
+        env->tee.nt_psr &= ~PSR_VEC_MASK;
+        env->tee.nt_psr |= (env->tee.t_psr & PSR_VEC_MASK);
+        env->tee.nt_psr |= PSR_S_MASK;
+        env->cp0.psr = env->tee.nt_psr;
+        env->pc = cpu_ldl_code(env, env->tee.nt_ebr + 0 * 4);
+    } else {
+        /* Non-secured world switch to secured world. */
+        cpu_stl_data(env, env->stackpoint.nt_ssp - 4, env->pc + 4);
+        cpu_stl_data(env, env->stackpoint.nt_ssp - 8, env->cp0.psr);
+        env->stackpoint.nt_ssp -= 8;
+
+        env->tee.nt_psr = env->cp0.psr;
+        env->tee.t_psr |= PSR_SC_MASK;
+        env->tee.t_psr &= ~PSR_SP_MASK;
+        env->tee.t_psr &= ~PSR_VEC_MASK;
+        env->tee.t_psr |= (env->tee.nt_psr & PSR_VEC_MASK);
+        env->tee.t_psr |= PSR_S_MASK;
+        env->cp0.psr = env->tee.t_psr;
+        env->pc = cpu_ldl_code(env, env->tee.t_ebr + 0 * 4);
+    }
+
+    if ((env->tee.nt_psr & 0x2) != (env->tee.t_psr & 0x2)) {
+        helper_switch_regs(env);
+    }
+    helper_record_psr_bits(env);
+    helper_tee_choose_cr(env);
+    helper_choose_sp(env);
+    env->sce_condexec_bits = env->sce_condexec_bits_bk;
+}
+
+static inline uint32_t do_helper_tee_rte(CPUCSKYState *env)
+{
+    uint32_t tmp = 0;
+    uint32_t is_from_wsc = TRUE;
+    helper_save_sp(env);
+    helper_tee_save_cr(env);
+
+    if (env->psr_t == 1
+        && PSR_SP(env->cp0.psr) == 0
+        && PSR_SC(env->tee.t_psr) == 1) {
+        /* return from Trust world to Non-Trust world, wsc */
+        tmp = env->tee.t_psr;
+        env->tee.t_psr = env->cp0.psr;
+        env->cp0.psr = cpu_ldl_data(env, env->stackpoint.nt_ssp);
+        env->pc = cpu_ldl_data(env, env->stackpoint.nt_ssp + 4);
+        env->stackpoint.nt_ssp += 8;
+    } else if (env->psr_t == 0
+               && PSR_SP(env->cp0.psr) == 1
+               && PSR_HS(env->tee.t_psr) == 0) {
+        /* return from Non-Trust world to Trust world, wsc */
+        tmp = env->tee.nt_psr;
+        env->tee.nt_psr = env->cp0.psr;
+        env->cp0.psr = cpu_ldl_data(env, env->stackpoint.t_ssp);
+        env->pc = cpu_ldl_data(env, env->stackpoint.t_ssp + 4);
+        env->stackpoint.t_ssp += 8;
+    } else if (env->psr_t == 1
+               && PSR_SP(env->cp0.psr) == 0
+               && PSR_SC(env->tee.t_psr) == 0) {
+        /* return from Trust world to Non-Trust world, interrupt */
+        is_from_wsc = FALSE;
+        tmp = env->cp0.psr;
+        env->tee.t_psr = env->tee.t_epsr;
+        env->cp0.psr = cpu_ldl_data(env, env->stackpoint.nt_ssp);
+        env->pc = cpu_ldl_data(env, env->stackpoint.nt_ssp + 4);
+        env->stackpoint.nt_ssp += 8;
+    } else if (env->psr_t == 0
+               && PSR_SP(env->cp0.psr) == 1
+               && PSR_HS(env->tee.t_psr) == 1) {
+        /* return from Non-Trust world to Trust world, interrupt */
+        is_from_wsc = FALSE;
+        tmp = env->cp0.psr;
+        env->tee.nt_psr = env->tee.nt_epsr;
+        helper_tee_restore_gpr(env);
+        env->cp0.psr = cpu_ldl_data(env, env->stackpoint.t_ssp);
+        env->pc = cpu_ldl_data(env, env->stackpoint.t_ssp + 4);
+        env->stackpoint.t_ssp += 8;
+    } else {
+        /* return from interrupt without change the world, interrupt */
+        is_from_wsc = FALSE;
+        tmp = env->cp0.psr;
+        env->cp0.psr = env->cp0.epsr;
+        env->pc = env->cp0.epc;
+    }
+
+    if ((tmp & 0x2) != (env->cp0.psr & 0x2)) {
+        helper_switch_regs(env);
+    }
+    helper_record_psr_bits(env);
+    helper_tee_choose_cr(env);
+    helper_choose_sp(env);
+    return is_from_wsc;
+}
+
+/* helper for rte and nir */
+void helper_rte(CPUCSKYState *env)
+{
+    uint32_t irq;
+    uint32_t is_from_wsc;
+    if (env->features & ABIV2_TEE) {
+        is_from_wsc = do_helper_tee_rte(env);
+        if (is_from_wsc) {
+            return;
+        }
+    } else {
+        /* cpu without feature tee, or return from one world to
+         * the same kind of world */
+        if ((env->cp0.psr & 0x2) != (env->cp0.epsr & 0x2)) {
+            helper_switch_regs(env);
+        }
+        helper_save_sp(env);
+        env->cp0.psr = env->cp0.epsr;
+        env->pc = env->cp0.epc;
+        helper_record_psr_bits(env);
+        helper_choose_sp(env);
+    }
+
+    /* if irq >= 32, it is a vic interrupt. */
+    irq = env->intc_signals.isr & 0xff;
+    if (irq >= 32) {
+        env->intc_signals.isr &= ~0xff;
+        env->intc_signals.isr |= ((env->cp0.epsr >> 16) & 0xff);
+        env->intc_signals.iabr &= ~(1 << (irq - 32));
+        /* if the finished irq is same as VIC_IPTR(threshold),
+         *  clean the en bit of VIC_IPTR. */
+        if (irq == ((env->intc_signals.iptr && 0xff00) >> 8)) {
+            env->intc_signals.iptr &= ~(1 << 31);
+        }
+    }
+    if (unlikely(PSR_TP(env->cp0.epsr))) {
+        env->cp0.psr |= EXCP_CSKY_TRACE << 16;
+        helper_update_psr(env);
+        env->cp0.psr &= ~PSR_TP_MASK;   /* clear TP in EPSR */
+        env->cp0.epsr = env->cp0.psr;
+
+        env->cp0.psr |= PSR_S_MASK;
+        env->cp0.psr &= ~PSR_TM_MASK;
+        env->cp0.psr &= ~PSR_EE_MASK;
+        env->cp0.psr &= ~PSR_IE_MASK;
+
+        env->pc = cpu_ldl_code(env, env->cp0.vbr + EXCP_CSKY_TRACE * 4);
+        if (unlikely((env->pc & 0x1) != ((env->cp0.psr & 0x2) >> 1))) {
+            helper_switch_regs(env);
+            env->cp0.psr &= ~0x1;
+            env->cp0.psr |= (env->pc & 0x1) << 1;
+        }
+        helper_choose_sp(env);
+        env->pc &= ~0x1;
+    } else {
+        env->sce_condexec_bits = env->sce_condexec_bits_bk;
+    }
+}
+
+void helper_rfi(CPUCSKYState *env)
+{
+    if ((env->cp0.psr & 0x2) != (env->cp0.fpsr & 0x2)) {
+        helper_switch_regs(env);
+    }
+    helper_save_sp(env);
+    env->cp0.psr = env->cp0.fpsr & ~(0xff << 16);
+    helper_record_psr_bits(env);
+    helper_choose_sp(env);
+    if (unlikely(PSR_TP(env->cp0.fpsr))) {
+        env->cp0.psr |= EXCP_CSKY_TRACE << 16;
+        helper_update_psr(env);
+        env->cp0.psr &= ~PSR_TP_MASK;   /* clear TP in EPSR */
+        env->cp0.epsr = env->cp0.psr;
+
+        env->cp0.psr |= PSR_S_MASK;
+        env->cp0.psr &= ~PSR_TM_MASK;
+        env->cp0.psr &= ~PSR_EE_MASK;
+        env->cp0.psr &= ~PSR_IE_MASK;
+
+        env->pc = cpu_ldl_code(env, env->cp0.vbr + EXCP_CSKY_TRACE * 4);
+        if (unlikely((env->pc & 0x1) != ((env->cp0.psr & 0x2) >> 1))) {
+            helper_switch_regs(env);
+            env->cp0.psr &= ~0x1;
+            env->cp0.psr |= (env->pc & 0x1) << 1;
+        }
+        helper_choose_sp(env);
+        env->pc &= ~0x1;
+    } else {
+        env->pc = env->cp0.fpc;
+        env->sce_condexec_bits = env->sce_condexec_bits_bk;
+    }
+}
+
+void helper_meh_write(CPUCSKYState *env, uint32_t rx)
+{
+    CPUState *cs = CPU(csky_env_get_cpu(env));
+    /* if ASID is Changed, QEMU TLB must be flush */
+    if ((env->mmu.meh & 0xff) != (rx & 0xff)) {
+        tlb_flush(cs, 1);
+    }
+
+    env->mmu.meh = rx;
+}
+
+void helper_mcir_write(CPUCSKYState *env, uint32_t rx)
+{
+    /* Note: when more than one of the most significant
+       bits are asserted at the same time, these operations
+       are implemented according to the priority as follows:
+           Tlb invalid all operation
+           Tlb invalid operation
+           Tlb probe operation
+           Tlb writing index operation
+           Tlb writing random operation
+           Tlb reading operation
+    */
+    if ((rx & CSKY_MCIR_TTLBINV_ALL_MASK) && (env->features & ABIV2_TEE)) {
+        helper_ttlbinv_all(env);
+    } else if (rx & CSKY_MCIR_TLBINV_ALL_MASK) {
+        helper_tlbinv_all(env);
+    } else if (rx & CSKY_MCIR_TLBINV_MASK) {
+        helper_tlbinv(env);
+    } else if (rx & CSKY_MCIR_TLBP_MASK) {
+        env->tlb_context->helper_tlbp(env);
+    } else if (rx & CSKY_MCIR_TLBWI_MASK) {
+        env->tlb_context->helper_tlbwi(env);
+    } else if (rx & CSKY_MCIR_TLBWR_MASK) {
+        env->tlb_context->helper_tlbwr(env);
+    } else if (rx & CSKY_MCIR_TLBR_MASK) {
+        env->tlb_context->helper_tlbr(env);
+    }
+}
+
+uint32_t helper_tee_mfcr_cr19(CPUCSKYState *env)
+{
+    uint32_t i, s7_s0;
+    uint32_t res = 0;
+    if (env->psr_t) {
+        res = env->cp0.capr;
+    } else {
+        /* Non-Trust, S bit can not read or write,
+         * NX and SAP, can read and write only if S bit is 1. */
+        s7_s0 = env->cp0.capr >> 24;
+        /* Get NX */
+        res = env->cp0.capr & s7_s0;
+        /* Get SAP */
+        for (i = 0; i < 8; i++) {
+            if (s7_s0 & (1 << i)) {
+                res |= (env->cp0.capr & (0x3 << (2 * i + 8)));
+            }
+        }
+    }
+    return res;
+}
+
+void helper_tee_mtcr_cr19(CPUCSKYState *env, uint32_t rx)
+{
+    uint32_t i, s7_s0, mask;
+    if (env->psr_t) {
+        env->cp0.capr = rx;
+    } else {
+        /* Non-Trust, S bit can not read or write,
+         * NX and SAP, can read and write only if S bit is 1. */
+        s7_s0 = env->cp0.capr >> 24;
+        /* Set NX and SAP */
+        for (i = 0; i < 8; i++) {
+            if (s7_s0 & (1 << i)) {
+                mask = (0x3 << (2 * i + 8)) | (0x1 << i);
+                env->cp0.capr &= ~mask;
+                env->cp0.capr |= rx & mask;
+            }
+        }
+    }
+}
+
+uint32_t helper_mfcr_cr20(CPUCSKYState *env)
+{
+    uint32_t rid;
+    rid = env->cp0.prsr & 0x7;
+
+    if (!(env->features & ABIV2_TEE)
+        || env->psr_t
+        || env->cp0.capr & (1 << (rid + 24))) {
+        return env->cp0.pacr[rid];
+    } else {
+        return 0;
+    }
+}
+
+void helper_mtcr_cr20(CPUCSKYState *env, uint32_t rx)
+{
+    uint32_t rid;
+    rid = env->cp0.prsr & 0x7;
+
+    if (!(env->features & ABIV2_TEE)
+        || env->psr_t
+        || env->cp0.capr & (1 << (rid + 24))) {
+        env->cp0.pacr[rid] = rx;
+    }
+}
+
+uint32_t helper_mfcr_cpidr(CPUCSKYState *env)
+{
+    uint32_t counter;
+
+    counter = env->cp0.cpidr_counter;
+    env->cp0.cpidr_counter = (counter + 1) % 4;
+    return env->cp0.cpidr[counter];
+}
+#endif /* !CONFIG_USER_ONLY */
+
diff --git a/target-csky/op_vdsp.c b/target-csky/op_vdsp.c
new file mode 100644
index 0000000..a010b82
--- /dev/null
+++ b/target-csky/op_vdsp.c
@@ -0,0 +1,8393 @@
+/*
+ *  CSKY helper routines
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "cpu.h"
+#include "translate.h"
+#include "exec/helper-proto.h"
+#include "exec/cpu_ldst.h"
+#include <math.h>
+
+void VDSP_HELPER(vadd64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt, i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] +
+                                          env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] +
+                                          env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] +
+                                          env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+
+}
+void VDSP_HELPER(vadd128)(CPUCSKYState *env, uint32_t insn)
+{
+    int i, cnt;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] +
+                                          env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] +
+                                          env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] +
+                                          env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vadde64)(CPUCSKYState *env, uint32_t insn)
+{
+    int i, cnt;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspc[i] +
+                                              env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dsps[i] +
+                                              env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspc[i] +
+                                               env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udsps[i] +
+                                               env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+
+    }
+
+}
+void VDSP_HELPER(vadde128)(CPUCSKYState *env, uint32_t insn)
+{
+    int i, cnt;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspc[i] +
+                                              env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dsps[i] +
+                                              env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspc[i] +
+                                               env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udsps[i] +
+                                               env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+
+    }
+
+}
+
+void VDSP_HELPER(vcadd64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[i] = env->vfp.reg[rx].udspc[2 * i] +
+                                           env->vfp.reg[rx].udspc[2 * i + 1];
+            env->vfp.reg[rz].udspc[i + cnt] = env->vfp.reg[ry].udspc[2 * i] +
+                                             env->vfp.reg[ry].udspc[2 * i + 1];
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[2 * i] +
+                                           env->vfp.reg[rx].udsps[2 * i + 1]);
+            env->vfp.reg[rz].udsps[i + cnt] = (env->vfp.reg[ry].udsps[2 * i] +
+                                             env->vfp.reg[ry].udsps[2 * i + 1]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[2 * i] +
+                                           env->vfp.reg[rx].udspi[2 * i + 1]);
+            env->vfp.reg[rz].udspi[i + cnt] = (env->vfp.reg[ry].udspi[2 * i] +
+                                             env->vfp.reg[ry].udspi[2 * i + 1]);
+        }
+        break;
+    }
+}
+void VDSP_HELPER(vcadd128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[2 * i] +
+                                         env->vfp.reg[rx].udspc[2 * i + 1]);
+            env->vfp.reg[rz].udspc[i + cnt] = (env->vfp.reg[ry].udspc[2 * i] +
+                                             env->vfp.reg[ry].udspc[2 * i + 1]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[2 * i] +
+                                         env->vfp.reg[rx].udsps[2 * i + 1]);
+            env->vfp.reg[rz].udsps[i + cnt] = (env->vfp.reg[ry].udsps[2 * i] +
+                                        env->vfp.reg[ry].udsps[2 * i + 1]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[2 * i] +
+                                         env->vfp.reg[rx].udspi[2 * i + 1]);
+            env->vfp.reg[rz].udspi[i + cnt] = (env->vfp.reg[ry].udspi[2 * i] +
+                                        env->vfp.reg[ry].udspi[2 * i + 1]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vcadde64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspc[2 * i] +
+                                            env->vfp.reg[rx].dspc[2 * i + 1]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dsps[2 * i] +
+                                            env->vfp.reg[rx].dsps[2 * i + 1]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspc[2 * i] +
+                                             env->vfp.reg[rx].udspc[2 * i + 1]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udsps[2 * i] +
+                                             env->vfp.reg[rx].udsps[2 * i + 1]);
+            }
+            break;
+        }
+    }
+}
+void VDSP_HELPER(vcadde128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspc[2 * i] +
+                                            env->vfp.reg[rx].dspc[2 * i + 1]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dsps[2 * i] +
+                                            env->vfp.reg[rx].dsps[2 * i + 1]);
+            }
+            break;
+        }
+
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspc[2 * i] +
+                                             env->vfp.reg[rx].udspc[2 * i + 1]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udsps[2 * i] +
+                                             env->vfp.reg[rx].udsps[2 * i + 1]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vaddxsl64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = (tmp + env->vfp.reg[ry].dspc[i]);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = (tmp + env->vfp.reg[ry].dsps[i]);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = (tmp + env->vfp.reg[ry].udspc[i]);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = (tmp + env->vfp.reg[ry].udsps[i]);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+void VDSP_HELPER(vaddxsl128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = (tmp + env->vfp.reg[ry].dspc[i]);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = (tmp + env->vfp.reg[ry].dsps[i]);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = (tmp + env->vfp.reg[ry].udspc[i]);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = (tmp + env->vfp.reg[ry].udsps[i]);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vadds64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = (tmp + env->vfp.reg[ry].dspc[i]);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = (tmp + env->vfp.reg[ry].dsps[i]);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = (tmp + env->vfp.reg[ry].dspi[i]);
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = (tmp + env->vfp.reg[ry].udspc[i]);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = (tmp + env->vfp.reg[ry].udsps[i]);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = (tmp + env->vfp.reg[ry].udspi[i]);
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+void VDSP_HELPER(vadds128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = (tmp + env->vfp.reg[ry].dspc[i]);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = (tmp + env->vfp.reg[ry].dsps[i]);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = (tmp + env->vfp.reg[ry].dspi[i]);
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = (tmp + env->vfp.reg[ry].udspc[i]);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = (tmp + env->vfp.reg[ry].udsps[i]);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = (tmp + env->vfp.reg[ry].udspi[i]);
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+
+}
+
+void VDSP_HELPER(vaddx64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] +
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] +
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] +
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] +
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vaddx128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] +
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] +
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] +
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] +
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vaddh64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (((double)env->vfp.reg[rx].dspc[i] / 2) +
+                     ((double)env->vfp.reg[ry].dspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (((double)env->vfp.reg[rx].dsps[i] / 2) +
+                     ((double)env->vfp.reg[ry].dsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (((double)env->vfp.reg[rx].dspi[i] / 2) +
+                     ((double)env->vfp.reg[ry].dspi[i] / 2));
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (((double)env->vfp.reg[rx].udspc[i] / 2) +
+                     ((double)env->vfp.reg[ry].udspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (((double)env->vfp.reg[rx].udsps[i] / 2) +
+                     ((double)env->vfp.reg[ry].udsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (((double)env->vfp.reg[rx].udspi[i] / 2) +
+                     ((double)env->vfp.reg[ry].udspi[i] / 2));
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vaddh128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (((double)env->vfp.reg[rx].dspc[i] / 2) +
+                     ((double)env->vfp.reg[ry].dspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (((double)env->vfp.reg[rx].dsps[i] / 2) +
+                     ((double)env->vfp.reg[ry].dsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (((double)env->vfp.reg[rx].dspi[i] / 2) +
+                     ((double)env->vfp.reg[ry].dspi[i] / 2));
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (((double)env->vfp.reg[rx].udspc[i] / 2) +
+                     ((double)env->vfp.reg[ry].udspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (((double)env->vfp.reg[rx].udsps[i] / 2) +
+                     ((double)env->vfp.reg[ry].udsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (((double)env->vfp.reg[rx].udspi[i] / 2) +
+                     ((double)env->vfp.reg[ry].udspi[i] / 2));
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vaddhr64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (((double)env->vfp.reg[rx].dspc[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].dspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (((double)env->vfp.reg[rx].dsps[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].dsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (((double)env->vfp.reg[rx].dspi[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].dspi[i] / 2));
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (((double)env->vfp.reg[rx].udspc[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].udspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (((double)env->vfp.reg[rx].udsps[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].udsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (((double)env->vfp.reg[rx].udspi[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].udspi[i] / 2));
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vaddhr128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (((double)env->vfp.reg[rx].dspc[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].dspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (((double)env->vfp.reg[rx].dsps[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].dsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (((double)env->vfp.reg[rx].dspi[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].dspi[i] / 2));
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (((double)env->vfp.reg[rx].udspc[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].udspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (((double)env->vfp.reg[rx].udsps[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].udsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (((double)env->vfp.reg[rx].udspi[i] / 2) + 0.5 +
+                     ((double)env->vfp.reg[ry].udspi[i] / 2));
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsub64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] -
+                                        env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] -
+                                        env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] -
+                                        env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+void VDSP_HELPER(vsub128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] -
+                                        env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] -
+                                        env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] -
+                                        env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vsube64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspc[i] -
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dsps[i] -
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspc[i] -
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udsps[i] -
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsube128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspc[i] -
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dsps[i] -
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspc[i] -
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udsps[i] -
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsabs64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = abs(env->vfp.reg[rx].dspc[i] -
+                                               env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = abs(env->vfp.reg[rx].dsps[i] -
+                                               env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = abs(env->vfp.reg[rx].dspi[i] -
+                                               env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = env->vfp.reg[rx].udspc[i] -
+                                            env->vfp.reg[ry].udspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = env->vfp.reg[rx].udsps[i] -
+                                            env->vfp.reg[ry].udsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = env->vfp.reg[rx].udspi[i] -
+                                            env->vfp.reg[ry].udspi[i];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsabs128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = abs(env->vfp.reg[rx].dspc[i] -
+                                               env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = abs(env->vfp.reg[rx].dsps[i] -
+                                               env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = abs(env->vfp.reg[rx].dspi[i] -
+                                               env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = env->vfp.reg[rx].udspc[i] -
+                                            env->vfp.reg[ry].udspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = env->vfp.reg[rx].udsps[i] -
+                                            env->vfp.reg[ry].udsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = env->vfp.reg[rx].udspi[i] -
+                                            env->vfp.reg[ry].udspi[i];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsabsa64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] += abs(env->vfp.reg[rx].dspc[i] -
+                                                env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] += abs(env->vfp.reg[rx].dsps[i] -
+                                                env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] += abs(env->vfp.reg[rx].dspi[i] -
+                                               env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] += env->vfp.reg[rx].udspc[i] -
+                                             env->vfp.reg[ry].udspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] += env->vfp.reg[rx].udsps[i] -
+                                             env->vfp.reg[ry].udsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] += env->vfp.reg[rx].udspi[i] -
+                                             env->vfp.reg[ry].udspi[i];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsabsa128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] += abs(env->vfp.reg[rx].dspc[i] -
+                                                env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] += abs(env->vfp.reg[rx].dsps[i] -
+                                                env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] += abs(env->vfp.reg[rx].dspi[i] -
+                                                env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] += env->vfp.reg[rx].udspc[i] -
+                                             env->vfp.reg[ry].udspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] += env->vfp.reg[rx].udsps[i] -
+                                             env->vfp.reg[ry].udsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] += env->vfp.reg[rx].udspi[i] -
+                                             env->vfp.reg[ry].udspi[i];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsabse64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = abs(env->vfp.reg[rx].dspc[i] -
+                                               env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = abs(env->vfp.reg[rx].dsps[i] -
+                                               env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = abs(env->vfp.reg[rx].udspc[i] -
+                                                env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = abs(env->vfp.reg[rx].udsps[i] -
+                                                env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsabse128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = abs(env->vfp.reg[rx].dspc[i] -
+                                               env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = abs(env->vfp.reg[rx].dsps[i] -
+                                               env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = abs(env->vfp.reg[rx].udspc[i] -
+                                                env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = abs(env->vfp.reg[rx].udsps[i] -
+                                                env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsabsae64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] += abs(env->vfp.reg[rx].dspc[i] -
+                                                env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] += abs(env->vfp.reg[rx].dsps[i] -
+                                                env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] += abs(env->vfp.reg[rx].udspc[i] -
+                                                 env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] += abs(env->vfp.reg[rx].udsps[i] -
+                                                 env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsabsae128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] += abs(env->vfp.reg[rx].dspc[i] -
+                                                env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] += abs(env->vfp.reg[rx].dsps[i] -
+                                                env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] += abs(env->vfp.reg[rx].udspc[i] -
+                                                 env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] += abs(env->vfp.reg[rx].udsps[i] -
+                                                 env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsubx64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] -
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] -
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] -
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] -
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsubx128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] -
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] -
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] -
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] -
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsubh64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (((double)env->vfp.reg[rx].dspc[i] / 2) -
+                     ((double)env->vfp.reg[ry].dspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (((double)env->vfp.reg[rx].dsps[i] / 2) -
+                     ((double)env->vfp.reg[ry].dsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (((double)env->vfp.reg[rx].dspi[i] / 2) -
+                     ((double)env->vfp.reg[ry].dspi[i] / 2));
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (((double)env->vfp.reg[rx].udspc[i] / 2) -
+                     ((double)env->vfp.reg[ry].udspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (((double)env->vfp.reg[rx].udsps[i] / 2) -
+                     ((double)env->vfp.reg[ry].udsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (((double)env->vfp.reg[rx].udspi[i] / 2) -
+                     ((double)env->vfp.reg[ry].udspi[i] / 2));
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsubh128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (((double)env->vfp.reg[rx].dspc[i] / 2) -
+                     ((double)env->vfp.reg[ry].dspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (((double)env->vfp.reg[rx].dsps[i] / 2) -
+                     ((double)env->vfp.reg[ry].dsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (((double)env->vfp.reg[rx].dspi[i] / 2) -
+                     ((double)env->vfp.reg[ry].dspi[i] / 2));
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (((double)env->vfp.reg[rx].udspc[i] / 2) -
+                     ((double)env->vfp.reg[ry].udspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (((double)env->vfp.reg[rx].udsps[i] / 2) -
+                     ((double)env->vfp.reg[ry].udsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (((double)env->vfp.reg[rx].udspi[i] / 2) -
+                     ((double)env->vfp.reg[ry].udspi[i] / 2));
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsubhr64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (((double)env->vfp.reg[rx].dspc[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].dspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (((double)env->vfp.reg[rx].dsps[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].dsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (((double)env->vfp.reg[rx].dspi[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].dspi[i] / 2));
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (((double)env->vfp.reg[rx].udspc[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].udspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (((double)env->vfp.reg[rx].udsps[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].udsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (((double)env->vfp.reg[rx].udspi[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].udspi[i] / 2));
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsubhr128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (((double)env->vfp.reg[rx].dspc[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].dspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (((double)env->vfp.reg[rx].dsps[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].dsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (((double)env->vfp.reg[rx].dspi[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].dspi[i] / 2));
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (((double)env->vfp.reg[rx].udspc[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].udspc[i] / 2));
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (((double)env->vfp.reg[rx].udsps[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].udsps[i] / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (((double)env->vfp.reg[rx].udspi[i] / 2) + 0.5 -
+                     ((double)env->vfp.reg[ry].udspi[i] / 2));
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsubs64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = (tmp - env->vfp.reg[ry].dspc[i]);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = (tmp - env->vfp.reg[ry].dsps[i]);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = (tmp - env->vfp.reg[ry].dspi[i]);
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = (tmp - env->vfp.reg[ry].udspc[i]);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = (tmp - env->vfp.reg[ry].udsps[i]);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = (tmp - env->vfp.reg[ry].udspi[i]);
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vsubs128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = (tmp - env->vfp.reg[ry].dspc[i]);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = (tmp - env->vfp.reg[ry].dsps[i]);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = (tmp - env->vfp.reg[ry].dspi[i]);
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = (tmp - env->vfp.reg[ry].udspc[i]);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = (tmp - env->vfp.reg[ry].udsps[i]);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = (tmp - env->vfp.reg[ry].udspi[i]);
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmul64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] *
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] *
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] *
+                                            env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] *
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] *
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] *
+                                             env->vfp.reg[ry].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmul128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] *
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] *
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] *
+                                            env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] *
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] *
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] *
+                                             env->vfp.reg[ry].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmule64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspc[i] *
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dsps[i] *
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspc[i] *
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udsps[i] *
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmule128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspc[i] *
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dsps[i] *
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspc[i] *
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udsps[i] *
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmula64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] += (env->vfp.reg[rx].dspc[i] *
+                                             env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] += (env->vfp.reg[rx].dsps[i] *
+                                             env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] += (env->vfp.reg[rx].dspi[i] *
+                                             env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] += (env->vfp.reg[rx].udspc[i] *
+                                              env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] += (env->vfp.reg[rx].udsps[i] *
+                                              env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] += (env->vfp.reg[rx].udspi[i] *
+                                              env->vfp.reg[ry].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmula128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] += (env->vfp.reg[rx].dspc[i] *
+                                             env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] += (env->vfp.reg[rx].dsps[i] *
+                                             env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] += (env->vfp.reg[rx].dspi[i] *
+                                             env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] += (env->vfp.reg[rx].udspc[i] *
+                                              env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] += (env->vfp.reg[rx].udsps[i] *
+                                              env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] += (env->vfp.reg[rx].udspi[i] *
+                                              env->vfp.reg[ry].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmulae64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] += (env->vfp.reg[rx].dspc[i] *
+                                             env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] += (env->vfp.reg[rx].dsps[i] *
+                                             env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] += (env->vfp.reg[rx].udspc[i] *
+                                              env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] += (env->vfp.reg[rx].udsps[i] *
+                                              env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmulae128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] += (env->vfp.reg[rx].dspc[i] *
+                                             env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] += (env->vfp.reg[rx].dsps[i] *
+                                             env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] += (env->vfp.reg[rx].udspc[i] *
+                                              env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] += (env->vfp.reg[rx].udsps[i] *
+                                              env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmuls64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] -= (env->vfp.reg[rx].dspc[i] *
+                                             env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] -= (env->vfp.reg[rx].dsps[i] *
+                                             env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] -= (env->vfp.reg[rx].dspi[i] *
+                                             env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] -= (env->vfp.reg[rx].udspc[i] *
+                                              env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] -= (env->vfp.reg[rx].udsps[i] *
+                                              env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] -= (env->vfp.reg[rx].udspi[i] *
+                                              env->vfp.reg[ry].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmuls128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] -= (env->vfp.reg[rx].dspc[i] *
+                                             env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] -= (env->vfp.reg[rx].dsps[i] *
+                                             env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] -= (env->vfp.reg[rx].dspi[i] *
+                                             env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] -= (env->vfp.reg[rx].udspc[i] *
+                                              env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] -= (env->vfp.reg[rx].udsps[i] *
+                                              env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] -= (env->vfp.reg[rx].udspi[i] *
+                                              env->vfp.reg[ry].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmulse64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] -= (env->vfp.reg[rx].dspc[i] *
+                                             env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] -= (env->vfp.reg[rx].dsps[i] *
+                                             env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] -= (env->vfp.reg[rx].udspc[i] *
+                                              env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] -= (env->vfp.reg[rx].udsps[i] *
+                                              env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmulse128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] -= (env->vfp.reg[rx].dspc[i] *
+                                             env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] -= (env->vfp.reg[rx].dsps[i] *
+                                             env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] -= (env->vfp.reg[rx].udspc[i] *
+                                              env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] -= (env->vfp.reg[rx].udsps[i] *
+                                              env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshri64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+    int immd;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+    immd = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK)
+                        | (((insn > CSKY_VDSP_SOP_SHI_S) & 0x1) << 4);
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >> immd);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >> immd);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >> immd);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >> immd);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >> immd);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >> immd);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshri128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+    int immd;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+    immd = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK)
+                        | (((insn > CSKY_VDSP_SOP_SHI_S) & 0x1) << 4);
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >> immd);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >> immd);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >> immd);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >> immd);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >> immd);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >> immd);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshrir64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+    int immd;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+    immd = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK)
+                        | (((insn > CSKY_VDSP_SOP_SHI_S) & 0x1) << 4);
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >> immd);
+                if (((env->vfp.reg[rz].dspc[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dspc[i] += 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >> immd);
+                if (((env->vfp.reg[rz].dsps[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dsps[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >> immd);
+                if (((env->vfp.reg[rz].dspi[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dspi[i] += 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >> immd);
+                if (((env->vfp.reg[rz].udspc[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udspc[i] += 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >> immd);
+                if (((env->vfp.reg[rz].udsps[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udsps[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >> immd);
+                if (((env->vfp.reg[rz].udspi[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udspi[i] += 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshrir128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+    int immd;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+    immd = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK)
+                        | (((insn > CSKY_VDSP_SOP_SHI_S) & 0x1) << 4);
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >> immd);
+                if (((env->vfp.reg[rz].dspc[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dspc[i] += 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >> immd);
+                if (((env->vfp.reg[rz].dsps[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dsps[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >> immd);
+                if (((env->vfp.reg[rz].dspi[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dspi[i] += 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >> immd);
+                if (((env->vfp.reg[rz].udspc[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udspc[i] += 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >> immd);
+                if (((env->vfp.reg[rz].udsps[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udsps[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >> immd);
+                if (((env->vfp.reg[rz].udspi[i] >> (immd - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udspi[i] += 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshrr64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >>
+                                            (env->vfp.reg[ry].dspc[i] & 0x1f));
+                if (((env->vfp.reg[rz].dspc[i] >> ((env->vfp.reg[ry].dspc[i] &
+                                                    0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dspc[i] += 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >>
+                                            (env->vfp.reg[ry].dsps[i] & 0x1f));
+                if (((env->vfp.reg[rz].dsps[i] >> ((env->vfp.reg[ry].dsps[i] &
+                                                    0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dsps[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >>
+                                            (env->vfp.reg[ry].dspi[i] & 0x1f));
+                if (((env->vfp.reg[rz].dspi[i] >> ((env->vfp.reg[ry].dspi[i] &
+                                                    0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dspi[i] += 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >>
+                                            (env->vfp.reg[ry].udspc[i] & 0x1f));
+                if (((env->vfp.reg[rz].udspc[i] >> ((env->vfp.reg[ry].udspc[i] &
+                                                     0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udspc[i] += 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >>
+                                            (env->vfp.reg[ry].udsps[i] & 0x1f));
+                if (((env->vfp.reg[rz].udsps[i] >> ((env->vfp.reg[ry].udsps[i] &
+                                                     0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udsps[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >>
+                                         (env->vfp.reg[ry].udspi[i] & 0x1f));
+                if (((env->vfp.reg[rz].udspi[i] >> ((env->vfp.reg[ry].udspi[i] &
+                                                     0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udspi[i] += 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshrr128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >>
+                                            (env->vfp.reg[ry].dspc[i] & 0x1f));
+                if (((env->vfp.reg[rz].dspc[i] >> ((env->vfp.reg[ry].dspc[i] &
+                                                    0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dspc[i] += 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >>
+                                            (env->vfp.reg[ry].dsps[i] & 0x1f));
+                if (((env->vfp.reg[rz].dsps[i] >> ((env->vfp.reg[ry].dsps[i] &
+                                                    0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dsps[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >>
+                                            (env->vfp.reg[ry].dspi[i] & 0x1f));
+                if (((env->vfp.reg[rz].dspi[i] >> ((env->vfp.reg[ry].dspi[i] &
+                                                    0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dspi[i] += 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >>
+                                            (env->vfp.reg[ry].udspc[i] & 0x1f));
+                if (((env->vfp.reg[rz].udspc[i] >> ((env->vfp.reg[ry].udspc[i] &
+                                                     0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udspc[i] += 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >>
+                                            (env->vfp.reg[ry].udsps[i] & 0x1f));
+                if (((env->vfp.reg[rz].udsps[i] >> ((env->vfp.reg[ry].udsps[i] &
+                                                     0x1f) - 1)) & 0x1) == 1){
+                    env->vfp.reg[rz].udsps[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >>
+                                         (env->vfp.reg[ry].udspi[i] & 0x1f));
+                if (((env->vfp.reg[rz].udspi[i] >> ((env->vfp.reg[ry].udspi[i] &
+                                                     0x1f) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udspi[i] += 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshls64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = (tmp << (env->vfp.reg[ry].dspc[i] & 0x1f));
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = (tmp << (env->vfp.reg[ry].dsps[i] & 0x1f));
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = (tmp << (env->vfp.reg[ry].dspi[i] & 0x1f));
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = (tmp << (env->vfp.reg[ry].udspc[i] & 0x1f));
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = (tmp << (env->vfp.reg[ry].udsps[i] & 0x1f));
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = (tmp << (env->vfp.reg[ry].udspi[i] & 0x1f));
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshls128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = (tmp << (env->vfp.reg[ry].dspc[i] & 0x1f));
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = (tmp << (env->vfp.reg[ry].dsps[i] & 0x1f));
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = (tmp << (env->vfp.reg[ry].dspi[i] & 0x1f));
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+
+        }
+
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = (tmp << (env->vfp.reg[ry].udspc[i] & 0x1f));
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = (tmp << (env->vfp.reg[ry].udsps[i] & 0x1f));
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = (tmp << (env->vfp.reg[ry].udspi[i] & 0x1f));
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshr64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >>
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >>
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >>
+                                            env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >>
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >>
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >>
+                                             env->vfp.reg[ry].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshr128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >>
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >>
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >>
+                                            env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >>
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >>
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >>
+                                             env->vfp.reg[ry].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshli64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+    int immd;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+    immd = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK)
+                        | (((insn > CSKY_VDSP_SOP_SHI_S) & 0x1) << 4);
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] << immd);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] << immd);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] << immd);
+            }
+            break;
+
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] << immd);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] << immd);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] << immd);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshli128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+    int immd;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+    immd = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK)
+                        | (((insn > CSKY_VDSP_SOP_SHI_S) & 0x1) << 4);
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] << immd);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] << immd);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] << immd);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] << immd);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] << immd);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] << immd);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshlis64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, rz;
+    int immd;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+    immd = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK)
+                        | (((insn > CSKY_VDSP_SOP_SHI_S) & 0x1) << 4);
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshlis128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, rz;
+    int immd;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+    immd = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK)
+                        | (((insn > CSKY_VDSP_SOP_SHI_S) & 0x1) << 4);
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = (tmp << immd);
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshl64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] <<
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] <<
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] <<
+                                            env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] <<
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] <<
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] <<
+                                             env->vfp.reg[ry].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vshl128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] <<
+                                            env->vfp.reg[ry].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] <<
+                                            env->vfp.reg[ry].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] <<
+                                            env->vfp.reg[ry].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] <<
+                                             env->vfp.reg[ry].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] <<
+                                             env->vfp.reg[ry].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] <<
+                                             env->vfp.reg[ry].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmphs64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >=
+                                        env->vfp.reg[ry].dspc[i]) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >=
+                                    env->vfp.reg[ry].dsps[i]) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >=
+                                   env->vfp.reg[ry].dspi[i]) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >=
+                                        env->vfp.reg[ry].udspc[i]) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >=
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >=
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmphs128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >=
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >=
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >=
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >=
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >=
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >=
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmplt64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] <
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] <
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] <
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] <
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] <
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] <
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             0xffffffff : 0x0;
+            }
+            break;
+
+        }
+
+    }
+
+}
+
+void VDSP_HELPER(vcmplt128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] <
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] <
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] <
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] <
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] <
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] <
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmpne64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] !=
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] !=
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] !=
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] !=
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] !=
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] !=
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+void VDSP_HELPER(vcmpne128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] !=
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] !=
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] !=
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] !=
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] !=
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] !=
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             0xffffffff : 0x0;
+            }
+            break;
+
+        }
+
+    }
+
+}
+
+void VDSP_HELPER(vcmphsz64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >= 0) ?
+                                           0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >=
+                                            0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >=
+                                            0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspc[i];
+                env->vfp.reg[rz].udspc[i] = (tmp2 >= 0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udsps[i];
+                env->vfp.reg[rz].udsps[i] = (tmp2 >= 0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspi[i];
+                env->vfp.reg[rz].udspi[i] = (tmp2 >= 0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmphsz128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >=
+                                            0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >=
+                                            0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >=
+                                            0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspc[i];
+                env->vfp.reg[rz].udspc[i] = (tmp2 >= 0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udsps[i];
+                env->vfp.reg[rz].udsps[i] = (tmp2 >= 0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspi[i];
+                env->vfp.reg[rz].udspi[i] = (tmp2 >= 0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmpltz64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] <
+                                            0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] <
+                                            0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] <
+                                            0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspc[i];
+                env->vfp.reg[rz].udspc[i] = (tmp2 < 0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udsps[i];
+                env->vfp.reg[rz].udsps[i] = (tmp2 < 0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspi[i];
+                env->vfp.reg[rz].udspi[i] = (tmp2 < 0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmpltz128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] <
+                                            0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] <
+                                            0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] <
+                                            0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspc[i];
+                env->vfp.reg[rz].udspc[i] = (tmp2 < 0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udsps[i];
+                env->vfp.reg[rz].udsps[i] = (tmp2 < 0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspi[i];
+                env->vfp.reg[rz].udspi[i] = (tmp2 < 0) ? 0xffffffff : 0x0;
+            }
+            break;
+
+        }
+
+    }
+
+}
+
+void VDSP_HELPER(vcmpnez64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] !=
+                                            0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] !=
+                                            0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] !=
+                                            0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspc[i];
+                env->vfp.reg[rz].udspc[i] = (tmp2 != 0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udsps[i];
+                env->vfp.reg[rz].udsps[i] = (tmp2 != 0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspi[i];
+                env->vfp.reg[rz].udspi[i] = (tmp2 != 0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+void VDSP_HELPER(vcmpnez128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] !=
+                                            0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] !=
+                                            0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] !=
+                                            0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspc[i];
+                env->vfp.reg[rz].udspc[i] = (tmp2 != 0) ? 0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udsps[i];
+                env->vfp.reg[rz].udsps[i] = (tmp2 != 0) ? 0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                int64_t tmp2 = env->vfp.reg[rx].udspi[i];
+                env->vfp.reg[rz].udspi[i] = (tmp2 != 0) ? 0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmax64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            env->vfp.reg[rx].dspc[i] :
+                                            env->vfp.reg[ry].dspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            env->vfp.reg[rx].dsps[i] :
+                                            env->vfp.reg[ry].dsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            env->vfp.reg[rx].dspi[i] :
+                                            env->vfp.reg[ry].dspi[i];
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             env->vfp.reg[rx].udspc[i] :
+                                             env->vfp.reg[ry].udspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             env->vfp.reg[rx].udsps[i] :
+                                             env->vfp.reg[ry].udsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             env->vfp.reg[rx].udspi[i] :
+                                             env->vfp.reg[ry].udspi[i];
+            }
+            break;
+        }
+    }
+
+}
+void VDSP_HELPER(vmax128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] >
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            env->vfp.reg[rx].dspc[i] :
+                                            env->vfp.reg[ry].dspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] >
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            env->vfp.reg[rx].dsps[i] :
+                                            env->vfp.reg[ry].dsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] >
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            env->vfp.reg[rx].dspi[i] :
+                                            env->vfp.reg[ry].dspi[i];
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] >
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             env->vfp.reg[rx].udspc[i] :
+                                             env->vfp.reg[ry].udspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] >
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             env->vfp.reg[rx].udsps[i] :
+                                             env->vfp.reg[ry].udsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] >
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             env->vfp.reg[rx].udspi[i] :
+                                             env->vfp.reg[ry].udspi[i];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmin64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] <
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            env->vfp.reg[rx].dspc[i] :
+                                            env->vfp.reg[ry].dspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] <
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            env->vfp.reg[rx].dsps[i] :
+                                            env->vfp.reg[ry].dsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] <
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            env->vfp.reg[rx].dspi[i] :
+                                            env->vfp.reg[ry].dspi[i];
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] <
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             env->vfp.reg[rx].udspc[i] :
+                                             env->vfp.reg[ry].udspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] <
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             env->vfp.reg[rx].udsps[i] :
+                                             env->vfp.reg[ry].udsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] <
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             env->vfp.reg[rx].udspi[i] :
+                                             env->vfp.reg[ry].udspi[i];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmin128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] <
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            env->vfp.reg[rx].dspc[i] :
+                                            env->vfp.reg[ry].dspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] <
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            env->vfp.reg[rx].dsps[i] :
+                                            env->vfp.reg[ry].dsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] <
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            env->vfp.reg[rx].dspi[i] :
+                                            env->vfp.reg[ry].dspi[i];
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] <
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             env->vfp.reg[rx].udspc[i] :
+                                             env->vfp.reg[ry].udspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] <
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             env->vfp.reg[rx].udsps[i] :
+                                             env->vfp.reg[ry].udsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] <
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             env->vfp.reg[rx].udspi[i] :
+                                             env->vfp.reg[ry].udspi[i];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmax64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[2 * i] >
+                                            env->vfp.reg[rx].dspc[2 * i + 1]) ?
+                                            env->vfp.reg[rx].dspc[2 * i] :
+                                            env->vfp.reg[rx].dspc[2 * i + 1];
+                env->vfp.reg[rz].dspc[i + cnt] = (env->vfp.reg[ry].dspc[2 * i] >
+                                            env->vfp.reg[ry].dspc[2 * i + 1]) ?
+                                            env->vfp.reg[ry].dspc[2 * i] :
+                                            env->vfp.reg[ry].dspc[2 * i + 1];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[2 * i] >
+                                            env->vfp.reg[rx].dsps[2 * i + 1]) ?
+                                            env->vfp.reg[rx].dsps[2 * i] :
+                                            env->vfp.reg[rx].dsps[2 * i + 1];
+                env->vfp.reg[rz].dsps[i + cnt] = (env->vfp.reg[ry].dsps[2 * i] >
+                                            env->vfp.reg[ry].dsps[2 * i + 1]) ?
+                                            env->vfp.reg[ry].dsps[2 * i] :
+                                            env->vfp.reg[ry].dsps[2 * i + 1];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[2 * i] >
+                                            env->vfp.reg[rx].dspi[2 * i + 1]) ?
+                                            env->vfp.reg[rx].dspi[2 * i] :
+                                            env->vfp.reg[rx].dspi[2 * i + 1];
+                env->vfp.reg[rz].dspi[i + cnt] = (env->vfp.reg[ry].dspi[2 * i] >
+                                            env->vfp.reg[ry].dspi[2 * i + 1]) ?
+                                            env->vfp.reg[ry].dspi[2 * i] :
+                                            env->vfp.reg[ry].dspi[2 * i + 1];
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[2 * i] >
+                                            env->vfp.reg[rx].udspc[2 * i + 1]) ?
+                                            env->vfp.reg[rx].udspc[2 * i] :
+                                            env->vfp.reg[rx].udspc[2 * i + 1];
+                env->vfp.reg[rz].udspc[i + cnt] =
+                    (env->vfp.reg[ry].udspc[2 * i] >
+                     env->vfp.reg[ry].udspc[2 * i + 1]) ?
+                     env->vfp.reg[ry].udspc[2 * i] :
+                     env->vfp.reg[ry].udspc[2 * i + 1];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (env->vfp.reg[rx].udsps[2 * i] >
+                    env->vfp.reg[rx].udsps[2 * i + 1]) ?
+                    env->vfp.reg[rx].udsps[2 * i] :
+                    env->vfp.reg[rx].udsps[2 * i + 1];
+                env->vfp.reg[rz].udsps[i + cnt] =
+                    (env->vfp.reg[ry].udsps[2 * i] >
+                    env->vfp.reg[ry].udsps[2 * i + 1]) ?
+                    env->vfp.reg[ry].udsps[2 * i] :
+                    env->vfp.reg[ry].udsps[2 * i + 1];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (env->vfp.reg[rx].udspi[2 * i] >
+                     env->vfp.reg[rx].udspi[2 * i + 1]) ?
+                    env->vfp.reg[rx].udspi[2 * i] :
+                    env->vfp.reg[rx].udspi[2 * i + 1];
+                env->vfp.reg[rz].udspi[i + cnt] =
+                    (env->vfp.reg[ry].udspi[2 * i] >
+                     env->vfp.reg[ry].udspi[2 * i + 1]) ?
+                    env->vfp.reg[ry].udspi[2 * i] :
+                    env->vfp.reg[ry].udspi[2 * i + 1];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmax128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (env->vfp.reg[rx].dspc[2 * i] >
+                     env->vfp.reg[rx].dspc[2 * i + 1]) ?
+                    env->vfp.reg[rx].dspc[2 * i] :
+                    env->vfp.reg[rx].dspc[2 * i + 1];
+                env->vfp.reg[rz].dspc[i + cnt] =
+                    (env->vfp.reg[ry].dspc[2 * i] >
+                     env->vfp.reg[ry].dspc[2 * i + 1]) ?
+                    env->vfp.reg[ry].dspc[2 * i] :
+                    env->vfp.reg[ry].dspc[2 * i + 1];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (env->vfp.reg[rx].dsps[2 * i] >
+                     env->vfp.reg[rx].dsps[2 * i + 1]) ?
+                    env->vfp.reg[rx].dsps[2 * i] :
+                    env->vfp.reg[rx].dsps[2 * i + 1];
+                env->vfp.reg[rz].dsps[i + cnt] =
+                    (env->vfp.reg[ry].dsps[2 * i] >
+                     env->vfp.reg[ry].dsps[2 * i + 1]) ?
+                    env->vfp.reg[ry].dsps[2 * i] :
+                    env->vfp.reg[ry].dsps[2 * i + 1];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (env->vfp.reg[rx].dspi[2 * i] >
+                     env->vfp.reg[rx].dspi[2 * i + 1]) ?
+                    env->vfp.reg[rx].dspi[2 * i] :
+                    env->vfp.reg[rx].dspi[2 * i + 1];
+                env->vfp.reg[rz].dspi[i + cnt] =
+                    (env->vfp.reg[ry].dspi[2 * i] >
+                     env->vfp.reg[ry].dspi[2 * i + 1]) ?
+                    env->vfp.reg[ry].dspi[2 * i] :
+                    env->vfp.reg[ry].dspi[2 * i + 1];
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (env->vfp.reg[rx].udspc[2 * i] >
+                     env->vfp.reg[rx].udspc[2 * i + 1]) ?
+                    env->vfp.reg[rx].udspc[2 * i] :
+                    env->vfp.reg[rx].udspc[2 * i + 1];
+                env->vfp.reg[rz].udspc[i + cnt] =
+                    (env->vfp.reg[ry].udspc[2 * i] >
+                     env->vfp.reg[ry].udspc[2 * i + 1]) ?
+                    env->vfp.reg[ry].udspc[2 * i] :
+                    env->vfp.reg[ry].udspc[2 * i + 1];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (env->vfp.reg[rx].udsps[2 * i] >
+                     env->vfp.reg[rx].udsps[2 * i + 1]) ?
+                    env->vfp.reg[rx].udsps[2 * i] :
+                    env->vfp.reg[rx].udsps[2 * i + 1];
+                env->vfp.reg[rz].udsps[i + cnt] =
+                    (env->vfp.reg[ry].udsps[2 * i] >
+                     env->vfp.reg[ry].udsps[2 * i + 1]) ?
+                    env->vfp.reg[ry].udsps[2 * i] :
+                    env->vfp.reg[ry].udsps[2 * i + 1];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (env->vfp.reg[rx].udspi[2 * i] >
+                     env->vfp.reg[rx].udspi[2 * i + 1]) ?
+                    env->vfp.reg[rx].udspi[2 * i] :
+                    env->vfp.reg[rx].udspi[2 * i + 1];
+                env->vfp.reg[rz].udspi[i + cnt] =
+                    (env->vfp.reg[ry].udspi[2 * i] >
+                     env->vfp.reg[ry].udspi[2 * i + 1]) ?
+                    env->vfp.reg[ry].udspi[2 * i] :
+                    env->vfp.reg[ry].udspi[2 * i + 1];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmin64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (env->vfp.reg[rx].dspc[2 * i] <
+                     env->vfp.reg[rx].dspc[2 * i + 1]) ?
+                    env->vfp.reg[rx].dspc[2 * i] :
+                    env->vfp.reg[rx].dspc[2 * i + 1];
+                env->vfp.reg[rz].dspc[i + cnt] =
+                    (env->vfp.reg[ry].dspc[2 * i] <
+                     env->vfp.reg[ry].dspc[2 * i + 1]) ?
+                    env->vfp.reg[ry].dspc[2 * i] :
+                    env->vfp.reg[ry].dspc[2 * i + 1];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (env->vfp.reg[rx].dsps[2 * i] <
+                     env->vfp.reg[rx].dsps[2 * i + 1]) ?
+                    env->vfp.reg[rx].dsps[2 * i] :
+                    env->vfp.reg[rx].dsps[2 * i + 1];
+                env->vfp.reg[rz].dsps[i + cnt] =
+                    (env->vfp.reg[ry].dsps[2 * i] <
+                     env->vfp.reg[ry].dsps[2 * i + 1]) ?
+                    env->vfp.reg[ry].dsps[2 * i] :
+                    env->vfp.reg[ry].dsps[2 * i + 1];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (env->vfp.reg[rx].dspi[2 * i] <
+                     env->vfp.reg[rx].dspi[2 * i + 1]) ?
+                    env->vfp.reg[rx].dspi[2 * i] :
+                    env->vfp.reg[rx].dspi[2 * i + 1];
+                env->vfp.reg[rz].dspi[i + cnt] =
+                    (env->vfp.reg[ry].dspi[2 * i] <
+                     env->vfp.reg[ry].dspi[2 * i + 1]) ?
+                    env->vfp.reg[ry].dspi[2 * i] :
+                    env->vfp.reg[ry].dspi[2 * i + 1];
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (env->vfp.reg[rx].udspc[2 * i] <
+                     env->vfp.reg[rx].udspc[2 * i + 1]) ?
+                    env->vfp.reg[rx].udspc[2 * i] :
+                    env->vfp.reg[rx].udspc[2 * i + 1];
+                env->vfp.reg[rz].udspc[i + cnt] =
+                    (env->vfp.reg[ry].udspc[2 * i] <
+                     env->vfp.reg[ry].udspc[2 * i + 1]) ?
+                    env->vfp.reg[ry].udspc[2 * i] :
+                    env->vfp.reg[ry].udspc[2 * i + 1];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (env->vfp.reg[rx].udsps[2 * i] <
+                     env->vfp.reg[rx].udsps[2 * i + 1]) ?
+                    env->vfp.reg[rx].udsps[2 * i] :
+                    env->vfp.reg[rx].udsps[2 * i + 1];
+                env->vfp.reg[rz].udsps[i + cnt] =
+                    (env->vfp.reg[ry].udsps[2 * i] <
+                     env->vfp.reg[ry].udsps[2 * i + 1]) ?
+                    env->vfp.reg[ry].udsps[2 * i] :
+                    env->vfp.reg[ry].udsps[2 * i + 1];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (env->vfp.reg[rx].udspi[2 * i] <
+                     env->vfp.reg[rx].udspi[2 * i + 1]) ?
+                    env->vfp.reg[rx].udspi[2 * i] :
+                    env->vfp.reg[rx].udspi[2 * i + 1];
+                env->vfp.reg[rz].udspi[i + cnt] =
+                    (env->vfp.reg[ry].udspi[2 * i] <
+                     env->vfp.reg[ry].udspi[2 * i + 1]) ?
+                    env->vfp.reg[ry].udspi[2 * i] :
+                    env->vfp.reg[ry].udspi[2 * i + 1];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vcmin128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (env->vfp.reg[rx].dspc[2 * i] <
+                     env->vfp.reg[rx].dspc[2 * i + 1]) ?
+                    env->vfp.reg[rx].dspc[2 * i] :
+                    env->vfp.reg[rx].dspc[2 * i + 1];
+                env->vfp.reg[rz].dspc[i + cnt] =
+                    (env->vfp.reg[ry].dspc[2 * i] <
+                     env->vfp.reg[ry].dspc[2 * i + 1]) ?
+                    env->vfp.reg[ry].dspc[2 * i] :
+                    env->vfp.reg[ry].dspc[2 * i + 1];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (env->vfp.reg[rx].dsps[2 * i] <
+                     env->vfp.reg[rx].dsps[2 * i + 1]) ?
+                    env->vfp.reg[rx].dsps[2 * i] :
+                    env->vfp.reg[rx].dsps[2 * i + 1];
+                env->vfp.reg[rz].dsps[i + cnt] =
+                    (env->vfp.reg[ry].dsps[2 * i] <
+                     env->vfp.reg[ry].dsps[2 * i + 1]) ?
+                    env->vfp.reg[ry].dsps[2 * i] :
+                    env->vfp.reg[ry].dsps[2 * i + 1];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] =
+                    (env->vfp.reg[rx].dspi[2 * i] <
+                     env->vfp.reg[rx].dspi[2 * i + 1]) ?
+                    env->vfp.reg[rx].dspi[2 * i] :
+                    env->vfp.reg[rx].dspi[2 * i + 1];
+                env->vfp.reg[rz].dspi[i + cnt] =
+                    (env->vfp.reg[ry].dspi[2 * i] <
+                     env->vfp.reg[ry].dspi[2 * i + 1]) ?
+                    env->vfp.reg[ry].dspi[2 * i] :
+                    env->vfp.reg[ry].dspi[2 * i + 1];
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (env->vfp.reg[rx].udspc[2 * i] <
+                     env->vfp.reg[rx].udspc[2 * i + 1]) ?
+                    env->vfp.reg[rx].udspc[2 * i] :
+                    env->vfp.reg[rx].udspc[2 * i + 1];
+                env->vfp.reg[rz].udspc[i + cnt] =
+                    (env->vfp.reg[ry].udspc[2 * i] <
+                     env->vfp.reg[ry].udspc[2 * i + 1]) ?
+                    env->vfp.reg[ry].udspc[2 * i] :
+                    env->vfp.reg[ry].udspc[2 * i + 1];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (env->vfp.reg[rx].udsps[2 * i] <
+                     env->vfp.reg[rx].udsps[2 * i + 1]) ?
+                    env->vfp.reg[rx].udsps[2 * i] :
+                    env->vfp.reg[rx].udsps[2 * i + 1];
+                env->vfp.reg[rz].udsps[i + cnt] =
+                    (env->vfp.reg[ry].udsps[2 * i] <
+                     env->vfp.reg[ry].udsps[2 * i + 1]) ?
+                    env->vfp.reg[ry].udsps[2 * i] :
+                    env->vfp.reg[ry].udsps[2 * i + 1];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] =
+                    (env->vfp.reg[rx].udspi[2 * i] <
+                     env->vfp.reg[rx].udspi[2 * i + 1]) ?
+                    env->vfp.reg[rx].udspi[2 * i] :
+                    env->vfp.reg[rx].udspi[2 * i + 1];
+                env->vfp.reg[rz].udspi[i + cnt] =
+                    (env->vfp.reg[ry].udspi[2 * i] <
+                     env->vfp.reg[ry].udspi[2 * i + 1]) ?
+                    env->vfp.reg[ry].udspi[2 * i] :
+                    env->vfp.reg[ry].udspi[2 * i + 1];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vand64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] &
+                                        env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] &
+                                        env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] &
+                                        env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vand128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] &
+                                        env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] &
+                                        env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] &
+                                        env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vandn64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] &
+                                        ~env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] &
+                                        ~env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] &
+                                        ~env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vandn128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] &
+                                        ~env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] &
+                                        ~env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] &
+                                        ~env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vor64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] |
+                                        env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] |
+                                        env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] |
+                                        env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vor128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] |
+                                        env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] |
+                                        env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] |
+                                        env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vnor64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = ~(env->vfp.reg[rx].dspc[i] |
+                                         env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = ~(env->vfp.reg[rx].dsps[i] |
+                                         env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = ~(env->vfp.reg[rx].dspi[i] |
+                                         env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vnor128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = ~(env->vfp.reg[rx].dspc[i] |
+                                         env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = ~(env->vfp.reg[rx].dsps[i] |
+                                         env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = ~(env->vfp.reg[rx].dspi[i] |
+                                         env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vxor64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] ^
+                                        env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] ^
+                                        env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] ^
+                                        env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vxor128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] ^
+                                        env->vfp.reg[ry].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] ^
+                                        env->vfp.reg[ry].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] ^
+                                        env->vfp.reg[ry].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vtst64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] &
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] &
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] &
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] &
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] &
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] &
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vtst128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i] &
+                                            env->vfp.reg[ry].dspc[i]) ?
+                                            0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i] &
+                                            env->vfp.reg[ry].dsps[i]) ?
+                                            0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i] &
+                                            env->vfp.reg[ry].dspi[i]) ?
+                                            0xffffffff : 0x0;
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[i] &
+                                             env->vfp.reg[ry].udspc[i]) ?
+                                             0xff : 0x0;
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[i] &
+                                             env->vfp.reg[ry].udsps[i]) ?
+                                             0xffff : 0x0;
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[i] &
+                                             env->vfp.reg[ry].udspi[i]) ?
+                                             0xffffffff : 0x0;
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmov64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vmov128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vmove64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmove128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = (env->vfp.reg[rx].dsps[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udsps[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmovh64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dsps[i] >>
+                                            (lng / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspi[i] >>
+                                            (lng / 2));
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udsps[i] >>
+                                             (lng / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspi[i] >>
+                                             (lng / 2));
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmovh128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dsps[i] >>
+                                            (lng / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspi[i] >>
+                                            (lng / 2));
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udsps[i] >>
+                                             (lng / 2));
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspi[i] >>
+                                             (lng / 2));
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmovrh64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dsps[i] >>
+                                            (lng / 2));
+                if (((env->vfp.reg[rz].dspc[i] >>
+                      ((lng / 2) - 1)) & 0x1) == 1) {
+                        env->vfp.reg[rz].dspc[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspi[i] >>
+                                            (lng / 2));
+                if (((env->vfp.reg[rz].dsps[i] >>
+                      ((lng / 2) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dsps[i] += 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (env->vfp.reg[rx].udsps[i] >> (lng / 2));
+
+                if (((env->vfp.reg[rz].udspc[i] >>
+                      ((lng / 2) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udspc[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (env->vfp.reg[rx].udspi[i] >> (lng / 2));
+
+                if (((env->vfp.reg[rz].udsps[i] >>
+                      ((lng / 2) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udsps[i] += 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmovrh128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] =
+                    (env->vfp.reg[rx].dsps[i] >> (lng / 2));
+
+                if (((env->vfp.reg[rz].dspc[i] >>
+                      ((lng / 2) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dspc[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] =
+                    (env->vfp.reg[rx].dspi[i] >> (lng / 2));
+
+                if (((env->vfp.reg[rz].dsps[i] >>
+                      ((lng / 2) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].dsps[i] += 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] =
+                    (env->vfp.reg[rx].udsps[i] >> (lng / 2));
+
+                if (((env->vfp.reg[rz].udspc[i] >>
+                      ((lng / 2) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udspc[i] += 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] =
+                    (env->vfp.reg[rx].udspi[i] >> (lng / 2));
+
+                if (((env->vfp.reg[rz].udsps[i] >>
+                      ((lng / 2) - 1)) & 0x1) == 1) {
+                    env->vfp.reg[rz].udsps[i] += 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+
+void VDSP_HELPER(vmovl64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmovl128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = (env->vfp.reg[rx].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = (env->vfp.reg[rx].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmovsl64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmovsl128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vstousl64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udsps[i]);
+            env->vfp.reg[rz].udspc[i] = tmp;
+            if (tmp > 0xff) {
+                env->vfp.reg[rz].udspc[i] = 0xff;
+            }
+            if (tmp < 1) {
+                env->vfp.reg[rz].udspc[i] = 1 - 1;
+            }
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udspi[i]);
+            env->vfp.reg[rz].udsps[i] = tmp;
+            if (tmp > 0xffff) {
+                env->vfp.reg[rz].udsps[i] = 0xffff;
+            }
+            if (tmp < 1) {
+                env->vfp.reg[rz].udsps[i] = 1 - 1;
+            }
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vstousl128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udsps[i]);
+            env->vfp.reg[rz].udspc[i] = tmp;
+            if (tmp > 0xff) {
+                env->vfp.reg[rz].udspc[i] = 0xff;
+            }
+            if (tmp < 1) {
+                env->vfp.reg[rz].udspc[i] = 1 - 1;
+            }
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udspi[i]);
+            env->vfp.reg[rz].udsps[i] = tmp;
+            if (tmp > 0xffff) {
+                env->vfp.reg[rz].udsps[i] = 0xffff;
+            }
+            if (tmp < 1) {
+                env->vfp.reg[rz].udsps[i] = 1 - 1;
+            }
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vrev64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[cnt - i - 1] = (env->vfp.reg[rx].udspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[cnt - i - 1] = (env->vfp.reg[rx].udsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[cnt - i - 1] = (env->vfp.reg[rx].udspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vrev128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[cnt - i - 1] = (env->vfp.reg[rx].udspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[cnt - i - 1] = (env->vfp.reg[rx].udsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[cnt - i - 1] = (env->vfp.reg[rx].udspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vdup64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, rz, immd;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[immd]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[immd]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[immd]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vdup128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, rz, immd;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[immd]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[immd]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[immd]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vtrcl64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[2 * i] = (env->vfp.reg[rx].udspc[2 * i]);
+            env->vfp.reg[rz].udspc[2 * i + 1] = (env->vfp.reg[ry].udspc[2 * i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[2 * i] = (env->vfp.reg[rx].udsps[2 * i]);
+            env->vfp.reg[rz].udsps[2 * i + 1] = (env->vfp.reg[ry].udsps[2 * i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[2 * i] = (env->vfp.reg[rx].udspi[2 * i]);
+            env->vfp.reg[rz].udspi[2 * i + 1] = (env->vfp.reg[ry].udspi[2 * i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vtrcl128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[2 * i] = (env->vfp.reg[rx].udspc[2 * i]);
+            env->vfp.reg[rz].udspc[2 * i + 1] = (env->vfp.reg[ry].udspc[2 * i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[2 * i] = (env->vfp.reg[rx].udsps[2 * i]);
+            env->vfp.reg[rz].udsps[2 * i + 1] = (env->vfp.reg[ry].udsps[2 * i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[2 * i] = (env->vfp.reg[rx].udspi[2 * i]);
+            env->vfp.reg[rz].udspi[2 * i + 1] = (env->vfp.reg[ry].udspi[2 * i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vtrch64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[2 * i] = (env->vfp.reg[rx].udspc[2 * i + 1]);
+            env->vfp.reg[rz].udspc[2 * i + 1] =
+                (env->vfp.reg[ry].udspc[2 * i + 1]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[2 * i] = (env->vfp.reg[rx].udsps[2 * i + 1]);
+            env->vfp.reg[rz].udsps[2 * i + 1] =
+                (env->vfp.reg[ry].udsps[2 * i + 1]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[2 * i] = (env->vfp.reg[rx].udspi[2 * i + 1]);
+            env->vfp.reg[rz].udspi[2 * i + 1] =
+                (env->vfp.reg[ry].udspi[2 * i + 1]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vtrch128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[2 * i] = (env->vfp.reg[rx].udspc[2 * i + 1]);
+            env->vfp.reg[rz].udspc[2 * i + 1] =
+                (env->vfp.reg[ry].udspc[2 * i + 1]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[2 * i] = (env->vfp.reg[rx].udsps[2 * i + 1]);
+            env->vfp.reg[rz].udsps[2 * i + 1] =
+                (env->vfp.reg[ry].udsps[2 * i + 1]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[2 * i] = (env->vfp.reg[rx].udspi[2 * i + 1]);
+            env->vfp.reg[rz].udspi[2 * i + 1] =
+                (env->vfp.reg[ry].udspi[2 * i + 1]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vich64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[2 * i] = (env->vfp.reg[rx].udspc[i + cnt]);
+            env->vfp.reg[rz].udspc[2 * i + 1] =
+                (env->vfp.reg[ry].udspc[i + cnt]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[2 * i] = (env->vfp.reg[rx].udsps[i + cnt]);
+            env->vfp.reg[rz].udsps[2 * i + 1] =
+                (env->vfp.reg[ry].udsps[i + cnt]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[2 * i] = (env->vfp.reg[rx].udspi[i + cnt]);
+            env->vfp.reg[rz].udspi[2 * i + 1] =
+                (env->vfp.reg[ry].udspi[i + cnt]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vich128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[2 * i] = (env->vfp.reg[rx].udspc[i + cnt]);
+            env->vfp.reg[rz].udspc[2 * i + 1] =
+                (env->vfp.reg[ry].udspc[i + cnt]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[2 * i] = (env->vfp.reg[rx].udsps[i + cnt]);
+            env->vfp.reg[rz].udsps[2 * i + 1] =
+                (env->vfp.reg[ry].udsps[i + cnt]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[2 * i] = (env->vfp.reg[rx].udspi[i + cnt]);
+            env->vfp.reg[rz].udspi[2 * i + 1] =
+                (env->vfp.reg[ry].udspi[i + cnt]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vicl64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[2 * i] = (env->vfp.reg[rx].udspc[i]);
+            env->vfp.reg[rz].udspc[2 * i + 1] = (env->vfp.reg[ry].udspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[2 * i] = (env->vfp.reg[rx].udsps[i]);
+            env->vfp.reg[rz].udsps[2 * i + 1] = (env->vfp.reg[ry].udsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[2 * i] = (env->vfp.reg[rx].udspi[i]);
+            env->vfp.reg[rz].udspi[2 * i + 1] = (env->vfp.reg[ry].udspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vicl128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[2 * i] = (env->vfp.reg[rx].udspc[i]);
+            env->vfp.reg[rz].udspc[2 * i + 1] = (env->vfp.reg[ry].udspc[i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[2 * i] = (env->vfp.reg[rx].udsps[i]);
+            env->vfp.reg[rz].udsps[2 * i + 1] = (env->vfp.reg[ry].udsps[i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[2 * i] = (env->vfp.reg[rx].udspi[i]);
+            env->vfp.reg[rz].udspi[2 * i + 1] = (env->vfp.reg[ry].udspi[i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vdch64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[2 * i + 1]);
+            env->vfp.reg[rz].udspc[i + cnt] =
+                (env->vfp.reg[ry].udspc[2 * i + 1]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[2 * i + 1]);
+            env->vfp.reg[rz].udsps[i + cnt] =
+                (env->vfp.reg[ry].udsps[2 * i + 1]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[2 * i + 1]);
+            env->vfp.reg[rz].udspi[i + cnt] =
+                (env->vfp.reg[ry].udspi[2 * i + 1]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vdch128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[2 * i + 1]);
+            env->vfp.reg[rz].udspc[i + cnt] =
+                (env->vfp.reg[ry].udspc[2 * i + 1]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[2 * i + 1]);
+            env->vfp.reg[rz].udsps[i + cnt] =
+                (env->vfp.reg[ry].udsps[2 * i + 1]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[2 * i + 1]);
+            env->vfp.reg[rz].udspi[i + cnt] =
+                (env->vfp.reg[ry].udspi[2 * i + 1]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vdcl64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[2 * i]);
+            env->vfp.reg[rz].udspc[i + cnt] = (env->vfp.reg[ry].udspc[2 * i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[2 * i]);
+            env->vfp.reg[rz].udsps[i + cnt] = (env->vfp.reg[ry].udsps[2 * i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[2 * i]);
+            env->vfp.reg[rz].udspi[i + cnt] = (env->vfp.reg[ry].udspi[2 * i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vdcl128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng / 2;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspc[i] = (env->vfp.reg[rx].udspc[2 * i]);
+            env->vfp.reg[rz].udspc[i + cnt] = (env->vfp.reg[ry].udspc[2 * i]);
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udsps[i] = (env->vfp.reg[rx].udsps[2 * i]);
+            env->vfp.reg[rz].udsps[i + cnt] = (env->vfp.reg[ry].udsps[2 * i]);
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            env->vfp.reg[rz].udspi[i] = (env->vfp.reg[rx].udspi[2 * i]);
+            env->vfp.reg[rz].udspi[i + cnt] = (env->vfp.reg[ry].udspi[2 * i]);
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vabs64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = abs(env->vfp.reg[rx].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = abs(env->vfp.reg[rx].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = abs(env->vfp.reg[rx].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = env->vfp.reg[rx].udspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = env->vfp.reg[rx].udsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = env->vfp.reg[rx].udspi[i];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vabs128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = abs(env->vfp.reg[rx].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = abs(env->vfp.reg[rx].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = abs(env->vfp.reg[rx].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = env->vfp.reg[rx].udspc[i];
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = env->vfp.reg[rx].udsps[i];
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = env->vfp.reg[rx].udspi[i];
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vneg64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = -(env->vfp.reg[rx].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = -(env->vfp.reg[rx].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = -(env->vfp.reg[rx].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = -(env->vfp.reg[rx].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = -(env->vfp.reg[rx].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = -(env->vfp.reg[rx].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vneg128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspc[i] = -(env->vfp.reg[rx].dspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dsps[i] = -(env->vfp.reg[rx].dsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].dspi[i] = -(env->vfp.reg[rx].dspi[i]);
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspc[i] = -(env->vfp.reg[rx].udspc[i]);
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udsps[i] = -(env->vfp.reg[rx].udsps[i]);
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                env->vfp.reg[rz].udspi[i] = -(env->vfp.reg[rx].udspi[i]);
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vabss64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vabss128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = labs(tmp);
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vnegs64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 1 - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 1 - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 1 - 1;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vnegs128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    int64_t tmp;
+    uint32_t wid, lng, sign, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    sign = (insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_SIGN_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    if (sign) {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspc[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].dspc[i] = tmp;
+                if (tmp > 0x7f) {
+                    env->vfp.reg[rz].dspc[i] = 0x7f;
+                }
+                if (tmp < -0x7f) {
+                    env->vfp.reg[rz].dspc[i] = -0x7f - 1;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dsps[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].dsps[i] = tmp;
+                if (tmp > 0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = 0x7fff;
+                }
+                if (tmp < -0x7fff) {
+                    env->vfp.reg[rz].dsps[i] = -0x7fff - 1;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].dspi[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].dspi[i] = tmp;
+                if (tmp > 0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = 0x7fffffff;
+                }
+                if (tmp < -0x7fffffff) {
+                    env->vfp.reg[rz].dspi[i] = -0x7fffffff - 1;
+                }
+            }
+            break;
+        }
+    } else {
+        switch (lng) {
+        case 8:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspc[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].udspc[i] = tmp;
+                if (tmp > 0xff) {
+                    env->vfp.reg[rz].udspc[i] = 0xff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspc[i] = 0;
+                }
+            }
+            break;
+        case 16:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udsps[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].udsps[i] = tmp;
+                if (tmp > 0xffff) {
+                    env->vfp.reg[rz].udsps[i] = 0xffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udsps[i] = 0;
+                }
+            }
+            break;
+        case 32:
+            for (i = 0; i < cnt; i++) {
+                tmp = (env->vfp.reg[rx].udspi[i]);
+                tmp = -(tmp);
+                env->vfp.reg[rz].udspi[i] = tmp;
+                if (tmp > 0xffffffff) {
+                    env->vfp.reg[rz].udspi[i] = 0xffffffff;
+                }
+                if (tmp < 1) {
+                    env->vfp.reg[rz].udspi[i] = 0;
+                }
+            }
+            break;
+        }
+    }
+}
+
+void VDSP_HELPER(vmfvru8)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t immd, rx, rz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->regs[rz] = env->vfp.reg[rx].udspc[immd];
+}
+
+void VDSP_HELPER(vmfvru16)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t immd, rx, rz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->regs[rz] = env->vfp.reg[rx].udsps[immd];
+}
+
+void VDSP_HELPER(vmfvru32)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t immd, rx, rz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->regs[rz] = env->vfp.reg[rx].udspi[immd];
+}
+
+void VDSP_HELPER(vmfvrs8)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t immd, rx, rz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->regs[rz] = env->vfp.reg[rx].dspc[immd];
+}
+
+void VDSP_HELPER(vmfvrs16)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t immd, rx, rz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->regs[rz] = env->vfp.reg[rx].dsps[immd];
+}
+
+void VDSP_HELPER(vmtvru8)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t immd, rx, rz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->vfp.reg[rz].udspc[immd] = env->regs[rx];
+}
+
+void VDSP_HELPER(vmtvru16)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t immd, rx, rz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->vfp.reg[rz].udsps[immd] = env->regs[rx];
+}
+
+void VDSP_HELPER(vmtvru32)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t immd, rx, rz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->vfp.reg[rz].udspi[immd] = env->regs[rx];
+}
+
+void VDSP_HELPER(vins8)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t rx, rz, immd, immdz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    immdz = (insn >> CSKY_VDSP_SOP_SHI_S) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->vfp.reg[rz].udspc[immdz] = (env->vfp.reg[rx].udspc[immd]);
+}
+
+void VDSP_HELPER(vins16)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t rx, rz, immd, immdz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    immdz = (insn >> CSKY_VDSP_SOP_SHI_S) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->vfp.reg[rz].udsps[immdz] = (env->vfp.reg[rx].udsps[immd]);
+}
+
+void VDSP_HELPER(vins32)(CPUCSKYState *env, uint32_t insn)
+{
+    uint32_t rx, rz, immd, immdz;
+
+    immd = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    immdz = (insn >> CSKY_VDSP_SOP_SHI_S) & CSKY_VDSP_REG_MASK;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    env->vfp.reg[rz].udspi[immdz] = (env->vfp.reg[rx].udspi[immd]);
+}
+
+void VDSP_HELPER(vcnt164)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i, j;
+    int64_t tmp;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    for (i = 0; i < cnt; i++) {
+        tmp = env->vfp.reg[rx].udspc[i];
+        for (j = 0; tmp > 0x0; ++j) {
+            tmp &= (tmp - 1);
+        }
+        env->vfp.reg[rz].udspc[i] = j;
+    }
+}
+
+void VDSP_HELPER(vcnt1128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i, j;
+    int64_t tmp;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    for (i = 0; i < cnt; i++) {
+        tmp = env->vfp.reg[rx].udspc[i];
+        for (j = 0; tmp > 0x0; ++j) {
+            tmp &= (tmp - 1);
+        }
+        env->vfp.reg[rz].udspc[i] = j;
+    }
+}
+
+void VDSP_HELPER(vbperm64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    for (i = 0; i < cnt; i++) {
+        if (env->vfp.reg[ry].udspc[i] < 16) {
+            env->vfp.reg[rz].udspc[i] =
+                env->vfp.reg[rx].udspc[env->vfp.reg[ry].udspc[i]];
+        } else {
+            env->vfp.reg[rz].udspc[i] = 0xff;
+        }
+    }
+
+}
+
+void VDSP_HELPER(vbperm128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    for (i = 0; i < cnt; i++) {
+        if (env->vfp.reg[ry].udspc[i] < 16) {
+            env->vfp.reg[rz].udspc[i] =
+                env->vfp.reg[rx].udspc[env->vfp.reg[ry].udspc[i]];
+        } else {
+            env->vfp.reg[rz].udspc[i] = 0xff;
+        }
+    }
+}
+
+void VDSP_HELPER(vbpermz64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    for (i = 0; i < cnt; i++) {
+        if (env->vfp.reg[ry].udspc[i] < 16) {
+            env->vfp.reg[rz].udspc[i] =
+                env->vfp.reg[rx].udspc[env->vfp.reg[ry].udspc[i]];
+        } else {
+            env->vfp.reg[rz].udspc[i] = 0x0;
+        }
+    }
+
+}
+
+void VDSP_HELPER(vbpermz128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i;
+    uint32_t wid, lng, rx, ry, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    ry = (insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    for (i = 0; i < cnt; i++) {
+        if (env->vfp.reg[ry].udspc[i] < 16) {
+            env->vfp.reg[rz].udspc[i] =
+                env->vfp.reg[rx].udspc[env->vfp.reg[ry].udspc[i]];
+        } else {
+            env->vfp.reg[rz].udspc[i] = 0x0;
+        }
+    }
+}
+
+void VDSP_HELPER(vcls64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i, c;
+    int64_t tmp;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udspc[i] & 0x7f);
+            for (c = 0; tmp < 0x40; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udspc[i] = c;
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udsps[i] & 0x7fff);
+            for (c = 0; tmp < 0x4000; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udsps[i] = c;
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udspi[i] & 0x7fffffff);
+            for (c = 0; tmp < 0x40000000; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udspi[i] = c;
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vcls128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i, c;
+    int64_t tmp;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udspc[i] & 0x7f);
+            for (c = 0; tmp < 0x40; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udspc[i] = c;
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udsps[i] & 0x7fff);
+            for (c = 0; tmp < 0x4000; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udsps[i] = c;
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udspi[i] & 0x7fffffff);
+            for (c = 0; tmp < 0x40000000; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udspi[i] = c;
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vclz64)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt;
+    int i, c;
+    int64_t tmp;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 64 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udspc[i]);
+            for (c = 0; tmp < 0x80; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udspc[i] = c;
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udsps[i]);
+            for (c = 0; tmp < 0x8000; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udsps[i] = c;
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udspi[i]);
+            for (c = 0; tmp < 0x80000000; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udspi[i] = c;
+        }
+        break;
+    }
+}
+
+void VDSP_HELPER(vclz128)(CPUCSKYState *env, uint32_t insn)
+{
+    int cnt, i, c;
+    int64_t tmp;
+    uint32_t wid, lng, rx, rz;
+
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+    lng = 8 * pow(2, wid);
+    cnt = 128 / lng;
+    rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+    rz = insn & CSKY_VDSP_REG_MASK;
+
+    switch (lng) {
+    case 8:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udspc[i]);
+            for (c = 0; tmp < 0x80; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udspc[i] = c;
+        }
+        break;
+    case 16:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udsps[i]);
+            for (c = 0; tmp < 0x8000; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udsps[i] = c;
+        }
+        break;
+    case 32:
+        for (i = 0; i < cnt; i++) {
+            tmp = (env->vfp.reg[rx].udspi[i]);
+            for (c = 0; tmp < 0x80000000; tmp <<= 1) {
+                c++;
+            }
+            env->vfp.reg[rz].udspi[i] = c;
+        }
+        break;
+    }
+}
diff --git a/target-csky/translate.h b/target-csky/translate.h
new file mode 100644
index 0000000..5b9334e
--- /dev/null
+++ b/target-csky/translate.h
@@ -0,0 +1,627 @@
+/*
+ * CSKY translate header
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef CSKY_TRANSLATE_H
+#define CSKY_TRANSLATE_H
+#include "qemu/log.h"
+#include "exec/cpu_ldst.h"
+
+#if !defined(CONFIG_USER_ONLY)
+typedef enum TraceMode {
+    NORMAL_MODE = 0,
+    INST_TRACE_MODE = 1,
+    BRAN_TRACE_MODE = 3,
+} TraceMode;
+#endif
+
+typedef struct DisasContext {
+    struct TranslationBlock *tb;
+    target_ulong pc;
+    int singlestep_enabled;
+    uint32_t insn;
+
+    /* Routine used to access memory */
+    int mem_idx;   /*selects user or supervisor access*/
+    int is_jmp;
+    int bctm;
+
+    uint64_t features;
+
+#if !defined(CONFIG_USER_ONLY)
+    int super;
+    int trust;
+    int current_cp;
+
+    /* trace mode support */
+    TraceMode trace_mode;
+    int cannot_be_traced;
+    int maybe_change_flow;
+#endif
+} DisasContext;
+
+#if !defined(CONFIG_USER_ONLY)
+typedef struct csky_tlb_t csky_tlb_t;
+struct csky_tlb_t {
+    uint32_t VPN;
+    uint32_t PageMask; /* [24:13] */
+    uint8_t ASID;
+    uint16_t G:1;
+    uint16_t C0:3;
+    uint16_t C1:3;
+    uint16_t V0:1;
+    uint16_t V1:1;
+    uint16_t D0:1;
+    uint16_t D1:1;
+    uint32_t PFN[2]; /* [31:12] */
+};
+
+#define CSKY_TLB_MAX            128
+typedef struct CPUCSKYTLBContext {
+    int (*get_physical_address)(CPUCSKYState *env, hwaddr *physical, int *prot,
+                                target_ulong address, int rw);
+
+    void (*helper_tlbwi) (CPUCSKYState *env);
+    void (*helper_tlbwr) (CPUCSKYState *env);
+    void (*helper_tlbp) (CPUCSKYState *env);
+    void (*helper_tlbr) (CPUCSKYState *env);
+
+    csky_tlb_t *tlb;
+    uint8_t *round_robin;
+    csky_tlb_t nt_tlb[CSKY_TLB_MAX];
+    csky_tlb_t t_tlb[CSKY_TLB_MAX];
+    uint8_t nt_round_robin[CSKY_TLB_MAX / 2];
+    uint8_t t_round_robin[CSKY_TLB_MAX / 2];
+} CPUCSKYTLBContext;
+
+int mmu_get_physical_address(CPUCSKYState *env, hwaddr *physical,
+                             int *prot, target_ulong address, int rw);
+void csky_tlbwi(CPUCSKYState *env);
+void csky_tlbwr(CPUCSKYState *env);
+void csky_tlbp(CPUCSKYState *env);
+void csky_tlbr(CPUCSKYState *env);
+void helper_ttlbinv_all(CPUCSKYState *env);
+void helper_tlbinv_all(CPUCSKYState *env);
+void helper_tlbinv(CPUCSKYState *env);
+int nommu_get_physical_address(struct CPUCSKYState *env, hwaddr *physical,
+                               int *prot, target_ulong address, int rw);
+int mgu_get_physical_address(struct CPUCSKYState *env, hwaddr *physical,
+                             int *prot, target_ulong address, int rw);
+#endif
+
+/* VDSP MASK and SHIFT*/
+#define CSKY_VDSP_SOP_MASK_M            0x7f
+#define CSKY_VDSP_SOP_MASK_S            0xf
+#define CSKY_VDSP_SOP_MASK_E            0x3f
+#define CSKY_VDSP_SOP_SHI_M             9
+#define CSKY_VDSP_SOP_SHI_S             5
+#define CSKY_VDSP_SOP_SHI_E             10
+#define CSKY_VDSP_WIDTH_BIT_HI          24
+#define CSKY_VDSP_WIDTH_BIT_LO          20
+#define CSKY_VDSP_REG_MASK              0xf
+#define CSKY_VDSP_REG_SHI_VRX           16
+#define CSKY_VDSP_REG_SHI_VRY           21
+#define CSKY_VDSP_SIGN_SHI              4
+#define CSKY_VDSP_SIGN_MASK             0x1
+
+#define VDSPLEN                 128
+#define VDSP_VADD               0x0
+#define VDSP_VSUB               0x1
+#define VDSP_VMUL               0x2
+#define VDSP_VSH                0x3
+#define VDSP_VCMP               0x4
+#define VDSP_VAND               0x5
+#define VDSP_VMOV               0x6
+#define VDSP_VSPE               0x7
+#define VDSP_VABS               0x8
+#define VDSP_VMVVR              0x9
+#define VDSP_VINS               0xa
+
+#define VDSP_HELPER(name) HELPER(glue(vdsp_, name))
+
+/* DSPv2 Macro begin */
+/* DSPv2 ISA secondary/third OP MASK and SHIFT */
+#define CSKY_DSPV2_SOP_MASK         0x1f
+#define CSKY_DSPV2_SOP_SHI          11
+#define CSKY_DSPV2_THOP_MASK        0x3f
+#define CSKY_DSPV2_THOP_SHI         5
+
+#define CSKY_DSPV2_REG_MASK         0x1f
+#define CSKY_DSPV2_REG_SHI_RX       16
+#define CSKY_DSPV2_REG_SHI_RY       21
+#define CSKY_DSPV2_REG_SHI_RZ       0
+
+#define DSPV2_HELPER(name) HELPER(glue(dspv2_, name))
+
+/* SOP and THOP for dspv2 instructions. */
+#define DSPV2_ADD_SUB               0x18
+#define   OP_PADD_8_1st             0x2
+#define   OP_PADD_8_2nd             0x6
+#define   OP_PADD_16_1st            0x0
+#define   OP_PADD_16_2nd            0x4
+#define   OP_PADD_U8_S              0xa
+#define   OP_PADD_S8_S              0xe
+#define   OP_PADD_U16_S             0x8
+#define   OP_PADD_S16_S             0xc
+#define   OP_ADD_U32_S              0x9
+#define   OP_ADD_S32_S              0xd
+#define   OP_PSUB_8_1st             0x22
+#define   OP_PSUB_8_2nd             0x26
+#define   OP_PSUB_16_1st            0x20
+#define   OP_PSUB_16_2nd            0x24
+#define   OP_PSUB_U8_S              0x2a
+#define   OP_PSUB_S8_S              0x2e
+#define   OP_PSUB_U16_S             0x28
+#define   OP_PSUB_S16_S             0x2c
+#define   OP_SUB_U32_S              0x29
+#define   OP_SUB_S32_S              0x2d
+#define   OP_PADDH_U8               0x12
+#define   OP_PADDH_S8               0x16
+#define   OP_PADDH_U16              0x10
+#define   OP_PADDH_S16              0x14
+#define   OP_ADDH_U32               0x11
+#define   OP_ADDH_S32               0x15
+#define   OP_PSUBH_U8               0x32
+#define   OP_PSUBH_S8               0x36
+#define   OP_PSUBH_U16              0x30
+#define   OP_PSUBH_S16              0x34
+#define   OP_SUBH_U32               0x31
+#define   OP_SUBH_S32               0x35
+#define   OP_ADD_64_1st             0x3
+#define   OP_ADD_64_2nd             0x7
+#define   OP_SUB_64_1st             0x23
+#define   OP_SUB_64_2nd             0x27
+#define   OP_ADD_U64_S              0xb
+#define   OP_ADD_S64_S              0xf
+#define   OP_SUB_U64_S              0x2b
+#define   OP_SUB_S64_S              0x2f
+
+#define DSPV2_CMP                   0x19
+#define   OP_PASX_16_1st            0x3
+#define   OP_PASX_16_2nd            0x7
+#define   OP_PSAX_16_1st            0x23
+#define   OP_PSAX_16_2nd            0x27
+#define   OP_PASX_U16_S             0xb
+#define   OP_PASX_S16_S             0xf
+#define   OP_PSAX_U16_S             0x2b
+#define   OP_PSAX_S16_S             0x2f
+#define   OP_PASXH_U16              0x13
+#define   OP_PASXH_S16              0x17
+#define   OP_PSAXH_U16              0x33
+#define   OP_PSAXH_S16              0x37
+#define   OP_PCMPNE_8_1st           0x2
+#define   OP_PCMPNE_8_2nd           0x6
+#define   OP_PCMPNE_16_1st          0x0
+#define   OP_PCMPNE_16_2nd          0x4
+#define   OP_PCMPHS_U8              0xa
+#define   OP_PCMPHS_S8              0xe
+#define   OP_PCMPHS_U16             0x8
+#define   OP_PCMPHS_S16             0xc
+#define   OP_PCMPLT_U8              0x12
+#define   OP_PCMPLT_S8              0x16
+#define   OP_PCMPLT_U16             0x10
+#define   OP_PCMPLT_S16             0x14
+#define   OP_PMAX_U8                0x22
+#define   OP_PMAX_S8                0x26
+#define   OP_PMAX_U16               0x20
+#define   OP_PMAX_S16               0x24
+#define   OP_MAX_U32                0x21
+#define   OP_MAX_S32                0x25
+#define   OP_PMIN_U8                0x2a
+#define   OP_PMIN_S8                0x2e
+#define   OP_PMIN_U16               0x28
+#define   OP_PMIN_S16               0x2c
+#define   OP_MIN_U32                0x29
+#define   OP_MIN_S32                0x2d
+
+#define DSPV2_SEL                   0x12
+#define   OP_SEL_begin              0x0
+#define   OP_SEL_end                0x1f
+
+#define DSPV2_MISC                  0x1c
+#define   OP_PSABSA_U8_1st          0x2
+#define   OP_PSABSA_U8_2nd          0x6
+#define   OP_PSABSAA_U8_1st         0xa
+#define   OP_PSABSAA_U8_2nd         0xe
+#define   OP_DIVUL                  0x13
+#define   OP_DIVSL                  0x17
+#define   OP_MULACA_S8              0x26
+
+#define DSPV2_SHIFT                 0x1a
+#define   OP_ASRI_S32_R             0xd
+#define   OP_ASR_S32_R              0xf
+#define   OP_LSRI_U32_R             0x19
+#define   OP_LSR_U32_R              0x1b
+#define   OP_LSLI_U32_S             0x29
+#define   OP_LSLI_S32_S             0x2d
+#define   OP_LSL_U32_S              0x2b
+#define   OP_LSL_S32_S              0x2f
+#define   OP_PASRI_S16              0x4
+#define   OP_PASR_S16               0x6
+#define   OP_PASRI_S16_R            0xc
+#define   OP_PASR_S16_R             0xe
+#define   OP_PLSRI_U16              0x10
+#define   OP_PLSR_U16               0x12
+#define   OP_PLSRI_U16_R            0x18
+#define   OP_PLSR_U16_R             0x1a
+#define   OP_PLSLI_U16              0x20
+#define   OP_PLSL_U16               0x22
+#define   OP_PLSLI_U16_S            0x28
+#define   OP_PLSLI_S16_S            0x2c
+#define   OP_PLSL_U16_S             0x2a
+#define   OP_PLSL_S16_S             0x2e
+
+#define DSPV2_PKG_begin             0x14
+#define DSPV2_PKG_end               0x17
+#define DSPV2_DEXT                  0x13
+#define DSPV2_PKG_CLIP              0x1b
+#define   OP_PKGLL_1st              0x2
+#define   OP_PKGLL_2nd              0x6
+#define   OP_PKGHH_1st              0x3
+#define   OP_PKGHH_2nd              0x7
+#define   OP_PEXT_U8_E              0x8
+#define   OP_PEXT_S8_E              0xc
+#define   OP_PEXTX_U8_E             0x9
+#define   OP_PEXTX_S8_E             0xd
+#define   OP_NARL_1st               0x10
+#define   OP_NARL_2nd               0x14
+#define   OP_NARH_1st               0x11
+#define   OP_NARH_2nd               0x15
+#define   OP_NARLX_1st              0x12
+#define   OP_NARLX_2nd              0x16
+#define   OP_NARHX_1st              0x13
+#define   OP_NARHX_2nd              0x17
+#define   OP_CLIPI_U32              0x18
+#define   OP_CLIPI_S32              0x1c
+#define   OP_CLIP_U32               0x19
+#define   OP_CLIP_S32               0x1d
+#define   OP_PCLIPI_U16             0x1a
+#define   OP_PCLIPI_S16             0x1e
+#define   OP_PCLIP_U16              0x1b
+#define   OP_PCLIP_S16              0x1f
+#define   OP_PABS_S8_S              0x24
+#define   OP_PABS_S16_S             0x25
+#define   OP_ABS_S32_S              0x26
+#define   OP_PNEG_S8_S              0x2c
+#define   OP_PNEG_S16_S             0x2d
+#define   OP_NEG_S32_S              0x2e
+#define   OP_DUP_8_begin            0x30
+#define   OP_DUP_8_end              0x37
+#define   OP_DUP_16_begin           0x38
+#define   OP_DUP_16_end             0x3f
+
+#define DSPV2_MUL_1st               0x10
+/* 32X32 -> 64 */
+#define   OP_MUL_U32                0x0
+#define   OP_MUL_S32                0x10
+#define   OP_MULA_U32               0x4
+#define   OP_MULA_S32               0x14
+#define   OP_MULS_U32               0x6
+#define   OP_MULS_S32               0x16
+#define   OP_MULA_U32_S             0xc
+#define   OP_MULA_S32_S             0x1c
+#define   OP_MULS_U32_S             0xe
+#define   OP_MULS_S32_S             0x1e
+#define   OP_MULA_32_L              0x22
+/* 32X32 -> 32(hi) */
+#define   OP_MUL_S32_H              0x20
+#define   OP_MUL_S32_RH             0x30
+#define   OP_RMUL_S32_H             0x28
+#define   OP_RMUL_S32_RH            0x38
+#define   OP_MULA_S32_HS            0x2c
+#define   OP_MULS_S32_HS            0x2e
+#define   OP_MULA_S32_RHS           0x3c
+#define   OP_MULS_S32_RHS           0x3e
+/* 16X16  , not SIMD */
+#define   OP_MULLL_S16              0x1
+#define   OP_MULHH_S16              0x13
+#define   OP_MULHL_S16              0x11
+#define   OP_RMULLL_S16             0x9
+#define   OP_RMULHH_S16             0x1b
+#define   OP_RMULHL_S16             0x19
+#define   OP_MULALL_S16_S           0xd
+#define   OP_MULAHH_S16_S           0x1f
+#define   OP_MULAHL_S16_S           0x1d
+#define   OP_MULALL_S16_E           0x5
+#define   OP_MULAHH_S16_E           0x17
+#define   OP_MULAHL_S16_E           0x7
+/* 16X16, SIMD */
+#define   OP_PMUL_U16               0x25
+#define   OP_PMULX_U16              0x27
+#define   OP_PMUL_S16               0x21
+#define   OP_PMULX_S16              0x23
+#define   OP_PRMUL_S16              0x29
+#define   OP_PRMULX_S16             0x2b
+#define   OP_PRMUL_S16_H            0x2d
+#define   OP_PRMUL_S16_RH           0x3d
+#define   OP_PRMULX_S16_H           0x2f
+#define   OP_PRMULX_S16_RH          0x3f
+
+#define DSPV2_MUL_2nd               0x11
+/* 32X32 -> 32(hi) */
+#define   OP_MULXL_S32              0x0
+#define   OP_MULXL_S32_R            0x10
+#define   OP_MULXH_S32              0x20
+#define   OP_MULXH_S32_R            0x30
+#define   OP_RMULXL_S32             0x8
+#define   OP_RMULXL_S32_R           0x18
+#define   OP_RMULXH_S32             0x28
+#define   OP_RMULXH_S32_R           0x38
+#define   OP_MULAXL_S32_S           0xc
+#define   OP_MULAXL_S32_RS          0x1c
+#define   OP_MULAXH_S32_S           0x2c
+#define   OP_MULAXH_S32_RS          0x3c
+/* 16X16 chain */
+#define   OP_MULCA_S16_S            0x9
+#define   OP_MULCAX_S16_S           0xb
+#define   OP_MULCS_S16              0x11
+#define   OP_MULCSR_S16             0x13
+#define   OP_MULCSX_S16             0x21
+/* 16X16, chain, accumulate */
+#define   OP_MULACA_S16_S           0xd
+#define   OP_MULACAX_S16_S          0xf
+#define   OP_MULACS_S16_S           0x1d
+#define   OP_MULACSR_S16_S          0x1f
+#define   OP_MULACSX_S16_S          0x2d
+#define   OP_MULSCA_S16_S           0x2f
+#define   OP_MULSCAX_S16_S          0x3d
+#define   OP_MULACA_S16_E           0x5
+#define   OP_MULACAX_S16_E          0x7
+#define   OP_MULACS_S16_E           0x15
+#define   OP_MULACSR_S16_E          0x17
+#define   OP_MULACSX_S16_E          0x25
+#define   OP_MULSCA_S16_E           0x27
+#define   OP_MULSCAX_S16_E          0x35
+
+/* sop for dsp v2 ld/st instructions */
+#define   OP_LDBI_B                 0x20
+#define   OP_LDBI_H                 0x21
+#define   OP_LDBI_W                 0x22
+#define   OP_PLDBI_D                0x23
+#define   OP_LDBI_BS                0x25
+#define   OP_LDBI_HS                0x24
+#define   OP_LDBIR_B                0x28
+#define   OP_LDBIR_H                0x29
+#define   OP_LDBIR_W                0x2a
+#define   OP_PLDBIR_D               0x2b
+#define   OP_LDBIR_BS               0x2c
+#define   OP_LDBIR_HS               0x2d
+#define   OP_STBI_B                 0x20
+#define   OP_STBI_H                 0x21
+#define   OP_STBI_W                 0x22
+#define   OP_STBIR_B                0x28
+#define   OP_STBIR_H                0x29
+#define   OP_STBIR_W                0x2a
+
+/* DSPv2 Macro end. */
+
+static inline void helper_update_psr(CPUCSKYState *env)
+{
+    env->cp0.psr &= ~0xc000c401;
+    env->cp0.psr |= env->psr_s << 31;
+    env->cp0.psr |= env->psr_t << 30;
+    env->cp0.psr |= env->psr_bm << 10;
+    env->cp0.psr |= env->psr_c;
+    env->cp0.psr |= env->psr_tm << 14;
+}
+
+static inline void helper_record_psr_bits(CPUCSKYState *env)
+{
+    env->psr_s = PSR_S(env->cp0.psr);
+    env->psr_t = PSR_T(env->cp0.psr);
+    env->psr_bm = PSR_BM(env->cp0.psr);
+    env->psr_c = PSR_C(env->cp0.psr);
+    env->psr_tm = PSR_TM(env->cp0.psr);
+}
+
+static inline void helper_switch_regs(CPUCSKYState *env)
+{
+    uint32_t temps[16];
+    if (env->features & (CPU_610 | CPU_807 | CPU_810)) {
+        memcpy(temps, env->regs, 16 * 4);
+        memcpy(env->regs, env->banked_regs, 16 * 4);
+        memcpy(env->banked_regs, temps, 16 * 4);
+    }
+}
+
+#ifdef TARGET_CSKYV2
+static inline void helper_save_sp(CPUCSKYState *env)
+{
+    if (env->psr_t && (env->features & ABIV2_TEE)) {
+        if ((env->cp0.psr & 0x2)
+            && (env->features & (CPU_807 | CPU_810))) {
+            env->stackpoint.t_asp = env->regs[14];
+        } else if (env->psr_s) {
+            env->stackpoint.t_ssp = env->regs[14];
+        } else {
+            env->stackpoint.t_usp = env->regs[14];
+        }
+    } else {
+        if ((env->cp0.psr & 0x2)
+            && (env->features & (CPU_807 | CPU_810))) {
+            env->stackpoint.nt_asp = env->regs[14];
+        } else if (env->psr_s) {
+            env->stackpoint.nt_ssp = env->regs[14];
+        } else {
+            env->stackpoint.nt_usp = env->regs[14];
+        }
+    }
+}
+
+static inline void helper_choose_sp(CPUCSKYState *env)
+{
+    if (env->psr_t && (env->features & ABIV2_TEE)) {
+        if ((env->cp0.psr & 0x2)
+            && (env->features & (CPU_807 | CPU_810))) {
+            env->regs[14] = env->stackpoint.t_asp;
+        } else if (env->psr_s) {
+            env->regs[14] = env->stackpoint.t_ssp;
+        } else {
+            env->regs[14] = env->stackpoint.t_usp;
+        }
+    } else {
+        if ((env->cp0.psr & 0x2)
+            && (env->features & (CPU_807 | CPU_810))) {
+            env->regs[14] = env->stackpoint.nt_asp;
+        } else if (env->psr_s) {
+            env->regs[14] = env->stackpoint.nt_ssp;
+        } else {
+            env->regs[14] = env->stackpoint.nt_usp;
+        }
+    }
+}
+
+static inline void helper_tee_save_cr(CPUCSKYState *env)
+{
+    if (env->psr_t) {
+        env->tee.t_vbr = env->cp0.vbr;
+        env->tee.t_epsr = env->cp0.epsr;
+        env->tee.t_epc = env->cp0.epc;
+        env->t_mmu = env->mmu;
+    } else {
+        env->tee.nt_vbr = env->cp0.vbr;
+        env->tee.nt_epsr = env->cp0.epsr;
+        env->tee.nt_epc = env->cp0.epc;
+        env->nt_mmu = env->mmu;
+    }
+}
+
+static inline void helper_tee_choose_cr(CPUCSKYState *env)
+{
+    if (env->psr_t) {
+        env->cp0.vbr = env->tee.t_vbr;
+        env->cp0.epsr = env->tee.t_epsr;
+        env->cp0.epc = env->tee.t_epc;
+        env->mmu = env->t_mmu;
+#if !defined(CONFIG_USER_ONLY)
+        env->tlb_context->tlb = env->tlb_context->t_tlb;
+        env->tlb_context->round_robin = env->tlb_context->t_round_robin;
+#endif
+    } else {
+        env->cp0.vbr = env->tee.nt_vbr;
+        env->cp0.epsr = env->tee.nt_epsr;
+        env->cp0.epc = env->tee.nt_epc;
+        env->mmu = env->nt_mmu;
+#if !defined(CONFIG_USER_ONLY)
+        env->tlb_context->tlb = env->tlb_context->nt_tlb;
+        env->tlb_context->round_robin = env->tlb_context->nt_round_robin;
+#endif
+    }
+}
+
+/* For ck_tee_lite, when change from Trust to Non-Trust world by NT-interrupt,
+ * need to push the GPRs to trust-supervised stack, and clear them. */
+static inline void helper_tee_save_gpr(CPUCSKYState *env)
+{
+    int32_t i;
+    if (env->features & CPU_801) {
+        for (i = 0; i <= 8; i++) {
+            env->stackpoint.t_ssp -= 4;
+            cpu_stl_data(env, env->stackpoint.t_ssp, env->regs[i]);
+            env->regs[i] = 0;
+        }
+        cpu_stl_data(env, env->stackpoint.t_ssp - 4, env->regs[13]);
+        env->regs[13] = 0;
+        cpu_stl_data(env, env->stackpoint.t_ssp - 8, env->regs[15]);
+        env->regs[15] = 0;
+        env->stackpoint.t_ssp -= 8;
+    } else if (env->features & CPU_802) {
+        for (i = 0; i <= 13; i++) {
+            env->stackpoint.t_ssp -= 4;
+            cpu_stl_data(env, env->stackpoint.t_ssp, env->regs[i]);
+            env->regs[i] = 0;
+        }
+        cpu_stl_data(env, env->stackpoint.t_ssp - 4, env->regs[15]);
+        env->regs[15] = 0;
+        env->stackpoint.t_ssp -= 4;
+    } else if (env->features & CPU_803S) {
+        for (i = 0; i <= 13; i++) {
+            env->stackpoint.t_ssp -= 4;
+            cpu_stl_data(env, env->stackpoint.t_ssp, env->regs[i]);
+            env->regs[i] = 0;
+        }
+        cpu_stl_data(env, env->stackpoint.t_ssp - 4, env->regs[15]);
+        env->regs[15] = 0;
+        cpu_stl_data(env, env->stackpoint.t_ssp - 8, env->regs[28]);
+        env->regs[28] = 0;
+        env->stackpoint.t_ssp -= 8;
+    }
+}
+
+/* For ck_tee_lite, when return from NT-interrupt which change the world from
+ * Trust to Non-Trust world before, need to pop the GPRs from
+ * trust-supervised stack. */
+static inline void helper_tee_restore_gpr(CPUCSKYState *env)
+{
+    int32_t i;
+    if (env->features & CPU_801) {
+        env->regs[15] = cpu_ldl_data(env, env->stackpoint.t_ssp);
+        env->regs[13] = cpu_ldl_data(env, env->stackpoint.t_ssp + 4);
+        env->stackpoint.t_ssp += 8;
+        for (i = 8; i >= 0; i--) {
+            env->regs[i] = cpu_ldl_data(env, env->stackpoint.t_ssp);
+            env->stackpoint.t_ssp += 4;
+        }
+    } else if (env->features & CPU_802) {
+        env->regs[15] = cpu_ldl_data(env, env->stackpoint.t_ssp);
+        env->stackpoint.t_ssp += 4;
+        for (i = 13; i >= 0; i--) {
+            env->regs[i] = cpu_ldl_data(env, env->stackpoint.t_ssp);
+            env->stackpoint.t_ssp += 4;
+        }
+    } else if (env->features & CPU_803S) {
+        env->regs[28] = cpu_ldl_data(env, env->stackpoint.t_ssp);
+        env->regs[15] = cpu_ldl_data(env, env->stackpoint.t_ssp + 4);
+        env->stackpoint.t_ssp += 8;
+        for (i = 13; i >= 0; i--) {
+            env->regs[i] = cpu_ldl_data(env, env->stackpoint.t_ssp);
+            env->stackpoint.t_ssp += 4;
+        }
+    }
+}
+#endif
+
+static inline int has_insn(DisasContext *ctx, uint32_t flags)
+{
+    if (ctx->features & flags) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
+
+static inline void print_exception(DisasContext *ctx, int excp)
+{
+    switch (excp) {
+    case EXCP_CSKY_RESET:
+    case EXCP_CSKY_ALIGN:
+    case EXCP_CSKY_DATA_ABORT:
+    case EXCP_CSKY_DIV:
+    case EXCP_CSKY_UDEF:
+    case EXCP_CSKY_PRIVILEGE:
+    case EXCP_CSKY_TRACE:
+    case EXCP_CSKY_BKPT:
+    case EXCP_CSKY_URESTORE:
+    case EXCP_CSKY_IDLY4:
+    case EXCP_CSKY_HAI:
+        qemu_log_mask(LOG_GUEST_ERROR, "##exception No = 0x%x\n", excp);
+        qemu_log_mask(LOG_GUEST_ERROR, "##exception pc = 0x%x\n", ctx->pc);
+        break;
+    default:
+        break;
+    }
+}
+#endif
diff --git a/target-csky/translate_v1.c b/target-csky/translate_v1.c
new file mode 100644
index 0000000..420473f
--- /dev/null
+++ b/target-csky/translate_v1.c
@@ -0,0 +1,3211 @@
+/*
+ *  csky_v1 translation
+ *
+ *  Copyright (c) 2003 Fabrice Bellard
+ *  Copyright (c) 2011 C-SKY Microsystems, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "cpu.h"
+#include "translate.h"
+#include "disas/disas.h"
+#include "exec/exec-all.h"
+#include "exec/cpu_ldst.h"
+#include "exec/log.h"
+#include "tcg-op.h"
+#include "trace-tcg.h"
+#include "qemu/log.h"
+#include "exec/gdbstub.h"
+
+#include "exec/helper-proto.h"
+#include "exec/helper-gen.h"
+
+static const char *regnames[] = {
+    "sp", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15" };
+
+static TCGv_env cpu_env;
+static TCGv_i32 cpu_R[16];
+static TCGv_i32 cpu_c;
+static TCGv_i32 cpu_v;
+static TCGv_i32 cpu_s;
+static TCGv_i32 cpu_hi ;
+static TCGv_i32 cpu_lo;
+static TCGv_i32 cpu_hi_guard;
+static TCGv_i32 cpu_lo_guard;
+
+#include "exec/gen-icount.h"
+
+#if defined(CONFIG_USER_ONLY)
+#define IS_SUPER(dc)  0
+#else
+#define IS_SUPER(dc)  (dc->super)
+#endif
+
+/* initialize TCG globals. */
+void csky_translate_init(void)
+{
+    int i;
+
+    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, "env");
+    tcg_ctx.tcg_env = cpu_env;
+
+    for (i = 0; i < 16; i++) {
+        cpu_R[i] = tcg_global_mem_new_i32(cpu_env,
+                            offsetof(CPUCSKYState, regs[i]),
+                            regnames[i]);
+    }
+    cpu_c = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, psr_c), "cpu_c");
+    cpu_v = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, dcsr_v), "cpu_v");
+    cpu_s = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, psr_s), "cpu_s");
+    cpu_hi = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, hi), "cpu_hi");
+    cpu_lo = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, lo), "cpu_lo");
+    cpu_hi_guard = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, hi_guard), "cpu_hi_guard");
+    cpu_lo_guard = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, lo_guard), "cpu_lo_guard");
+
+}
+
+
+static inline TCGv load_cpu_offset(int offset)
+{
+    TCGv tmp = tcg_temp_new();
+    tcg_gen_ld_i32(tmp, cpu_env, offset);
+    return tmp;
+}
+
+#define load_cpu_field(name) load_cpu_offset(offsetof(CPUCSKYState, name))
+
+static inline void store_cpu_offset(TCGv var, int offset)
+{
+    tcg_gen_st_i32(var, cpu_env, offset);
+}
+
+#define store_cpu_field(var, name) \
+store_cpu_offset(var, offsetof(CPUCSKYState, name))
+
+static inline void gen_save_pc(target_ulong pc)
+{
+    TCGv t0 = tcg_temp_new();
+
+    t0 = tcg_const_i32(pc);
+    store_cpu_field(t0, pc);
+
+    tcg_temp_free(t0);
+}
+
+static inline void generate_exception(DisasContext *ctx, int excp)
+{
+    TCGv t0 = tcg_temp_new();
+
+    print_exception(ctx, excp);
+
+    t0 = tcg_const_i32(excp);
+    gen_save_pc(ctx->pc);
+    gen_helper_exception(cpu_env, t0);
+    ctx->is_jmp = DISAS_UPDATE;
+
+    tcg_temp_free(t0);
+}
+
+static inline bool use_goto_tb(DisasContext *s, uint32_t dest)
+{
+#ifndef CONFIG_USER_ONLY
+    return (s->tb->pc & TARGET_PAGE_MASK) == (dest & TARGET_PAGE_MASK) ||
+           (s->pc & TARGET_PAGE_MASK) == (dest & TARGET_PAGE_MASK);
+#else
+    return true;
+#endif
+}
+
+static inline void gen_goto_tb(DisasContext *ctx, int n, uint32_t dest)
+{
+    TranslationBlock *tb;
+    TCGv t0 = tcg_temp_new();
+
+    tb = ctx->tb;
+
+    if (unlikely(ctx->singlestep_enabled)) {
+        gen_save_pc(dest);
+        t0 = tcg_const_tl(EXCP_DEBUG);
+        gen_helper_exception(cpu_env, t0);
+    }
+#if !defined(CONFIG_USER_ONLY)
+    else if (unlikely((ctx->trace_mode == INST_TRACE_MODE)
+                || (ctx->trace_mode == BRAN_TRACE_MODE))) {
+        gen_save_pc(dest);
+        t0 = tcg_const_tl(EXCP_CSKY_TRACE);
+        gen_helper_exception(cpu_env, t0);
+        ctx->maybe_change_flow = 1;
+    }
+#endif
+    else if (use_goto_tb(ctx, dest)) {
+        tcg_gen_goto_tb(n);
+        gen_save_pc(dest);
+        tcg_gen_exit_tb((uintptr_t)tb + n);
+    } else {
+        gen_save_pc(dest);
+        tcg_gen_exit_tb(0);
+    }
+
+    tcg_temp_free(t0);
+}
+
+static inline void check_insn(DisasContext *ctx, uint32_t flags)
+{
+    if (unlikely(!has_insn(ctx, flags))) {
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+    }
+}
+
+#ifndef CONFIG_USER_ONLY
+/* generate mfcr instruction */
+static inline void gen_mfcr(DisasContext *ctx, uint32_t rz, uint32_t cr_num)
+{
+    TCGv t0;
+
+    switch (cr_num) {
+    case 0x0:
+        /* cr0 psr */
+        gen_helper_mfcr_cr0(cpu_R[rz], cpu_env);
+        break;
+    case 0x1:
+        /* vbr */
+        t0 = load_cpu_field(cp0.vbr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x2:
+        /* epsr */
+        t0 = load_cpu_field(cp0.epsr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x3:
+        /* fpsr */
+        t0 = load_cpu_field(cp0.fpsr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x4:
+        /* epc */
+        t0 = load_cpu_field(cp0.epc);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x5:
+        /* fpc */
+        t0 = load_cpu_field(cp0.fpc);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x6:
+        /* ss0 */
+        t0 = load_cpu_field(cp0.ss0);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x7:
+        /* ss1 */
+        t0 = load_cpu_field(cp0.ss1);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x8:
+        /* ss2 */
+        t0 = load_cpu_field(cp0.ss2);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x9:
+        /* ss3 */
+        t0 = load_cpu_field(cp0.ss3);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xa:
+        /* ss4 */
+        t0 = load_cpu_field(cp0.ss4);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xb:
+        /* gcr */
+        t0 = load_cpu_field(cp0.gcr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xc:
+        /* gsr */
+        t0 = load_cpu_field(cp0.gsr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xd:
+        /* cpidr */
+        t0 = load_cpu_field(cp0.cpidr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xe:
+        /* cr14 dcsr */
+        t0 = load_cpu_field(cp0.dcsr);
+        tcg_gen_andi_tl(cpu_R[rz], t0, ~0x1);
+        t0 = load_cpu_field(dcsr_v);
+        tcg_gen_or_tl(cpu_R[rz], cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xf:
+        /* cpwr */
+        t0 = load_cpu_field(cp0.cpwr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x10:
+        /* no CR16 */
+        break;
+    case 0x11:
+        /* cfr */
+        t0 = load_cpu_field(cp0.cfr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x12:
+        /* ccr */
+        t0 = load_cpu_field(cp0.ccr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+
+        tcg_temp_free(t0);
+        break;
+    case 0x13:
+        /* capr */
+        t0 = load_cpu_field(cp0.capr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x14:
+        /* cr20 pacr */
+        gen_helper_mfcr_cr20(cpu_R[rz], cpu_env);
+        break;
+    case 0x15:
+        /* prsr */
+        t0 = load_cpu_field(cp0.prsr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    default:
+        break;
+    }
+}
+
+/* generate mtcr instruction */
+static inline void gen_mtcr(DisasContext *ctx, uint32_t cr_num, uint32_t rx)
+{
+
+    switch (cr_num) {
+    case 0x0:
+        /* psr */
+        gen_helper_mtcr_cr0(cpu_env, cpu_R[rx]);
+        gen_save_pc(ctx->pc + 2);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x1:
+        /* vbr */
+        {
+            TCGv t0 = tcg_temp_new();
+
+            tcg_gen_andi_tl(t0, cpu_R[rx], ~0x3ff);
+            store_cpu_field(t0, cp0.vbr);
+
+            tcg_temp_free(t0);
+        }
+        break;
+    case 0x2:
+        /* epsr */
+        store_cpu_field(cpu_R[rx], cp0.epsr);
+        break;
+    case 0x3:
+        /* fpsr */
+        store_cpu_field(cpu_R[rx], cp0.fpsr);
+        break;
+    case 0x4:
+        /* epc */
+        store_cpu_field(cpu_R[rx], cp0.epc);
+        break;
+    case 0x5:
+        /* fpc */
+        store_cpu_field(cpu_R[rx], cp0.fpc);
+        break;
+    case 0x6:
+        /* ss0 */
+        store_cpu_field(cpu_R[rx], cp0.ss0);
+        break;
+    case 0x7:
+        /* ss1 */
+        store_cpu_field(cpu_R[rx], cp0.ss1);
+        break;
+    case 0x8:
+        /* ss2 */
+        store_cpu_field(cpu_R[rx], cp0.ss2);
+        break;
+    case 0x9:
+        /* ss3 */
+        store_cpu_field(cpu_R[rx], cp0.ss3);
+        break;
+    case 0xa:
+        /* ss4 */
+        store_cpu_field(cpu_R[rx], cp0.ss4);
+        break;
+    case 0xb:
+        /* gcr */
+        store_cpu_field(cpu_R[rx], cp0.gcr);
+        break;
+    case 0xc:
+        /* gsr */
+        /* Read only */
+        break;
+    case 0xd:
+        /* cpidr */
+        /* Read only */
+        break;
+    case 0xe:
+        /* dcsr */
+        {
+            TCGv t0, t1;
+
+            t0 = load_cpu_field(cp0.dcsr);
+            t1 = load_cpu_field(dcsr_v);
+            tcg_gen_andi_tl(t0, t0, ~0x1);
+            tcg_gen_or_tl(t1, t1, t0);
+            store_cpu_field(t1, cp0.dcsr);
+
+            tcg_temp_free(t0);
+            tcg_temp_free(t1);
+        }
+        break;
+    case 0xf:
+        /* cpwr */
+        /* FIXME */
+        store_cpu_field(cpu_R[rx], cp0.cpwr);
+        break;
+    case 0x10:
+        /* no CR16 */
+        break;
+    case 0x11:
+        /* cfr */
+        store_cpu_field(cpu_R[rx], cp0.cfr);
+        break;
+    case 0x12:
+        /* ccr */
+        gen_helper_mtcr_cr18(cpu_env, cpu_R[rx]);
+        gen_save_pc(ctx->pc + 2);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x13:
+        /* capr */
+        store_cpu_field(cpu_R[rx], cp0.capr);
+        break;
+    case 0x14:
+        /* pacr */
+        gen_helper_mtcr_cr20(cpu_env, cpu_R[rx]);
+        gen_save_pc(ctx->pc + 2);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x15:
+        /* psrsr */
+        store_cpu_field(cpu_R[rx], cp0.prsr);
+        break;
+    default:
+        break;
+    }
+}
+
+/* Read MMU Coprocessor Contronl Registers */
+static inline void
+gen_cprcr_cp15(DisasContext *ctx, uint32_t rz, uint32_t cr_num)
+{
+    TCGv t0;
+
+    switch (cr_num) {
+    case 0x0:
+        /* MIR */
+        t0 = load_cpu_field(mmu.mir);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x1:
+        /* MRR */
+        t0 = load_cpu_field(mmu.mrr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x2:
+        /* MEL0 */
+        t0 = load_cpu_field(mmu.mel0);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x3:
+        /* MEL1 */
+        t0 = load_cpu_field(mmu.mel1);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x4:
+        /* MEH */
+        t0 = load_cpu_field(mmu.meh);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x5:
+        /* MCR */
+        t0 = load_cpu_field(mmu.mcr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x6:
+        /* MPR */
+        t0 = load_cpu_field(mmu.mpr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x7:
+        /* MWR */
+        t0 = load_cpu_field(mmu.mwr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x8:
+        /* MCIR */
+        t0 = load_cpu_field(mmu.mcir);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x9:
+        /* CP15_CR9 */
+        t0 = load_cpu_field(mmu.cr9);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xa:
+        /* CP15_CR10 */
+        t0 = load_cpu_field(mmu.cr10);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xb:
+        /* CP15_CR11 */
+        t0 = load_cpu_field(mmu.cr11);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xc:
+        /* CP15_CR12 */
+        t0 = load_cpu_field(mmu.cr12);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0xd:
+        /* CP15_CR13 */
+        t0 = load_cpu_field(mmu.cr13);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0xe:
+        /* CP15_CR14 */
+        t0 = load_cpu_field(mmu.cr14);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0xf:
+        /* CP15_CR15 */
+        t0 = load_cpu_field(mmu.cr15);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x10:
+        /* CP15_CR16 */
+        t0 = load_cpu_field(mmu.cr16);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x1d:
+        /* CP15_mpar */
+        t0 = load_cpu_field(mmu.mpar);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    default:
+        break;
+    }
+}
+
+/* Write MMU Coprocessor Contronl Registers */
+static inline void
+gen_cpwcr_cp15(DisasContext *ctx, uint32_t cr_num, uint32_t rx)
+{
+    switch (cr_num) {
+    case 0x0:
+        /* MIR */
+        store_cpu_field(cpu_R[rx], mmu.mir);
+        break;
+    case 0x1:
+        /* MRR */
+        store_cpu_field(cpu_R[rx], mmu.mrr);
+        break;
+    case 0x2:
+        /* MEL0 */
+        store_cpu_field(cpu_R[rx], mmu.mel0);
+        break;
+    case 0x3:
+        /* MEL1 */
+        store_cpu_field(cpu_R[rx], mmu.mel1);
+        break;
+    case 0x4:
+        /* MEH */
+        gen_helper_meh_write(cpu_env, cpu_R[rx]);
+        gen_save_pc(ctx->pc + 2);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x5:
+        /* MCR */
+        store_cpu_field(cpu_R[rx], mmu.mcr);
+        break;
+    case 0x6:
+        /* MPR */
+        store_cpu_field(cpu_R[rx], mmu.mpr);
+        break;
+    case 0x7:
+        /* MWR */
+        store_cpu_field(cpu_R[rx], mmu.mwr);
+        break;
+    case 0x8:
+        /* MCIR */
+        gen_helper_mcir_write(cpu_env, cpu_R[rx]);
+        gen_save_pc(ctx->pc + 2);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x9:
+        /* FIXME SPM is not implement yet */
+        /* CP15_CR9 */
+        store_cpu_field(cpu_R[rx], mmu.cr9);
+        break;
+    case 0xa:
+        /* CP15_CR10 */
+        store_cpu_field(cpu_R[rx], mmu.cr10);
+        break;
+    case 0xb:
+        /* CP15_CR11 */
+        store_cpu_field(cpu_R[rx], mmu.cr11);
+        break;
+    case 0xc:
+        /* CP15_CR12 */
+        store_cpu_field(cpu_R[rx], mmu.cr12);
+        break;
+    case 0xd:
+        /* CP15_CR13 */
+        store_cpu_field(cpu_R[rx], mmu.cr13);
+        break;
+    case 0xe:
+        /* CP15_CR14 */
+        store_cpu_field(cpu_R[rx], mmu.cr14);
+        break;
+    case 0xf:
+        /* CP15_CR15 */
+        store_cpu_field(cpu_R[rx], mmu.cr15);
+        break;
+    case 0x10:
+        /* CP15_CR16 */
+        store_cpu_field(cpu_R[rx], mmu.cr16);
+        break;
+    case 0x1d:
+        /* CP15_mpar */
+        store_cpu_field(cpu_R[rx], mmu.mpar);
+        gen_save_pc(ctx->pc + 2);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    default:
+        break;
+    }
+}
+#endif /* !CONFIG_USER_ONLY */
+
+static inline void tstnbz(int rx)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGLabel *l1 = gen_new_label();
+    tcg_gen_movi_tl(cpu_c, 0);
+    tcg_gen_andi_tl(t0, cpu_R[rx], 0xff000000);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
+    tcg_gen_andi_tl(t0, cpu_R[rx], 0x00ff0000);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
+    tcg_gen_andi_tl(t0, cpu_R[rx], 0x0000ff00);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
+    tcg_gen_andi_tl(t0, cpu_R[rx], 0x000000ff);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
+    tcg_gen_movi_tl(cpu_c, 1);
+    gen_set_label(l1);
+
+    tcg_temp_free(t0);
+}
+
+static inline void mac(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+
+    tcg_gen_extu_tl_i64(t0, cpu_R[rx]);
+    tcg_gen_extu_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_concat_tl_i64(t1, cpu_lo, cpu_hi);
+    tcg_gen_add_i64(t0, t0, t1);
+
+    tcg_gen_trunc_i64_tl(cpu_lo, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_trunc_i64_tl(cpu_hi, t0);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void addc(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    tcg_gen_mov_tl(t0, cpu_R[rx]);
+    tcg_gen_add_tl(cpu_R[rx], cpu_R[rx], cpu_R[ry]);
+    tcg_gen_add_tl(cpu_R[rx], cpu_R[rx], cpu_c);
+    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 0, l1);
+    tcg_gen_setcond_tl(TCG_COND_LTU, cpu_c, cpu_R[rx], t0);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+    tcg_gen_setcond_tl(TCG_COND_LEU, cpu_c, cpu_R[rx], t0);
+    gen_set_label(l2);
+
+    tcg_temp_free(t0);
+}
+
+static inline void subc(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    tcg_gen_subfi_tl(t0, 1, cpu_c);
+    tcg_gen_mov_tl(t1, cpu_R[rx]);
+    tcg_gen_sub_tl(cpu_R[rx], cpu_R[rx], cpu_R[ry]);
+    tcg_gen_sub_tl(cpu_R[rx], cpu_R[rx], t0);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
+    tcg_gen_setcond_tl(TCG_COND_GTU, cpu_c, t1, cpu_R[ry]);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+    tcg_gen_setcond_tl(TCG_COND_GEU, cpu_c, t1, cpu_R[ry]);
+    gen_set_label(l2);
+
+}
+
+static inline void lsr(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGv t1 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_movi_tl(t1, 0);
+    tcg_gen_andi_tl(t0, cpu_R[ry], 0x3f);
+    tcg_gen_brcondi_tl(TCG_COND_GTU, t0, 31, l1);
+    tcg_gen_shr_tl(t1, cpu_R[rx], t0);
+    gen_set_label(l1);
+    tcg_gen_mov_tl(cpu_R[rx], t1);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static inline void lsl(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGv t1 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_movi_tl(t1, 0);
+    tcg_gen_andi_tl(t0, cpu_R[ry], 0x3f);
+    tcg_gen_brcondi_tl(TCG_COND_GTU, t0, 31, l1);
+    tcg_gen_shl_tl(t1, cpu_R[rx], t0);
+    gen_set_label(l1);
+    tcg_gen_mov_tl(cpu_R[rx], t1);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static inline void bgenr(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGv t1 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+    tcg_gen_mov_tl(t1, cpu_R[ry]);  /* maybe rx==ry, so ry's saved in temp */
+    tcg_gen_movi_tl(cpu_R[rx], 0);
+    tcg_gen_andi_tl(t0, t1, 0x20);
+    tcg_gen_brcondi_tl(TCG_COND_NE, t0, 0, l1);
+    tcg_gen_andi_tl(t1, t1, 0x1f);
+    tcg_gen_movi_tl(t0, 1);
+    tcg_gen_shl_tl(cpu_R[rx], t0, t1);
+    gen_set_label(l1);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static inline void asr(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+    tcg_gen_andi_tl(t0, cpu_R[ry], 0x3f);
+    tcg_gen_brcondi_tl(TCG_COND_LEU, t0, 31, l1);
+    tcg_gen_movi_tl(t0, 31);
+    gen_set_label(l1);
+    tcg_gen_sar_tl(cpu_R[rx], cpu_R[rx], t0);
+
+    tcg_temp_free(t0);
+}
+
+
+static inline void divu(DisasContext *ctx, int rx)
+{
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+
+    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[1], 0, l1);
+    tcg_gen_divu_tl(cpu_R[rx], cpu_R[rx], cpu_R[1]);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+
+    TCGv t0 = tcg_temp_new();
+
+    t0 = tcg_const_i32(EXCP_CSKY_DIV);
+    gen_save_pc(ctx->pc);
+    gen_helper_exception(cpu_env, t0);
+    ctx->is_jmp = DISAS_NEXT;
+
+    tcg_temp_free(t0);
+
+    gen_set_label(l2);
+}
+
+static inline void divs(DisasContext *ctx, int rx)
+{
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+
+    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[1], 0, l1);
+    tcg_gen_div_tl(cpu_R[rx], cpu_R[rx], cpu_R[1]);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+
+    TCGv t0 = tcg_temp_new();
+
+    t0 = tcg_const_i32(EXCP_CSKY_DIV);
+    gen_save_pc(ctx->pc);
+    gen_helper_exception(cpu_env, t0);
+    ctx->is_jmp = DISAS_NEXT;
+
+    tcg_temp_free(t0);
+
+    gen_set_label(l2);
+}
+
+static inline void xsr(int rx)
+{
+    TCGv t0 = tcg_temp_new();
+
+    tcg_gen_andi_tl(t0, cpu_R[rx], 0x1);
+    tcg_gen_shri_tl(cpu_R[rx], cpu_R[rx], 1);
+    tcg_gen_shli_tl(cpu_c, cpu_c, 31);
+    tcg_gen_or_tl(cpu_R[rx], cpu_R[rx], cpu_c);
+    tcg_gen_mov_tl(cpu_c, t0);
+
+    tcg_temp_free(t0);
+}
+
+static inline void muls(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+
+    tcg_gen_movi_tl(cpu_v, 0);
+    tcg_gen_movi_tl(cpu_lo_guard, 0x00000000);
+    tcg_gen_movi_tl(cpu_hi_guard, 0x00000000);
+    tcg_gen_ext_tl_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_trunc_i64_tl(cpu_lo, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_extrl_i64_i32(cpu_hi, t0);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void mulsa(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_new_i64();
+    TCGv_i64 t4 = tcg_temp_new_i64();
+
+    tcg_gen_ext_tl_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_concat_i32_i64(t1, cpu_lo, cpu_hi);
+    tcg_gen_add_i64(t2, t0, t1);
+
+    tcg_gen_xor_i64(t3, t0, t1);
+    tcg_gen_xor_i64(t4, t0, t2);
+    tcg_gen_andc_i64(t4, t4, t3);
+
+    TCGv_i64 tx = tcg_temp_new_i64();
+    tcg_gen_shri_i64(tx, t4, 63);
+    tcg_gen_mov_i32(cpu_v, MAKE_TCGV_I32(GET_TCGV_I64(tx)));
+    tcg_temp_free_i64(tx);
+
+    tcg_gen_trunc_i64_tl(cpu_lo, t2);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_trunc_i64_tl(cpu_hi, t2);
+
+    tcg_gen_movi_tl(cpu_lo_guard, 0x00000000);
+    tcg_gen_movi_tl(cpu_hi_guard, 0x00000000);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+    tcg_temp_free_i64(t4);
+}
+
+static inline void mulss(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_new_i64();
+    TCGv_i64 t4 = tcg_temp_new_i64();
+
+    tcg_gen_ext_tl_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_concat_i32_i64(t1, cpu_lo, cpu_hi);
+    tcg_gen_sub_i64(t2, t1, t0);
+
+    tcg_gen_xor_i64(t3, t0, t1);
+    tcg_gen_xor_i64(t4, t0, t2);
+    tcg_gen_andc_i64(t4, t3, t4);
+
+    TCGv_i64 tx = tcg_temp_new_i64();
+    tcg_gen_shri_i64(tx, t4, 63);
+    tcg_gen_mov_i32(cpu_v, MAKE_TCGV_I32(GET_TCGV_I64(tx)));
+    tcg_temp_free_i64(tx);
+
+    tcg_gen_shri_i64(t3, t2, 63);
+    tcg_gen_trunc_i64_tl(cpu_lo, t2);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_trunc_i64_tl(cpu_hi, t2);
+
+    tcg_gen_movi_tl(cpu_lo_guard, 0x00000000);
+    tcg_gen_movi_tl(cpu_hi_guard, 0x00000000);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+    tcg_temp_free_i64(t4);
+
+}
+
+static inline void mulu(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+
+    tcg_gen_movi_tl(cpu_v, 0);
+    tcg_gen_movi_tl(cpu_lo_guard, 0x00000000);
+    tcg_gen_movi_tl(cpu_hi_guard, 0x00000000);
+
+    tcg_gen_extu_tl_i64(t0, cpu_R[rx]);
+    tcg_gen_extu_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_trunc_i64_tl(cpu_lo, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_extrl_i64_i32(cpu_hi, t0);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void mulua(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+
+    tcg_gen_extu_tl_i64(t0, cpu_R[rx]);
+    tcg_gen_extu_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t1, t0);
+    tcg_gen_concat_i32_i64(t1, cpu_lo, cpu_hi);
+    tcg_gen_add_i64(t2, t1, t0);
+
+    tcg_gen_trunc_i64_tl(cpu_lo, t2);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_trunc_i64_tl(cpu_hi, t2);
+    TCGv_i64 tx = tcg_temp_new_i64();
+    tcg_gen_setcond_i64(TCG_COND_LT, tx, t2, t1);
+    tcg_gen_extrl_i64_i32(cpu_v, tx);
+    tcg_temp_free_i64(tx);
+
+    tcg_gen_movi_tl(cpu_lo_guard, 0x00000000);
+    tcg_gen_movi_tl(cpu_hi_guard, 0x00000000);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+}
+
+static inline void mulus(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+
+    tcg_gen_extu_tl_i64(t0, cpu_R[rx]);
+    tcg_gen_extu_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t1, t0);
+    tcg_gen_concat_i32_i64(t1, cpu_lo, cpu_hi);
+
+    TCGv_i64 tx = tcg_temp_new_i64();
+    tcg_gen_setcond_i64(TCG_COND_LT, tx, t1, t0);
+    tcg_gen_extrl_i64_i32(cpu_v, tx);
+    tcg_temp_free_i64(tx);
+    tcg_gen_sub_i64(t2, t1, t0);
+
+    tcg_gen_trunc_i64_tl(cpu_lo, t2);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_trunc_i64_tl(cpu_hi, t2);
+
+    tcg_gen_movi_tl(cpu_lo_guard, 0x00000000);
+    tcg_gen_movi_tl(cpu_hi_guard, 0x00000000);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+
+}
+
+static inline void mulsha(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_new();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_local_new_i64();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t0, cpu_R[rx]);
+    tcg_gen_ext16s_tl(t1, cpu_R[ry]);
+    tcg_gen_mul_tl(t0, t0, t1);
+    tcg_gen_ext_tl_i64(t2, t0);
+    tcg_gen_concat_i32_i64(t3, cpu_lo, cpu_lo_guard);
+    tcg_gen_add_i64(t2, t3, t2);
+    tcg_gen_extrl_i64_i32(cpu_lo, t2);
+    tcg_gen_shri_i64(t3, t2, 31);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t2);
+    tcg_gen_movi_i32(cpu_v, 0);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t3, 0x0, l1);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t3, 0x1ffffffffLL, l1);
+    tcg_gen_movi_i32(cpu_v, 1);
+    gen_set_label(l1);
+
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+}
+
+static inline void mulshs(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_new();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_local_new_i64();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t0, cpu_R[rx]);
+    tcg_gen_ext16s_tl(t1, cpu_R[ry]);
+    tcg_gen_mul_tl(t0, t0, t1);
+    tcg_gen_ext_tl_i64(t2, t0);
+    tcg_gen_concat_i32_i64(t3, cpu_lo, cpu_lo_guard);
+    tcg_gen_sub_i64(t2, t3, t2);
+    tcg_gen_extrl_i64_i32(cpu_lo, t2);
+    tcg_gen_shri_i64(t3, t2, 31);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t2);
+    tcg_gen_movi_i32(cpu_v, 0);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t3, 0x0, l1);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t3, 0x1ffffffffLL, l1);
+    tcg_gen_movi_i32(cpu_v, 1);
+    gen_set_label(l1);
+
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+
+}
+
+static inline void mulsw(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv t2 = tcg_temp_new();
+
+    tcg_gen_ext16s_tl(t2, cpu_R[rx]);
+    tcg_gen_ext_tl_i64(t0, t2);
+    tcg_gen_ext_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_shri_i64(t0, t0, 16);
+    tcg_gen_extrl_i64_i32(cpu_R[rx], t0);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free(t2);
+}
+
+static inline void mulswa(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv_i64 t1 = tcg_temp_local_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t0, cpu_R[rx]) ;
+    tcg_gen_ext_tl_i64(t1, t0);
+    tcg_gen_ext_tl_i64(t2, cpu_R[ry]);
+    tcg_gen_mul_i64(t1, t1, t2) ;
+    tcg_gen_shri_i64(t1, t1, 16);
+    tcg_gen_concat_i32_i64(t2, cpu_lo, cpu_lo_guard);
+    tcg_gen_add_i64(t2, t2, t1);
+    tcg_gen_extrl_i64_i32(cpu_lo, t2);
+    tcg_gen_shri_i64(t1, t2, 31);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t2);
+    tcg_gen_movi_i32(cpu_v, 0);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t1, 0x0, l1);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t1, 0x1ffffffffLL, l1);
+    tcg_gen_movi_i32(cpu_v, 1);
+    gen_set_label(l1);
+
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+
+}
+
+
+static inline void mulsws(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv_i64 t1 = tcg_temp_local_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, t0);
+    tcg_gen_ext_i32_i64(t2, cpu_R[ry]);
+    tcg_gen_mul_i64(t1, t1, t2);
+    tcg_gen_shri_i64(t1, t1, 16);
+    tcg_gen_concat_i32_i64(t2, cpu_lo, cpu_lo_guard);
+    tcg_gen_sub_i64(t2, t2, t1);
+    tcg_gen_extrl_i64_i32(cpu_lo, t2);
+    tcg_gen_shri_i64(t1, t2, 31);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t2);
+    tcg_gen_movi_i32(cpu_v, 0);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t1, 0x0, l1);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t1, 0x1ffffffffLL, l1);
+    tcg_gen_movi_i32(cpu_v, 1);
+    gen_set_label(l1);
+
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+
+}
+
+
+
+static inline void vmulsh(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_new();
+
+    tcg_gen_movi_tl(cpu_v, 0);
+    tcg_gen_ext16s_tl(t0, cpu_R[rx]);
+    tcg_gen_ext16s_tl(t1, cpu_R[ry]);
+    tcg_gen_mul_tl(cpu_lo, t0, t1);
+    tcg_gen_sari_tl(cpu_lo_guard, cpu_lo, 31);
+    tcg_gen_sari_tl(t0, cpu_R[rx], 16);
+    tcg_gen_sari_tl(t1, cpu_R[ry], 16);
+    tcg_gen_mul_tl(cpu_hi, t0, t1);
+    tcg_gen_sari_tl(cpu_hi_guard, cpu_hi, 31);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+
+}
+
+
+static inline void vmulsha(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv t3 = tcg_temp_new();
+    TCGv t4 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t3, cpu_R[rx]);
+    tcg_gen_ext16s_tl(t4,  cpu_R[ry]);
+    tcg_gen_mul_tl(t3, t3, t4);
+    tcg_gen_concat_i32_i64(t1, cpu_lo, cpu_lo_guard);
+    tcg_gen_ext_tl_i64(t0, t3);
+    tcg_gen_add_i64(t0, t0, t1);
+    tcg_gen_extrl_i64_i32(cpu_lo, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t0);
+
+    tcg_gen_sari_tl(t3, cpu_R[rx], 16);
+    tcg_gen_sari_tl(t4, cpu_R[ry], 16);
+    tcg_gen_mul_tl(t3, t3, t4);
+    tcg_gen_concat_i32_i64(t1, cpu_hi, cpu_hi_guard);
+    tcg_gen_ext_tl_i64(t0, t3) ;
+    tcg_gen_add_i64(t0, t0, t1);
+    tcg_gen_extrl_i64_i32(cpu_hi, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_extrl_i64_i32(cpu_hi_guard, t0);
+
+    tcg_gen_sari_tl(t3, cpu_lo, 31);
+    tcg_gen_sari_tl(t4, cpu_hi, 31);
+    tcg_gen_movi_tl(cpu_v, 1);
+    tcg_gen_brcond_tl(TCG_COND_NE, t3, cpu_lo_guard, l1);
+    tcg_gen_brcond_tl(TCG_COND_NE, t4, cpu_hi_guard, l1);
+    tcg_gen_movi_tl(cpu_v, 0);
+    gen_set_label(l1);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free(t3);
+    tcg_temp_free(t4);
+
+}
+
+
+static inline void vmulshs(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv t3 = tcg_temp_new();
+    TCGv t4 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t3, cpu_R[rx]);
+    tcg_gen_ext16s_tl(t4,  cpu_R[ry]);
+    tcg_gen_mul_tl(t3, t3, t4);
+    tcg_gen_concat_i32_i64(t1, cpu_lo, cpu_lo_guard);
+    tcg_gen_ext_tl_i64(t0, t3);
+    tcg_gen_sub_i64(t0, t1, t0);
+    tcg_gen_extrl_i64_i32(cpu_lo, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t0);
+
+    tcg_gen_sari_tl(t3, cpu_R[rx], 16);
+    tcg_gen_sari_tl(t4, cpu_R[ry], 16);
+    tcg_gen_mul_tl(t3, t3, t4);
+    tcg_gen_concat_i32_i64(t1, cpu_hi, cpu_hi_guard);
+    tcg_gen_ext_tl_i64(t0, t3) ;
+    tcg_gen_sub_i64(t0, t1, t0);
+    tcg_gen_extrl_i64_i32(cpu_hi, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_extrl_i64_i32(cpu_hi_guard, t0);
+
+    tcg_gen_sari_tl(t3, cpu_lo, 31);
+    tcg_gen_sari_tl(t4, cpu_hi, 31);
+    tcg_gen_movi_tl(cpu_v, 1);
+    tcg_gen_brcond_tl(TCG_COND_NE, t3, cpu_lo_guard, l1);
+    tcg_gen_brcond_tl(TCG_COND_NE, t4, cpu_hi_guard, l1);
+    tcg_gen_movi_tl(cpu_v, 0);
+    gen_set_label(l1);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free(t3);
+    tcg_temp_free(t4);
+
+
+}
+
+static inline void vmulsw(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv t2 = tcg_temp_new();
+
+    tcg_gen_movi_tl(cpu_v, 0);
+    tcg_gen_ext16s_tl(t2, cpu_R[rx]);
+    tcg_gen_ext_tl_i64(t0, t2);
+    tcg_gen_ext_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_shri_i64(t0, t0, 16);
+    tcg_gen_extrl_i64_i32(cpu_lo, t0);
+    tcg_gen_sari_tl(cpu_lo_guard, cpu_lo, 31);
+    tcg_gen_sari_tl(t2, cpu_R[rx], 16);
+    tcg_gen_ext_tl_i64(t0, t2);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_shri_i64(t0, t0, 16);
+    tcg_gen_extrl_i64_i32(cpu_hi, t0);
+    tcg_gen_sari_tl(cpu_hi_guard, cpu_hi, 31);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free(t2);
+
+}
+
+static inline void vmulswa(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv t3 = tcg_temp_new();
+    TCGv t4 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t3, cpu_R[rx]);
+    tcg_gen_ext_tl_i64(t0, t3);
+    tcg_gen_ext_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_concat_i32_i64(t2, cpu_lo, cpu_lo_guard);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_sari_i64(t0, t0, 16);
+    tcg_gen_add_i64(t0, t0, t2);
+    tcg_gen_extrl_i64_i32(cpu_lo, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t0);
+
+    tcg_gen_sari_tl(t3, cpu_R[rx], 16);
+    tcg_gen_ext_tl_i64(t0, t3);
+    tcg_gen_concat_i32_i64(t2, cpu_hi, cpu_hi_guard);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_sari_i64(t0, t0, 16);
+    tcg_gen_add_i64(t0, t0, t2);
+    tcg_gen_extrl_i64_i32(cpu_hi, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_extrl_i64_i32(cpu_hi_guard, t0);
+
+    tcg_gen_sari_tl(t3, cpu_lo, 31);
+    tcg_gen_sari_tl(t4, cpu_hi, 31);
+    tcg_gen_movi_tl(cpu_v, 1);
+    tcg_gen_brcond_tl(TCG_COND_NE, t3, cpu_lo_guard, l1);
+    tcg_gen_brcond_tl(TCG_COND_NE, t4, cpu_hi_guard, l1);
+    tcg_gen_movi_tl(cpu_v, 0);
+    gen_set_label(l1);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free(t3);
+    tcg_temp_free(t4);
+
+}
+
+static inline void vmulsws(int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv t3 = tcg_temp_new();
+    TCGv t4 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t3, cpu_R[rx]);
+    tcg_gen_ext_tl_i64(t0, t3);
+    tcg_gen_ext_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_concat_i32_i64(t2, cpu_lo, cpu_lo_guard);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_sari_i64(t0, t0, 16);
+    tcg_gen_sub_i64(t0, t2, t0);
+    tcg_gen_extrl_i64_i32(cpu_lo, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t0);
+
+    tcg_gen_sari_tl(t3, cpu_R[rx], 16);
+    tcg_gen_ext_tl_i64(t0, t3);
+    tcg_gen_concat_i32_i64(t2, cpu_hi, cpu_hi_guard);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_sari_i64(t0, t0, 16);
+    tcg_gen_sub_i64(t0, t2, t0);
+    tcg_gen_extrl_i64_i32(cpu_hi, t0);
+    tcg_gen_shri_i64(t0, t0, 32);
+    tcg_gen_extrl_i64_i32(cpu_hi_guard, t0) ;
+
+    tcg_gen_sari_tl(t3, cpu_lo, 31);
+    tcg_gen_sari_tl(t4, cpu_hi, 31);
+    tcg_gen_movi_tl(cpu_v, 1);
+    tcg_gen_brcond_tl(TCG_COND_NE, t3, cpu_lo_guard, l1);
+    tcg_gen_brcond_tl(TCG_COND_NE, t4, cpu_hi_guard, l1);
+    tcg_gen_movi_tl(cpu_v, 0);
+    gen_set_label(l1);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free(t3);
+    tcg_temp_free(t4);
+
+}
+
+static inline void bt(DisasContext *ctx, int offset)
+{
+    int val;
+    TCGLabel *l1 = gen_new_label();
+    TCGv t0 = tcg_temp_new();
+
+    val = offset << 1;
+    if (val & 0x800) {
+        val |= 0xfffff800;
+    }
+    val += ctx->pc + 2;
+
+    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 0, l1);
+    gen_goto_tb(ctx, 1, ctx->pc + 2);
+    gen_set_label(l1);
+
+    gen_goto_tb(ctx, 0, val);
+
+    tcg_temp_free(t0);
+}
+
+static inline void bf(DisasContext *ctx, int offset)
+{
+    int val;
+    TCGLabel *l1 = gen_new_label();
+    TCGv t0 = tcg_temp_new();
+
+    val = offset << 1;
+    if (val & 0x800) {
+        val |= 0xfffff800;
+    }
+    val += ctx->pc + 2;
+    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 1, l1);
+    gen_goto_tb(ctx, 1, ctx->pc + 2);
+    gen_set_label(l1);
+
+    gen_goto_tb(ctx, 0, val);
+
+    tcg_temp_free(t0);
+}
+
+static inline void br(DisasContext *ctx, int offset)
+{
+    int val;
+    val = offset << 1;
+    if (val & 0x800) {
+        val |= 0xfffff800;
+    }
+    val += ctx->pc + 2;
+
+    gen_goto_tb(ctx, 0, val);
+
+}
+
+static inline void bsr(DisasContext *ctx, int offset)
+{
+    int val;
+    val = offset << 1;
+    if (val & 0x800) {
+        val |= 0xfffff800;
+    }
+    val += ctx->pc + 2;
+    tcg_gen_movi_tl(cpu_R[15], ctx->pc + 2);
+
+    gen_goto_tb(ctx, 0, val);
+}
+
+
+
+#define  insn_1  ((ctx->insn & 0xf000) >> 12)
+#define  insn_2  ((ctx->insn & 0x0f00) >> 8)
+#define  insn_3  ((ctx->insn & 0x00f0) >> 4)
+#define  insn_4   (ctx->insn & 0x000f)
+
+static void disas_csky_v1_insn(CPUCSKYState *env, DisasContext *ctx)
+{   unsigned int insn, rz, rx, ry;
+    int imm, disp, i;
+    TCGv t0 = 0;
+    TCGLabel *l1;
+
+    rx = 0;
+    ry = 0;
+    insn = ctx->insn;
+
+    switch (insn_1) {
+    case 0x0:
+        switch (insn_2) {
+        case 0x0:
+            switch (insn_3) {
+            case 0x0:
+                switch (insn_4) {
+                case 0x0:
+                    if (is_gdbserver_start == TRUE) {
+                        generate_exception(ctx, EXCP_DEBUG);
+                        ctx->is_jmp = DISAS_JUMP;
+                    } else {
+                        generate_exception(ctx, EXCP_CSKY_BKPT);
+                    }
+#if !defined(CONFIG_USER_ONLY)
+                    ctx->cannot_be_traced = 1;
+#endif
+                    break;/*bkpt*/
+                case 0x1:
+                    break;/*sync*/
+                case 0x2:
+#if defined(CONFIG_USER_ONLY)
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#else
+                    if (IS_SUPER(ctx)) {
+                        t0 = tcg_const_tl(0);
+                        store_cpu_field(t0, idly4_counter);
+
+                        gen_helper_rte(cpu_env);
+                        ctx->is_jmp = DISAS_UPDATE;
+#if !defined(CONFIG_USER_ONLY)
+                        ctx->cannot_be_traced = 1;
+#endif
+                    } else {
+                        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                    }
+#endif
+                    break;/*rte*/
+                case 0x3:
+#if defined(CONFIG_USER_ONLY)
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#else
+                    if (IS_SUPER(ctx)) {
+                        t0 = tcg_const_tl(0);
+                        store_cpu_field(t0, idly4_counter);
+
+                        gen_helper_rfi(cpu_env);
+                        ctx->is_jmp = DISAS_UPDATE;
+#if !defined(CONFIG_USER_ONLY)
+                        ctx->cannot_be_traced = 1;
+#endif
+                    } else {
+                        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                    }
+#endif
+                    break;/*rfi*/
+                case 0x4:
+#if defined(CONFIG_USER_ONLY)
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#else
+                    if (IS_SUPER(ctx)) {
+                        t0 = tcg_const_tl(0);
+                        store_cpu_field(t0, idly4_counter);
+
+                        gen_save_pc(ctx->pc + 2);
+                        gen_helper_stop(cpu_env);
+                        ctx->is_jmp = DISAS_UPDATE;
+#if !defined(CONFIG_USER_ONLY)
+                        ctx->cannot_be_traced = 1;
+#endif
+                    } else {
+                        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                    }
+#endif
+                    break;/*stop*/
+                case 0x5:
+#if defined(CONFIG_USER_ONLY)
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#else
+                    if (IS_SUPER(ctx)) {
+                        t0 = tcg_const_tl(0);
+                        store_cpu_field(t0, idly4_counter);
+
+                        gen_save_pc(ctx->pc + 2);
+                        gen_helper_wait(cpu_env);
+                        ctx->is_jmp = DISAS_UPDATE;
+#if !defined(CONFIG_USER_ONLY)
+                        ctx->cannot_be_traced = 1;
+#endif
+                    } else {
+                        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                    }
+#endif
+                    break;/*wait*/
+                case 0x6:
+#if defined(CONFIG_USER_ONLY)
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#else
+                    if (IS_SUPER(ctx)) {
+                        t0 = tcg_const_tl(0);
+                        store_cpu_field(t0, idly4_counter);
+
+                        gen_save_pc(ctx->pc + 2);
+                        gen_helper_doze(cpu_env);
+                        ctx->is_jmp = DISAS_UPDATE;
+#if !defined(CONFIG_USER_ONLY)
+                        ctx->cannot_be_traced = 1;
+#endif
+                    } else {
+                        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                    }
+#endif
+                    break;/*doze*/
+                case 0x7:
+#if !defined(CONFIG_USER_ONLY)
+                    if (ctx->trace_mode == NORMAL_MODE) {
+                        l1 = gen_new_label();
+                        t0 =  load_cpu_field(idly4_counter);
+                        tcg_gen_brcondi_tl(TCG_COND_NE, t0, 0, l1);
+
+                        t0 = tcg_const_tl(4);
+                        store_cpu_field(t0, idly4_counter);
+                        tcg_gen_movi_tl(cpu_c, 0);
+
+                        gen_save_pc(ctx->pc + 2);
+                        ctx->is_jmp = DISAS_UPDATE;
+                        gen_set_label(l1);
+                    }
+#endif
+                    break;/*idly4*/
+                case 0x8:
+                    generate_exception(ctx, EXCP_CSKY_TRAP0);
+#if !defined(CONFIG_USER_ONLY)
+                    ctx->cannot_be_traced = 1;
+#endif
+                    break;/*trap0*/
+                case 0x9:
+#if !defined(CONFIG_USER_ONLY)
+                    generate_exception(ctx, EXCP_CSKY_TRAP1);
+                    ctx->cannot_be_traced = 1;
+#endif
+                    break;/*trap1*/
+                case 0xa:
+                    generate_exception(ctx, EXCP_CSKY_TRAP2);
+#if !defined(CONFIG_USER_ONLY)
+                    ctx->cannot_be_traced = 1;
+#endif
+                    break;/*trap2*/
+                case 0xb:
+                    generate_exception(ctx, EXCP_CSKY_TRAP3);
+#if !defined(CONFIG_USER_ONLY)
+                    ctx->cannot_be_traced = 1;
+#endif
+                    break;/*trap3*/
+                case 0xc:
+                    check_insn(ctx, ABIV1_DSP);
+                    tcg_gen_mov_tl(cpu_c, cpu_v);
+                    break;/*mvtc*/
+                case 0xd:
+                    gen_helper_cprc(cpu_env);
+                    gen_save_pc(ctx->pc + 2);
+                    ctx->is_jmp = DISAS_UPDATE;
+                    break;/*cprc-todo*/
+
+                default:
+                    goto illegal_op;
+                }
+                break;
+            case 0x1:
+#if defined(CONFIG_USER_ONLY)
+                /*
+                 * A temporary solution to support
+                 * float instructions in cskyv1
+                 */
+                rx = (insn & 0xf) << 24;
+                t0 = load_cpu_field(cp0.psr);
+                tcg_gen_andi_tl(t0, t0, ~0x0f000000);
+                tcg_gen_ori_tl(t0, t0, rx);
+                store_cpu_field(t0, cp0.psr);
+                if (rx == (0x1 << 24)) {
+                    tcg_gen_movi_tl(t0, 0x0);
+                    store_cpu_field(t0, cp1.fcr);
+                    store_cpu_field(t0, cp1.fsr);
+                }
+                gen_save_pc(ctx->pc + 2);
+                ctx->is_jmp = DISAS_UPDATE;
+
+                tcg_temp_free(t0);
+#else
+                if (IS_SUPER(ctx)) {
+                    rx = (insn & 0xf) << 24;
+                    t0 = load_cpu_field(cp0.psr);
+                    tcg_gen_andi_tl(t0, t0, ~0x0f000000);
+                    tcg_gen_ori_tl(t0, t0, rx);
+                    store_cpu_field(t0, cp0.psr);
+                    if (rx == (0x1 << 24)) {
+                        tcg_gen_movi_tl(t0, 0x0);
+                        store_cpu_field(t0, cp1.fcr);
+                        store_cpu_field(t0, cp1.fsr);
+                    }
+                    gen_save_pc(ctx->pc + 2);
+                    ctx->is_jmp = DISAS_UPDATE;
+
+                    tcg_temp_free(t0);
+                } else {
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                }
+#endif
+                break;/*cpseti-todo*/
+            case 0x2:
+                rx = insn & 0x000f;
+                tcg_gen_mov_tl(cpu_R[rx], cpu_c);
+                break;/*mvc*/
+            case 0x3:
+                rx = insn & 0x000f;
+                tcg_gen_subfi_tl(cpu_R[rx], 1, cpu_c);
+                break;/*mvcv*/
+            case 0x4:
+                rx = insn & 0x000f;
+                t0 = tcg_temp_new();
+                tcg_gen_mov_tl(t0, cpu_R[rx]);
+                for (i = 4; i <= 7; i++) {
+                    tcg_gen_qemu_ld32u(cpu_R[i], t0, ctx->mem_idx);
+                    tcg_gen_addi_tl(t0, t0, 4);
+                }
+                tcg_temp_free(t0);
+                break;/*ldq*/
+            case 0x5:
+                rx = insn & 0x000f;
+                t0 = tcg_temp_new();
+                tcg_gen_mov_tl(t0, cpu_R[rx]);
+                for (i = 4; i <= 7; i++) {
+                    tcg_gen_qemu_st32(cpu_R[i], t0, ctx->mem_idx);
+                    tcg_gen_addi_tl(t0, t0, 4);
+                }
+                tcg_temp_free(t0);
+                break;/*stq*/
+            case 0x6:
+                rx = insn & 0x000f;
+                t0 = tcg_temp_new();
+
+                tcg_gen_mov_tl(t0, cpu_R[0]);
+                for (i = rx; i <= 15; i++) {
+                    tcg_gen_qemu_ld32u(cpu_R[i], t0, ctx->mem_idx);
+                    tcg_gen_addi_tl(t0, t0, 4);
+                }
+                tcg_temp_free(t0);
+                break;/*ldm*/
+            case 0x7:
+                rx = insn & 0x000f;
+                t0 = tcg_temp_new();
+
+                tcg_gen_mov_tl(t0, cpu_R[0]);
+                for (i = rx; i <= 15; i++) {
+                    tcg_gen_qemu_st32(cpu_R[i], t0, ctx->mem_idx);
+                    tcg_gen_addi_tl(t0, t0, 4);
+                }
+                tcg_temp_free(t0);
+                break;/*stm*/
+            case 0x8:
+                rx = insn & 0x000f;
+                tcg_gen_sub_tl(cpu_R[rx], cpu_R[rx], cpu_c);
+                break;/*dect*/
+            case 0x9:
+                rx = insn & 0x000f;
+                tcg_gen_subi_tl(cpu_R[rx], cpu_R[rx], 1);
+                tcg_gen_add_tl(cpu_R[rx], cpu_R[rx], cpu_c);
+                break;/*decf*/
+            case 0xa:
+                rx = insn & 0x000f;
+                tcg_gen_add_tl(cpu_R[rx], cpu_R[rx], cpu_c);
+                break;/*inct*/
+            case 0xb:
+                rx = insn & 0x000f;
+                tcg_gen_addi_tl(cpu_R[rx], cpu_R[rx], 1);
+                tcg_gen_sub_tl(cpu_R[rx], cpu_R[rx], cpu_c);
+                break;/*incf*/
+            case 0xc:
+                rx = insn & 0x000f;
+                t0 = tcg_temp_new();
+                tcg_gen_andi_tl(t0, cpu_R[rx], 0xfffffffe);
+                store_cpu_field(t0, pc);
+
+#if !defined(CONFIG_USER_ONLY)
+                if ((ctx->trace_mode == BRAN_TRACE_MODE)
+                        || (ctx->trace_mode == INST_TRACE_MODE)) {
+                    t0 = tcg_const_i32(EXCP_CSKY_TRACE);
+                    gen_helper_exception(cpu_env, t0);
+                }
+                ctx->maybe_change_flow = 1;
+#endif
+                tcg_temp_free(t0);
+                ctx->is_jmp = DISAS_JUMP;
+                break;/*jmp*/
+            case 0xd:
+                rx = insn & 0x000f;
+                t0 = tcg_temp_new();
+                tcg_gen_andi_tl(t0, cpu_R[rx], 0xfffffffe);
+                tcg_gen_movi_tl(cpu_R[15], ctx->pc + 2);
+                store_cpu_field(t0, pc);
+
+#if !defined(CONFIG_USER_ONLY)
+                if ((ctx->trace_mode == BRAN_TRACE_MODE)
+                        || (ctx->trace_mode == INST_TRACE_MODE)) {
+                    t0 = tcg_const_i32(EXCP_CSKY_TRACE);
+                    gen_helper_exception(cpu_env, t0);
+                }
+                ctx->maybe_change_flow = 1;
+#endif
+                tcg_temp_free(t0);
+                ctx->is_jmp = DISAS_JUMP;
+                break;/*jsr*/
+            case 0xe:
+                rx = insn & 0x000f;
+                gen_helper_ff1(cpu_R[rx], cpu_R[rx]);
+                break;/*ff1*/
+            case 0xf:
+                rx = insn & 0x000f;
+                gen_helper_brev(cpu_R[rx], cpu_R[rx]);
+                break;/*brev*/
+            default:
+                goto illegal_op;
+            }
+            break;
+        case 0x1:
+            switch (insn_3) {
+            case 0x0:
+                rx = insn & 0x000f;
+                tcg_gen_andi_tl(cpu_R[1], cpu_R[rx], 0x000000ff);
+                tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[1], 0);
+                break;/*xtrb3*/
+            case 0x1:
+                rx = insn & 0x000f;
+                tcg_gen_andi_tl(cpu_R[1], cpu_R[rx], 0x0000ff00);
+                tcg_gen_shri_tl(cpu_R[1], cpu_R[1], 8);
+                tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[1], 0);
+                break;/*xtrb2*/
+            case 0x2:
+                rx = insn & 0x000f;
+                tcg_gen_andi_tl(cpu_R[1], cpu_R[rx], 0x00ff0000);
+                tcg_gen_shri_tl(cpu_R[1], cpu_R[1], 16);
+                tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[1], 0);
+                break;/*xtrb1*/
+            case 0x3:
+                rx = insn & 0x000f;
+                tcg_gen_shri_tl(cpu_R[1], cpu_R[rx], 24);
+                tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[1], 0);
+                break;/*xtrb0*/
+            case 0x4:
+                rx = insn & 0x000f;
+                tcg_gen_ext8u_tl(cpu_R[rx], cpu_R[rx]);
+                break;/*zextb*/
+            case 0x5:
+                rx = insn & 0x000f;
+                tcg_gen_ext8s_tl(cpu_R[rx], cpu_R[rx]);
+                break;/*sextb*/
+            case 0x6:
+                rx = insn & 0x000f;
+                tcg_gen_ext16u_tl(cpu_R[rx], cpu_R[rx]);
+                break;/*zexth*/
+            case 0x7:
+                rx = insn & 0x000f;
+                tcg_gen_ext16s_tl(cpu_R[rx], cpu_R[rx]);
+                break;/*sexth*/
+            case 0x8:
+                rx = insn & 0x000f;
+                tcg_gen_subi_tl(cpu_R[rx], cpu_R[rx], 1);
+                tcg_gen_setcondi_tl(TCG_COND_LT, cpu_c, cpu_R[rx], 0);
+                break;/*declt*/
+            case 0x9:
+                rx = insn & 0x000f;
+                tstnbz(rx);
+                break;/*tstnbz*/
+            case 0xa:
+                rx = insn & 0x000f;
+                tcg_gen_subi_tl(cpu_R[rx], cpu_R[rx], 1);
+                tcg_gen_setcondi_tl(TCG_COND_GT, cpu_c, cpu_R[rx], 0);
+                break;/*decgt*/
+            case 0xb:
+                rx = insn & 0x000f;
+                tcg_gen_subi_tl(cpu_R[rx], cpu_R[rx], 1);
+                tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[rx], 0);
+                break;/*decne*/
+            case 0xc:
+                rx = insn & 0x000f;
+                l1 = gen_new_label();
+                tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_c, 0, l1);
+                tcg_gen_movi_tl(cpu_R[rx], 0);
+                gen_set_label(l1);
+                break;/*clrt*/
+            case 0xd:
+                rx = insn & 0x000f;
+                l1 = gen_new_label();
+                tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 0, l1);
+                tcg_gen_movi_tl(cpu_R[rx], 0);
+                gen_set_label(l1);
+                break;/*clrf*/
+            case 0xe:
+                rx = insn & 0x000f;
+                l1 = gen_new_label();
+                tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rx], 0x80000000, l1);
+                tcg_gen_brcondi_tl(TCG_COND_GE, cpu_R[rx], 0, l1);
+                tcg_gen_neg_tl(cpu_R[rx], cpu_R[rx]);
+                gen_set_label(l1);
+                break;/*abs*/
+            case 0xf:
+                rx = insn & 0x000f;
+                tcg_gen_not_tl(cpu_R[rx], cpu_R[rx]);
+                break;/*not*/
+            default:
+                goto illegal_op;
+            }
+            break;
+        case 0x2:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_c, 0, l1);
+            tcg_gen_mov_tl(cpu_R[rx], cpu_R[ry]);
+            gen_set_label(l1);
+            break;/*movt*/
+        case 0x3:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_mul_tl(cpu_R[rx], cpu_R[rx], cpu_R[ry]);
+            break;/*mult*/
+        case 0x4:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            mac(rx, ry);
+            break;/*mac*/
+        case 0x5:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_sub_tl(cpu_R[rx], cpu_R[rx], cpu_R[ry]);
+            break;/*subu*/
+        case 0x6:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            addc(rx, ry);
+            break;/*addc*/
+        case 0x7:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            subc(rx, ry);
+            break;/*subc*/
+        case 0x8:
+        case 0x9:
+             rx = (insn & 0x1f0) >> 4;
+             rz = insn & 0xf;
+             t0 = load_cpu_field(cp1.fr[rx]);
+             tcg_gen_mov_tl(cpu_R[rz], t0);
+             tcg_temp_free(t0);
+            break;/*cprgr-todo*/
+        case 0xa:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 0, l1);
+            tcg_gen_mov_tl(cpu_R[rx], cpu_R[ry]);
+            gen_set_label(l1);
+            break;/*movf*/
+        case 0xb:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            lsr(rx, ry);
+            break;/*lsr*/
+        case 0xc:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_setcond_tl(TCG_COND_GEU, cpu_c, cpu_R[rx], cpu_R[ry]);
+            break;/*cmphs*/
+        case 0xd:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_setcond_tl(TCG_COND_LT, cpu_c, cpu_R[rx], cpu_R[ry]);
+            break;/*cmplt*/
+        case 0xe:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            t0 = tcg_temp_new();
+            tcg_gen_and_tl(t0, cpu_R[rx], cpu_R[ry]);
+            tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, t0, 0);
+            tcg_temp_free(t0);
+            break;/*tst*/
+        case 0xf:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_setcond_tl(TCG_COND_NE, cpu_c, cpu_R[rx], cpu_R[ry]);
+            break;/*cmpne*/
+        default:
+            goto illegal_op;
+        }
+        break;
+
+    case 0x1:
+        switch (insn_2) {
+        case 0x0:
+#if defined(CONFIG_USER_ONLY)
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#else
+            if (IS_SUPER(ctx)) {
+                rz = insn & 0xf;
+                rx = (insn & 0x1f0) >> 4;
+                gen_mfcr(ctx, rz, rx);
+            } else {
+                generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+            }
+#endif
+            break;/*mfcr*/
+        case 0x1:
+            if (insn_3 != 0xf) {
+#if defined(CONFIG_USER_ONLY)
+                generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#else
+                if (IS_SUPER(ctx)) {
+                    rz = insn & 0xf;
+                    rx = (insn & 0x1f0) >> 4;
+                    gen_mfcr(ctx, rz, rx);
+                } else {
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                }
+#endif
+                break;/*mfcr*/
+            } else if (insn_3 == 0xf) {
+                if (insn_4 >> 3 == 0) {
+#if defined(CONFIG_USER_ONLY)
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#else
+                    if (IS_SUPER(ctx)) {
+                        t0 = tcg_const_tl(insn & 0x7);
+                        gen_helper_psrclr(cpu_env, t0);
+
+                        gen_save_pc(ctx->pc + 2);
+                        ctx->is_jmp = DISAS_UPDATE;
+                    } else {
+                        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                    }
+#endif
+                    break;/*psrclr*/
+                } else if (insn_4 >> 3 == 1) {
+#if defined(CONFIG_USER_ONLY)
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#else
+                    if (IS_SUPER(ctx)) {
+                        t0 = tcg_const_tl(insn & 0x7);
+                        gen_helper_psrset(cpu_env, t0);
+
+                        gen_save_pc(ctx->pc + 2);
+                        ctx->is_jmp = DISAS_UPDATE;
+                    } else {
+                        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                    }
+#endif
+                    break;/*psrset*/
+                } else {
+                    goto illegal_op;
+                }
+            } else {
+                goto illegal_op;
+            }
+        case 0x2:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_mov_tl(cpu_R[rx], cpu_R[ry]);
+            break;/*mov*/
+        case 0x3:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            bgenr(rx, ry);
+            break;/*bgenr*/
+        case 0x4:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_sub_tl(cpu_R[rx], cpu_R[ry], cpu_R[rx]);
+            break;/*rsub*/
+        case 0x5:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            t0 = tcg_temp_new();
+            tcg_gen_shli_tl(t0, cpu_R[ry], 2);
+            tcg_gen_add_tl(cpu_R[rx], cpu_R[rx], t0);
+            tcg_temp_free(t0);
+            break;/*ixw*/
+        case 0x6:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_and_tl(cpu_R[rx], cpu_R[rx], cpu_R[ry]);
+            break;/*and*/
+        case 0x7:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_xor_tl(cpu_R[rx], cpu_R[rx], cpu_R[ry]);
+            break;/*xor*/
+        case 0x8:
+        case 0x9:
+#if defined(CONFIG_USER_ONLY)
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#else
+            if (IS_SUPER(ctx)) {
+                rx = insn & 0xf;
+                rz = (insn & 0x1f0) >> 4;
+                gen_mtcr(ctx, rz, rx);
+            } else {
+                generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+            }
+#endif
+            break;/*mtcr*/
+        case 0xa:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            asr(rx, ry);
+            break;/*asr*/
+        case 0xb:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            lsl(rx, ry);
+            break;/*lsl*/
+        case 0xc:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_add_tl(cpu_R[rx], cpu_R[rx], cpu_R[ry]);
+            break;/*addu*/
+        case 0xd:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            {
+            t0 = tcg_temp_new();
+            tcg_gen_shli_tl(t0, cpu_R[ry], 1);
+            tcg_gen_add_tl(cpu_R[rx], cpu_R[rx], t0);
+            tcg_temp_free(t0);
+            }
+            break;/*ixh*/
+        case 0xe:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_or_tl(cpu_R[rx], cpu_R[rx], cpu_R[ry]);
+            break;/*or*/
+        case 0xf:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            tcg_gen_andc_tl(cpu_R[rx], cpu_R[rx], cpu_R[ry]);
+            break;/*andn*/
+        default:
+            goto illegal_op;
+        }
+        break;
+    case 0x2:
+        switch (insn_2) {
+        case 0x0:
+        case 0x1:
+            rx = insn & 0x000f;
+            imm = ((insn & 0x01f0) >> 4) + 1;
+            tcg_gen_addi_tl(cpu_R[rx], cpu_R[rx], imm);
+            break;/*addi*/
+        case 0x2:
+        case 0x3:
+            rx = insn & 0x000f;
+            imm = ((insn & 0x01f0) >> 4) + 1;
+            tcg_gen_setcondi_tl(TCG_COND_LT, cpu_c, cpu_R[rx], imm);
+            break;/*cmplti*/
+        case 0x4:
+        case 0x5:
+            rx = insn & 0x000f;
+            imm = ((insn & 0x01f0) >> 4) + 1;
+            tcg_gen_subi_tl(cpu_R[rx], cpu_R[rx], imm);
+            break;/*subi*/
+        case 0x6:
+        case 0x7:
+            rx = (insn & 0x1f0) >> 4;
+            rz = insn & 0xf;
+            store_cpu_field(cpu_R[rz], cp1.fr[rx]);
+            break;/*cpwgr-todo*/
+        case 0x8:
+        case 0x9:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            tcg_gen_subfi_tl(cpu_R[rx], imm, cpu_R[rx]);
+            break;/*rsubi*/
+        case 0xa:
+        case 0xb:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[rx], imm);
+            break;/*cmpnei*/
+        case 0xc:
+            switch (insn_3) {
+            case 0x0:
+                rx = insn & 0x000f;
+                imm = (insn & 0x01f0) >> 4;
+
+                if (imm == 0) {
+                    tcg_gen_movi_tl(cpu_R[rx], 0xffffffff);
+                } else {
+                    tcg_gen_movi_tl(cpu_R[rx], (1 << imm) - 1);
+                }
+
+                break;/*bmaski#32*/
+            case 0x1:
+                rx = insn & 0x000f;
+                divu(ctx, rx);
+                break;/*divu*/
+            case 0x2:
+                check_insn(ctx, ABIV1_DSP);
+                rx = insn & 0x000f;
+                l1 = gen_new_label();
+                tcg_gen_mov_tl(cpu_R[rx], cpu_lo_guard);
+                tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_v, 1, l1);
+                tcg_gen_mov_tl(cpu_R[rx], cpu_lo);
+                gen_set_label(l1);
+                break;/*mflos*/
+            case 0x3:
+                check_insn(ctx, ABIV1_DSP);
+                rx = insn & 0x000f;
+                l1 = gen_new_label();
+                tcg_gen_mov_tl(cpu_R[rx], cpu_hi_guard);
+                tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_v, 1, l1);
+                tcg_gen_mov_tl(cpu_R[rx], cpu_hi);
+                gen_set_label(l1);
+                break;/*mfhis*/
+            case 0x4:
+                {
+                    check_insn(ctx, ABIV1_DSP);
+                    rx = insn & 0x000f;
+                    TCGv_i64 t0 = tcg_temp_new_i64();
+                    tcg_gen_movi_tl(cpu_v, 0);
+                    tcg_gen_mov_tl(cpu_lo, cpu_R[rx]);
+                    tcg_gen_ext_tl_i64(t0, cpu_lo);
+                    tcg_gen_shri_i64(t0, t0, 32);
+                    tcg_gen_extrl_i64_i32(cpu_lo_guard, t0);
+                    tcg_temp_free_i64(t0);
+                }
+                break;/*mtlo*/
+            case 0x5:
+                {
+                    check_insn(ctx, ABIV1_DSP);
+                    rx = insn & 0x000f;
+                    TCGv_i64 t0 = tcg_temp_new_i64();
+                    tcg_gen_movi_tl(cpu_v, 0);
+                    tcg_gen_mov_tl(cpu_hi, cpu_R[rx]);
+                    tcg_gen_ext_tl_i64(t0, cpu_hi);
+                    tcg_gen_shri_i64(t0, t0, 32);
+                    tcg_gen_extrl_i64_i32(cpu_hi_guard, t0);
+                    tcg_temp_free_i64(t0);
+                }
+                break;/*mthi*/
+            case 0x6:
+                check_insn(ctx, ABIV1_DSP);
+                rx = insn & 0x000f;
+                tcg_gen_mov_tl(cpu_R[rx], cpu_lo);
+                break;/*mflo*/
+            case 0x7:
+                check_insn(ctx, ABIV1_DSP);
+                rx = insn & 0x000f;
+                tcg_gen_mov_tl(cpu_R[rx], cpu_hi);
+                break;/*mfhi*/
+            case 0x8:
+            case 0x9:
+            case 0xa:
+            case 0xb:
+            case 0xc:
+            case 0xd:
+            case 0xe:
+            case 0xf:
+                rx = insn & 0x000f;
+                imm = (insn & 0x01f0) >> 4;
+
+                if (imm == 0) {
+                    tcg_gen_movi_tl(cpu_R[rx], 0xffffffff);
+                } else {
+                    tcg_gen_movi_tl(cpu_R[rx], (1 << imm) - 1);
+                }
+
+                break;/*bmaski*/
+            default:
+                goto illegal_op;
+            }
+            break;
+        case 0xd:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+
+            if (imm == 0) {
+                tcg_gen_movi_tl(cpu_R[rx], 0xffffffff);
+            } else {
+                tcg_gen_movi_tl(cpu_R[rx], (1 << imm) - 1);
+            }
+            break;/*bmaski*/
+        case 0xe:
+        case 0xf:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            tcg_gen_andi_tl(cpu_R[rx], cpu_R[rx], imm);
+            break;/*andi*/
+        default:
+            goto illegal_op;
+        }
+        break;
+    case 0x3:
+        switch (insn_2) {
+        case 0x0:
+        case 0x1:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            tcg_gen_andi_tl(cpu_R[rx], cpu_R[rx], ~(1 << imm));
+            break;/*bclri*/
+        case 0x2:
+            switch (insn_3) {
+            case 0x0:
+                rx = insn & 0xf;
+                store_cpu_field(cpu_R[rx], cp1.fir);
+                gen_helper_cpwir(cpu_env);
+                gen_save_pc(ctx->pc + 2);
+                ctx->is_jmp = DISAS_UPDATE;
+                break;/*cpwir-todo*/
+            case 0x1:
+                rx = insn & 0x000f;
+                divs(ctx, rx);
+                break;/*divs*/
+            case 0x2:
+#if defined(CONFIG_USER_ONLY)
+                rz = insn & 0xf;
+                t0 = load_cpu_field(cp1.fsr);
+                tcg_gen_mov_tl(cpu_R[rz], t0);
+                tcg_temp_free(t0);
+#else
+                if (IS_SUPER(ctx)) {
+                    rz = insn & 0xf;
+                    t0 = load_cpu_field(cp1.fsr);
+                    tcg_gen_mov_tl(cpu_R[rz], t0);
+                    tcg_temp_free(t0);
+                } else {
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                }
+#endif
+                break;/*cprsr-todo*/
+            case 0x3:
+#if defined(CONFIG_USER_ONLY)
+                rz = insn & 0xf;
+                store_cpu_field(cpu_R[rz], cp1.fsr);
+#else
+                if (IS_SUPER(ctx)) {
+                    rz = insn & 0xf;
+                    store_cpu_field(cpu_R[rz], cp1.fsr);
+                } else {
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                }
+#endif
+                break;/*cpwsr-todo*/
+
+            case 0x7:
+            case 0x8:
+            case 0x9:
+            case 0xa:
+            case 0xb:
+            case 0xc:
+            case 0xd:
+            case 0xe:
+            case 0xf:
+                rx = insn & 0x000f;
+                imm = (insn & 0x01f0) >> 4;
+                tcg_gen_movi_tl(cpu_R[rx], 1 << imm);
+                break;/* bgeni */
+            default:
+                goto illegal_op;
+            }
+            break;
+
+        case 0x3:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            tcg_gen_movi_tl(cpu_R[rx], 1 << imm);
+            break;/*bgeni*/
+        case 0x4:
+        case 0x5:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            tcg_gen_ori_tl(cpu_R[rx], cpu_R[rx], 1 << imm);
+            break;/*bseti*/
+        case 0x6:
+        case 0x7:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            t0 = tcg_temp_new();
+            tcg_gen_andi_tl(t0, cpu_R[rx], 1 << imm);
+            tcg_gen_shri_tl(cpu_c, t0, imm);
+            tcg_temp_free(t0);
+            break;/*btsti*/
+        case 0x8:
+            if (insn_3 == 0) {
+                rx = insn & 0x000f;
+                xsr(rx);
+                break;/*xsr*/
+            } else {
+                rx = insn & 0x000f;
+                imm = (insn & 0x01f0) >> 4;
+                tcg_gen_rotli_tl(cpu_R[rx], cpu_R[rx], imm);
+                break;/*rotli*/
+            }
+        case 0x9:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            tcg_gen_rotli_tl(cpu_R[rx], cpu_R[rx], imm);
+            break;/*rotli*/
+        case 0xa:
+            if (insn_3 == 0) {
+                rx = insn & 0x000f;
+                tcg_gen_andi_tl(cpu_c, cpu_R[rx], 0x1);
+                tcg_gen_sari_tl(cpu_R[rx], cpu_R[rx], 1);
+                break;/*asrc*/
+            } else {
+                rx = insn & 0x000f;
+                imm = (insn & 0x01f0) >> 4;
+                tcg_gen_sari_tl(cpu_R[rx], cpu_R[rx], imm);
+                break;/*asri*/
+            }
+        case 0xb:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            tcg_gen_sari_tl(cpu_R[rx], cpu_R[rx], imm);
+            break;/*asri*/
+        case 0xc:
+            if (insn_3 == 0) {
+                rx = insn & 0x000f;
+                tcg_gen_shri_tl(cpu_c, cpu_R[rx], 31);
+                tcg_gen_shli_tl(cpu_R[rx], cpu_R[rx], 1);
+                break;/*lslc*/
+            } else {
+                rx = insn & 0x000f;
+                imm = (insn & 0x01f0) >> 4;
+                tcg_gen_shli_tl(cpu_R[rx], cpu_R[rx], imm);
+                break;/*lsli*/
+            }
+        case 0xd:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            tcg_gen_shli_tl(cpu_R[rx], cpu_R[rx], imm);
+            break;/*lsli*/
+        case 0xe:
+            if (insn_3 == 0) {
+                rx = insn & 0x000f;
+                tcg_gen_andi_tl(cpu_c, cpu_R[rx], 0x1);
+                tcg_gen_shri_tl(cpu_R[rx], cpu_R[rx], 1);
+                break;/*lsrc*/
+            } else {
+                rx = insn & 0x000f;
+                imm = (insn & 0x01f0) >> 4;
+                tcg_gen_shri_tl(cpu_R[rx], cpu_R[rx], imm);
+                break;/*lsri*/
+            }
+        case 0xf:
+            rx = insn & 0x000f;
+            imm = (insn & 0x01f0) >> 4;
+            tcg_gen_shri_tl(cpu_R[rx], cpu_R[rx], imm);
+            break;/*lsri*/
+        default:
+            goto illegal_op;
+        }
+        break;
+    case 0x4:
+        switch (insn_2) {
+        case 0x0:
+            goto illegal_op;
+            break;/*omflip0*/
+        case 0x1:
+            goto illegal_op;
+            break;/* omflip1*/
+        case 0x2:
+            goto illegal_op;
+            break;/* omflip2*/
+        case 0x3:
+            goto illegal_op;
+            break;/* omflip3*/
+
+        default:
+            goto illegal_op;
+        }
+        break;
+    case 0x5:
+        switch (insn_2) {
+        case 0x0:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            muls(rx, ry);
+            break;/*muls*/
+        case 0x1:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            mulsa(rx, ry);
+            break;/*mulsa*/
+        case 0x2:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            mulss(rx, ry);
+            break;/*mulss*/
+        case 0x4:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            mulu(rx, ry);
+            break;/*mulu*/
+        case 0x5:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            mulua(rx, ry);
+            break;/*mulua*/
+        case 0x6:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+            mulus(rx, ry);
+            break;/*mulus*/
+        case 0x8:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            vmulsh(rx, ry);
+
+            break;/*vmulsh*/
+        case 0x9:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            vmulsha(rx, ry);
+
+            break;/* vmulsha */
+        case 0xa:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            vmulshs(rx, ry);
+
+            break;/* vmulshs */
+        case 0xc:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            vmulsw(rx, ry);
+
+            break;/* vmulsw*/
+        case 0xd:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            vmulswa(rx, ry);
+
+            break;/* vmulswa */
+        case 0xe:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            vmulsws(rx, ry);
+
+            break;/* vmulsws */
+        default:
+            goto illegal_op;
+        }
+        break;
+    case 0x6:
+        switch (insn_2) {
+        case 0x0:
+        case 0x1:
+        case 0x2:
+        case 0x3:
+        case 0x4:
+        case 0x5:
+        case 0x6:
+        case 0x7:
+            rx = insn & 0x000f;
+            imm = (insn & 0x07f0) >> 4;
+            tcg_gen_movi_tl(cpu_R[rx], imm);
+            break; /*movi*/
+        case 0x8:
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            t0 = tcg_temp_new();
+            tcg_gen_ext16s_tl(cpu_R[rx], cpu_R[rx]);
+            tcg_gen_ext16s_tl(t0, cpu_R[ry]);
+            tcg_gen_mul_tl(cpu_R[rx], cpu_R[rx], t0);
+            tcg_temp_free(t0);
+
+            break;/*mulsh*/
+        case 0x9:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            mulsha(rx, ry);
+
+            break;/*mulsha*/
+        case 0xa:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            mulshs(rx, ry);
+
+            break;/*mulshs*/
+        case 0xb:
+#if defined(CONFIG_USER_ONLY)
+            /* ck610 has only one coprocessor: fpu, needn't be tested */
+            rz = insn & 0x7;
+            rx = (insn & 0xf8) >> 3;
+            switch (rx) {
+            case 0:
+                t0 = load_cpu_field(cp1.fpcid);
+                break;
+            case 1:
+                t0 = load_cpu_field(cp1.fcr);
+                break;
+            case 2:
+                t0 = load_cpu_field(cp1.fsr);
+                break;
+            case 3:
+                t0 = load_cpu_field(cp1.fir);
+                break;
+            case 4:
+                t0 = load_cpu_field(cp1.fesr);
+                break;
+            case 5:
+                t0 = load_cpu_field(cp1.feinst1);
+                break;
+            case 6:
+                t0 = load_cpu_field(cp1.feinst2);
+                break;
+            default:
+                tcg_gen_movi_tl(t0, 0);
+                break;
+            }
+            tcg_gen_mov_tl(cpu_R[rz], t0);
+            tcg_temp_free(t0);
+#else
+            rz = insn & 0x7;
+            rx = (insn & 0xf8) >> 3;
+
+            if (!IS_SUPER(ctx)) {
+                generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+            }
+
+            if (ctx->current_cp == 15) {
+                check_insn(ctx, CSKY_MMU);
+                gen_cprcr_cp15(ctx, rz, rx);
+            } else if (ctx->current_cp == 1) {
+                switch (rx) {
+                case 0:
+                    t0 = load_cpu_field(cp1.fpcid);
+                    break;
+                case 1:
+                    t0 = load_cpu_field(cp1.fcr);
+                    break;
+                case 2:
+                    t0 = load_cpu_field(cp1.fsr);
+                    break;
+                case 3:
+                    t0 = load_cpu_field(cp1.fir);
+                    break;
+                case 4:
+                    t0 = load_cpu_field(cp1.fesr);
+                    break;
+                case 5:
+                    t0 = load_cpu_field(cp1.feinst1);
+                    break;
+                case 6:
+                    t0 = load_cpu_field(cp1.feinst2);
+                    break;
+                default:
+                    tcg_gen_movi_tl(t0, 0);
+                    break;
+                }
+                tcg_gen_mov_tl(cpu_R[rz], t0);
+                tcg_temp_free(t0);
+            }
+#endif
+            break;/*cprcr-todo*/
+
+        case 0xc:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            mulsw(rx, ry);
+
+            break;/*mulsw*/
+        case 0xd:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            mulswa(rx, ry);
+
+            break;/*mulswa*/
+        case 0xe:
+            check_insn(ctx, ABIV1_DSP);
+            rx = insn & 0x000f;
+            ry = (insn & 0x00f0) >> 4;
+
+            mulsws(rx, ry);
+
+            break;/*mulsws*/
+        case 0xf:
+#if defined(CONFIG_USER_ONLY)
+            /* ck610 has only one coprocessor: fpu, so needn't be test */
+            rx = insn & 0x7;
+            rz = (insn & 0xf8) >> 3;
+            store_cpu_field(cpu_R[rz], cp1.fcr);
+#else
+            rx = insn & 0x7;
+            rz = (insn & 0xf8) >> 3;
+
+            if (!IS_SUPER(ctx)) {
+                generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+            }
+
+            if (ctx->current_cp == 15) {
+                check_insn(ctx, CSKY_MMU);
+                gen_cpwcr_cp15(ctx, rz, rx);
+            } else if (ctx->current_cp == 1) {
+                store_cpu_field(cpu_R[rz], cp1.fcr);
+            }
+#endif
+            break;/*cpwcr-todo*/
+        default:
+            goto illegal_op;
+        }
+        break;
+
+    case 0x7:
+        if ((insn_2 > 0) && (insn_2 < 15)) {
+            target_ulong addr;
+            t0 = tcg_temp_new();
+
+            disp = insn & 0x00ff;
+            rz = (insn & 0x0f00) >> 8;
+            addr = (ctx->pc + 2 + (disp << 2)) & 0xfffffffc ;
+            tcg_gen_movi_tl(t0, addr);
+            tcg_gen_qemu_ld32u(cpu_R[rz], t0, ctx->mem_idx);
+            tcg_temp_free(t0);
+
+            break;/*lrw*/
+        } else if (insn_2 == 0) {
+            target_ulong addr;
+
+            disp = insn & 0x00ff;
+            addr = (ctx->pc + 2 + (disp << 2)) & 0xfffffffc ;
+#if defined(CONFIG_USER_ONLY)
+            addr = cpu_ldl_code(env, addr);
+            gen_goto_tb(ctx, 0, addr);
+            ctx->is_jmp = DISAS_TB_JUMP;
+#else
+            t0 = tcg_temp_new();
+            tcg_gen_movi_tl(t0, addr);
+            tcg_gen_qemu_ld32u(t0, t0, ctx->mem_idx);
+            tcg_gen_andi_tl(t0, t0, 0xfffffffe);
+            store_cpu_field(t0, pc);
+
+            if ((ctx->trace_mode == BRAN_TRACE_MODE)
+                    || (ctx->trace_mode == INST_TRACE_MODE)) {
+                t0 = tcg_const_i32(EXCP_CSKY_TRACE);
+                gen_helper_exception(cpu_env, t0);
+            }
+            ctx->maybe_change_flow = 1;
+            tcg_temp_free(t0);
+            ctx->is_jmp = DISAS_JUMP;
+#endif
+            break;/*jmpi*/
+        } else if (insn_2 == 15) {
+            target_ulong addr;
+
+            disp = insn & 0x00ff;
+            addr = (ctx->pc + 2 + (disp << 2)) & 0xfffffffc;
+            tcg_gen_movi_tl(cpu_R[15], ctx->pc + 2);
+#if defined(CONFIG_USER_ONLY)
+            addr = cpu_ldl_code(env, addr);
+            gen_goto_tb(ctx, 0, addr);
+            ctx->is_jmp = DISAS_TB_JUMP;
+#else
+            t0 = tcg_temp_new();
+            tcg_gen_movi_tl(t0, addr);
+            tcg_gen_qemu_ld32u(t0, t0, ctx->mem_idx);
+            tcg_gen_andi_tl(t0, t0, 0xfffffffe);
+            store_cpu_field(t0, pc);
+
+            if ((ctx->trace_mode == BRAN_TRACE_MODE)
+                    || (ctx->trace_mode == INST_TRACE_MODE)) {
+                t0 = tcg_const_i32(EXCP_CSKY_TRACE);
+                gen_helper_exception(cpu_env, t0);
+            }
+            ctx->maybe_change_flow = 1;
+            tcg_temp_free(t0);
+            ctx->is_jmp = DISAS_JUMP;
+#endif
+            break;/*jsri*/
+        } else {
+            goto illegal_op;
+        }
+    case 0x8:
+        rx = insn & 0x000f;
+        imm = ((insn & 0x00f0) >> 4) << 2;
+        rz = (insn & 0x0f00) >> 8;
+
+        t0 = tcg_temp_new();
+        tcg_gen_addi_tl(t0, cpu_R[rx], imm);
+        tcg_gen_qemu_ld32u(cpu_R[rz], t0, ctx->mem_idx);
+        tcg_temp_free(t0);
+        break;/*ld.w*/
+    case 0x9:
+        rx = insn & 0x000f;
+        imm = ((insn & 0x00f0) >> 4) << 2;
+        rz = (insn & 0x0f00) >> 8;
+
+        t0 = tcg_temp_new();
+        tcg_gen_addi_tl(t0, cpu_R[rx], imm);
+        tcg_gen_qemu_st32(cpu_R[rz], t0, ctx->mem_idx);
+        tcg_temp_free(t0);
+        break;/*st.w*/
+    case 0xa:
+        rx = insn & 0x000f;
+        imm = (insn & 0x00f0) >> 4;
+        rz = (insn & 0x0f00) >> 8;
+
+        t0 = tcg_temp_new();
+        tcg_gen_addi_tl(t0, cpu_R[rx], imm);
+        tcg_gen_qemu_ld8u(cpu_R[rz], t0, ctx->mem_idx);
+        tcg_temp_free(t0);
+        break;/*ld.b*/
+    case 0xb:
+        rx = insn & 0x000f;
+        imm = (insn & 0x00f0) >> 4;
+        rz = (insn & 0x0f00) >> 8;
+
+        t0 = tcg_temp_new();
+        tcg_gen_addi_tl(t0, cpu_R[rx], imm);
+        tcg_gen_qemu_st8(cpu_R[rz], t0, ctx->mem_idx);
+        tcg_temp_free(t0);
+        break;/*st.b*/
+    case 0xc:
+        rx = insn & 0x000f;
+        imm = ((insn & 0x00f0) >> 4) << 1;
+        rz = (insn & 0x0f00) >> 8;
+
+        t0 = tcg_temp_new();
+        tcg_gen_addi_tl(t0, cpu_R[rx], imm);
+        tcg_gen_qemu_ld16u(cpu_R[rz], t0, ctx->mem_idx);
+        tcg_temp_free(t0);
+        break;/*ld.h*/
+    case 0xd:
+        rx = insn & 0x000f;
+        imm = ((insn & 0x00f0) >> 4) << 1;
+        rz = (insn & 0x0f00) >> 8;
+
+        t0 = tcg_temp_new();
+        tcg_gen_addi_tl(t0, cpu_R[rx], imm);
+        tcg_gen_qemu_st16(cpu_R[rz], t0, ctx->mem_idx);
+        tcg_temp_free(t0);
+
+        break;/*st.h*/
+    case 0xe:
+        if (insn_2 >> 3 == 0) {
+            disp = insn & 0x07ff;
+
+            bt(ctx, disp);
+            ctx->is_jmp = DISAS_TB_JUMP;
+            break;/*bt*/
+        } else if (insn_2 >> 3 == 1) {
+            disp = insn & 0x07ff;
+
+            bf(ctx, disp);
+            ctx->is_jmp = DISAS_TB_JUMP;
+            break;/*bf*/
+        } else {
+            goto illegal_op;
+        }
+    case 0xf:
+        if (insn_2 >> 3 == 0) {
+            disp = insn & 0x07ff;
+
+            br(ctx, disp);
+            ctx->is_jmp = DISAS_TB_JUMP;
+            break;/*br*/
+        } else if (insn_2 >> 3 == 1) {
+            disp = insn & 0x07ff;
+
+            bsr(ctx, disp);
+            ctx->is_jmp = DISAS_TB_JUMP;
+            break;/*bsr*/
+        } else {
+            goto illegal_op;
+        }
+    default:
+
+illegal_op:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static void csky_tb_start(CPUCSKYState *env, TranslationBlock *tb)
+{
+    uint32_t tb_pc = (uint32_t)tb->pc;
+    TCGv t0 = tcg_temp_new();
+
+    t0 = tcg_const_tl(tb_pc);
+    gen_helper_tb_trace(cpu_env, t0);
+    tcg_temp_free(t0);
+}
+
+static void csky_dump_tb_map(CPUCSKYState *env, TranslationBlock *tb)
+{
+    uint32_t tb_pc = (uint32_t)tb->pc;
+    uint32_t tb_end =  tb_pc + (uint32_t)tb->size;
+    uint32_t icount = (uint32_t)tb->icount;
+
+    qemu_log_mask(CPU_TB_TRACE, "tb_map: 0x%.8x 0x%.8x %d\n",
+                  tb_pc, tb_end, icount);
+}
+
+static int jcount_start_insn_idx;
+static void gen_csky_jcount_start(CPUCSKYState *env, TranslationBlock *tb)
+{
+    uint32_t tb_pc = (uint32_t)tb->pc;
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_new_i32();
+    /* We emit a movi with a dummy immediate argument. Keep the insn index
+     * of the movi so that we later (when we know the actual insn count)
+     * can update the immediate argument with the actual insn count.  */
+    jcount_start_insn_idx = tcg_op_buf_count();
+    tcg_gen_movi_i32(t1, 0xdeadbeef);
+
+    t0 = tcg_const_tl(tb_pc);
+    gen_helper_jcount(cpu_env, t0, t1);
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static void gen_csky_jcount_end(int num_insns)
+{
+    tcg_set_insn_param(jcount_start_insn_idx, 1, num_insns);
+}
+
+/* generate intermediate code in tcg_ctx.gen_opc_buf and gen_opparam_buf for
+   basic block 'tb'. If search_pc is TRUE, also generate PC
+   information for each intermediate instruction. */
+void gen_intermediate_code(CPUCSKYState *env, TranslationBlock *tb)
+{
+    CSKYCPU *cpu = csky_env_get_cpu(env);
+    CPUState *cs = CPU(cpu);
+    DisasContext dc1, *dc = &dc1;
+    target_ulong pc_start;
+    uint32_t next_page_start;
+    int num_insns;
+    int max_insns;
+
+    /* part var init */
+    pc_start = tb->pc;
+    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;
+    num_insns = 0;
+    max_insns = tb->cflags & CF_COUNT_MASK;
+    if (max_insns == 0) {
+        max_insns = CF_COUNT_MASK;
+    }
+    if (max_insns > TCG_MAX_INSNS) {
+        max_insns = TCG_MAX_INSNS;
+    }
+
+    /* DisasContext init */
+    dc->tb = tb;
+    dc->pc = tb->pc;
+    dc->singlestep_enabled = cs->singlestep_enabled;
+    dc->is_jmp = DISAS_NEXT;
+    dc->features = env->features;
+
+#ifndef CONFIG_USER_ONLY
+    dc->super = CSKY_TBFLAG_PSR_S(tb->flags);
+    dc->current_cp = CSKY_TBFLAG_CPID(tb->flags);
+    dc->trace_mode = (TraceMode)CSKY_TBFLAG_PSR_TM(tb->flags);
+#endif
+
+#ifdef CONFIG_USER_ONLY
+    dc->mem_idx = CSKY_USERMODE;
+#else
+    dc->mem_idx = dc->super;
+#endif
+
+    gen_tb_start(tb);
+
+    if (env->jcount_start != 0) {
+        gen_csky_jcount_start(env, tb);
+    }
+
+    if (env->tb_trace == 1) {
+        csky_tb_start(env, tb);
+    }
+
+    /* for idly */
+#if !defined(CONFIG_USER_ONLY)
+    uint32_t idly4_counter;
+    idly4_counter = env->idly4_counter;
+    if (unlikely(idly4_counter != 0)) {
+        TCGv t0 = tcg_temp_new();
+        do {
+            /* Intercept jump to the magic kernel page.  */
+#ifdef CONFIG_USER_ONLY
+            if (dc->pc >= 0x80000000) {
+                /* We always get here via a jump, so know we are not in a
+                   conditional execution block.  */
+                generate_exception(dc, EXCP_CSKY_PRIVILEGE);
+                dc->is_jmp = DISAS_UPDATE;
+                break;
+            }
+#endif
+            tcg_gen_insn_start(dc->pc);
+            num_insns++;
+
+            if (unlikely(cpu_breakpoint_test(cs, dc->pc, BP_ANY))) {
+                generate_exception(dc, EXCP_DEBUG);
+                dc->is_jmp = DISAS_JUMP;
+                dc->pc += 2;
+                goto done_generating;
+                break;
+            }
+
+            if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {
+                gen_io_start();
+            }
+
+            dc->insn = cpu_lduw_code(env, dc->pc);
+
+            disas_csky_v1_insn(env, dc);
+            dc->pc += 2;
+
+            idly4_counter--;
+
+            if (!idly4_counter) {
+                break;
+            }
+        } while (!dc->is_jmp && !tcg_op_buf_full() &&
+                 !cs->singlestep_enabled &&
+                 !singlestep &&
+                 dc->pc < next_page_start &&
+                 num_insns < max_insns);
+
+        t0 = tcg_const_tl(idly4_counter);
+        store_cpu_field(t0, idly4_counter);
+
+        tcg_temp_free(t0);
+        goto done_translation;
+    }
+#endif
+
+    do {
+#if !defined(CONFIG_USER_ONLY)
+        dc->cannot_be_traced = 0;
+        dc->maybe_change_flow = 0;
+#endif
+        /* Intercept jump to the magic kernel page.  */
+#ifdef CONFIG_USER_ONLY
+        if (dc->pc >= 0x80000000) {
+            /* We always get here via a jump, so know we are not in a
+                 conditional execution block.  */
+            generate_exception(dc, EXCP_CSKY_PRIVILEGE);
+            dc->is_jmp = DISAS_UPDATE;
+            break;
+        }
+#endif
+
+        tcg_gen_insn_start(dc->pc);
+        num_insns++;
+
+        if (unlikely(cpu_breakpoint_test(cs, dc->pc, BP_ANY))) {
+            generate_exception(dc, EXCP_DEBUG);
+            dc->is_jmp = DISAS_JUMP;
+            dc->pc += 2;
+            goto done_generating;
+            break;
+        }
+
+        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {
+            gen_io_start();
+        }
+
+        dc->insn = cpu_lduw_code(env, dc->pc);
+
+        disas_csky_v1_insn(env, dc);
+        dc->pc += 2;
+
+#if !defined(CONFIG_USER_ONLY)
+        if (dc->cannot_be_traced) {
+            break;
+        }
+
+        if (dc->trace_mode == INST_TRACE_MODE) {
+            if (!dc->maybe_change_flow) {
+                generate_exception(dc, EXCP_CSKY_TRACE);
+            }
+            break;
+        }
+#endif
+
+        /* Translation stops when a conditional branch is encountered.
+         * Otherwise the subsequent code could get translated several times.
+         * Also stop translation when a page boundary is reached.  This
+         * ensures prefetch aborts occur at the right place.  */
+    } while (!dc->is_jmp && !tcg_op_buf_full() &&
+             !cs->singlestep_enabled &&
+             !singlestep &&
+             dc->pc < next_page_start &&
+             num_insns < max_insns);
+
+#ifndef CONFIG_USER_ONLY
+done_translation:
+#endif
+    if (tb->cflags & CF_LAST_IO) {
+        gen_io_end();
+    }
+
+    if (unlikely(cs->singlestep_enabled)) {
+        if (!dc->is_jmp) {
+            generate_exception(dc, EXCP_DEBUG);
+        } else if (dc->is_jmp != DISAS_TB_JUMP) {
+            TCGv t0 = tcg_temp_new();
+
+            t0 = tcg_const_tl(EXCP_DEBUG);
+            gen_helper_exception(cpu_env, t0);
+
+            tcg_temp_free(t0);
+        }
+    } else {
+        switch (dc->is_jmp) {
+        case DISAS_NEXT:
+            gen_goto_tb(dc, 1, dc->pc);
+            break;
+        case DISAS_JUMP:
+        case DISAS_UPDATE:
+        /* indicate that the hash table must be used to find the next TB */
+            tcg_gen_exit_tb(0);
+            break;
+        case DISAS_TB_JUMP:
+        /* nothing more to generate */
+            break;
+        }
+    }
+
+done_generating:
+    if (env->jcount_start != 0) {
+        gen_csky_jcount_end(num_insns);
+    }
+    gen_tb_end(tb, num_insns);
+
+#ifdef DEBUG_DISAS
+    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {
+        qemu_log("----------------\n");
+        qemu_log("IN: %s\n", lookup_symbol(pc_start));
+        log_target_disas(cs, pc_start, dc->pc - pc_start, 0);
+        qemu_log("\n");
+    }
+#endif
+
+    tb->size = dc->pc - pc_start;
+    tb->icount = num_insns;
+    if (env->tb_trace == 1) {
+        csky_dump_tb_map(env, tb);
+    }
+}
+
+void csky_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,
+                         int flags)
+{
+    int i;
+    uint32_t psr;
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+
+    psr = (env->psr_s << 31) | (env->psr_tm << 14) | (env->cp0.psr) |
+           (env->psr_c);
+
+    for (i = 0; i < 16; i++) {
+        cpu_fprintf(f, "R%02d=%08x", i, env->regs[i]);
+        if ((i % 4) == 3) {
+            cpu_fprintf(f, "\n");
+        } else {
+            cpu_fprintf(f, " ");
+        }
+    }
+
+    cpu_fprintf(f, "psr=%08x ", psr);
+    cpu_fprintf(f, "pc=%08x\n", env->pc);
+    cpu_fprintf(f, "epsr=%08x ", env->cp0.epsr);
+    cpu_fprintf(f, "epc=%08x\n", env->cp0.epc);
+    cpu_fprintf(f, "hi=%08x ", env->hi);
+    cpu_fprintf(f, "lo=%08x ", env->lo);
+    cpu_fprintf(f, "hi_guard=%08x ", env->hi_guard);
+    cpu_fprintf(f, "lo_guard=%08x\n", env->lo_guard);
+}
+
+void restore_state_to_opc(CPUCSKYState *env, TranslationBlock *tb,
+                          target_ulong *data)
+{
+    env->pc = data[0];
+}
diff --git a/target-csky/translate_v2.c b/target-csky/translate_v2.c
new file mode 100644
index 0000000..afcef1f
--- /dev/null
+++ b/target-csky/translate_v2.c
@@ -0,0 +1,9276 @@
+/*
+ * CSKY translation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "cpu.h"
+#include "translate.h"
+#include "disas/disas.h"
+#include "exec/exec-all.h"
+#include "exec/cpu_ldst.h"
+#include "tcg-op.h"
+#include "trace-tcg.h"
+#include "qemu/log.h"
+#include <math.h>
+#include "exec/gdbstub.h"
+
+#include "exec/helper-proto.h"
+#include "exec/helper-gen.h"
+
+/*******************************/
+#define sp 14
+#define SVBR 30
+#define FP 23
+#define TOP 24
+#define BSP 25
+#define WORD_MASK 0x3
+#define REG_MASK   0x1c
+/*******************************************/
+
+static TCGv_env cpu_env;
+static TCGv_i32 cpu_R[32];
+static TCGv_i32 vdsp_Rl[16];
+static TCGv_i32 vdsp_Rh[16];
+static TCGv_i32 cpu_c;
+static TCGv_i32 cpu_v;
+static TCGv_i32 cpu_hi ;
+static TCGv_i32 cpu_lo;
+static TCGv_i32 cpu_hi_guard;
+static TCGv_i32 cpu_lo_guard;
+
+static TCGv_i32 cpu_F0s, cpu_F1s;
+static TCGv_i64 cpu_F0d, cpu_F1d;
+
+#include "exec/gen-icount.h"
+
+static const char *regnames[] = {
+    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+    "r8", "r9", "r10", "r11", "r12", "r13", "sp", "r15",
+    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
+    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31" };
+
+static const char *vreglnames[] = {
+    "vr0l", "vr1l", "vr2l", "vr3l", "vr4l", "vr5l", "vr6l", "vr7l",
+    "vr8l", "vr9l", "vr10l", "vr11l", "vr12l", "vr13l", "rv14l", "vr15l" };
+
+static const char *vreghnames[] = {
+    "vr0h", "vr1h", "vr2h", "vr3h", "vr4h", "vr5h", "vr6h", "vr7h",
+    "vr8h", "vr9h", "vr10h", "vr11h", "vr12h", "vr13h", "rv14h", "vr15h" };
+
+#if defined(CONFIG_USER_ONLY)
+#define IS_SUPER(ctx)   0
+#define IS_TRUST(ctx)   0
+#else
+#define IS_SUPER(ctx)   (ctx->super)
+#define IS_TRUST(ctx)   (ctx->trust)
+#endif
+
+static inline void mulsha(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_new();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_local_new_i64();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t0, cpu_R[rx]);
+    tcg_gen_ext16s_tl(t1, cpu_R[ry]);
+    tcg_gen_mul_tl(t0, t0, t1);
+    tcg_gen_ext_tl_i64(t2, t0);
+    tcg_gen_concat_i32_i64(t3, cpu_lo, cpu_lo_guard);
+    tcg_gen_add_i64(t2, t3, t2);
+    tcg_gen_extrl_i64_i32(cpu_lo, t2);
+    tcg_gen_shri_i64(t3, t2, 31);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t2);
+    tcg_gen_movi_i32(cpu_v, 0);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t3, 0x0, l1);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t3, 0x1ffffffffLL, l1);
+    tcg_gen_movi_i32(cpu_v, 1);
+    gen_set_label(l1);
+
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+}
+
+static inline void mulshs(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_new();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_local_new_i64();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t0, cpu_R[rx]);
+    tcg_gen_ext16s_tl(t1, cpu_R[ry]);
+    tcg_gen_mul_tl(t0, t0, t1);
+    tcg_gen_ext_tl_i64(t2, t0);
+    tcg_gen_concat_i32_i64(t3, cpu_lo, cpu_lo_guard);
+    tcg_gen_sub_i64(t2, t3, t2);
+    tcg_gen_extrl_i64_i32(cpu_lo, t2);
+    tcg_gen_shri_i64(t3, t2, 31);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t2);
+    tcg_gen_movi_i32(cpu_v, 0);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t3, 0x0, l1);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t3, 0x1ffffffffLL, l1);
+    tcg_gen_movi_i32(cpu_v, 1);
+    gen_set_label(l1);
+
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+
+}
+
+static inline void mulsw(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv t2 = tcg_temp_new();
+
+    tcg_gen_ext16s_tl(t2, cpu_R[rx]);
+    tcg_gen_ext_tl_i64(t0, t2);
+    tcg_gen_ext_tl_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_shri_i64(t0, t0, 16);
+    tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free(t2);
+}
+static inline void mulswa(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv_i64 t1 = tcg_temp_local_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t0, cpu_R[rx]) ;
+    tcg_gen_ext_tl_i64(t1, t0);
+    tcg_gen_ext_tl_i64(t2, cpu_R[ry]);
+    tcg_gen_mul_i64(t1, t1, t2) ;
+    tcg_gen_shri_i64(t1, t1, 16);
+    tcg_gen_concat_i32_i64(t2, cpu_lo, cpu_lo_guard);
+    tcg_gen_add_i64(t2, t2, t1);
+    tcg_gen_extrl_i64_i32(cpu_lo, t2);
+    tcg_gen_shri_i64(t1, t2, 31);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t2);
+    tcg_gen_movi_i32(cpu_v, 0);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t1, 0x0, l1);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t1, 0x1ffffffffLL, l1);
+    tcg_gen_movi_i32(cpu_v, 1);
+    gen_set_label(l1);
+
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+
+}
+static inline void mulsws(int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv_i64 t1 = tcg_temp_local_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_ext16s_tl(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, t0);
+    tcg_gen_ext_i32_i64(t2, cpu_R[ry]);
+    tcg_gen_mul_i64(t1, t1, t2);
+    tcg_gen_shri_i64(t1, t1, 16);
+    tcg_gen_concat_i32_i64(t2, cpu_lo, cpu_lo_guard);
+    tcg_gen_sub_i64(t2, t2, t1);
+    tcg_gen_extrl_i64_i32(cpu_lo, t2);
+    tcg_gen_shri_i64(t1, t2, 31);
+    tcg_gen_shri_i64(t2, t2, 32);
+    tcg_gen_extrl_i64_i32(cpu_lo_guard, t2);
+    tcg_gen_movi_i32(cpu_v, 0);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t1, 0x0, l1);
+    tcg_gen_brcondi_i64(TCG_COND_EQ, t1, 0x1ffffffffLL, l1);
+    tcg_gen_movi_i32(cpu_v, 1);
+    gen_set_label(l1);
+
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+}
+
+/* initialize TCG globals. */
+void csky_translate_init(void)
+{
+    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, "env");
+    tcg_ctx.tcg_env = cpu_env;
+    int i;
+
+    for (i = 0; i < 32; i++) {
+        cpu_R[i] = tcg_global_mem_new_i32(cpu_env,
+            offsetof(CPUCSKYState, regs[i]),
+            regnames[i]);
+    }
+
+    for (i = 0; i < 16; i++) {
+        vdsp_Rl[i] = MAKE_TCGV_I32(GET_TCGV_I64(tcg_global_mem_new_i64(cpu_env,
+            offsetof(CPUCSKYState, vfp.reg[i].udspl[0]),
+            vreglnames[i])));
+    }
+
+    for (i = 0; i < 16; i++) {
+        vdsp_Rh[i] = MAKE_TCGV_I32(GET_TCGV_I64(tcg_global_mem_new_i64(cpu_env,
+            offsetof(CPUCSKYState, vfp.reg[i].udspl[1]),
+            vreghnames[i])));
+    }
+
+    cpu_c = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, psr_c), "cpu_c");
+    cpu_v = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, dcsr_v), "cpu_v");
+    cpu_hi = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, hi), "cpu_hi");
+    cpu_lo = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, lo), "cpu_lo");
+    cpu_hi_guard = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, hi_guard), "cpu_hi_guard");
+    cpu_lo_guard = tcg_global_mem_new_i32(cpu_env,
+        offsetof(CPUCSKYState, lo_guard), "cpu_lo_guard");
+}
+
+static TCGv_i32 new_tmp(void)
+{
+    return tcg_temp_new_i32();
+}
+
+static void dead_tmp(TCGv tmp)
+{
+    tcg_temp_free(tmp);
+}
+
+
+static inline TCGv load_cpu_offset(int offset)
+{
+    TCGv tmp = tcg_temp_new();
+    tcg_gen_ld_i32(tmp, cpu_env, offset);
+    return tmp;
+}
+
+#define load_cpu_field(name) load_cpu_offset(offsetof(CPUCSKYState, name))
+
+static inline void store_cpu_offset(TCGv var, int offset)
+{
+    tcg_gen_st_i32(var, cpu_env, offset);
+}
+
+#define store_cpu_field(var, name) \
+store_cpu_offset(var, offsetof(CPUCSKYState, name))
+
+static inline void gen_save_pc(target_ulong pc)
+{
+    TCGv t0 = tcg_temp_new();
+
+    t0 = tcg_const_tl(pc);
+    store_cpu_field(t0, pc);
+
+    tcg_temp_free(t0);
+}
+
+static inline void generate_exception(DisasContext *ctx, int excp)
+{
+    TCGv t0 = tcg_temp_new();
+
+    print_exception(ctx, excp);
+
+    t0 = tcg_const_tl(excp);
+    gen_save_pc(ctx->pc);
+    gen_helper_exception(cpu_env, t0);
+    ctx->is_jmp = DISAS_UPDATE;
+
+    tcg_temp_free(t0);
+}
+
+static inline bool use_goto_tb(DisasContext *s, uint32_t dest)
+{
+#ifndef CONFIG_USER_ONLY
+    return (s->tb->pc & TARGET_PAGE_MASK) == (dest & TARGET_PAGE_MASK) ||
+           (s->pc & TARGET_PAGE_MASK) == (dest & TARGET_PAGE_MASK);
+#else
+    return true;
+#endif
+}
+
+static inline void gen_goto_tb(DisasContext *ctx, int n, uint32_t dest)
+{
+    TranslationBlock *tb;
+    TCGv t0 = tcg_temp_new();
+
+    tb = ctx->tb;
+
+    if (unlikely(ctx->singlestep_enabled)) {
+        gen_save_pc(dest);
+        t0 = tcg_const_tl(EXCP_DEBUG);
+        gen_helper_exception(cpu_env, t0);
+    }
+#if !defined(CONFIG_USER_ONLY)
+    else if (unlikely((ctx->trace_mode == INST_TRACE_MODE)
+        || (ctx->trace_mode == BRAN_TRACE_MODE))) {
+        gen_save_pc(dest);
+        t0 = tcg_const_tl(EXCP_CSKY_TRACE);
+        gen_helper_exception(cpu_env, t0);
+        ctx->maybe_change_flow = 1;
+    }
+#endif
+    else if (use_goto_tb(ctx, dest)) {
+        tcg_gen_goto_tb(n);
+        gen_save_pc(dest);
+        tcg_gen_exit_tb((uintptr_t)tb + n);
+    } else {
+        gen_save_pc(dest);
+        tcg_gen_exit_tb(0);
+    }
+
+    tcg_temp_free(t0);
+}
+
+
+#define ldst(name, rx, rz, imm, isize)                         \
+do {                                                           \
+    if (ctx->bctm) {                                           \
+        TCGLabel *l1 = gen_new_label();                        \
+        tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rx], 0, l1);     \
+        tcg_gen_movi_tl(cpu_R[15], ctx->pc + isize);           \
+        tcg_gen_subi_tl(t0, cpu_R[SVBR], 4);                   \
+        store_cpu_field(t0, pc);                               \
+        tcg_gen_exit_tb(0);                                    \
+        gen_set_label(l1);                                     \
+        tcg_gen_addi_tl(t0, cpu_R[rx], imm);                   \
+        tcg_gen_qemu_##name(cpu_R[rz], t0, ctx->mem_idx);      \
+        gen_goto_tb(ctx, 1, ctx->pc + isize);                  \
+        ctx->is_jmp = DISAS_TB_JUMP;                           \
+    } else {                                                   \
+        tcg_gen_addi_tl(t0, cpu_R[rx], imm);                   \
+        tcg_gen_qemu_##name(cpu_R[rz], t0, ctx->mem_idx);      \
+    }                                                          \
+} while (0)
+
+#define ldrstr(name, rx, ry, rz, imm)                          \
+do {                                                           \
+    if (ctx->bctm) {                                           \
+        TCGLabel *l1 = gen_new_label();                        \
+        tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rx], 0, l1);     \
+        tcg_gen_movi_tl(cpu_R[15], ctx->pc + 4);               \
+        tcg_gen_subi_tl(t0, cpu_R[SVBR], 4);                   \
+        store_cpu_field(t0, pc);                               \
+        tcg_gen_exit_tb(0);                                    \
+        gen_set_label(l1);                                     \
+        tcg_gen_shli_tl(t0, cpu_R[ry], imm);                   \
+        tcg_gen_add_tl(t0, cpu_R[rx], t0);                     \
+        tcg_gen_qemu_##name(cpu_R[rz], t0, ctx->mem_idx);      \
+        gen_goto_tb(ctx, 1, ctx->pc + 4);                      \
+        ctx->is_jmp = DISAS_TB_JUMP;                           \
+        break;                                                 \
+    } else {                                                   \
+        tcg_gen_shli_tl(t0, cpu_R[ry], imm);                   \
+        tcg_gen_add_tl(t0, cpu_R[rx], t0);                     \
+        tcg_gen_qemu_##name(cpu_R[rz], t0, ctx->mem_idx);      \
+    }                                                          \
+} while (0)
+
+/* The insn support the cpu contained in the argument 'flags'.  */
+static inline void check_insn(DisasContext *ctx, uint32_t flags)
+{
+    if (unlikely(!has_insn(ctx, flags))) {
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+    }
+}
+
+/* The insn not support the cpu contained in the argument 'flags'.  */
+static inline void check_insn_except(DisasContext *ctx, uint32_t flags)
+{
+    if (unlikely(has_insn(ctx, flags))) {
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+    }
+}
+
+/* Set a variable to the value of a CPU register.  */
+static void load_reg_var(DisasContext *s, TCGv var, int reg)
+{
+    tcg_gen_mov_i32(var, cpu_R[reg]);
+}
+
+/* Create a new temporary and set it to the value of a CPU register.  */
+static inline TCGv load_reg(DisasContext *s, int reg)
+{
+    TCGv tmp = new_tmp();
+    load_reg_var(s, tmp, reg);
+    return tmp;
+}
+
+static inline void addc(int rz, int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+
+    tcg_gen_mov_tl(t1, cpu_R[rx]);
+    tcg_gen_add_tl(t0, t1, cpu_R[ry]);
+    tcg_gen_add_tl(cpu_R[rz], t0, cpu_c);
+    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 0, l1);
+    tcg_gen_setcond_tl(TCG_COND_LTU, cpu_c, cpu_R[rz], t1);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+    tcg_gen_setcond_tl(TCG_COND_LEU, cpu_c, cpu_R[rz], t1);
+    gen_set_label(l2);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static inline void subc(int rz, int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_new();
+    TCGv t2 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+
+    tcg_gen_subfi_tl(t0, 1, cpu_c);
+    tcg_gen_sub_tl(t1, cpu_R[rx], cpu_R[ry]);
+    tcg_gen_sub_tl(t2, t1, t0);
+    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 0, l1);
+    tcg_gen_setcond_tl(TCG_COND_GTU, cpu_c, cpu_R[rx], cpu_R[ry]);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+    tcg_gen_setcond_tl(TCG_COND_GEU, cpu_c, cpu_R[rx], cpu_R[ry]);
+    gen_set_label(l2);
+    tcg_gen_mov_tl(cpu_R[rz], t2);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+    tcg_temp_free(t2);
+
+}
+
+
+static inline void tstnbz(int rx)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_movi_tl(cpu_c, 0);
+
+    tcg_gen_andi_tl(t0, cpu_R[rx], 0xff000000);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
+
+    tcg_gen_andi_tl(t0, cpu_R[rx], 0x00ff0000);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
+
+    tcg_gen_andi_tl(t0, cpu_R[rx], 0x0000ff00);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
+
+    tcg_gen_andi_tl(t0, cpu_R[rx], 0x000000ff);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);
+
+    tcg_gen_movi_tl(cpu_c, 1);
+    gen_set_label(l1);
+
+    tcg_temp_free(t0);
+}
+
+static inline void lsl(int rz, int rx, int ry)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGv t1 = tcg_temp_local_new();
+
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_mov_tl(t1, cpu_R[rx]);
+    tcg_gen_andi_tl(t0, cpu_R[ry], 0x3f);
+    tcg_gen_movi_tl(cpu_R[rz], 0);
+    tcg_gen_brcondi_tl(TCG_COND_GTU, t0, 31, l1);
+    tcg_gen_shl_tl(cpu_R[rz], t1, t0);
+    gen_set_label(l1);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static inline void lsr(int rz, int rx, int ry)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGv t1 = tcg_temp_local_new();
+
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_mov_tl(t1, cpu_R[rx]);
+    tcg_gen_andi_tl(t0, cpu_R[ry], 0x3f);
+    tcg_gen_movi_tl(cpu_R[rz], 0);
+    tcg_gen_brcondi_tl(TCG_COND_GTU, t0, 31, l1);
+    tcg_gen_shr_tl(cpu_R[rz], t1, t0);
+    gen_set_label(l1);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static inline void asr(int rz, int rx, int ry)
+{
+    TCGv t0 = tcg_temp_local_new();
+
+    TCGLabel *l1 = gen_new_label();
+    tcg_gen_andi_tl(t0, cpu_R[ry], 0x3f);
+    tcg_gen_brcondi_tl(TCG_COND_LEU, t0, 31, l1);
+    tcg_gen_movi_tl(t0, 31);
+    gen_set_label(l1);
+    tcg_gen_sar_tl(cpu_R[rz], cpu_R[rx], t0);
+
+    tcg_temp_free(t0);
+}
+
+static inline void rotl(int rz, int rx, int ry)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGv t1 = tcg_temp_local_new();
+
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_mov_tl(t1, cpu_R[rx]);
+    tcg_gen_andi_tl(t0, cpu_R[ry], 0x3f);
+    tcg_gen_movi_tl(cpu_R[rz], 0);
+    tcg_gen_brcondi_tl(TCG_COND_GTU, t0, 31, l1);
+    tcg_gen_rotl_tl(cpu_R[rz], t1, t0);
+    gen_set_label(l1);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static inline void branch16(DisasContext *ctx, TCGCond cond, int offset)
+{
+    int val;
+    TCGLabel *l1 = gen_new_label();
+    TCGv t0 = tcg_temp_new();
+
+    val = offset << 1;
+    if (val & 0x400) {
+        val |= 0xfffffc00;
+    }
+    val += ctx->pc;
+
+    tcg_gen_brcondi_tl(cond, cpu_c, 0, l1);
+    gen_goto_tb(ctx, 1, ctx->pc + 2);
+    gen_set_label(l1);
+
+    gen_goto_tb(ctx, 0, val);
+
+    ctx->is_jmp = DISAS_TB_JUMP;
+
+    tcg_temp_free(t0);
+}
+
+static inline void bsr16(DisasContext *ctx, int offset)
+{
+    int val;
+
+    val = offset << 1;
+    if (val & 0x400) {
+        val |= 0xfffffc00;
+    }
+    val += ctx->pc;
+
+    gen_goto_tb(ctx, 0, val);
+
+    ctx->is_jmp = DISAS_TB_JUMP;
+}
+
+static inline void pop16(DisasContext *ctx, int imm)
+{
+    int i;
+    TCGv t0 = tcg_temp_new();
+    tcg_gen_mov_tl(t0, cpu_R[sp]);
+    if (imm & 0xf) {
+        for (i = 0; i < (imm & 0xf); i++) {
+            tcg_gen_qemu_ld32u(cpu_R[i + 4], t0, ctx->mem_idx);
+            tcg_gen_addi_i32(t0, t0, 4);
+        }
+    }
+    if (imm & 0x10) {
+        tcg_gen_qemu_ld32u(cpu_R[15], t0, ctx->mem_idx);
+        tcg_gen_addi_i32(t0, t0, 4);
+    }
+    tcg_gen_mov_tl(cpu_R[sp], t0);
+
+    tcg_gen_andi_tl(t0, cpu_R[15], 0xfffffffe);
+    store_cpu_field(t0, pc);
+    ctx->is_jmp = DISAS_JUMP;
+    tcg_temp_free(t0);
+}
+
+static inline void push16(DisasContext *ctx, int imm)
+{
+    int i;
+    TCGv t0 = tcg_temp_new();
+
+    tcg_gen_mov_tl(t0, cpu_R[sp]);
+
+    if (imm & 0x10) {
+        tcg_gen_subi_i32(t0, t0, 4);
+        tcg_gen_qemu_st32(cpu_R[15], t0, ctx->mem_idx);
+    }
+
+    if (imm & 0xf) {
+        for (i = (imm & 0xf); i > 0; i--) {
+            tcg_gen_subi_i32(t0, t0, 4);
+            tcg_gen_qemu_st32(cpu_R[i + 3], t0, ctx->mem_idx);
+        }
+    }
+    tcg_gen_mov_tl(cpu_R[sp], t0);
+    tcg_temp_free(t0);
+}
+
+static inline void gen_cmp16(DisasContext *ctx, uint32_t sop, int rz, int rx)
+{
+    switch (sop) {
+    case 0x0:
+        /* cmphs */
+        tcg_gen_setcond_tl(TCG_COND_GEU, cpu_c, cpu_R[rx], cpu_R[rz]);
+        break;
+    case 0x1:
+        /* cmplt */
+        tcg_gen_setcond_tl(TCG_COND_LT, cpu_c, cpu_R[rx], cpu_R[rz]);
+        break;
+    case 0x2:
+        /* cmpne */
+        tcg_gen_setcond_tl(TCG_COND_NE, cpu_c, cpu_R[rx], cpu_R[rz]);
+        break;
+    case 0x3:
+        /* mvcv */
+        tcg_gen_subfi_tl(cpu_R[rz], 1, cpu_c);
+        break;
+    default:
+        break;
+    }
+}
+
+static inline void gen_logic_and16(DisasContext *ctx, uint32_t sop,
+                                   int rz, int rx)
+{
+    switch (sop) {
+    case 0x0:
+        /* and */
+        tcg_gen_and_tl(cpu_R[rz], cpu_R[rz], cpu_R[rx]);
+        break;
+    case 0x1:
+        /* andn */
+        tcg_gen_andc_tl(cpu_R[rz], cpu_R[rz], cpu_R[rx]);
+        break;
+    case 0x2:
+        /* tst */
+        {
+            TCGv t0 = tcg_temp_new();
+            tcg_gen_and_tl(t0, cpu_R[rx], cpu_R[rz]);
+            tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, t0, 0);
+
+            tcg_temp_free(t0);
+        }
+        break;
+    case 0x3:
+        /* tstnbz */
+        tstnbz(rx);
+        break;
+    default:
+        break;
+    }
+}
+
+static inline void gen_logic_or16(DisasContext *ctx, uint32_t sop,
+                                  int rz, int rx)
+{
+    switch (sop) {
+    case 0x0:
+        /* or */
+        tcg_gen_or_tl(cpu_R[rz], cpu_R[rz], cpu_R[rx]);
+        break;
+    case 0x1:
+        /* xor */
+        tcg_gen_xor_tl(cpu_R[rz], cpu_R[rz], cpu_R[rx]);
+        break;
+    case 0x2:
+        /* nor */
+        tcg_gen_nor_tl(cpu_R[rz], cpu_R[rz], cpu_R[rx]);
+        break;
+    case 0x3:
+        /* mov */
+        tcg_gen_mov_tl(cpu_R[rz], cpu_R[rx]);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static inline void gen_shift_reg16(DisasContext *ctx, uint32_t sop,
+                                   int rz, int rx)
+{
+    switch (sop) {
+    case 0x0:
+        /* lsl */
+        lsl(rz, rz, rx);
+        break;
+    case 0x1:
+        /* lsr */
+        lsr(rz, rz, rx);
+        break;
+    case 0x2:
+        /* asr */
+        asr(rz, rz, rx);
+        break;
+    case 0x3:
+        /* rotl */
+        rotl(rz, rz, rx);
+        break;
+    default:
+        break;
+    }
+}
+
+static inline void gen_ext16(DisasContext *ctx, uint32_t sop, int rz, int rx)
+{
+    switch (sop) {
+    case 0x0:
+        /* zextb */
+        tcg_gen_andi_tl(cpu_R[rz], cpu_R[rx], 0xff);
+        break;
+    case 0x1:
+        /* zexth */
+        tcg_gen_andi_tl(cpu_R[rz], cpu_R[rx], 0xffff);
+        break;
+    case 0x2:
+        /* sextb */
+        tcg_gen_shli_tl(cpu_R[rz], cpu_R[rx], 24);
+        tcg_gen_sari_tl(cpu_R[rz], cpu_R[rz], 24);
+        break;
+    case 0x3:
+        /* sexth */
+        tcg_gen_shli_tl(cpu_R[rz], cpu_R[rx], 16);
+        tcg_gen_sari_tl(cpu_R[rz], cpu_R[rz], 16);
+        break;
+    default:
+        break;
+    }
+}
+
+static inline void gen_arith_misc16(DisasContext *ctx, uint32_t sop,
+                                    int rz, int rx)
+{
+    switch (sop) {
+    case 0x0:
+        /* jmp */
+        {
+            TCGv t0 = tcg_temp_new();
+            tcg_gen_andi_tl(t0, cpu_R[rx], 0xfffffffe);
+            store_cpu_field(t0, pc);
+
+#if !defined(CONFIG_USER_ONLY)
+            if ((ctx->trace_mode == BRAN_TRACE_MODE)
+                || (ctx->trace_mode == INST_TRACE_MODE)) {
+                t0 = tcg_const_i32(EXCP_CSKY_TRACE);
+                gen_helper_exception(cpu_env, t0);
+            }
+            ctx->maybe_change_flow = 1;
+#endif
+            ctx->is_jmp = DISAS_JUMP;
+            tcg_temp_free(t0);
+        }
+        break;
+    case 0x1:
+        /* jsr */
+        {
+            TCGv t0 = tcg_temp_new();
+            tcg_gen_andi_tl(t0, cpu_R[rx], 0xfffffffe);
+            tcg_gen_movi_tl(cpu_R[15], ctx->pc + 2);
+            store_cpu_field(t0, pc);
+
+#if !defined(CONFIG_USER_ONLY)
+            if ((ctx->trace_mode == BRAN_TRACE_MODE)
+                || (ctx->trace_mode == INST_TRACE_MODE)) {
+                t0 = tcg_const_i32(EXCP_CSKY_TRACE);
+                gen_helper_exception(cpu_env, t0);
+            }
+            ctx->maybe_change_flow = 1;
+#endif
+            ctx->is_jmp = DISAS_JUMP;
+            tcg_temp_free(t0);
+            break;
+        }
+        break;
+    case 0x2:
+        /* revb */
+        check_insn_except(ctx, CPU_801);
+        tcg_gen_bswap32_tl(cpu_R[rz], cpu_R[rx]);
+        break;
+    case 0x3:
+        /* revh */
+        {
+            check_insn_except(ctx, CPU_801);
+            TCGv t0 = tcg_temp_new();
+            TCGv t1 = tcg_temp_new();
+
+            tcg_gen_bswap32_tl(t0, cpu_R[rx]);
+            tcg_gen_shri_tl(t1, t0, 16);
+            tcg_gen_shli_tl(t0, t0, 16);
+            tcg_gen_or_tl(cpu_R[rz], t0, t1);
+
+            tcg_temp_free(t0);
+            tcg_temp_free(t1);
+        }
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static inline void gen_mul16(DisasContext *ctx, uint32_t sop, int rz, int rx)
+{
+    switch (sop) {
+    case 0x0:
+        /* mult */
+        tcg_gen_mul_tl(cpu_R[rz], cpu_R[rz], cpu_R[rx]);
+        break;
+    case 0x1:
+        /* mulsh */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        {
+            TCGv t0 = tcg_temp_new();
+
+            tcg_gen_ext16s_tl(t0, cpu_R[rx]);
+            tcg_gen_ext16s_tl(cpu_R[rz], cpu_R[rz]);
+            tcg_gen_mul_tl(cpu_R[rz], cpu_R[rz], t0);
+
+            tcg_temp_free(t0);
+        }
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+
+
+static void gen_branch16(DisasContext *ctx, uint32_t op, int offset)
+{
+    switch (op) {
+    case 0x0:
+        if (offset == 0) {
+            /*bkpt16*/
+            if (is_gdbserver_start == TRUE) {
+                generate_exception(ctx, EXCP_DEBUG);
+                ctx->is_jmp = DISAS_JUMP;
+            } else {
+                generate_exception(ctx, EXCP_CSKY_BKPT);
+            }
+#if !defined(CONFIG_USER_ONLY)
+            ctx->cannot_be_traced = 1;
+#endif
+        } else if (!has_insn(ctx, ABIV2_ELRW)) {
+            /*bsr16*/
+            tcg_gen_movi_tl(cpu_R[15], ctx->pc + 2);
+            bsr16(ctx, offset);
+        } else {
+            /* lrw16 extend */
+            unsigned int imm, rz, addr;
+            TCGv t0 = tcg_temp_new();
+
+            imm = ((ctx->insn & 0x300) >> 3) | (ctx->insn & 0x1f);
+            imm = (~imm & 0x7f) | 0x80;
+            rz = (ctx->insn >> 5) & 0x7;
+            addr = (ctx->pc + (imm << 2)) & 0xfffffffc ;
+            tcg_gen_movi_tl(t0, addr);
+            tcg_gen_qemu_ld32u(cpu_R[rz], t0, ctx->mem_idx);
+            tcg_temp_free(t0);
+        }
+        break;
+    case 0x1:
+        /*br16*/
+        {
+            int val;
+
+            val = offset << 1;
+            if (val & 0x400) {
+                val |= 0xfffffc00;
+            }
+            val += ctx->pc;
+
+            gen_goto_tb(ctx, 0, val);
+
+            ctx->is_jmp = DISAS_TB_JUMP;
+        }
+        break;
+    case 0x2:
+        /*bt16*/
+        branch16(ctx, TCG_COND_NE, offset);
+        break;
+    case 0x3:
+        /*bf16*/
+        branch16(ctx, TCG_COND_EQ, offset);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static inline void gen_nvic_insn(DisasContext *ctx, uint32_t op, int imm)
+{
+    int i;
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    tcg_gen_mov_i32(t0, cpu_R[sp]);
+
+    switch (imm) {
+    case 0x0:
+        /* nie */
+        t1 = load_cpu_field(cp0.epc);
+        tcg_gen_subi_i32(t0, t0, 4);
+        tcg_gen_qemu_st32(t1, t0, ctx->mem_idx);
+        t1 = load_cpu_field(cp0.epsr);
+        tcg_gen_subi_i32(t0, t0, 4);
+        tcg_gen_qemu_st32(t1, t0, ctx->mem_idx);
+        tcg_gen_mov_i32(cpu_R[sp], t0);
+        t1 = load_cpu_field(cp0.psr);
+        tcg_gen_ori_i32(t1, t1, PSR_EE_MASK);
+        tcg_gen_ori_i32(t1, t1, PSR_IE_MASK);
+        store_cpu_field(t1, cp0.psr);
+        break;
+    case 0x1:
+        /* nir */
+#ifndef CONFIG_USER_ONLY
+        if (!IS_SUPER(ctx)) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        } else {
+            tcg_gen_qemu_ld32u(t1, t0, ctx->mem_idx);
+            store_cpu_field(t1, cp0.epsr);
+            tcg_gen_addi_i32(t0, t0, 4);
+            tcg_gen_qemu_ld32u(t1, t0, ctx->mem_idx);
+            store_cpu_field(t1, cp0.epc);
+            tcg_gen_addi_i32(t0, t0, 4);
+            tcg_gen_mov_i32(cpu_R[sp], t0);
+            t0 = tcg_const_i32(0);
+            store_cpu_field(t0, idly4_counter);
+            gen_helper_rte(cpu_env);
+            ctx->is_jmp = DISAS_UPDATE;
+        }
+#else
+        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#endif
+        break;
+    case 0x2:
+        /* ipush */
+        tcg_gen_subi_i32(t0, t0, 4);
+        tcg_gen_qemu_st32(cpu_R[13], t0, ctx->mem_idx);
+        tcg_gen_subi_i32(t0, t0, 4);
+        tcg_gen_qemu_st32(cpu_R[12], t0, ctx->mem_idx);
+        for (i = 3; i >= 0; i--) {
+            tcg_gen_subi_i32(t0, t0, 4);
+            tcg_gen_qemu_st32(cpu_R[i], t0, ctx->mem_idx);
+        }
+        tcg_gen_mov_i32(cpu_R[sp], t0);
+        break;
+    case 0x3:
+        /* ipop */
+        for (i = 0; i <= 3; i++) {
+            tcg_gen_qemu_ld32u(cpu_R[i], t0, ctx->mem_idx);
+            tcg_gen_addi_i32(t0, t0, 4);
+        }
+        tcg_gen_qemu_ld32u(cpu_R[12], t0, ctx->mem_idx);
+        tcg_gen_addi_i32(t0, t0, 4);
+        tcg_gen_qemu_ld32u(cpu_R[13], t0, ctx->mem_idx);
+        tcg_gen_addi_i32(t0, t0, 4);
+        tcg_gen_mov_i32(cpu_R[sp], t0);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static void gen_imm7_arith16(DisasContext *ctx, uint32_t op, uint16_t sop,
+                             int imm)
+{
+    switch (sop) {
+    case 0x0:
+        /*addisp(2)*/
+        tcg_gen_addi_tl(cpu_R[sp], cpu_R[sp], imm << 2);
+        break;
+    case 0x1:
+        /*subisp*/
+        tcg_gen_subi_tl(cpu_R[sp], cpu_R[sp], imm << 2);
+        break;
+    case 0x3:
+        check_insn(ctx, CPU_801 | CPU_802 | CPU_803S);
+        gen_nvic_insn(ctx, op, imm);
+        break;
+    case 0x4:
+        /*pop16*/
+        if (ctx->bctm) {
+            TCGv t0 = tcg_temp_new();
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[sp], 0, l1);
+            tcg_gen_movi_tl(cpu_R[15], ctx->pc + 2);
+            tcg_gen_subi_tl(t0, cpu_R[SVBR], 4);
+            store_cpu_field(t0, pc);
+            tcg_gen_exit_tb(0);
+            gen_set_label(l1);
+            pop16(ctx, imm & 0x1f);
+            tcg_temp_free(t0);
+            break;
+        } else {
+            pop16(ctx, imm & 0x1f);
+            break;
+        }
+    case 0x6:
+        /*push16*/
+        if (ctx->bctm) {
+            TCGv t0 = tcg_temp_new();
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[sp], 0, l1);
+            tcg_gen_movi_tl(cpu_R[15], ctx->pc + 2);
+            tcg_gen_subi_tl(t0, cpu_R[SVBR], 4);
+            store_cpu_field(t0, pc);
+            tcg_gen_exit_tb(0);
+            gen_set_label(l1);
+            push16(ctx, imm & 0x1f);
+            gen_goto_tb(ctx, 1, ctx->pc + 2);
+            ctx->is_jmp = DISAS_TB_JUMP;
+            tcg_temp_free(t0);
+            break;
+        } else {
+            push16(ctx, imm & 0x1f);
+            break;
+        }
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static void gen_imm8_arith16(DisasContext *ctx, uint32_t op, int rz, int imm)
+{
+    switch (op) {
+    case 0x6:
+    case 0x7:
+        /*addisp(1)*/
+        tcg_gen_addi_tl(cpu_R[rz], cpu_R[sp], imm << 2);
+        break;
+    case 0x8:
+    case 0x9:
+        /*addi16(1)*/
+        tcg_gen_addi_tl(cpu_R[rz], cpu_R[rz], imm + 1);
+        break;
+    case 0xa:
+    case 0xb:
+        /*subi16(1)*/
+        tcg_gen_subi_tl(cpu_R[rz], cpu_R[rz], imm + 1);
+        break;
+    case 0xc:
+    case 0xd:
+        /*movi16*/
+        tcg_gen_movi_tl(cpu_R[rz], imm);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static void gen_imm5_arith16(DisasContext *ctx, uint32_t op, uint16_t sop,
+                             int rx, int imm)
+{
+    switch (sop) {
+    case 0x0:
+        /*cmphsi16*/
+        tcg_gen_setcondi_tl(TCG_COND_GEU, cpu_c, cpu_R[rx], imm + 1);
+        break;
+    case 0x1:
+        /*cmplti16*/
+        tcg_gen_setcondi_tl(TCG_COND_LT, cpu_c, cpu_R[rx], imm + 1);
+        break;
+    case 0x2:
+        /*cmpnei16*/
+        tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[rx], imm);
+        break;
+    case 0x4:
+        /*bclri16*/
+        tcg_gen_andi_tl(cpu_R[rx], cpu_R[rx], ~(1 << imm));
+        break;
+    case 0x5:
+        /*bseti16*/
+        tcg_gen_ori_tl(cpu_R[rx], cpu_R[rx], 1 << imm);
+        break;
+    case 0x7:
+        /* jmpix16 */
+        check_insn(ctx, ABIV2_JAVA);
+        if (ctx->bctm) {
+            TCGv t0 = tcg_temp_new();
+            TCGv t1 = tcg_temp_new();
+            /*
+            tcg_gen_addi_tl(t0, cpu_R[rx], 0xff);
+            tcg_gen_and_tl(t0, t0, (16 + ((imm & 0x3) << 3)));
+            tcg_gen_add_tl(t0, cpu_R[SVBR], t0);
+            */
+            tcg_gen_andi_tl(t0, cpu_R[rx], 0xff);
+            switch (imm & 0x3) {
+            case 0x0:
+                tcg_gen_shli_tl(t0, t0, 4);
+                break;
+            case 0x1:
+                tcg_gen_shli_tl(t1, t0, 4);
+                tcg_gen_shli_tl(t0, t0, 3);
+                tcg_gen_add_tl(t0, t0, t1);
+                break;
+            case 0x2:
+                tcg_gen_shli_tl(t0, t0, 5);
+                break;
+            case 0x3:
+                tcg_gen_shli_tl(t1, t0, 5);
+                tcg_gen_shli_tl(t0, t0, 3);
+                tcg_gen_add_tl(t0, t0, t1);
+                break;
+            default:
+                break;
+            }
+            tcg_gen_add_tl(t0, cpu_R[SVBR], t0);
+            store_cpu_field(t0, pc);
+
+            ctx->is_jmp = DISAS_JUMP;
+            tcg_temp_free(t1);
+            tcg_temp_free(t0);
+            break;
+        }
+    case 0x6:
+        if (has_insn(ctx, ABIV2_ELRW)) {
+            /* btsti16 */
+            tcg_gen_andi_tl(cpu_c, cpu_R[rx], 1 << imm);
+            tcg_gen_shri_tl(cpu_c, cpu_c, imm);
+            break;
+        }
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static void gen_reg1_arith16(DisasContext *ctx, uint32_t op, int rz,
+                             int rx, int imm)
+{
+    switch (op) {
+    case 0x10:
+    case 0x11:
+        /*lsli16*/
+        tcg_gen_shli_tl(cpu_R[rz], cpu_R[rx], imm);
+        break;
+    case 0x12:
+    case 0x13:
+        /*lsri16*/
+        tcg_gen_shri_tl(cpu_R[rz], cpu_R[rx], imm);
+        break;
+    case 0x14:
+    case 0x15:
+        /*asri16*/
+        tcg_gen_sari_tl(cpu_R[rz], cpu_R[rx], imm);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static void gen_reg3_arith16(DisasContext *ctx, uint32_t op, uint16_t sop,
+                             int rz, int rx, int ry, int imm)
+{
+    switch (sop) {
+    case 0x0:
+        /*addu16(2)*/
+        tcg_gen_add_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case 0x1:
+        /*subu16(2)*/
+        tcg_gen_sub_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case 0x2:
+        /*addi16(2)*/
+        tcg_gen_addi_tl(cpu_R[rz], cpu_R[rx], imm + 1);
+        break;
+    case 0x3:
+        /*subi16(2)*/
+        tcg_gen_subi_tl(cpu_R[rz], cpu_R[rx], imm + 1);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static void gen_reg2_arith16(DisasContext *ctx, uint32_t op, uint16_t sop,
+                             int rx, int rz)
+{
+    switch (op) {
+    case 0x18:
+        switch (sop) {
+        case 0x0:
+            /*addu16(1)*/
+            tcg_gen_add_tl(cpu_R[rz], cpu_R[rz], cpu_R[rx]);
+            break;
+        case 0x1:
+            /*addc16*/
+            addc(rz, rz, rx);
+            break;
+        case 0x2:
+            /*subu16(1)*/
+            tcg_gen_sub_tl(cpu_R[rz], cpu_R[rz], cpu_R[rx]);
+            break;
+        case 0x3:
+            /*subc16*/
+            subc(rz, rz, rx);
+            break;
+        default:
+            generate_exception(ctx, EXCP_CSKY_UDEF);
+            break;
+        }
+        break;
+    case 0x19:
+        gen_cmp16(ctx, sop, rz, rx);
+        break;
+    case 0x1a:
+        gen_logic_and16(ctx, sop, rz, rx);
+        break;
+    case 0x1b:
+        gen_logic_or16(ctx, sop, rz, rx);
+        break;
+    case 0x1c:
+        gen_shift_reg16(ctx, sop, rz, rx);
+        break;
+    case 0x1d:
+        gen_ext16(ctx, sop, rz, rx);
+        break;
+    case 0x1e:
+        gen_arith_misc16(ctx, sop, rz, rx);
+        break;
+    case 0x1f:
+        gen_mul16(ctx, sop, rz, rx);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static void gen_ldst16(DisasContext *ctx, uint32_t op, int rz, int rx, int imm)
+{
+    TCGv t0 = tcg_temp_new();
+
+    switch (op) {
+    case 0x20:
+    case 0x21:
+        /*ld.b16*/
+        ldst(ld8u, rx, rz, imm, 2);
+        break;
+    case 0x22:
+    case 0x23:
+        /*ld.h16*/
+        ldst(ld16u, rx, rz, imm << 1, 2);
+        break;
+    case 0x24:
+    case 0x25:
+        /*ld.w16*/
+        ldst(ld32u, rx, rz, imm << 2, 2);
+        break;
+    case 0x28:
+    case 0x29:
+        /*st.b16*/
+        ldst(st8, rx, rz, imm, 2);
+        break;
+    case 0x2a:
+    case 0x2b:
+        /*st.h16*/
+        ldst(st16, rx, rz, imm << 1, 2);
+        break;
+    case 0x2c:
+    case 0x2d:
+        /*st.w16*/
+        ldst(st32, rx, rz, imm << 2, 2);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+
+    tcg_temp_free(t0);
+
+}
+
+static void disas_csky_16_insn(CPUCSKYState *env, DisasContext *ctx)
+{
+    unsigned int insn, rz, rx, ry;
+    uint32_t op, sop;
+    int imm;
+    target_ulong addr;
+    TCGv t0;
+
+    insn = ctx->insn;
+
+    op = (insn >> 10) & 0x3f;
+    switch (op) {
+    case 0x0 ... 0x3:
+        imm = insn & 0x3ff;
+        gen_branch16(ctx, op, imm);
+        break;
+    case 0x4:
+        /*lrw16*/
+        t0 = tcg_temp_new();
+        imm = ((insn & 0x300) >> 3) | (insn & 0x1f);
+        rz = (insn >> 5) & 0x7;
+        addr = (ctx->pc + (imm << 2)) & 0xfffffffc ;
+        tcg_gen_movi_tl(t0, addr);
+        tcg_gen_qemu_ld32u(cpu_R[rz], t0, ctx->mem_idx);
+        tcg_temp_free(t0);
+        break;
+    case 0x5:
+        imm = ((insn >> 3) & 0x60) | (insn & 0x1f);
+        sop = (insn >> 5) & 0x7;
+        gen_imm7_arith16(ctx, op, sop, imm);
+        break;
+    case 0x6 ... 0xd:
+        imm = insn & 0xff;
+        rz = (insn >> 8) & 0x7;
+        gen_imm8_arith16(ctx, op, rz, imm);
+        break;
+    case 0xe:
+    case 0xf:
+        imm = insn & 0x1f;
+        sop = (insn >> 5) & 0x7;
+        rx = (insn >> 8) & 0x7;
+        gen_imm5_arith16(ctx, op, sop, rx, imm);
+        break;
+    case 0x10 ... 0x15:
+        imm = insn & 0x1f;
+        rz = (insn >> 5) & 0x7;
+        rx = (insn >> 8) & 0x7;
+        gen_reg1_arith16(ctx, op, rz, rx, imm);
+        break;
+    case 0x16:
+    case 0x17:
+        sop = insn & 0x3;
+        imm = (insn >> 2) & 0x7;
+        ry = (insn >> 2) & 0x7;
+        rz = (insn >> 5) & 0x7;
+        rx = (insn >> 8) & 0x7;
+        gen_reg3_arith16(ctx, op, sop, rz, rx, ry, imm);
+        break;
+    case 0x18 ... 0x1f:
+        sop = insn & 0x3;
+        rx = (insn >> 2) & 0xf;
+        rz = (insn >> 6) & 0xf;
+        gen_reg2_arith16(ctx, op, sop, rx, rz);
+        break;
+    case 0x20 ... 0x25:
+        imm = insn & 0x1f;
+        rz = (insn >> 5) & 0x7;
+        rx = (insn >> 8) & 0x7;
+        gen_ldst16(ctx, op, rz, rx, imm);
+        break;
+    case 0x26:
+    case 0x27:
+        /*ld16.w(sp)*/
+        t0 = tcg_temp_new();
+        imm = ((insn & 0x700) >> 3) | (insn & 0x1f);
+        rz = (insn >> 5) & 0x7;
+        ldst(ld32u, sp, rz, imm << 2, 2);
+        tcg_temp_free(t0);
+        break;
+    case 0x28 ... 0x2d:
+        imm = insn & 0x1f;
+        rz = (insn >> 5) & 0x7;
+        rx = (insn >> 8) & 0x7;
+        gen_ldst16(ctx, op, rz, rx, imm);
+        break;
+    case 0x2e:
+    case 0x2f:
+        /*st16.w(sp)*/
+        t0 = tcg_temp_new();
+        imm = ((insn & 0x700) >> 3) | (insn & 0x1f);
+        rz = (insn >> 5) & 0x7;
+        ldst(st32, sp, rz, imm << 2, 2);
+        tcg_temp_free(t0);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static inline void branch32(DisasContext *ctx, TCGCond cond, int rx, int offset)
+{
+    int val;
+    TCGLabel *l1 = gen_new_label();
+    TCGv t0 = tcg_temp_new();
+
+    val = offset << 1;
+    if (val & 0x10000) {
+        val |= 0xffff0000;
+    }
+    val += ctx->pc;
+
+    if (rx != -1) {
+        tcg_gen_brcondi_tl(cond, cpu_R[rx], 0, l1);
+    } else {
+        tcg_gen_brcondi_tl(cond, cpu_c, 0, l1);
+    }
+    gen_goto_tb(ctx, 1, ctx->pc + 4);
+    gen_set_label(l1);
+
+    gen_goto_tb(ctx, 0, val);
+
+    ctx->is_jmp = DISAS_TB_JUMP;
+
+    tcg_temp_free(t0);
+
+}
+
+static inline void bsr32(DisasContext *ctx, int offset)
+{
+    int val;
+
+    val = offset << 1;
+    if (val & 0x4000000) {
+        val |= 0xfc000000;
+    }
+    val += ctx->pc;
+
+    gen_goto_tb(ctx, 0, val);
+
+    ctx->is_jmp = DISAS_TB_JUMP;
+}
+
+static inline void sce(DisasContext *ctx, int cond)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGLabel *l1 = gen_new_label();
+
+    tcg_gen_movi_tl(t0, cond);
+    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 0, l1);
+    tcg_gen_not_tl(t0, t0);
+    tcg_gen_andi_tl(t0, t0, 0xf);
+    gen_set_label(l1);
+    tcg_gen_ori_tl(t0, t0, 0x10);
+    store_cpu_field(t0, sce_condexec_bits);
+
+    gen_save_pc(ctx->pc + 4);
+    ctx->is_jmp = DISAS_UPDATE;
+}
+
+#ifndef CONFIG_USER_ONLY
+static inline void gen_mfcr_cpu(DisasContext *ctx, uint32_t rz, uint32_t cr_num)
+{
+    TCGv t0;
+
+    switch (cr_num) {
+    case 0x0:
+        /* cr0 psr */
+        gen_helper_mfcr_cr0(cpu_R[rz], cpu_env);
+        break;
+    case 0x1:
+        /* vbr */
+        t0 = load_cpu_field(cp0.vbr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x2:
+        /* epsr */
+        t0 = load_cpu_field(cp0.epsr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x3:
+        /* fpsr */
+        t0 = load_cpu_field(cp0.fpsr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x4:
+        /* epc */
+        t0 = load_cpu_field(cp0.epc);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x5:
+        /* fpc */
+        t0 = load_cpu_field(cp0.fpc);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x6:
+        /* ss0 */
+        t0 = load_cpu_field(cp0.ss0);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x7:
+        /* ss1 */
+        t0 = load_cpu_field(cp0.ss1);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x8:
+        /* ss2 */
+        t0 = load_cpu_field(cp0.ss2);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x9:
+        /* ss3 */
+        t0 = load_cpu_field(cp0.ss3);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xa:
+        /* ss4 */
+        t0 = load_cpu_field(cp0.ss4);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xb:
+        /* gcr */
+        t0 = load_cpu_field(cp0.gcr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xc:
+        /* gsr */
+        t0 = load_cpu_field(cp0.gsr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xd:
+        /* cpidr */
+        gen_helper_mfcr_cpidr(cpu_R[rz], cpu_env);
+        break;
+    case 0xe:
+        /* dcsr */
+        t0 = load_cpu_field(cp0.dcsr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0xf:
+        /* cpwr */
+        t0 = load_cpu_field(cp0.cpwr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x10:
+        /* no CR16 */
+        break;
+    case 0x11:
+        /* cfr */
+        t0 = load_cpu_field(cp0.cfr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x12:
+        /* ccr */
+        t0 = load_cpu_field(cp0.ccr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    case 0x13:
+        /* capr */
+        if (ctx->features & ABIV2_TEE) {
+            gen_helper_tee_mfcr_cr19(cpu_R[rz], cpu_env);
+        } else {
+            t0 = load_cpu_field(cp0.capr);
+            tcg_gen_mov_tl(cpu_R[rz], t0);
+            tcg_temp_free(t0);
+        }
+        break;
+    case 0x14:
+        /* cr20 pacr */
+        gen_helper_mfcr_cr20(cpu_R[rz], cpu_env);
+        break;
+    case 0x15:
+        /* prsr */
+        t0 = load_cpu_field(cp0.prsr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+
+        tcg_temp_free(t0);
+        break;
+    default:
+        break;
+    }
+}
+
+static inline void gen_mfcr_tee(DisasContext *ctx, uint32_t rz, uint32_t cr_num)
+{
+    TCGv t0;
+    switch (cr_num) {
+    case 0x0:
+        /* NT_PSR */
+        t0 = load_cpu_field(tee.nt_psr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0x1:
+        /* NT_VBR */
+        t0 = load_cpu_field(tee.nt_vbr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0x2:
+        /* NT_EPSR */
+        t0 = load_cpu_field(tee.nt_epsr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0x4:
+        /* NT_EPC */
+        t0 = load_cpu_field(tee.nt_epc);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0x6:
+        /* NT_SSP */
+        t0 = load_cpu_field(stackpoint.nt_ssp);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0x7:
+        /* T_USP */
+        t0 = load_cpu_field(stackpoint.t_usp);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0x8:
+        /* T_DCR */
+        t0 = load_cpu_field(tee.t_dcr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0x9:
+        /* T_PCR */
+        t0 = load_cpu_field(tee.t_pcr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0xa:
+        /* NT_EBR */
+        t0 = load_cpu_field(tee.nt_ebr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+
+    default:
+        break;
+    }
+}
+
+/* Read MMU Coprocessor Contronl Registers */
+static inline void
+gen_mfcr_mmu(DisasContext *ctx, uint32_t rz, uint32_t cr_num)
+{
+    TCGv t0;
+
+    switch (cr_num) {
+    case 0x0:
+        /* MIR */
+        t0 = load_cpu_field(mmu.mir);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x1:
+        /* MRR */
+        t0 = load_cpu_field(mmu.mrr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x2:
+        /* MEL0 */
+        t0 = load_cpu_field(mmu.mel0);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x3:
+        /* MEL1 */
+        t0 = load_cpu_field(mmu.mel1);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x4:
+        /* MEH */
+        t0 = load_cpu_field(mmu.meh);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x5:
+        /* MCR */
+        t0 = load_cpu_field(mmu.mcr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x6:
+        /* MPR */
+        t0 = load_cpu_field(mmu.mpr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x7:
+        /* MWR */
+        t0 = load_cpu_field(mmu.mwr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x8:
+        /* MCIR */
+        t0 = load_cpu_field(mmu.mcir);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x9:
+        /* CP15_CR9 */
+        t0 = load_cpu_field(mmu.cr9);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0xa:
+        /* CP15_CR10 */
+        t0 = load_cpu_field(mmu.cr10);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0xb:
+        /* CP15_CR11 */
+        t0 = load_cpu_field(mmu.cr11);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0xc:
+        /* CP15_CR12 */
+        t0 = load_cpu_field(mmu.cr12);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0xd:
+        /* CP15_CR13 */
+        t0 = load_cpu_field(mmu.cr13);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0xe:
+        /* CP15_CR14 */
+        t0 = load_cpu_field(mmu.cr14);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0xf:
+        /* CP15_CR15 */
+        t0 = load_cpu_field(mmu.cr15);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x10:
+        /* CP15_CR16 */
+        t0 = load_cpu_field(mmu.cr16);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x1d:
+        t0 = load_cpu_field(mmu.mpar);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x1e:
+        t0 = load_cpu_field(mmu.msa0);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    case 0x1f:
+        t0 = load_cpu_field(mmu.msa1);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        break;
+    default:
+        t0 = tcg_temp_new();
+        break;
+    }
+    tcg_temp_free(t0);
+}
+
+static inline void gen_mtcr_cpu(DisasContext *ctx, uint32_t cr_num, uint32_t rx)
+{
+
+    switch (cr_num) {
+    case 0x0:
+        /* psr */
+        gen_helper_mtcr_cr0(cpu_env, cpu_R[rx]);
+        gen_save_pc(ctx->pc + 4);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x1:
+        /* vbr */
+        {
+            TCGv t0 = tcg_temp_new();
+
+            tcg_gen_andi_tl(t0, cpu_R[rx], ~0x3ff);
+            store_cpu_field(t0, cp0.vbr);
+
+            tcg_temp_free(t0);
+        }
+        break;
+    case 0x2:
+        /* epsr */
+        store_cpu_field(cpu_R[rx], cp0.epsr);
+        break;
+    case 0x3:
+        /* fpsr */
+        store_cpu_field(cpu_R[rx], cp0.fpsr);
+        break;
+    case 0x4:
+        /* epc */
+        store_cpu_field(cpu_R[rx], cp0.epc);
+        break;
+    case 0x5:
+        /* fpc */
+        store_cpu_field(cpu_R[rx], cp0.fpc);
+        break;
+    case 0x6:
+        /* ss0 */
+        store_cpu_field(cpu_R[rx], cp0.ss0);
+        break;
+    case 0x7:
+        /* ss1 */
+        store_cpu_field(cpu_R[rx], cp0.ss1);
+        break;
+    case 0x8:
+        /* ss2 */
+        store_cpu_field(cpu_R[rx], cp0.ss2);
+        break;
+    case 0x9:
+        /* ss3 */
+        store_cpu_field(cpu_R[rx], cp0.ss3);
+        break;
+    case 0xa:
+        /* ss4 */
+        store_cpu_field(cpu_R[rx], cp0.ss4);
+        break;
+    case 0xb:
+        /* gcr */
+        store_cpu_field(cpu_R[rx], cp0.gcr);
+        break;
+    case 0xc:
+        /* gsr */
+        /* Read only */
+        break;
+    case 0xd:
+        /* cpidr */
+        /* Read only */
+        break;
+    case 0xe:
+        /* dcsr */
+        store_cpu_field(cpu_R[rx], cp0.dcsr);
+        break;
+    case 0xf:
+        /* cpwr */
+        /* FIXME */
+        store_cpu_field(cpu_R[rx], cp0.cpwr);
+        break;
+    case 0x10:
+        /* no CR16 */
+        break;
+    case 0x11:
+        /* cfr */
+        store_cpu_field(cpu_R[rx], cp0.cfr);
+        break;
+    case 0x12:
+        /* ccr */
+        gen_helper_mtcr_cr18(cpu_env, cpu_R[rx]);
+        gen_save_pc(ctx->pc + 4);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x13:
+        /* capr */
+        if (ctx->features & ABIV2_TEE) {
+            gen_helper_tee_mtcr_cr19(cpu_env, cpu_R[rx]);
+        } else {
+            store_cpu_field(cpu_R[rx], cp0.capr);
+        }
+        break;
+    case 0x14:
+        /* pacr */
+        gen_helper_mtcr_cr20(cpu_env, cpu_R[rx]);
+        gen_save_pc(ctx->pc + 4);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x15:
+        /* prsr */
+        store_cpu_field(cpu_R[rx], cp0.prsr);
+        break;
+    default:
+        break;
+    }
+}
+
+static inline void gen_mtcr_tee(DisasContext *ctx, uint32_t cr_num, uint32_t rx)
+{
+    TCGv t0 = tcg_temp_new();
+    switch (cr_num) {
+    case 0x0:
+        /* NT_PSR */
+        if (!(ctx->features & ABIV2_JAVA)) {
+            tcg_gen_andi_tl(t0, cpu_R[rx], ~0x400);
+            store_cpu_field(t0, tee.nt_psr);
+        } else {
+            store_cpu_field(cpu_R[rx], tee.nt_psr);
+        }
+        break;
+    case 0x1:
+        /* NT_VBR */
+        tcg_gen_andi_tl(t0, cpu_R[rx], ~0x3ff);
+        store_cpu_field(t0, tee.nt_vbr);
+        break;
+    case 0x2:
+        /* NT_EPSR */
+        store_cpu_field(cpu_R[rx], tee.nt_epsr);
+        break;
+    case 0x4:
+        /* NT_EPC */
+        store_cpu_field(cpu_R[rx], tee.nt_epc);
+        break;
+    case 0x6:
+        /* NT_SSP */
+        store_cpu_field(cpu_R[rx], stackpoint.nt_ssp);
+        break;
+    case 0x7:
+        /* T_USP */
+        store_cpu_field(cpu_R[rx], stackpoint.t_usp);
+        break;
+    case 0x8:
+        /* T_DCR */
+        tcg_gen_andi_tl(t0, cpu_R[rx], 0x3);
+        store_cpu_field(t0, tee.t_dcr);
+        break;
+    case 0x9:
+        /* T_PCR */
+        tcg_gen_andi_tl(t0, cpu_R[rx], 0x1);
+        store_cpu_field(t0, tee.t_pcr);
+        break;
+    case 0xa:
+        /* NT_EBR */
+        store_cpu_field(cpu_R[rx], tee.nt_ebr);
+        break;
+
+    default:
+        break;
+    }
+    tcg_temp_free(t0);
+}
+
+static inline void gen_mtcr_mmu(DisasContext *ctx, uint32_t cr_num, uint32_t rx)
+{
+    switch (cr_num) {
+    case 0x0:
+        /* MIR */
+        store_cpu_field(cpu_R[rx], mmu.mir);
+        break;
+    case 0x1:
+        /* MRR */
+
+        store_cpu_field(cpu_R[rx], mmu.mrr);
+        break;
+    case 0x2:
+        /* MEL0 */
+        store_cpu_field(cpu_R[rx], mmu.mel0);
+        break;
+    case 0x3:
+        /* MEL1 */
+        store_cpu_field(cpu_R[rx], mmu.mel1);
+        break;
+    case 0x4:
+        /* MEH */
+        gen_helper_meh_write(cpu_env, cpu_R[rx]);
+        gen_save_pc(ctx->pc + 4);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x5:
+        /* MCR */
+        store_cpu_field(cpu_R[rx], mmu.mcr);
+        break;
+    case 0x6:
+        /* MPR */
+        store_cpu_field(cpu_R[rx], mmu.mpr);
+        break;
+    case 0x7:
+        /* MWR */
+        store_cpu_field(cpu_R[rx], mmu.mwr);
+        break;
+    case 0x8:
+        /* MCIR */
+        gen_helper_mcir_write(cpu_env, cpu_R[rx]);
+        gen_save_pc(ctx->pc + 4);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x9:
+        /* FIXME SPM is not implement yet */
+        /* CP15_CR9 */
+        store_cpu_field(cpu_R[rx], mmu.cr9);
+        break;
+    case 0xa:
+        /* CP15_CR10 */
+        store_cpu_field(cpu_R[rx], mmu.cr10);
+        break;
+    case 0xb:
+        /* CP15_CR11 */
+        store_cpu_field(cpu_R[rx], mmu.cr11);
+        break;
+    case 0xc:
+        /* CP15_CR12 */
+        store_cpu_field(cpu_R[rx], mmu.cr12);
+        break;
+    case 0xd:
+        /* CP15_CR13 */
+        store_cpu_field(cpu_R[rx], mmu.cr13);
+        break;
+    case 0xe:
+        /* CP15_CR14 */
+        store_cpu_field(cpu_R[rx], mmu.cr14);
+        break;
+    case 0xf:
+        /* CP15_CR15 */
+        store_cpu_field(cpu_R[rx], mmu.cr15);
+        break;
+    case 0x10:
+        /* CP15_CR16 */
+        store_cpu_field(cpu_R[rx], mmu.cr16);
+        break;
+    case 0x1d:
+        store_cpu_field(cpu_R[rx], mmu.mpar);
+        gen_save_pc(ctx->pc + 4);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x1e:
+        store_cpu_field(cpu_R[rx], mmu.msa0);
+        break;
+    case 0x1f:
+        store_cpu_field(cpu_R[rx], mmu.msa1);
+        break;
+    default:
+        break;
+    }
+}
+#endif /* !CONFIG_USER_ONLY */
+
+
+static inline void gen_mfcr_vfp(DisasContext *ctx,  int rz, int rx)
+{
+    TCGv t0;
+
+    switch (rx) {
+    case 0x0:
+        /* fid*/
+        t0 = load_cpu_field(vfp.fid);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0x1:
+        /* fcr*/
+        t0 = load_cpu_field(vfp.fcr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0x2:
+        /* fesr*/
+        t0 = load_cpu_field(vfp.fesr);
+        tcg_gen_mov_tl(cpu_R[rz], t0);
+        tcg_temp_free(t0);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "wrong mfcr vfp control register: pc=%x rx=%d\n",
+                      ctx->pc, rx);
+        break;
+    }
+}
+
+
+static inline void gen_mtcr_vfp(DisasContext *ctx,  int rz, int rx)
+{
+    switch (rz) {
+    case 0x1:
+        /* store_cpu_field(cpu_R[rx], vfp.fcr); */
+        store_cpu_field(cpu_R[rx], vfp.fcr);
+        gen_helper_vfp_update_fcr(cpu_env);
+        gen_save_pc(ctx->pc + 4);
+        ctx->is_jmp = DISAS_UPDATE;
+        break;
+    case 0x2:
+        store_cpu_field(cpu_R[rx], vfp.fesr);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "wrong mfcr vfp control register: pc=%x rz=%d\n",
+                      ctx->pc, rz);
+        break;
+    }
+}
+
+static inline void add_ix(int rz, int rx, int ry, int imm)
+{
+    TCGv t0 = tcg_temp_new();
+
+    tcg_gen_shli_tl(t0, cpu_R[ry], imm);
+    tcg_gen_add_tl(cpu_R[rz], cpu_R[rx], t0);
+
+    tcg_temp_free(t0);
+}
+
+static inline void lslc(int rz, int rx, int imm)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGv t1 = tcg_temp_local_new();
+    TCGv t2 = tcg_temp_new();
+    TCGLabel *l1 = gen_new_label();
+
+    t1 = tcg_const_tl(imm);
+    tcg_gen_mov_tl(t0, cpu_R[rx]);
+    tcg_gen_andi_tl(cpu_c, t0, 0x1);
+    tcg_gen_movi_tl(cpu_R[rz], 0);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 32, l1);
+    tcg_gen_shl_tl(cpu_R[rz], t0, t1);
+    tcg_gen_rotl_tl(t2, t0, t1);
+    tcg_gen_andi_tl(cpu_c, t2, 0x1);
+    gen_set_label(l1);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+    tcg_temp_free(t2);
+}
+
+static inline void lsrc(int rz, int rx, int imm)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGv t1 = tcg_temp_local_new();
+    TCGv t2 = tcg_temp_new();
+    TCGLabel *l1 = gen_new_label();
+
+    t1 = tcg_const_tl(imm);
+    tcg_gen_mov_tl(t0, cpu_R[rx]);
+    tcg_gen_andi_tl(cpu_c, t0, 0x80000000);
+    tcg_gen_shri_tl(cpu_c, cpu_c, 31);
+    tcg_gen_movi_tl(cpu_R[rz], 0);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 32, l1);
+    tcg_gen_shr_tl(cpu_R[rz], t0, t1);
+    tcg_gen_shri_tl(t2, t0, imm - 1);
+    tcg_gen_andi_tl(cpu_c, t2, 0x1);
+    gen_set_label(l1);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+    tcg_temp_free(t2);
+}
+
+static inline void asrc(int rz, int rx, int imm)
+{
+    TCGv t0 = tcg_temp_local_new();
+    TCGv t1 = tcg_temp_local_new();
+    TCGv t2 = tcg_temp_new();
+    TCGLabel *l1 = gen_new_label();
+
+    t1 = tcg_const_tl(imm);
+    tcg_gen_mov_tl(t0, cpu_R[rx]);
+    tcg_gen_sari_tl(cpu_R[rz], t0, 31);
+    tcg_gen_andi_tl(cpu_c, cpu_R[rz], 0x1);
+    tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 32, l1);
+    tcg_gen_sar_tl(cpu_R[rz], t0, t1);
+    tcg_gen_shri_tl(t2, t0, imm - 1);
+    tcg_gen_andi_tl(cpu_c, t2, 0x1);
+    gen_set_label(l1);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+    tcg_temp_free(t2);
+}
+
+static inline void divu(DisasContext *ctx, int rz, int rx, int ry)
+{
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[ry], 0, l1);
+    tcg_gen_divu_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+
+    TCGv t0 = tcg_temp_new();
+
+    t0 = tcg_const_tl(EXCP_CSKY_DIV);
+    gen_save_pc(ctx->pc);
+    gen_helper_exception(cpu_env, t0);
+    ctx->is_jmp = DISAS_NEXT;
+
+    tcg_temp_free(t0);
+
+    gen_set_label(l2);
+}
+
+static inline void divs(DisasContext *ctx, int rz, int rx, int ry)
+{
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[ry], 0, l1);
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_div_i64(t0, t0, t1);
+    tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+
+    TCGv t2 = tcg_temp_new();
+
+    t2 = tcg_const_tl(EXCP_CSKY_DIV);
+    gen_save_pc(ctx->pc);
+    gen_helper_exception(cpu_env, t2);
+    ctx->is_jmp = DISAS_NEXT;
+
+    tcg_temp_free(t2);
+
+    gen_set_label(l2);
+}
+
+static inline int csky_log2(uint32_t s)
+{
+    int i = 0;
+    if (s == 0) {
+        return -1;
+    }
+
+    while (s != 1) {
+        s >>= 1;
+        i++;
+    }
+    return i;
+}
+#define ldbistbi(name, rx, rz, imm)                             \
+do {                                                            \
+    tcg_gen_qemu_##name(cpu_R[rz], cpu_R[rx], ctx->mem_idx);    \
+    tcg_gen_addi_tl(cpu_R[rx], cpu_R[rx], imm);                 \
+} while (0)
+
+#define ldbirstbir(name, rx, rz, ry)                            \
+do {                                                            \
+    tcg_gen_mov_tl(t0, cpu_R[ry]);                              \
+    tcg_gen_qemu_##name(cpu_R[rz], cpu_R[rx], ctx->mem_idx);    \
+    tcg_gen_add_tl(cpu_R[rx], cpu_R[rx], t0);                   \
+} while (0)
+
+static inline void dspv2_insn_pldbi_d(DisasContext *s, int rz, int rx)
+{
+    /* Rz[31:0] <- mem(Rx)
+     * Rz+1[31:0] <- mem(Rx + 4)
+     * Rx[31:0] <- Rx[31:0] + 8 */
+    tcg_gen_qemu_ld32u(cpu_R[rz], cpu_R[rx], s->mem_idx);
+    tcg_gen_addi_i32(cpu_R[rx], cpu_R[rx], 4);
+    tcg_gen_qemu_ld32u(cpu_R[(rz + 1) % 32], cpu_R[rx], s->mem_idx);
+    tcg_gen_addi_i32(cpu_R[rx], cpu_R[rx], 4);
+}
+
+static inline void dspv2_insn_pldbir_d(DisasContext *s, int rz, int rx, int ry)
+{
+    /* Rz[31:0] <- mem(Rx)
+     * Rz+1[31:0] <- mem(Rx + Ry)
+     * Rx[31:0] <- Rx[31:0] + 2*Ry */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    tcg_gen_mov_i32(t0, cpu_R[ry]);
+    tcg_gen_qemu_ld32u(cpu_R[rz], cpu_R[rx], s->mem_idx);
+    tcg_gen_add_i32(cpu_R[rx], cpu_R[rx], t0);
+    tcg_gen_qemu_ld32u(cpu_R[(rz + 1) % 32], cpu_R[rx], s->mem_idx);
+    tcg_gen_add_i32(cpu_R[rx], cpu_R[rx], t0);
+    tcg_temp_free_i32(t0);
+}
+
+static void ldr(DisasContext *ctx, uint32_t sop,
+                 uint32_t pcode, int rz, int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    int imm = 0;
+    if (sop < 32) {
+        /* basic ld instructions. */
+        imm = csky_log2(pcode);
+        if (imm == -1) {
+            generate_exception(ctx, EXCP_CSKY_UDEF);
+            return;
+        }
+    } else {
+        check_insn(ctx, ABIV2_EDSP);
+        if (pcode != 0) {
+            generate_exception(ctx, EXCP_CSKY_UDEF);
+            return;
+        }
+    }
+
+    switch (sop) {
+    case 0x0:
+        /* ldr.b */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldrstr(ld8u, rx, ry, rz, imm);
+        break;
+    case 0x1:
+        /* ldr.h */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldrstr(ld16u, rx, ry, rz, imm);
+        break;
+    case 0x2:
+        /* ldr.w */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldrstr(ld32u, rx, ry, rz, imm);
+        break;
+    case 0x4:
+        /* ldr.bs */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldrstr(ld8s, rx, ry, rz, imm);
+        break;
+    case 0x5:
+        /* ldr.hs */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldrstr(ld16s, rx, ry, rz, imm);
+        break;
+    case 0x7:
+        /* ldm or ldq */
+        check_insn_except(ctx, CPU_801);
+        if (ctx->bctm) {
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rx], 0, l1);
+            tcg_gen_movi_tl(cpu_R[15], ctx->pc + 4);
+            tcg_gen_subi_tl(t0, cpu_R[SVBR], 4);
+            store_cpu_field(t0, pc);
+            tcg_gen_exit_tb(0);
+            gen_set_label(l1);
+            tcg_gen_mov_tl(t0, cpu_R[rx]);
+            for (imm = 0; imm <= rz; imm++) {
+                tcg_gen_qemu_ld32u(cpu_R[ry + imm], t0, ctx->mem_idx);
+                tcg_gen_addi_tl(t0, t0, 4);
+            }
+            gen_goto_tb(ctx, 1, ctx->pc + 4);
+            ctx->is_jmp = DISAS_TB_JUMP;
+            break;
+        } else {
+            tcg_gen_mov_tl(t0, cpu_R[rx]);
+            for (imm = 0; imm <= rz; imm++) {
+                tcg_gen_qemu_ld32u(cpu_R[ry + imm], t0, ctx->mem_idx);
+                tcg_gen_addi_tl(t0, t0, 4);
+            }
+            break;
+        }
+    case OP_LDBI_B:
+        ldbistbi(ld8u, rx, rz, 1);
+        break;
+    case OP_LDBI_H:
+        ldbistbi(ld16u, rx, rz, 2);
+        break;
+    case OP_LDBI_W:
+        ldbistbi(ld32u, rx, rz, 4);
+        break;
+    case OP_PLDBI_D:
+        dspv2_insn_pldbi_d(ctx, rz, rx);
+        break;
+    case OP_LDBI_BS:
+        ldbistbi(ld8s, rx, rz, 1);
+        break;
+    case OP_LDBI_HS:
+        ldbistbi(ld16s, rx, rz, 2);
+        break;
+    case OP_LDBIR_B:
+        ldbirstbir(ld8u, rx, rz, ry);
+        break;
+    case OP_LDBIR_H:
+        ldbirstbir(ld16u, rx, rz, ry);
+        break;
+    case OP_LDBIR_W:
+        ldbirstbir(ld32u, rx, rz, ry);
+        break;
+    case OP_PLDBIR_D:
+        dspv2_insn_pldbir_d(ctx, rz, rx, ry);
+        break;
+    case OP_LDBIR_BS:
+        ldbirstbir(ld8s, rx, rz, ry);
+        break;
+    case OP_LDBIR_HS:
+        ldbirstbir(ld16s, rx, rz, ry);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+    tcg_temp_free(t0);
+}
+
+static void str(DisasContext *ctx, uint32_t sop,
+                 uint32_t pcode, int rz, int rx, int ry)
+{
+    TCGv t0 = tcg_temp_new();
+    int imm = 0;
+
+    if (sop < 32) {
+        imm = csky_log2(pcode);
+
+        if (imm == -1) {
+            generate_exception(ctx, EXCP_CSKY_UDEF);
+            return;
+        }
+    } else {
+        check_insn(ctx, ABIV2_EDSP);
+        if (pcode != 0) {
+            generate_exception(ctx, EXCP_CSKY_UDEF);
+            return;
+        }
+    }
+
+    switch (sop) {
+    case 0x0:
+        /* str.b */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldrstr(st8, rx, ry, rz, imm);
+        break;
+    case 0x1:
+        /* str.h */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldrstr(st16, rx, ry, rz, imm);
+        break;
+    case 0x2:
+        /* str.w */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldrstr(st32, rx, ry, rz, imm);
+        break;
+    case 0x7:
+        /* stm or stq */
+        check_insn_except(ctx, CPU_801);
+        if (ctx->bctm) {
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rx], 0, l1);
+            tcg_gen_movi_tl(cpu_R[15], ctx->pc + 4);
+            tcg_gen_subi_tl(t0, cpu_R[SVBR], 4);
+            store_cpu_field(t0, pc);
+            tcg_gen_exit_tb(0);
+            gen_set_label(l1);
+            tcg_gen_mov_tl(t0, cpu_R[rx]);
+            for (imm = 0; imm <= rz; imm++) {
+                tcg_gen_qemu_st32(cpu_R[ry + imm], t0, ctx->mem_idx);
+                tcg_gen_addi_tl(t0, t0, 4);
+            }
+            gen_goto_tb(ctx, 1, ctx->pc + 4);
+            ctx->is_jmp = DISAS_TB_JUMP;
+            break;
+        } else {
+            tcg_gen_mov_tl(t0, cpu_R[rx]);
+            for (imm = 0; imm <= rz; imm++) {
+                tcg_gen_qemu_st32(cpu_R[ry + imm], t0, ctx->mem_idx);
+                tcg_gen_addi_tl(t0, t0, 4);
+            }
+            break;
+        }
+    case OP_STBI_B:
+        ldbistbi(st8, rx, rz, 1);
+        break;
+    case OP_STBI_H:
+        ldbistbi(st16, rx, rz, 2);
+        break;
+    case OP_STBI_W:
+        ldbistbi(st32, rx, rz, 4);
+        break;
+    case OP_STBIR_B:
+        ldbirstbir(st8, rx, rz, ry);
+        break;
+    case OP_STBIR_H:
+        ldbirstbir(st16, rx, rz, ry);
+        break;
+    case OP_STBIR_W:
+        ldbirstbir(st32, rx, rz, ry);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static inline void pop(DisasContext *ctx, int imm)
+{
+    int i;
+    TCGv t0 = tcg_temp_new();
+    tcg_gen_mov_tl(t0, cpu_R[sp]);
+
+    if (imm & 0xf) {
+        for (i = 0; i < (imm & 0xf); i++) {
+            tcg_gen_qemu_ld32u(cpu_R[4 + i], t0, ctx->mem_idx);
+            tcg_gen_addi_i32(t0, t0, 4);
+        }
+    }
+
+    if (imm & 0x10) {
+        tcg_gen_qemu_ld32u(cpu_R[15], t0, ctx->mem_idx);
+        tcg_gen_addi_i32(t0, t0, 4);
+    }
+
+    if ((imm >> 5) & 0x7) {
+        for (i = 0; i < ((imm >> 5) & 0x7); i++) {
+            tcg_gen_qemu_ld32u(cpu_R[16 + i], t0, ctx->mem_idx);
+            tcg_gen_addi_i32(t0, t0, 4);
+        }
+    }
+
+    if (imm & 0x100) {
+        tcg_gen_qemu_ld32u(cpu_R[28], t0, ctx->mem_idx);
+        tcg_gen_addi_i32(t0, t0, 4);
+    }
+    tcg_gen_mov_tl(cpu_R[sp], t0);
+
+    tcg_gen_andi_tl(t0, cpu_R[15], 0xfffffffe);
+    store_cpu_field(t0, pc);
+    ctx->is_jmp = DISAS_JUMP;
+    tcg_temp_free(t0);
+}
+
+static void ldi(DisasContext *ctx, uint32_t sop,
+                int rz, int rx, int imm)
+{
+    TCGv t0 = tcg_temp_new();
+
+    switch (sop) {
+    case 0x0:
+        /* ld.b */
+        ldst(ld8u, rx, rz, imm, 4);
+        break;
+    case 0x1:
+        /* ld.h */
+        ldst(ld16u, rx, rz, imm << 1, 4);
+        break;
+    case 0x2:
+        /* ld.w */
+        ldst(ld32u, rx, rz, imm << 2, 4);
+        break;
+    case 0x3:
+        /* ld.d */
+        check_insn(ctx, CPU_810 | CPU_807);
+        tcg_gen_addi_tl(t0, cpu_R[rx], imm << 2);
+        tcg_gen_qemu_ld32u(cpu_R[rz], t0, ctx->mem_idx);
+        tcg_gen_addi_tl(t0, t0, 4);
+        tcg_gen_qemu_ld32u(cpu_R[(rz + 1) % 32], t0, ctx->mem_idx);
+        break;
+    case 0x4:
+        /* ld.bs */
+        check_insn_except(ctx, CPU_801);
+        ldst(ld8s, rx, rz, imm, 4);
+        break;
+    case 0x5:
+        /* ld.hs */
+        check_insn_except(ctx, CPU_801);
+        ldst(ld16s, rx, rz, imm << 1, 4);
+        break;
+    case 0x6:
+        /* pldr */    /*ignore this instruction*/
+        check_insn(ctx, CPU_807 | CPU_810);
+        break;
+    case 0x7:
+        /* ldex.w */  /*ignore this instruction*/
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+
+    tcg_temp_free(t0);
+}
+
+static inline void push(DisasContext *ctx, int imm)
+{
+    TCGv t0 =  tcg_temp_new();
+    int i;
+
+    tcg_gen_mov_tl(t0, cpu_R[sp]);
+
+    if (imm & 0x100) {
+        tcg_gen_subi_i32(t0, t0, 4);
+        tcg_gen_qemu_st32(cpu_R[28], t0, ctx->mem_idx);
+    }
+
+    if ((imm >> 5) & 0x7) {
+        for (i = (imm >> 5) & 0x7; i > 0; i--) {
+            tcg_gen_subi_i32(t0, t0, 4);
+            tcg_gen_qemu_st32(cpu_R[15 + i], t0, ctx->mem_idx);
+        }
+    }
+
+    if (imm & 0x10) {
+        tcg_gen_subi_i32(t0, t0, 4);
+        tcg_gen_qemu_st32(cpu_R[15], t0, ctx->mem_idx);
+    }
+
+    if (imm & 0xf) {
+        for (i = (imm & 0xf); i > 0; i--) {
+            tcg_gen_subi_i32(t0, t0, 4);
+            tcg_gen_qemu_st32(cpu_R[3 + i], t0, ctx->mem_idx);
+        }
+    }
+    tcg_gen_mov_tl(cpu_R[sp], t0);
+    tcg_temp_free(t0);
+
+}
+
+static void sti(DisasContext *ctx, uint32_t sop, int rz, int rx, int imm)
+{
+    TCGv t0 = tcg_temp_new();
+
+    switch (sop) {
+    case 0x0:
+        /* st.b */
+        ldst(st8, rx, rz, imm, 4);
+        break;
+    case 0x1:
+        /* st.h */
+        ldst(st16, rx, rz, imm << 1, 4);
+        break;
+    case 0x2:
+        /* st.w */
+        ldst(st32, rx, rz, imm << 2, 4);
+        break;
+    case 0x3:
+        /* st.d */
+        check_insn(ctx, CPU_810 | CPU_807);
+        tcg_gen_addi_tl(t0, cpu_R[rx], imm << 2);
+        tcg_gen_qemu_st32(cpu_R[rz], t0, ctx->mem_idx);
+        tcg_gen_addi_tl(t0, t0, 4);
+        tcg_gen_qemu_st32(cpu_R[(rz + 1) % 32], t0, ctx->mem_idx);
+        break;
+    case 0x6:
+        /* pldw */    /*ignore this instruction*/
+        check_insn(ctx, CPU_807 | CPU_810);
+        break;
+    case 0x7:
+        /* stex.w */    /*ignore this instruction*/
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static inline void special(DisasContext *ctx, int rx, uint32_t sop,
+                            int rz, int ry)
+{
+    /* ry:25-21, rx:20-16, sop:15-10, rz:4-0 */
+    TCGv t0;
+
+    switch (sop) {
+    case 0x1:
+        /* sync */
+        break;
+    case 0x4:
+        /* bmset */
+        check_insn(ctx, ABIV2_JAVA);
+        t0 = tcg_temp_new();
+
+        t0 = tcg_const_tl(1);
+        store_cpu_field(t0, psr_bm);
+        ctx->is_jmp = DISAS_UPDATE;
+
+        tcg_temp_free(t0);
+        break;
+    case 0x5:
+        /* bmclr */
+        check_insn(ctx, ABIV2_JAVA);
+        t0 = tcg_temp_new();
+
+        t0 = tcg_const_tl(0);
+        store_cpu_field(t0, psr_bm);
+        ctx->is_jmp = DISAS_UPDATE;
+
+        tcg_temp_free(t0);
+        break;
+    case 0x6:
+        /* sce */
+        check_insn(ctx, CPU_810 | CPU_803S | CPU_807);
+        sce(ctx, ry & 0xf);
+        break;
+    case 0x7:
+        /* idly */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+#if !defined(CONFIG_USER_ONLY)
+        if (ctx->trace_mode == NORMAL_MODE) {
+            t0 = tcg_temp_new();
+            TCGLabel *l1 = gen_new_label();
+
+            t0 = load_cpu_field(idly4_counter);
+            tcg_gen_brcondi_tl(TCG_COND_NE, t0, 0, l1);
+
+            t0 = tcg_const_tl(4);
+            store_cpu_field(t0, idly4_counter);
+            tcg_gen_movi_tl(cpu_c, 0);
+
+            gen_set_label(l1);
+            ctx->is_jmp = DISAS_UPDATE;
+            gen_save_pc(ctx->pc + 4);
+            tcg_temp_free(t0);
+        }
+#endif
+        break;
+    case 0x8:
+        /* trap 0 */
+        generate_exception(ctx, EXCP_CSKY_TRAP0);
+#if !defined(CONFIG_USER_ONLY)
+        ctx->cannot_be_traced = 1;
+#endif
+        break;
+    case 0x9:
+        /* trap 1 */
+#if !defined(CONFIG_USER_ONLY)
+        generate_exception(ctx, EXCP_CSKY_TRAP1);
+        ctx->cannot_be_traced = 1;
+#endif
+        break;
+    case 0xa:
+        /* trap 2 */
+        generate_exception(ctx, EXCP_CSKY_TRAP2);
+#if !defined(CONFIG_USER_ONLY)
+        ctx->cannot_be_traced = 1;
+#endif
+        break;
+    case 0xb:
+        /* trap 3 */
+        generate_exception(ctx, EXCP_CSKY_TRAP3);
+#if !defined(CONFIG_USER_ONLY)
+        ctx->cannot_be_traced = 1;
+#endif
+        break;
+    case 0xf:
+        /* wsc */
+        check_insn(ctx, ABIV2_TEE);
+#ifndef CONFIG_USER_ONLY
+        t0 = tcg_temp_new();
+        tcg_gen_movi_tl(t0, ctx->pc);
+        store_cpu_field(t0, pc);
+        t0 = tcg_const_tl(0);
+        store_cpu_field(t0, idly4_counter);
+        tcg_temp_free(t0);
+        gen_helper_wsc(cpu_env);
+        ctx->is_jmp = DISAS_UPDATE;
+        ctx->cannot_be_traced = 1;
+#else
+        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#endif
+        break;
+    case 0x15:
+        /* we */
+        break;
+    case 0x16:
+        /* se */
+        break;
+    case 0x10:
+        /* rte */
+#ifndef CONFIG_USER_ONLY
+        if (!IS_SUPER(ctx)) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        } else {
+            t0 = tcg_temp_new();
+
+            t0 = tcg_const_tl(0);
+            store_cpu_field(t0, idly4_counter);
+            tcg_temp_free(t0);
+
+            gen_helper_rte(cpu_env);
+            ctx->is_jmp = DISAS_UPDATE;
+            ctx->cannot_be_traced = 1;
+        }
+#else
+        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#endif
+        break;
+    case 0x11:
+        /* rfi */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+#ifndef CONFIG_USER_ONLY
+        if (!IS_SUPER(ctx)) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        } else {
+            t0 = tcg_temp_new();
+
+            t0 = tcg_const_tl(0);
+            store_cpu_field(t0, idly4_counter);
+            tcg_temp_free(t0);
+
+            gen_helper_rfi(cpu_env);
+            ctx->is_jmp = DISAS_UPDATE;
+            ctx->cannot_be_traced = 1;
+        }
+#else
+        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#endif
+        break;
+    case 0x12:
+        /* stop */
+#ifndef CONFIG_USER_ONLY
+        if (!IS_SUPER(ctx)) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        } else {
+            t0 = tcg_temp_new();
+
+            t0 = tcg_const_tl(0);
+            store_cpu_field(t0, idly4_counter);
+            tcg_temp_free(t0);
+
+            gen_save_pc(ctx->pc + 4);
+            gen_helper_stop(cpu_env);
+            ctx->is_jmp = DISAS_UPDATE;
+            ctx->cannot_be_traced = 1;
+        }
+#else
+        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#endif
+        break;
+    case 0x13:
+        /* wait */
+#ifndef CONFIG_USER_ONLY
+        if (!IS_SUPER(ctx)) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        } else {
+            t0 = tcg_temp_new();
+
+            t0 = tcg_const_tl(0);
+            store_cpu_field(t0, idly4_counter);
+            tcg_temp_free(t0);
+
+            gen_save_pc(ctx->pc + 4);
+            gen_helper_wait(cpu_env);
+            ctx->is_jmp = DISAS_UPDATE;
+            ctx->cannot_be_traced = 1;
+        }
+#else
+        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#endif
+        break;
+    case 0x14:
+        /* doze */
+#ifndef CONFIG_USER_ONLY
+        if (!IS_SUPER(ctx)) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        } else {
+            t0 = tcg_temp_new();
+
+            t0 = tcg_const_tl(0);
+            store_cpu_field(t0, idly4_counter);
+            tcg_temp_free(t0);
+
+            gen_save_pc(ctx->pc + 4);
+            gen_helper_doze(cpu_env);
+            ctx->is_jmp = DISAS_UPDATE;
+            ctx->cannot_be_traced = 1;
+        }
+#else
+        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#endif
+        break;
+    case 0x18:
+        /* mfcr */
+#ifndef CONFIG_USER_ONLY
+        if (!IS_SUPER(ctx)) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        }
+
+        if (ry == 0) { /* sel */
+            gen_mfcr_cpu(ctx, rz, rx);
+        } else if (ry == 2) {
+            gen_mfcr_vfp(ctx, rz, rx);
+        } else if (ry == 3) {  /* tee */
+            check_insn(ctx, ABIV2_TEE);
+            if (IS_TRUST(ctx)) {
+                gen_mfcr_tee(ctx, rz, rx);
+            } else {
+                generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+            }
+        } else if (ry == 15) {
+            check_insn(ctx, CSKY_MMU);
+            gen_mfcr_mmu(ctx, rz, rx);
+        } else if ((ry == 1) && (rx == 14)) {
+            gen_helper_mfcr_cr14(cpu_R[rz], cpu_env);
+        } else if ((ry == 1) && (rx == 1)) {  /* mfcr cr<1, 1> */
+            check_insn(ctx, ABIV2_TEE);
+            TCGv t0;
+            if (IS_TRUST(ctx)) {
+                t0 = load_cpu_field(tee.t_ebr);
+            } else {
+                t0 = load_cpu_field(tee.nt_ebr);
+            }
+            tcg_gen_mov_tl(cpu_R[rz], t0);
+            tcg_temp_free(t0);
+        }
+        break;
+#else
+        if (ry == 2) {
+            gen_mfcr_vfp(ctx, rz, rx);
+        } else {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        }
+        break;
+#endif
+    case 0x19:
+        /* mtcr */
+#ifndef CONFIG_USER_ONLY
+        if (!IS_SUPER(ctx)) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        } else {
+            if (ry == 0) {  /* sel */
+                gen_mtcr_cpu(ctx, rz, rx);
+            } else if (ry == 2) {
+                gen_mtcr_vfp(ctx, rz, rx);
+            } else if (ry == 3) {  /* tee */
+                check_insn(ctx, ABIV2_TEE);
+                if (IS_TRUST(ctx)) {
+                    gen_mtcr_tee(ctx, rz, rx);
+                } else {
+                    generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                }
+            } else if (ry == 15) {
+                check_insn(ctx, CSKY_MMU);
+                gen_mtcr_mmu(ctx, rz, rx);
+            } else if ((ry == 1) && (rz == 14)) { /* mtcr cr<14, 1> */
+                gen_helper_mtcr_cr14(cpu_env, cpu_R[rx]);
+            } else if ((ry == 1) && (rz == 1)) {  /* mtcr cr<1, 1> */
+                check_insn(ctx, ABIV2_TEE);
+                TCGv t0 = tcg_temp_new();
+                tcg_gen_andi_tl(t0, cpu_R[rx], ~0x3);
+                if (IS_TRUST(ctx)) {
+                    store_cpu_field(t0, tee.t_ebr);
+                } else {
+                    store_cpu_field(t0, tee.nt_ebr);
+                }
+                tcg_temp_free(t0);
+            }
+            break;
+        }
+#else
+        if (ry == 2) {
+            gen_mtcr_vfp(ctx, rz, rx);
+        } else {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        }
+        break;
+#endif
+    case 0x1c:
+        /* psrclr */
+#ifndef CONFIG_USER_ONLY
+        if (!IS_SUPER(ctx)) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        } else {
+            t0 = tcg_temp_new();
+
+            t0 = tcg_const_tl(ry);
+            gen_helper_psrclr(cpu_env, t0);
+            tcg_temp_free(t0);
+
+            gen_save_pc(ctx->pc + 4);
+            ctx->is_jmp = DISAS_UPDATE;
+        }
+#else
+        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#endif
+        break;
+    case 0x1d:
+        /* psrset */
+#ifndef CONFIG_USER_ONLY
+        if (!IS_SUPER(ctx)) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+        } else {
+            t0 = tcg_temp_new();
+
+            t0 = tcg_const_tl(ry);
+            gen_helper_psrset(cpu_env, t0);
+            tcg_temp_free(t0);
+
+            gen_save_pc(ctx->pc + 4);
+            ctx->is_jmp = DISAS_UPDATE;
+        }
+#else
+        generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+#endif
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static inline void arth_reg32(DisasContext *ctx,  int ry, int rx, uint32_t sop,
+                              uint32_t pcode, int rz)
+{
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_new();
+    int lsb;
+    int msb;
+
+    switch (sop) {
+    case 0x0:
+        if (pcode == 0x1) {
+            /* addu */
+            check_insn_except(ctx, CPU_801);
+            tcg_gen_add_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        } else if (pcode == 0x2) {
+            /* addc */
+            check_insn_except(ctx, CPU_801);
+            addc(rz, rx, ry);
+        } else if (pcode == 0x4) {
+            /* subu or rsub */
+            check_insn_except(ctx, CPU_801);
+            tcg_gen_sub_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        } else if (pcode == 0x8) {
+            /* subc */
+            check_insn_except(ctx, CPU_801);
+            subc(rz, rx, ry);
+        } else if (pcode == 0x10) {
+            /* abs */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_mov_tl(cpu_R[rz], cpu_R[rx]);
+            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rx], 0x80000000, l1);
+            tcg_gen_brcondi_tl(TCG_COND_GE, cpu_R[rx], 0, l1);
+            tcg_gen_neg_tl(cpu_R[rz], cpu_R[rx]);
+            gen_set_label(l1);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x1:
+        if (pcode == 0x1) {
+            /* cmphs */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_setcond_tl(TCG_COND_GEU, cpu_c, cpu_R[rx], cpu_R[ry]);
+        } else if (pcode == 0x2) {
+            /* cmplt */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_setcond_tl(TCG_COND_LT, cpu_c, cpu_R[rx], cpu_R[ry]);
+        } else if (pcode == 0x4) {
+            /* cmpne */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_setcond_tl(TCG_COND_NE, cpu_c, cpu_R[rx], cpu_R[ry]);
+        } else if (pcode == 0x8) {
+            /* mvc */
+            check_insn_except(ctx, CPU_801);
+            tcg_gen_mov_tl(cpu_R[rz], cpu_c);
+        } else if (pcode == 0x10) {
+            /* mvcv */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_subfi_tl(cpu_R[rz], 1, cpu_c);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x2:
+        if (pcode == 0x1) {
+            /* ixh */
+            check_insn_except(ctx, CPU_801);
+            add_ix(rz, rx, ry, 1);
+        } else if (pcode == 0x2) {
+            /* ixw */
+            check_insn_except(ctx, CPU_801);
+            add_ix(rz, rx, ry, 2);
+        } else if (pcode == 0x4) {
+            /* ixd */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            add_ix(rz, rx, ry, 3);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x3:
+        check_insn_except(ctx, CPU_801);
+        if (pcode == 0x1) {
+            /* incf */
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 0, l1);
+            tcg_gen_addi_tl(cpu_R[ry], cpu_R[rx], rz);
+            gen_set_label(l1);
+        } else if (pcode == 0x2) {
+            /* inct */
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_c, 0, l1);
+            tcg_gen_addi_tl(cpu_R[ry], cpu_R[rx], rz);
+            gen_set_label(l1);
+        } else if (pcode == 0x4) {
+            /* decf */
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 0, l1);
+            tcg_gen_subi_tl(cpu_R[ry], cpu_R[rx], rz);
+            gen_set_label(l1);
+        } else if (pcode == 0x8) {
+            /* dect */
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_c, 0, l1);
+            tcg_gen_subi_tl(cpu_R[ry], cpu_R[rx], rz);
+            gen_set_label(l1);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x4:
+        if (pcode == 0x1) {
+            /* decgt */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_subi_tl(cpu_R[rz], cpu_R[rx], ry);
+            tcg_gen_setcondi_tl(TCG_COND_GT, cpu_c, cpu_R[rz], 0);
+        } else if (pcode == 0x2) {
+            /* declt */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_subi_tl(cpu_R[rz], cpu_R[rx], ry);
+            tcg_gen_setcondi_tl(TCG_COND_LT, cpu_c, cpu_R[rz], 0);
+        } else if (pcode == 0x4) {
+            /* decne */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_subi_tl(cpu_R[rz], cpu_R[rx], ry);
+            tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[rz], 0);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x7:
+        if (pcode == 1) {
+            /* cmpix */
+            check_insn(ctx, ABIV2_JAVA);
+            if (ctx->bctm) {
+                TCGLabel *l1 = gen_new_label();
+                tcg_gen_brcond_tl(TCG_COND_LT, cpu_R[rx], cpu_R[ry], l1);
+                tcg_gen_movi_tl(cpu_R[15], ctx->pc + 4);
+                tcg_gen_subi_tl(t0, cpu_R[SVBR], 8);
+                store_cpu_field(t0, pc);
+                ctx->is_jmp = DISAS_JUMP;
+                gen_set_label(l1);
+            } else {
+                break;
+            }
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x8:
+        if (pcode == 0x1) {
+            /* and */
+            check_insn_except(ctx, CPU_801);
+            tcg_gen_and_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        } else if (pcode == 0x2) {
+            /* andn */
+            check_insn_except(ctx, CPU_801);
+            tcg_gen_andc_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        } else if (pcode == 0x4) {
+            /* tst */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_and_tl(t0, cpu_R[rx], cpu_R[ry]);
+            tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, t0, 0);
+        } else if (pcode == 0x8) {
+            /* tstnbz */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tstnbz(rx);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x9:
+        check_insn_except(ctx, CPU_801);
+        if (pcode == 0x1) {
+            /* or */
+            tcg_gen_or_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        } else if (pcode == 0x2) {
+            /* xor */
+            tcg_gen_xor_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        } else if (pcode == 0x4) {
+            /* nor */
+            tcg_gen_nor_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0xa:
+        check_insn_except(ctx, CPU_801);
+        if (pcode == 0x1) {
+            /* bclri */
+            tcg_gen_andi_tl(cpu_R[rz], cpu_R[rx], ~(1 << ry));
+        } else if (pcode == 0x2) {
+            /* bseti */
+            tcg_gen_ori_tl(cpu_R[rz], cpu_R[rx], 1 << ry);
+        } else if (pcode == 0x4) {
+            /* btsti */
+            tcg_gen_andi_tl(cpu_c, cpu_R[rx], 1 << ry);
+            tcg_gen_shri_tl(cpu_c, cpu_c, ry);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0xb:
+        if (pcode == 0x1) {
+            /* clrf */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_NE, cpu_c, 0, l1);
+            tcg_gen_movi_tl(cpu_R[ry], 0);
+            gen_set_label(l1);
+        } else if (pcode == 0x2) {
+            /* clrt */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_c, 0, l1);
+            tcg_gen_movi_tl(cpu_R[ry], 0);
+            gen_set_label(l1);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x10:
+        check_insn_except(ctx, CPU_801);
+        if (pcode == 0x1) {
+            /* lsl */
+            lsl(rz, rx, ry);
+        } else if (pcode == 0x2) {
+            /* lsr */
+            lsr(rz, rx, ry);
+        } else if (pcode == 0x4) {
+            /* asr */
+            asr(rz, rx, ry);
+        } else if (pcode == 0x8) {
+            /* rotl */
+            rotl(rz, rx, ry);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x12:
+        check_insn_except(ctx, CPU_801);
+        if (pcode == 0x1) {
+            /* lsli */
+            tcg_gen_shli_tl(cpu_R[rz], cpu_R[rx], ry);
+        } else if (pcode == 0x2) {
+            /* lsri */
+            tcg_gen_shri_tl(cpu_R[rz], cpu_R[rx], ry);
+        } else if (pcode == 0x4) {
+            /* asri */
+            tcg_gen_sari_tl(cpu_R[rz], cpu_R[rx], ry);
+        } else if (pcode == 0x8) {
+            /* rotli */
+            tcg_gen_rotli_tl(cpu_R[rz], cpu_R[rx], ry);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x13:
+        check_insn_except(ctx, CPU_801);
+        if (pcode == 0x1) {
+            /* lslc */
+            lslc(rz, rx, ry + 1);
+        } else if (pcode == 0x2) {
+            /* lsrc */
+            lsrc(rz, rx, ry + 1);
+        } else if (pcode == 0x4) {
+            /* asrc */
+            asrc(rz, rx, ry + 1);
+        } else if (pcode == 0x8) {
+            /* xsr */
+            t0 = tcg_const_tl(ry + 1);
+            gen_helper_xsr(cpu_R[rz], cpu_env, cpu_R[rx], t0);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x14:
+        if (pcode == 0x1) {
+            /* bmaski */
+            check_insn_except(ctx, CPU_801);
+            ry += 1;
+            if (ry == 32) {
+                tcg_gen_movi_tl(cpu_R[rz], 0xffffffff);
+            } else {
+                tcg_gen_movi_tl(cpu_R[rz], (1 << ry) - 1);
+            }
+        } else if (pcode == 0x2) {
+            /* bgenr */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            TCGv t2 = tcg_temp_local_new();
+            TCGLabel *l1 = gen_new_label();
+
+            tcg_gen_mov_tl(t2, cpu_R[rx]);
+            tcg_gen_movi_tl(cpu_R[rz], 0);
+            tcg_gen_andi_tl(t1, t2, 0x20);
+            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);
+            tcg_gen_movi_tl(t1, 1);
+            tcg_gen_andi_tl(t2, t2, 0x1f);
+            tcg_gen_shl_tl(cpu_R[rz], t1, t2);
+            gen_set_label(l1);
+
+            tcg_temp_free(t2);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x15:
+        /* zext or zextb or zexth */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        lsb = ry;
+        msb = pcode;
+        if (lsb == 0 && msb == 31) {
+            tcg_gen_mov_tl(cpu_R[rz], cpu_R[rx]);
+        } else {
+            tcg_gen_movi_tl(t0, 0);
+            tcg_gen_shri_tl(cpu_R[rz], cpu_R[rx], lsb);
+            tcg_gen_deposit_tl(cpu_R[rz], t0, cpu_R[rz], 0, msb - lsb + 1);
+        }
+        break;
+    case 0x16:
+        /* sext or sextb or sexth */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        lsb = ry;
+        msb = pcode;
+        if (lsb == 0 && msb == 31) {
+            tcg_gen_mov_tl(cpu_R[rz], cpu_R[rx]);
+        } else {
+            tcg_gen_shri_tl(cpu_R[rz], cpu_R[rx], lsb);
+            tcg_gen_movi_tl(t0, 0);
+            tcg_gen_deposit_tl(t0, t0, cpu_R[rz], 0, msb - lsb + 1);
+            tcg_gen_shli_tl(t0, t0, 32 - (msb - lsb + 1));
+            tcg_gen_sari_tl(cpu_R[rz], t0, 32 - (msb - lsb + 1));
+        }
+        break;
+    case 0x17:
+        /* ins */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        lsb = rz;
+        if (pcode == 31) {
+            tcg_gen_mov_tl(cpu_R[ry], cpu_R[rx]);
+        } else {
+            tcg_gen_deposit_tl(cpu_R[ry], cpu_R[ry], cpu_R[rx], lsb, pcode + 1);
+        }
+        break;
+    case 0x18:
+        if (pcode == 0x4) {
+            /* revb */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_bswap32_tl(cpu_R[rz], cpu_R[rx]);
+        } else if (pcode == 0x8) {
+            /* revh */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_bswap32_tl(t0, cpu_R[rx]);
+            tcg_gen_shri_tl(t1, t0, 16);
+            tcg_gen_shli_tl(t0, t0, 16);
+            tcg_gen_or_tl(cpu_R[rz], t0, t1);
+        } else if (pcode == 0x10) {
+            /* brev */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            gen_helper_brev(cpu_R[rz], cpu_R[rx]);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x1c:
+        check_insn_except(ctx, CPU_801);
+        if (pcode == 0x1) {
+            /* xtrb0 */
+            tcg_gen_shri_tl(cpu_R[rz], cpu_R[rx], 24);
+            tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[rz], 0);
+        } else if (pcode == 0x2) {
+            /* xtrb1 */
+            tcg_gen_andi_tl(cpu_R[rz], cpu_R[rx], 0x00ff0000);
+            tcg_gen_shri_tl(cpu_R[rz], cpu_R[rz], 16);
+            tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[rz], 0);
+        } else if (pcode == 0x4) {
+            /* xtrb2 */
+            tcg_gen_andi_tl(cpu_R[rz], cpu_R[rx], 0x0000ff00);
+            tcg_gen_shri_tl(cpu_R[rz], cpu_R[rz], 8);
+            tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[rz], 0);
+        } else if (pcode == 0x8) {
+            /* xtrb3 */
+            tcg_gen_andi_tl(cpu_R[rz], cpu_R[rx], 0xff);
+            tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[rz], 0);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x1f:
+        check_insn_except(ctx, CPU_801);
+        if (pcode == 0x1) {
+            /* ff0 */
+            gen_helper_ff0(cpu_R[rz], cpu_R[rx]);
+        } else if (pcode == 0x2) {
+            /* ff1 */
+            gen_helper_ff1(cpu_R[rz], cpu_R[rx]);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x20:
+        if (pcode == 0x1) {
+            /* divu */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            divu(ctx, rz, rx, ry);
+        } else if (pcode == 0x2) {
+            /* divs */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            divs(ctx, rz, rx, ry);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x21:
+        check_insn_except(ctx, CPU_801);
+        if (pcode == 0x1) {
+            /* mult */
+            tcg_gen_mul_tl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x22:
+        if (pcode == 0x1) {
+            /* mulu */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            TCGv_i64 t2 = tcg_temp_new_i64();
+            TCGv_i64 t3 = tcg_temp_new_i64();
+
+            tcg_gen_extu_tl_i64(t2, cpu_R[rx]);
+            tcg_gen_extu_tl_i64(t3, cpu_R[ry]);
+            tcg_gen_mul_i64(t2, t2, t3);
+            tcg_temp_free_i64(t3);
+            tcg_gen_trunc_i64_tl(cpu_lo, t2);
+            tcg_gen_shri_i64(t2, t2, 32);
+            tcg_gen_trunc_i64_tl(cpu_hi, t2);
+            tcg_temp_free_i64(t2);
+        } else if (pcode == 0x2) {
+            /* mulua */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            TCGv_i64 t2 = tcg_temp_new_i64();
+            TCGv_i64 t3 = tcg_temp_new_i64();
+
+            tcg_gen_extu_tl_i64(t2, cpu_R[rx]);
+            tcg_gen_extu_tl_i64(t3, cpu_R[ry]);
+            tcg_gen_mul_i64(t3, t3, t2);
+            tcg_gen_concat_tl_i64(t2, cpu_lo, cpu_hi);
+            tcg_gen_add_i64(t3, t3, t2);
+            tcg_temp_free_i64(t2);
+            tcg_gen_trunc_i64_tl(cpu_lo, t3);
+            tcg_gen_shri_i64(t3, t3, 32);
+            tcg_gen_trunc_i64_tl(cpu_hi, t3);
+            tcg_temp_free_i64(t3);
+        } else if (pcode == 0x4) {
+            /* mulus */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            TCGv_i64 t2 = tcg_temp_new_i64();
+            TCGv_i64 t3 = tcg_temp_new_i64();
+
+            tcg_gen_extu_tl_i64(t2, cpu_R[rx]);
+            tcg_gen_extu_tl_i64(t3, cpu_R[ry]);
+            tcg_gen_mul_i64(t3, t3, t2);
+            tcg_gen_concat_tl_i64(t2, cpu_lo, cpu_hi);
+            tcg_gen_sub_i64(t3, t2, t3);
+            tcg_temp_free_i64(t2);
+            tcg_gen_trunc_i64_tl(cpu_lo, t3);
+            tcg_gen_shri_i64(t3, t3, 32);
+            tcg_gen_trunc_i64_tl(cpu_hi, t3);
+            tcg_temp_free_i64(t3);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x23:
+        if (pcode == 0x1) {
+            /* muls */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            TCGv_i64 t2 = tcg_temp_new_i64();
+            TCGv_i64 t3 = tcg_temp_new_i64();
+
+            tcg_gen_ext_tl_i64(t2, cpu_R[rx]);
+            tcg_gen_ext_tl_i64(t3, cpu_R[ry]);
+            tcg_gen_mul_i64(t2, t2, t3);
+            tcg_temp_free_i64(t3);
+            tcg_gen_trunc_i64_tl(cpu_lo, t2);
+            tcg_gen_shri_i64(t2, t2, 32);
+            tcg_gen_trunc_i64_tl(cpu_hi, t2);
+            tcg_temp_free_i64(t2);
+        } else if (pcode == 0x2) {
+            /* mulsa */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            TCGv_i64 t2 = tcg_temp_new_i64();
+            TCGv_i64 t3 = tcg_temp_new_i64();
+
+            tcg_gen_ext_tl_i64(t2, cpu_R[rx]);
+            tcg_gen_ext_tl_i64(t3, cpu_R[ry]);
+            tcg_gen_mul_i64(t3, t3, t2);
+            tcg_gen_concat_tl_i64(t2, cpu_lo, cpu_hi);
+            tcg_gen_add_i64(t3, t3, t2);
+            tcg_temp_free_i64(t2);
+            tcg_gen_trunc_i64_tl(cpu_lo, t3);
+            tcg_gen_shri_i64(t3, t3, 32);
+            tcg_gen_trunc_i64_tl(cpu_hi, t3);
+            tcg_temp_free_i64(t3);
+        } else if (pcode == 0x4) {
+            /* mulss */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            TCGv_i64 t2 = tcg_temp_new_i64();
+            TCGv_i64 t3 = tcg_temp_new_i64();
+
+            tcg_gen_ext_tl_i64(t2, cpu_R[rx]);
+            tcg_gen_ext_tl_i64(t3, cpu_R[ry]);
+            tcg_gen_mul_i64(t3, t3, t2);
+            tcg_gen_concat_tl_i64(t2, cpu_lo, cpu_hi);
+            tcg_gen_sub_i64(t3, t2, t3);
+            tcg_temp_free_i64(t2);
+            tcg_gen_trunc_i64_tl(cpu_lo, t3);
+            tcg_gen_shri_i64(t3, t3, 32);
+            tcg_gen_trunc_i64_tl(cpu_hi, t3);
+            tcg_temp_free_i64(t3);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x24:
+        if (pcode == 0x1) {
+            /* mulsh */
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            tcg_gen_ext16s_tl(t0, cpu_R[rx]);
+            tcg_gen_ext16s_tl(t1, cpu_R[ry]);
+            tcg_gen_mul_tl(cpu_R[rz], t0, t1);
+        } else if (pcode == 0x2) {
+            /* mulsha */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            mulsha(rx, ry);
+        } else if (pcode == 0x4) {
+            /* mulshs */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            mulshs(rx, ry);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x25:
+        if (pcode == 0x1) {
+            /* mulsw */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            mulsw(rz, rx, ry);
+        } else if (pcode == 0x2) {
+            /* mulswa */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            mulswa(rx, ry);
+        } else if (pcode == 0x4) {
+            /* mulsws */
+            check_insn(ctx, CPU_810 | CPU_807 | ABIV2_DSP);
+            mulsws(rx, ry);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x26:
+        if (pcode == 0x10) {
+            /*mvtc*/
+            check_insn(ctx, CPU_807 | CPU_810 | ABIV2_DSP);
+            tcg_gen_mov_tl(cpu_c, cpu_v);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    case 0x27:
+        if (pcode == 0x1) {
+            /* mfhi */
+            check_insn(ctx, CPU_807 | CPU_810 | ABIV2_DSP);
+            tcg_gen_mov_tl(cpu_R[rz], cpu_hi);
+        } else if (pcode == 0x2) {
+            /* mthi */
+            check_insn(ctx, CPU_807 | CPU_810 | ABIV2_DSP);
+            tcg_gen_mov_tl(cpu_hi, cpu_R[rx]);
+        } else if (pcode == 0x4) {
+            /* mflo */
+            check_insn(ctx, CPU_807 | CPU_810 | ABIV2_DSP);
+            tcg_gen_mov_tl(cpu_R[rz], cpu_lo);
+        } else if (pcode == 0x8) {
+            /* mtlo */
+            check_insn(ctx, CPU_807 | CPU_810 | ABIV2_DSP);
+            tcg_gen_mov_tl(cpu_lo, cpu_R[rx]);
+        } else {
+            goto illegal_op;
+        }
+        break;
+    default:
+illegal_op:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+
+}
+
+static inline void lrs(DisasContext *ctx, int rz, uint32_t sop, int imm)
+{
+    TCGv t0 = tcg_temp_new();
+    switch (sop) {
+    case 0x0: /*lrs.b*/
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldst(ld8u, 28, rz, imm, 4);
+        break;
+    case 0x1: /*lrs.h*/
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldst(ld16u, 28, rz, imm << 1, 4);
+        break;
+    case 0x2: /*lrs.w*/
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldst(ld32u, 28, rz, imm << 2, 4);
+        break;
+    case 0x3: /*grs*/
+        {
+            check_insn_except(ctx, CPU_801 | CPU_802);
+            int t1;
+            t1 = imm << 1;
+            if (t1 & 0x40000) {
+                t1 |= 0xfffc0000;
+            }
+            t1 += ctx->pc;
+            tcg_gen_movi_tl(cpu_R[rz], t1);
+        }
+        break;
+    case 0x4: /*srs.b*/
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldst(st8, 28, rz, imm, 4);
+        break;
+    case 0x5: /*srs.h*/
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldst(st16, 28, rz, imm << 1, 4);
+        break;
+    case 0x6: /*srs.w*/
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        ldst(st32, 28, rz, imm << 2, 4);
+        break;
+    case 0x7:  /* addi */
+        tcg_gen_addi_tl(cpu_R[rz], cpu_R[28], imm + 1);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+    tcg_temp_free(t0);
+}
+
+static inline void imm_2op(DisasContext *ctx, int rz, int rx, uint32_t sop,
+                            int imm)
+{
+    TCGv t0;
+
+    check_insn_except(ctx, CPU_801);
+    switch (sop) {
+    case 0x0:  /* addi */
+        tcg_gen_addi_tl(cpu_R[rz], cpu_R[rx], imm + 1);
+        break;
+    case 0x1: /* subi */
+        tcg_gen_subi_tl(cpu_R[rz], cpu_R[rx], imm + 1);
+        break;
+    case 0x2: /* andi */
+        tcg_gen_andi_tl(cpu_R[rz], cpu_R[rx], imm);
+        break;
+    case 0x3: /* andni */
+        t0 = tcg_temp_new();
+        t0 = tcg_const_tl(imm);
+        tcg_gen_andc_tl(cpu_R[rz], cpu_R[rx], t0);
+        tcg_temp_free(t0);
+        break;
+    case 0x4: /* xori */
+        tcg_gen_xori_tl(cpu_R[rz], cpu_R[rx], imm);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static inline void imm_1op(DisasContext *ctx, uint32_t sop, int rx, int imm)
+{
+    target_ulong addr;
+    int val = 0;
+    TCGv t0;
+    TCGv t1;
+
+    switch (sop) {
+    case 0x0: /* br */
+        val = imm << 1;
+        if (val & 0x10000) {
+            val |= 0xffff0000;
+        }
+        val += ctx->pc;
+
+        gen_goto_tb(ctx, 0, val);
+        ctx->is_jmp = DISAS_TB_JUMP;
+
+        break;
+    case 0x2: /* bf */
+        check_insn_except(ctx, CPU_801);
+        branch32(ctx, TCG_COND_EQ, -1, imm);
+        break;
+    case 0x3: /* bt */
+        check_insn_except(ctx, CPU_801);
+        branch32(ctx, TCG_COND_NE, -1, imm);
+        break;
+    case 0x6: /* jmp */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        t0 = tcg_temp_new();
+        tcg_gen_andi_tl(t0, cpu_R[rx], 0xfffffffe);
+        store_cpu_field(t0, pc);
+
+#if !defined(CONFIG_USER_ONLY)
+        if ((ctx->trace_mode == BRAN_TRACE_MODE)
+            || (ctx->trace_mode == INST_TRACE_MODE)) {
+            t0 = tcg_const_i32(EXCP_CSKY_TRACE);
+            gen_helper_exception(cpu_env, t0);
+        }
+        ctx->maybe_change_flow = 1;
+#endif
+        ctx->is_jmp = DISAS_JUMP;
+        tcg_temp_free(t0);
+        break;
+    case 0x7:/* jsr */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        t0 = tcg_temp_new();
+        tcg_gen_andi_tl(t0, cpu_R[rx], 0xfffffffe);
+        tcg_gen_movi_tl(cpu_R[15], ctx->pc + 4);
+        store_cpu_field(t0, pc);
+
+#if !defined(CONFIG_USER_ONLY)
+        if ((ctx->trace_mode == BRAN_TRACE_MODE)
+            || (ctx->trace_mode == INST_TRACE_MODE)) {
+            t0 = tcg_const_i32(EXCP_CSKY_TRACE);
+            gen_helper_exception(cpu_env, t0);
+        }
+        ctx->maybe_change_flow = 1;
+#endif
+        ctx->is_jmp = DISAS_JUMP;
+        tcg_temp_free(t0);
+        break;
+    case 0x8: /* bez */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        branch32(ctx, TCG_COND_EQ, rx, imm);
+        break;
+    case 0x9: /* bnez */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        branch32(ctx, TCG_COND_NE, rx, imm);
+        break;
+    case 0xa:  /* bhz */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        branch32(ctx, TCG_COND_GT, rx, imm);
+        break;
+    case 0xb: /* blsz */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        branch32(ctx, TCG_COND_LE, rx, imm);
+        break;
+    case 0xc: /* blz */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        branch32(ctx, TCG_COND_LT, rx, imm);
+        break;
+    case 0xd: /* bhsz */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        branch32(ctx, TCG_COND_GE, rx, imm);
+        break;
+    case 0xe: /* bloop */
+        check_insn(ctx, ABIV2_EDSP);
+        if (imm & 0x800) {
+            val = imm | 0xf000;
+        }
+        tcg_gen_subi_tl(cpu_R[rx], cpu_R[rx], 1);
+        branch32(ctx, TCG_COND_NE, rx, val);
+        break;
+    case 0xf: /* jmpix */
+        check_insn(ctx, ABIV2_JAVA);
+        if (ctx->bctm) {
+            t0 = tcg_temp_new();
+            t1 = tcg_temp_new();
+
+            tcg_gen_andi_tl(t0, cpu_R[rx], 0xff);
+            switch (imm & 0x3) {
+            case 0x0:
+                tcg_gen_shli_tl(t0, t0, 4);
+                break;
+            case 0x1:
+                tcg_gen_shli_tl(t1, t0, 4);
+                tcg_gen_shli_tl(t0, t0, 3);
+                tcg_gen_add_tl(t0, t0, t1);
+                break;
+            case 0x2:
+                tcg_gen_shli_tl(t0, t0, 5);
+                break;
+            case 0x3:
+                tcg_gen_shli_tl(t1, t0, 5);
+                tcg_gen_shli_tl(t0, t0, 3);
+                tcg_gen_add_tl(t0, t0, t1);
+                break;
+            default:
+                break;
+            }
+            tcg_gen_add_tl(t0, cpu_R[SVBR], t0);
+            store_cpu_field(t0, pc);
+
+            ctx->is_jmp = DISAS_JUMP;
+            tcg_temp_free(t1);
+            tcg_temp_free(t0);
+            break;
+        } else {
+            generate_exception(ctx, EXCP_CSKY_UDEF);
+            break;
+        }
+    case 0x10: /* movi */
+        check_insn_except(ctx, CPU_801);
+        tcg_gen_movi_tl(cpu_R[rx], imm);
+        break;
+    case 0x11: /* movih */
+        check_insn_except(ctx, CPU_801);
+        tcg_gen_movi_tl(cpu_R[rx], imm << 16);
+        break;
+    case 0x14:/* lrw */
+        t0 = tcg_temp_new();
+
+        addr = (ctx->pc + (imm << 2)) & 0xfffffffc ;
+        tcg_gen_movi_tl(t0, addr);
+        tcg_gen_qemu_ld32u(cpu_R[rx], t0, ctx->mem_idx);
+        tcg_temp_free(t0);
+        break;
+    case 0x16: /* jmpi */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        t0 = tcg_temp_new();
+
+        addr = (ctx->pc + (imm << 2)) & 0xfffffffc ;
+        tcg_gen_movi_tl(t0, addr);
+        tcg_gen_qemu_ld32u(t0, t0, ctx->mem_idx);
+        store_cpu_field(t0, pc);
+
+#if !defined(CONFIG_USER_ONLY)
+        if ((ctx->trace_mode == BRAN_TRACE_MODE)
+            || (ctx->trace_mode == INST_TRACE_MODE)) {
+            t0 = tcg_const_i32(EXCP_CSKY_TRACE);
+            gen_helper_exception(cpu_env, t0);
+        }
+        ctx->maybe_change_flow = 1;
+#endif
+        ctx->is_jmp = DISAS_JUMP;
+
+        tcg_temp_free(t0);
+        break;
+    case 0x17: /* jsri */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        t0 = tcg_temp_new();
+
+        addr =  (ctx->pc + (imm << 2)) & 0xfffffffc;
+        tcg_gen_movi_tl(cpu_R[15], ctx->pc + 4);
+        tcg_gen_movi_tl(t0, addr);
+        tcg_gen_qemu_ld32u(t0, t0, ctx->mem_idx);
+        store_cpu_field(t0, pc);
+
+#if !defined(CONFIG_USER_ONLY)
+        if ((ctx->trace_mode == BRAN_TRACE_MODE)
+            || (ctx->trace_mode == INST_TRACE_MODE)) {
+            t0 = tcg_const_i32(EXCP_CSKY_TRACE);
+            gen_helper_exception(cpu_env, t0);
+        }
+        ctx->maybe_change_flow = 1;
+#endif
+        ctx->is_jmp = DISAS_JUMP;
+
+        tcg_temp_free(t0);
+        break;
+    case 0x18: /* cmphsi */
+        check_insn_except(ctx, CPU_801);
+        tcg_gen_setcondi_tl(TCG_COND_GEU, cpu_c, cpu_R[rx], imm + 1);
+        break;
+    case 0x19:  /* cmplti */
+        check_insn_except(ctx, CPU_801);
+        tcg_gen_setcondi_tl(TCG_COND_LT, cpu_c, cpu_R[rx], imm + 1);
+        break;
+    case 0x1a: /* cmpnei */
+        check_insn_except(ctx, CPU_801);
+        tcg_gen_setcondi_tl(TCG_COND_NE, cpu_c, cpu_R[rx], imm);
+        break;
+    case 0x1e:   /* pop */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        if (ctx->bctm) {
+            t0 = tcg_temp_new();
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[sp], 0, l1);
+            tcg_gen_movi_tl(cpu_R[15], ctx->pc + 4);
+            tcg_gen_subi_tl(t0, cpu_R[SVBR], 4);
+            store_cpu_field(t0, pc);
+            tcg_gen_exit_tb(0);
+            gen_set_label(l1);
+            pop(ctx, imm & 0x1ff);
+            tcg_temp_free(t0);
+            break;
+        } else {
+            pop(ctx, imm & 0x1ff);
+            break;
+        }
+    case 0x1f:    /* push */
+        check_insn_except(ctx, CPU_801 | CPU_802);
+        if (ctx->bctm) {
+            t0 = tcg_temp_new();
+            TCGLabel *l1 = gen_new_label();
+            tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[sp], 0, l1);
+            tcg_gen_movi_tl(cpu_R[15], ctx->pc + 4);
+            tcg_gen_subi_tl(t0, cpu_R[SVBR], 4);
+            store_cpu_field(t0, pc);
+            tcg_gen_exit_tb(0);
+            gen_set_label(l1);
+            push(ctx, imm & 0x1ff);
+            gen_goto_tb(ctx, 1, ctx->pc + 4);
+            ctx->is_jmp = DISAS_TB_JUMP;
+            tcg_temp_free(t0);
+            break;
+        } else {
+            push(ctx, imm & 0x1ff);
+            break;
+        }
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static inline void gen_vfp_ld(DisasContext *s, int dp, TCGv addr)
+{
+    if (dp) {
+        /*doesn't cause alignment exception*/
+#if !defined TARGET_WORDS_BIGENDIAN
+        tcg_gen_qemu_ld32u(cpu_F0s, addr, s->mem_idx);
+        tcg_gen_addi_i32(addr, addr, 4);
+        tcg_gen_qemu_ld32u(cpu_F1s, addr, s->mem_idx);
+        tcg_gen_concat_i32_i64(cpu_F0d, cpu_F0s, cpu_F1s);
+#else
+        tcg_gen_qemu_ld32u(cpu_F0s, addr, s->mem_idx);
+        tcg_gen_addi_i32(addr, addr, 4);
+        tcg_gen_qemu_ld32u(cpu_F1s, addr, s->mem_idx);
+        tcg_gen_concat_i32_i64(cpu_F0d, cpu_F1s, cpu_F0s);
+#endif
+    } else {
+        tcg_gen_qemu_ld32u(cpu_F0s, addr, s->mem_idx);
+    }
+}
+
+static inline void gen_vfp_st(DisasContext *s, int dp, TCGv addr)
+{
+    if (dp) {
+        /*doesn't cause alignment exception*/
+#if !defined TARGET_WORDS_BIGENDIAN
+        tcg_gen_extrl_i64_i32(cpu_F0s, cpu_F0d);
+        tcg_gen_qemu_st32(cpu_F0s, addr, s->mem_idx);
+        tcg_gen_shri_i64(cpu_F0d, cpu_F0d, 32);
+        tcg_gen_extrl_i64_i32(cpu_F1s, cpu_F0d);
+        tcg_gen_addi_i32(addr, addr, 4);
+        tcg_gen_qemu_st32(cpu_F1s, addr, s->mem_idx);
+#else
+        tcg_gen_extrl_i64_i32(cpu_F0s, cpu_F0d);
+        tcg_gen_shri_i64(cpu_F0d, cpu_F0d, 32);
+        tcg_gen_extrl_i64_i32(cpu_F1s, cpu_F0d);
+        tcg_gen_qemu_st32(cpu_F1s, addr, s->mem_idx);
+        tcg_gen_addi_i32(addr, addr, 4);
+        tcg_gen_qemu_st32(cpu_F0s, addr, s->mem_idx);
+#endif
+    } else {
+        tcg_gen_qemu_st32(cpu_F0s, addr, s->mem_idx);
+    }
+}
+
+#define vfp_reg_offset(reg) offsetof(CPUCSKYState, vfp.reg[reg])
+
+#define tcg_gen_ld_f32 tcg_gen_ld_i32
+#define tcg_gen_ld_f64 tcg_gen_ld_i64
+#define tcg_gen_st_f32 tcg_gen_st_i32
+#define tcg_gen_st_f64 tcg_gen_st_i64
+
+static inline void gen_mov_F0_vreg(int dp, int reg)
+{
+    if (dp) {
+        tcg_gen_ld_f64(cpu_F0d, cpu_env, vfp_reg_offset(reg));
+    } else {
+        tcg_gen_ld_f32(cpu_F0s, cpu_env, vfp_reg_offset(reg));
+    }
+}
+
+static inline void gen_mov_F0_vreg_hi(int dp, int reg)
+{
+    if (dp) {
+        tcg_gen_ld_f64(cpu_F0d, cpu_env, vfp_reg_offset(reg) + 4);
+    } else {
+        tcg_gen_ld_f32(cpu_F0s, cpu_env, vfp_reg_offset(reg) + 4);
+    }
+}
+
+static inline void gen_mov_F1_vreg(int dp, int reg)
+{
+    if (dp) {
+        tcg_gen_ld_f64(cpu_F1d, cpu_env, vfp_reg_offset(reg));
+    } else {
+        tcg_gen_ld_f32(cpu_F1s, cpu_env, vfp_reg_offset(reg));
+    }
+}
+
+static inline void gen_mov_F1_vreg_hi(int dp, int reg)
+{
+    if (dp) {
+        tcg_gen_ld_f64(cpu_F0d, cpu_env, vfp_reg_offset(reg) + 4);
+    } else {
+        tcg_gen_ld_f32(cpu_F0s, cpu_env, vfp_reg_offset(reg) + 4);
+    }
+}
+
+static inline void gen_mov_vreg_F0(int dp, int reg)
+{
+    if (dp) {
+        tcg_gen_st_f64(cpu_F0d, cpu_env, vfp_reg_offset(reg));
+    } else {
+        tcg_gen_st_f32(cpu_F0s, cpu_env, vfp_reg_offset(reg));
+    }
+}
+
+static inline void gen_mov_vreg_F0_hi(int dp, int reg)
+{
+    if (dp) {
+        tcg_gen_st_f64(cpu_F0d, cpu_env, vfp_reg_offset(reg) + 4);
+    } else {
+        tcg_gen_st_f32(cpu_F0s, cpu_env, vfp_reg_offset(reg) + 4);
+    }
+}
+
+static inline void gen_vfp_F1_ld0(int dp)
+{
+    if (dp) {
+        tcg_gen_movi_i64(cpu_F1d, 0);
+    } else {
+        tcg_gen_movi_i32(cpu_F1s, 0);
+    }
+}
+
+static inline void gen_vfp_add(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_addd(cpu_F0d, cpu_F0d, cpu_F1d, cpu_env);
+    } else {
+        gen_helper_vfp_adds(cpu_F0s, cpu_F0s, cpu_F1s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_sub(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_subd(cpu_F0d, cpu_F0d, cpu_F1d, cpu_env);
+    } else {
+        gen_helper_vfp_subs(cpu_F0s, cpu_F0s, cpu_F1s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_mul(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_muld(cpu_F0d, cpu_F0d, cpu_F1d, cpu_env);
+    } else {
+        gen_helper_vfp_muls(cpu_F0s, cpu_F0s, cpu_F1s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_div(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_divd(cpu_F0d, cpu_F0d, cpu_F1d, cpu_env);
+    } else {
+        gen_helper_vfp_divs(cpu_F0s, cpu_F0s, cpu_F1s, cpu_env);
+    }
+}
+
+
+
+static inline void gen_vfp_abs(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_absd(cpu_F0d, cpu_F0d);
+    } else {
+        gen_helper_vfp_abss(cpu_F0s, cpu_F0s);
+    }
+}
+
+static inline void gen_vfp_neg(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_negd(cpu_F0d, cpu_F0d);
+    } else {
+        gen_helper_vfp_negs(cpu_F0s, cpu_F0s);
+    }
+}
+
+static inline void gen_vfp_sqrt(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_sqrtd(cpu_F0d, cpu_F0d, cpu_env);
+    } else {
+        gen_helper_vfp_sqrts(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_recip(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_recipd(cpu_F0d, cpu_F0d, cpu_env);
+    } else {
+        gen_helper_vfp_recips(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+
+static inline void gen_vfp_cmp_ge(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_cmp_ged(cpu_F0d, cpu_F1d, cpu_env);
+    } else {
+        gen_helper_vfp_cmp_ges(cpu_F0s, cpu_F1s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_cmp_l(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_cmp_ld(cpu_F0d, cpu_F1d, cpu_env);
+    } else {
+        gen_helper_vfp_cmp_ls(cpu_F0s, cpu_F1s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_cmp_ls(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_cmp_lsd(cpu_F0d, cpu_F1d, cpu_env);
+    } else {
+        gen_helper_vfp_cmp_lss(cpu_F0s, cpu_F1s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_cmp_ne(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_cmp_ned(cpu_F0d, cpu_F1d, cpu_env);
+    } else {
+        gen_helper_vfp_cmp_nes(cpu_F0s, cpu_F1s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_cmp_isNAN(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_cmp_isNANd(cpu_F0d, cpu_F1d, cpu_env);
+    } else {
+        gen_helper_vfp_cmp_isNANs(cpu_F0s, cpu_F1s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_tosirn(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_tosirnd(cpu_F0s, cpu_F0d, cpu_env);
+    } else {
+        gen_helper_vfp_tosirns(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_tosirz(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_tosirzd(cpu_F0s, cpu_F0d, cpu_env);
+    } else {
+        gen_helper_vfp_tosirzs(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_tosirpi(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_tosirpid(cpu_F0s, cpu_F0d, cpu_env);
+    } else {
+        gen_helper_vfp_tosirpis(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_tosirni(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_tosirnid(cpu_F0s, cpu_F0d, cpu_env);
+    } else {
+        gen_helper_vfp_tosirnis(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_touirn(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_touirnd(cpu_F0s, cpu_F0d, cpu_env);
+    } else {
+        gen_helper_vfp_touirns(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_touirz(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_touirzd(cpu_F0s, cpu_F0d, cpu_env);
+    } else {
+        gen_helper_vfp_touirzs(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_touirpi(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_touirpid(cpu_F0s, cpu_F0d, cpu_env);
+    } else {
+        gen_helper_vfp_touirpis(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_touirni(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_touirnid(cpu_F0s, cpu_F0d, cpu_env);
+    } else {
+        gen_helper_vfp_touirnis(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_uito(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_uitod(cpu_F0d, cpu_F0s, cpu_env);
+    } else {
+        gen_helper_vfp_uitos(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+static inline void gen_vfp_sito(int dp)
+{
+    if (dp) {
+        gen_helper_vfp_sitod(cpu_F0d, cpu_F0s, cpu_env);
+    } else {
+        gen_helper_vfp_sitos(cpu_F0s, cpu_F0s, cpu_env);
+    }
+}
+
+/* Move between integer and VFP cores.  */
+static TCGv gen_vfp_mrs(void)
+{
+    TCGv tmp = new_tmp();
+    tcg_gen_mov_i32(tmp, cpu_F0s);
+    return tmp;
+}
+
+static void gen_vfp_msr(TCGv tmp)
+{
+    tcg_gen_mov_i32(cpu_F0s, tmp);
+    dead_tmp(tmp);
+}
+
+static inline void fpu_insn_fmovi(int32_t insn)
+{
+    int vrz = insn & 0xf;
+    int imm = (((insn >> 21) & 0xf) << 7) | (((insn >> 4) & 0xf) << 3) | 0x800;
+    int pos = (insn >> 16) & 0xf;
+    int sign = (insn >> 20) & 0x1;
+    int dp = (insn >> 9) & 0x1;
+    TCGv_i32 t0, t1, t2;
+    t0 = tcg_const_i32(imm);
+    t1 = tcg_const_i32(pos);
+    t2 = tcg_const_i32(sign);
+    if (dp) {
+        gen_helper_vfp_fmovid(cpu_F0d, t0, t1, t2, cpu_env);
+    } else {
+        gen_helper_vfp_fmovis(cpu_F0s, t0, t1, t2, cpu_env);
+    }
+    gen_mov_vreg_F0(dp, vrz);
+}
+
+static void disas_vfp_insn(CPUCSKYState *env, DisasContext *s, uint32_t insn)
+{
+    int op1, op2, dp, imm, shift, i;
+    int vrx, vry, vrz;
+    int rx, ry, rz;
+
+    TCGv addr;
+    TCGv tmp;
+    op1 = (insn >> 8) & 0xff;
+    op2 = (insn >> 4) & 0xf;
+
+    switch (op1) {
+    case 0x0: /*single-alu*/
+        check_insn(s, ABIV2_FLOAT_S);
+        switch (op2) {
+        case 0x0:/* fadds */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x2:/* fsubs */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x8:/* fmovs */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xc:/* fabss */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_abs(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xe:/* fnegs */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_neg(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case 0x1:/*single-compare*/
+        check_insn(s, ABIV2_FLOAT_S);
+        switch (op2) {
+        case 0x0:/* fcmpzhss */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_F1_ld0(dp);
+            gen_vfp_cmp_ge(dp);
+            break;
+        case 0x2:/* fcmpzlss  */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_F1_ld0(dp);
+            gen_vfp_cmp_ls(dp);
+            break;
+        case 0x4:/* fcmpznes  */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_F1_ld0(dp);
+            gen_vfp_cmp_ne(dp);
+            break;
+        case 0x6:/* fcmpzuos  */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vrx);
+            gen_vfp_cmp_isNAN(dp);
+            break;
+        case 0x8:/* fcmphss */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_cmp_ge(dp);
+            break;
+        case 0xa:/* fcmplts */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_cmp_l(dp);
+            break;
+        case 0xc:/* fcmpnes */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_cmp_ne(dp);
+            break;
+        case 0xe:/* fcmpuos */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_cmp_isNAN(dp);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+
+    case 0x2:/* single-mul */
+        check_insn(s, ABIV2_FLOAT_S);
+        switch (op2) {
+        case 0x0:/* fmuls */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x2:/* fnmuls  */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x8:/* fmacs */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xa:/* fmscs */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xc:/* fnmacs */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xe:/* fnmscs */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+
+    case 0x3:/* single-div */
+        check_insn(s, ABIV2_FLOAT_S);
+        switch (op2) {
+        case 0x0:/* fdivs*/
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_div(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x2:/* frecips  */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_recip(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x4:/* fsqrts  */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_sqrt(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+
+    case 0x8:/* double-alu */
+        check_insn(s, ABIV2_FLOAT_D);
+        switch (op2) {
+        case 0x0:/* faddd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x2:/* fsubd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x8:/* fmovd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xc:/* fabsd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_abs(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xe:/* fnegd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_neg(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+
+        }
+        break;
+
+    case 0x9:/* double-compare */
+        check_insn(s, ABIV2_FLOAT_D);
+        switch (op2) {
+        case 0x0:/* fcmpzhsd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_F1_ld0(dp);
+            gen_vfp_cmp_ge(dp);
+            break;
+        case 0x2:/* fcmpzlsd  */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_F1_ld0(dp);
+            gen_vfp_cmp_ls(dp);
+            break;
+        case 0x4:/* fcmpzned  */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_F1_ld0(dp);
+            gen_vfp_cmp_ne(dp);
+            break;
+        case 0x6:/* fcmpzuod  */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vrx);
+            gen_vfp_cmp_isNAN(dp);
+            break;
+        case 0x8:/* fcmphsd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_cmp_ge(dp);
+            break;
+        case 0xa:/* fcmpltd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_cmp_l(dp);
+            break;
+        case 0xc:/* fcmpned */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_cmp_ne(dp);
+            break;
+        case 0xe:/* fcmpuod */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_cmp_isNAN(dp);
+            break;
+        default:
+            goto wrong;
+            break;
+
+        }
+        break;
+
+    case 0xa:/* double-mul */
+        check_insn(s, ABIV2_FLOAT_D);
+        switch (op2) {
+        case 0x0:/* fmuld */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x2:/* fnmuld  */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x8:/* fmacd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xa:/* fmscd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xc:/* fnmacd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xe:/* fnmscd */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+
+    case 0xb:/* double-div */
+        check_insn(s, ABIV2_FLOAT_D);
+        switch (op2) {
+        case 0x0:/* fdivd*/
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vry = (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_div(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x2:/* frecipd  */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_recip(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x4:/* fsqrtd  */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_sqrt(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+
+    case 0x10:/* simd-alu */
+        switch (op2) {
+        case 0x0:/* faddm */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            gen_mov_F0_vreg_hi(dp, vrx);
+            gen_mov_F1_vreg_hi(dp, vry);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0_hi(dp, vrz);
+            break;
+        case 0x2:/* fsubm */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            gen_mov_F0_vreg_hi(dp, vrx);
+            gen_mov_F1_vreg_hi(dp, vry);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0_hi(dp, vrz);
+            break;
+        case 0x8:/* fmovm */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xc:/* fabsm */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_abs(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            gen_mov_F0_vreg_hi(dp, vrx);
+            gen_vfp_abs(dp);
+            gen_mov_vreg_F0_hi(dp, vrz);
+            break;
+        case 0xe:/* fnegm */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_neg(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            gen_mov_F0_vreg_hi(dp, vrx);
+            gen_vfp_neg(dp);
+            gen_mov_vreg_F0_hi(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+
+    case 0x12:/* simd-mul  --fixe case 0x11:*/
+        switch (op2) {
+        case 0x0:/* fmulm */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            gen_mov_F0_vreg_hi(dp, vrx);
+            gen_mov_F1_vreg_hi(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_vreg_F0_hi(dp, vrz);
+            break;
+        case 0x2:/* fnmulm  */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            gen_mov_F0_vreg_hi(dp, vrx);
+            gen_mov_F1_vreg_hi(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_vreg_F0_hi(dp, vrz);
+            break;
+        case 0x8:/* fmacm */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            gen_mov_F0_vreg_hi(dp, vrx);
+            gen_mov_F1_vreg_hi(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_F1_vreg_hi(dp, vrz);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0_hi(dp, vrz);
+            break;
+        case 0xa:/* fmscm */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            gen_mov_F0_vreg_hi(dp, vrx);
+            gen_mov_F1_vreg_hi(dp, vry);
+            gen_vfp_mul(dp);
+            gen_mov_F1_vreg_hi(dp, vrz);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0_hi(dp, vrz);
+            break;
+        case 0xc:/* fnmacm */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            gen_mov_F0_vreg_hi(dp, vrx);
+            gen_mov_F1_vreg_hi(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_F1_vreg_hi(dp, vrz);
+            gen_vfp_add(dp);
+            gen_mov_vreg_F0_hi(dp, vrz);
+            break;
+        case 0xe:/* fnmscm */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vry =  (insn >> 21) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_mov_F1_vreg(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_F1_vreg(dp, vrz);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            gen_mov_F0_vreg_hi(dp, vrx);
+            gen_mov_F1_vreg_hi(dp, vry);
+            gen_vfp_mul(dp);
+            gen_vfp_neg(dp);
+            gen_mov_F1_vreg_hi(dp, vrz);
+            gen_vfp_sub(dp);
+            gen_mov_vreg_F0_hi(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+
+        }
+        break;
+
+    case 0x18:/* for-sti */
+        switch (op2) {
+            /* fstosi */
+        case 0x0:/* fstosi.rn */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_tosirn(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x2:/* fstosi.rz */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_tosirz(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x4:/* fstosi.rpi */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_tosirpi(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x6:/* fstosi.rni */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_tosirni(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+            /* fstoui */
+        case 0x8:/* fstoui.rn */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_touirn(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xa:/* fstoui.rz */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_touirz(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xc:/* fstoui.rpi */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_touirpi(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xe:/* fstoui.rni */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_touirni(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+
+        }
+        break;
+
+    case 0x19:/* for-dti */
+        switch (op2) {
+            /* fdtosi */
+        case 0x0:/* fdtosi.rn */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_tosirn(dp);
+            dp = 0;
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x2:/* fdtosi.rz */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_tosirz(dp);
+            dp = 0;
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x4:/* fdtosi.rpi */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_tosirpi(dp);
+            dp = 0;
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x6:/* fdtosi.rni */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_tosirni(dp);
+            dp = 0;
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+            /* fdtoui */
+        case 0x8:/* fdtoui.rn */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_touirn(dp);
+            dp = 0;
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xa:/* fdtoui.rz */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_touirz(dp);
+            dp = 0;
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xc:/* fdtoui.rpi */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_touirpi(dp);
+            dp = 0;
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xe:/* fdtoui.rni */
+            dp = 1;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_touirni(dp);
+            dp = 0;
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+
+    case 0x1a:/* for-misc */
+        switch (op2) {
+        case 0x0:/* fsitos */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_sito(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x2:/* fuitos  */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_vfp_uito(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0x8:/* fsitod */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            dp = 1;
+            gen_vfp_sito(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xa:/* fuitod */
+            dp = 0;
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            gen_mov_F0_vreg(dp, vrx);
+            dp = 1;
+            gen_vfp_uito(dp);
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xc:/* fdtos */
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            dp = 1;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_helper_vfp_tosd(cpu_F0s, cpu_F0d, cpu_env);
+            dp = 0;
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        case 0xe:/* fstod */
+            vrx = (insn >> 16) & 0xf;
+            vrz = insn & 0xf;
+            dp = 0;
+            gen_mov_F0_vreg(dp, vrx);
+            gen_helper_vfp_tods(cpu_F0d, cpu_F0s, cpu_env);
+            dp = 1;
+            gen_mov_vreg_F0(dp, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+
+    case 0x1b:/* for-fmvr */
+        switch (op2) {
+        case 0x0:
+        case 0x1:/* fmfvrh*/
+            vrx = (insn >> 16) & 0xf;
+            rz = insn & 0x1f;
+            gen_mov_F0_vreg_hi(0, vrx);
+            tmp = gen_vfp_mrs();
+            tcg_gen_mov_i32(cpu_R[rz], tmp);
+            tcg_temp_free_i32(tmp);
+            break;
+        case 0x2:
+        case 0x3:/* fmfvrl */
+            vrx = (insn >> 16) & 0xf;
+            rz = insn & 0x1f;
+            gen_mov_F0_vreg(0, vrx);
+            tmp = gen_vfp_mrs();
+            tcg_gen_mov_i32(cpu_R[rz], tmp);
+            tcg_temp_free_i32(tmp);
+            break;
+        case 0x4:/* fmtvrh */
+            rx = (insn >> 16) & 0x1f;
+            vrz = insn & 0xf;
+            tmp = load_reg(s, rx);
+            gen_vfp_msr(tmp);
+            gen_mov_vreg_F0_hi(0, vrz);
+            break;
+        case 0x6:/* fmtvrl */
+            rx = (insn >> 16) & 0x1f;
+            vrz = insn & 0xf;
+            tmp = load_reg(s, rx);
+            gen_vfp_msr(tmp);
+            gen_mov_vreg_F0(0, vrz);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    /* fmovis */
+    case 0x1c:
+    case 0x1e:
+        fpu_insn_fmovi(insn);
+        break;
+     /* flsu */
+    case 0x20:/* flds */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = ((insn >> 17) & 0xf0) | ((insn >> 4) & 0xf);
+        addr =  load_reg(s, rx);
+        tcg_gen_addi_i32(addr, addr, imm << 2);
+        gen_vfp_ld(s, 0, addr);
+        gen_mov_vreg_F0(0, vrz);
+        dead_tmp(addr);
+        break;
+    case 0x21:/* fldd */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = ((insn >> 17) & 0xf0) | ((insn >> 4) & 0xf);
+        addr =  load_reg(s, rx);
+        tcg_gen_addi_i32(addr, addr, imm << 2);
+        gen_vfp_ld(s, 1, addr);
+        gen_mov_vreg_F0(1, vrz);
+        dead_tmp(addr);
+        break;
+    case 0x22:/* fldm */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = ((insn >> 17) & 0xf0) | ((insn >> 4) & 0xf);
+        addr =  load_reg(s, rx);
+        tcg_gen_addi_i32(addr, addr, imm << 2);
+        gen_vfp_ld(s, 1, addr);
+        gen_mov_vreg_F0(1, vrz);
+        dead_tmp(addr);
+        break;
+    case 0x24:/* fsts */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = ((insn >> 17) & 0xf0) | ((insn >> 4) & 0xf);
+        addr =  load_reg(s, rx);
+        tcg_gen_addi_i32(addr, addr, imm << 2);
+        gen_mov_F0_vreg(0, vrz);
+        gen_vfp_st(s, 0, addr);
+        dead_tmp(addr);
+        break;
+    case 0x25:/* fstd */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = ((insn >> 17) & 0xf0) | ((insn >> 4) & 0xf);
+        addr =  load_reg(s, rx);
+        tcg_gen_addi_i32(addr, addr, imm << 2);
+        gen_mov_F0_vreg(1, vrz);
+        gen_vfp_st(s, 1, addr);
+        dead_tmp(addr);
+        break;
+    case 0x26:/* fstm */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = ((insn >> 17) & 0xf0) | ((insn >> 4) & 0xf);
+        addr =  load_reg(s, rx);
+        tcg_gen_addi_i32(addr, addr, imm << 2);
+        gen_mov_F0_vreg(1, vrz);
+        gen_vfp_st(s, 1, addr);
+        dead_tmp(addr);
+        break;
+    case 0x28:/* fldrs */
+        rx = (insn >> 16) & 0x1f;
+        ry = (insn >> 21) & 0x1f;
+        shift = (insn >> 0x5) & 0x3;
+        vrz = insn & 0xf;
+        addr =  load_reg(s, rx);
+        tmp =  load_reg(s, ry);
+        tcg_gen_shli_i32(tmp, tmp, shift);
+        tcg_gen_add_i32(addr, addr, tmp);
+        dead_tmp(tmp);
+        gen_vfp_ld(s, 0, addr);
+        gen_mov_vreg_F0(0, vrz);
+        dead_tmp(addr);
+        break;
+    case 0x29:/* fldrd */
+        rx = (insn >> 16) & 0x1f;
+        ry = (insn >> 21) & 0x1f;
+        shift = (insn >> 0x5) & 0x3;
+        vrz = insn & 0xf;
+        addr =  load_reg(s, rx);
+        tmp =  load_reg(s, ry);
+        tcg_gen_shli_i32(tmp, tmp, shift);
+        tcg_gen_add_i32(addr, addr, tmp);
+        dead_tmp(tmp);
+        gen_vfp_ld(s, 1, addr);
+        gen_mov_vreg_F0(1, vrz);
+        dead_tmp(addr);
+        break;
+    case 0x2a:/* fldrm */
+        rx = (insn >> 16) & 0x1f;
+        ry = (insn >> 21) & 0x1f;
+        shift = (insn >> 0x5) & 0x3;
+        vrz = insn & 0xf;
+        addr =  load_reg(s, rx);
+        tmp =  load_reg(s, ry);
+        tcg_gen_shli_i32(tmp, tmp, shift);
+        tcg_gen_add_i32(addr, addr, tmp);
+        dead_tmp(tmp);
+        gen_vfp_ld(s, 1, addr);
+        gen_mov_vreg_F0(1, vrz);
+        dead_tmp(addr);
+        break;
+    case 0x2c:/* fstrs */
+        rx = (insn >> 16) & 0x1f;
+        ry = (insn >> 21) & 0x1f;
+        shift = (insn >> 0x5) & 0x3;
+        vrz = insn & 0xf;
+        addr =  load_reg(s, rx);
+        tmp =  load_reg(s, ry);
+        tcg_gen_shli_i32(tmp, tmp, shift);
+        tcg_gen_add_i32(addr, addr, tmp);
+        dead_tmp(tmp);
+        gen_mov_F0_vreg(0, vrz);
+        gen_vfp_st(s, 0, addr);
+        dead_tmp(addr);
+        break;
+    case 0x2d:/* fstrd */
+        rx = (insn >> 16) & 0x1f;
+        ry = (insn >> 21) & 0x1f;
+        shift = (insn >> 0x5) & 0x3;
+        vrz = insn & 0xf;
+        addr =  load_reg(s, rx);
+        tmp =  load_reg(s, ry);
+        tcg_gen_shli_i32(tmp, tmp, shift);
+        tcg_gen_add_i32(addr, addr, tmp);
+        dead_tmp(tmp);
+        gen_mov_F0_vreg(1, vrz);
+        gen_vfp_st(s, 1, addr);
+        dead_tmp(addr);
+        break;
+    case 0x2e:/* fstrm */
+        rx = (insn >> 16) & 0x1f;
+        ry = (insn >> 21) & 0x1f;
+        shift = (insn >> 0x5) & 0x3;
+        vrz = insn & 0xf;
+        addr =  load_reg(s, rx);
+        tmp =  load_reg(s, ry);
+        tcg_gen_shli_i32(tmp, tmp, shift);
+        tcg_gen_add_i32(addr, addr, tmp);
+        dead_tmp(tmp);
+        gen_mov_F0_vreg(1, vrz);
+        gen_vfp_st(s, 1, addr);
+        dead_tmp(addr);
+        break;
+    case 0x30:/* fldms */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = (insn >> 21) & 0xf;
+        for (i = 0; i <= imm; i++) {
+            addr =  load_reg(s, rx);
+            gen_vfp_ld(s, 0, addr);
+            gen_mov_vreg_F0(0, vrz);
+            tcg_gen_addi_i32(addr, addr, 4);
+            vrz++;
+            dead_tmp(addr);
+        }
+        break;
+    case 0x31:/* fldmd */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = (insn >> 21) & 0xf;
+        for (i = 0; i <= imm; i++) {
+            addr =  load_reg(s, rx);
+            gen_vfp_ld(s, 1, addr);
+            gen_mov_vreg_F0(1, vrz);
+            tcg_gen_addi_i32(addr, addr, 8);
+            vrz++;
+            dead_tmp(addr);
+        }
+        break;
+    case 0x32:/* fldmm */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = (insn >> 21) & 0xf;
+        for (i = 0; i <= imm; i++) {
+            addr =  load_reg(s, rx);
+            gen_vfp_ld(s, 1, addr);
+            gen_mov_vreg_F0(1, vrz);
+            tcg_gen_addi_i32(addr, addr, 8);
+            vrz++;
+            dead_tmp(addr);
+        }
+        break;
+    case 0x34:/* fstms */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = (insn >> 21) & 0xf;
+        for (i = 0; i <= imm; i++) {
+            addr =  load_reg(s, rx);
+            gen_mov_F0_vreg(0, vrz);
+            gen_vfp_st(s, 0, addr);
+            tcg_gen_addi_i32(addr, addr, 8);
+            vrz++;
+            dead_tmp(addr);
+        }
+        break;
+    case 0x35:/* fstmd */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = (insn >> 21) & 0xf;
+        for (i = 0; i <= imm; i++) {
+            addr =  load_reg(s, rx);
+            gen_mov_F0_vreg(1, vrz);
+            gen_vfp_st(s, 1, addr);
+            tcg_gen_addi_i32(addr, addr, 8);
+            vrz++;
+            dead_tmp(addr);
+        }
+        break;
+    case 0x36:/* fstmm */
+        rx = (insn >> 16) & 0x1f;
+        vrz = insn & 0xf;
+        imm = (insn >> 21) & 0xf;
+        for (i = 0; i <= imm; i++) {
+            addr = load_reg(s, rx);
+            gen_mov_F0_vreg(1, vrz);
+            gen_vfp_st(s, 1, addr);
+            tcg_gen_addi_i32(addr, addr, 8);
+            vrz++;
+            dead_tmp(addr);
+         }
+         break;
+    default:
+wrong:
+        generate_exception(s, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR, "unknown vdsp insn pc=%x opc=%x\n",
+                      s->pc, insn);
+        break;
+    }
+
+}
+
+static void disas_vdsp_insn128(CPUState *cs, DisasContext *s, uint32_t insn)
+{
+    int op1, op2, op3, wid, shft, immd_i, rx, ry, vrz_i;
+    op1 = (insn >> CSKY_VDSP_SOP_SHI_M) & CSKY_VDSP_SOP_MASK_M;
+    op2 = (insn >> CSKY_VDSP_SOP_SHI_S) & CSKY_VDSP_SOP_MASK_S;
+    op3 = (insn >> CSKY_VDSP_SOP_SHI_E) & CSKY_VDSP_SOP_MASK_E;
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+
+    TCGv vrz = tcg_const_tl(insn & CSKY_VDSP_REG_MASK);
+    TCGv vdsp_insn = tcg_const_tl(insn);
+
+    switch (op1) {
+    case VDSP_VADD: /*VADD*/
+        switch  (op2) {
+        case 0x0:  /*VADD.T*/
+            gen_helper_vdsp_vadd128(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VADD.ET*/
+            gen_helper_vdsp_vadde128(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VCADD.T*/
+            gen_helper_vdsp_vcadd128(cpu_env, vdsp_insn);
+            break;
+        case 0x3:       /*VCADD.ET*/
+            gen_helper_vdsp_vcadde128(cpu_env, vdsp_insn);
+            break;
+        case 0xa:      /*VADD.XT.SL*/
+            gen_helper_vdsp_vaddxsl128(cpu_env, vdsp_insn);
+            break;
+        case 0xb:      /*VADD.XT*/
+            gen_helper_vdsp_vaddx128(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VADDH.T */
+            gen_helper_vdsp_vaddh128(cpu_env, vdsp_insn);
+            break;
+        case 0xd:      /*VADDH.T.R*/
+            gen_helper_vdsp_vaddhr128(cpu_env, vdsp_insn);
+            break;
+        case 0xe:      /*VADD.T.S*/
+            gen_helper_vdsp_vadds128(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VSUB: /*VSUB*/
+        switch (op2) {
+        case 0x0:       /*VSUB.T*/
+            gen_helper_vdsp_vsub128(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VSUB.ET*/
+            gen_helper_vdsp_vsube128(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VSABS.T*/
+            gen_helper_vdsp_vsabs128(cpu_env, vdsp_insn);
+            break;
+        case 0x3:       /*VSABS.ET*/
+            gen_helper_vdsp_vsabse128(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VSABSA.T*/
+            gen_helper_vdsp_vsabsa128(cpu_env, vdsp_insn);
+            break;
+        case 0x5:       /*VSABSA.ET */
+            gen_helper_vdsp_vsabsae128(cpu_env, vdsp_insn);
+            break;
+        case 0xb:      /*VSUB.XT */
+            gen_helper_vdsp_vsubx128(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VSUBH.T*/
+            gen_helper_vdsp_vsubh128(cpu_env, vdsp_insn);
+            break;
+        case 0xd:      /*VSUBH.T.R*/
+            gen_helper_vdsp_vsubhr128(cpu_env, vdsp_insn);
+            break;
+        case 0xe:      /*VSUB.T.S*/
+            gen_helper_vdsp_vsubs128(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VMUL: /*VMUL*/
+        switch (op2) {
+        case 0x0:       /*VMUL.T*/
+            gen_helper_vdsp_vmul128(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VMUL.ET*/
+            gen_helper_vdsp_vmule128(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VMULA.T*/
+            gen_helper_vdsp_vmula128(cpu_env, vdsp_insn);
+            break;
+        case 0x3:       /*VMULA.ET*/
+            gen_helper_vdsp_vmulae128(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VMULS.T*/
+            gen_helper_vdsp_vmuls128(cpu_env, vdsp_insn);
+            break;
+        case 0x5:       /*VMULS.ET*/
+            gen_helper_vdsp_vmulse128(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+       break;
+    case VDSP_VSH:  /*VSH*/
+        switch (op2) {
+        case 0x0:       /*VSHRI.T*/
+        case 0x1:
+            gen_helper_vdsp_vshri128(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VSHRI.T.R*/
+        case 0x3:
+            gen_helper_vdsp_vshrir128(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VSHR.T*/
+            gen_helper_vdsp_vshr128(cpu_env, vdsp_insn);
+            break;
+        case 0x6:       /*VSHR.T.R*/
+            gen_helper_vdsp_vshrr128(cpu_env, vdsp_insn);
+            break;
+        case 0x8:       /*VSHLI.T*/
+        case 0x9:
+            gen_helper_vdsp_vshli128(cpu_env, vdsp_insn);
+            break;
+        case 0xa:      /*VSHLI.T.S*/
+        case 0xb:
+            gen_helper_vdsp_vshlis128(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VSHL.T*/
+            gen_helper_vdsp_vshl128(cpu_env, vdsp_insn);
+            break;
+        case 0xe:      /*VSHL.T.S*/
+            gen_helper_vdsp_vshls128(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VCMP: /*VCMP*/
+        switch (op2) {
+        case 0x0:       /*VCMPHS.T*/
+            gen_helper_vdsp_vcmphs128(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VCMPLT.T*/
+            gen_helper_vdsp_vcmplt128(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VCMPNE.T*/
+            gen_helper_vdsp_vcmpne128(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VCMPHSZ.T*/
+            gen_helper_vdsp_vcmphsz128(cpu_env, vdsp_insn);
+            break;
+        case 0x5:       /*VCMPLTZ.T*/
+            gen_helper_vdsp_vcmpltz128(cpu_env, vdsp_insn);
+            break;
+        case 0x6:       /*VCMPNEZ.T */
+            gen_helper_vdsp_vcmpnez128(cpu_env, vdsp_insn);
+            break;
+        case 0x8:       /*VMAX.T*/
+            gen_helper_vdsp_vmax128(cpu_env, vdsp_insn);
+            break;
+        case 0x9:       /*VMIN.T*/
+            gen_helper_vdsp_vmin128(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VCMAX.T*/
+            gen_helper_vdsp_vcmax128(cpu_env, vdsp_insn);
+            break;
+        case 0xd:      /*VCMIN.T*/
+            gen_helper_vdsp_vcmin128(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VAND: /*VAND*/
+        switch (op2) {
+        case 0x0:       /*VAND.T*/
+            gen_helper_vdsp_vand128(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VANDN.T*/
+            gen_helper_vdsp_vandn128(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VOR.T*/
+            gen_helper_vdsp_vor128(cpu_env, vdsp_insn);
+            break;
+        case 0x3:       /*VNOR.T*/
+            gen_helper_vdsp_vnor128(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VXOR.T*/
+            gen_helper_vdsp_vxor128(cpu_env, vdsp_insn);
+            break;
+        case 0x9:       /*VTST.T */
+            gen_helper_vdsp_vtst128(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VMOV: /*VMOV*/
+        switch (op2) {
+        case 0x0:       /*VMOV*/
+            gen_helper_vdsp_vmov128(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VMOV.ET*/
+            gen_helper_vdsp_vmove128(cpu_env, vdsp_insn);
+            break;
+        case 0x8:       /*VMOV.T.L*/
+            gen_helper_vdsp_vmovl128(cpu_env, vdsp_insn);
+            break;
+        case 0xa:      /*VMOV.T.SL*/
+            gen_helper_vdsp_vmovsl128(cpu_env, vdsp_insn);
+            break;
+        case 0xb:      /*VMOV.T.H*/
+            gen_helper_vdsp_vmovh128(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VMOV.T.RH*/
+            gen_helper_vdsp_vmovrh128(cpu_env, vdsp_insn);
+            break;
+        case 0xe:      /*VSTOU.T.SL*/
+            gen_helper_vdsp_vstousl128(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VSPE: /*VSPE*/
+        switch (op2) {
+        case 0x3:       /*VREV.T */
+            gen_helper_vdsp_vrev128(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VDUP.T*/
+            gen_helper_vdsp_vdup128(cpu_env, vdsp_insn);
+            break;
+        case 0x5:       /*VCNT1.T*/
+            gen_helper_vdsp_vcnt1128(cpu_env, vdsp_insn);
+            break;
+        case 0x6:       /*VCLZ.T*/
+            gen_helper_vdsp_vclz128(cpu_env, vdsp_insn);
+            break;
+        case 0x7:       /*VCLS.T*/
+            gen_helper_vdsp_vcls128(cpu_env, vdsp_insn);
+            break;
+        case 0x8:       /*VBPERMZ.T*/
+            gen_helper_vdsp_vbpermz128(cpu_env, vdsp_insn);
+            break;
+        case 0x9:       /*VBPERM.T*/
+            gen_helper_vdsp_vbperm128(cpu_env, vdsp_insn);
+            break;
+        case 0xa:      /*VTRCH.T*/
+            gen_helper_vdsp_vtrch128(cpu_env, vdsp_insn);
+            break;
+        case 0xb:      /*VTRCL.T*/
+            gen_helper_vdsp_vtrcl128(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VICH.T*/
+            gen_helper_vdsp_vich128(cpu_env, vdsp_insn);
+            break;
+        case 0xd:      /*VICL.T*/
+            gen_helper_vdsp_vicl128(cpu_env, vdsp_insn);
+            break;
+        case 0xe:      /*VDCH.T*/
+            gen_helper_vdsp_vdch128(cpu_env, vdsp_insn);
+            break;
+        case 0xf:      /*VDCL.T*/
+            gen_helper_vdsp_vdcl128(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VABS: /*VABS*/
+        switch (op2) {
+        case 0x0:       /*VABS.T*/
+            gen_helper_vdsp_vabs128(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VABS.T.S*/
+            gen_helper_vdsp_vabss128(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VNEG.T*/
+            gen_helper_vdsp_vneg128(cpu_env, vdsp_insn);
+            break;
+        case 0x6:       /*VNEG.T.S*/
+            gen_helper_vdsp_vnegs128(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VMVVR:        /*VM*VR*/
+        switch (op2) {
+        case 0x0:       /*VMFVR.U8*/
+            gen_helper_vdsp_vmfvru8(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VMFVR.U16*/
+            gen_helper_vdsp_vmfvru16(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VMFVR.U32*/
+            gen_helper_vdsp_vmfvru32(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VMFVR.S8*/
+            gen_helper_vdsp_vmfvrs8(cpu_env, vdsp_insn);
+            break;
+        case 0x5:       /*VMFVR.S16*/
+            gen_helper_vdsp_vmfvrs16(cpu_env, vdsp_insn);
+            break;
+        case 0x8:       /*VMTVR.U8*/
+            gen_helper_vdsp_vmtvru8(cpu_env, vdsp_insn);
+            break;
+        case 0x9:       /*VMTVR.U16*/
+            gen_helper_vdsp_vmtvru16(cpu_env, vdsp_insn);
+            break;
+        case 0xa:      /*VMTVR.U32*/
+            gen_helper_vdsp_vmtvru32(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VINS: /*VINS*/
+        switch ((int)(8 * pow(2, wid))) {
+        case 8:
+            gen_helper_vdsp_vins8(cpu_env, vdsp_insn);
+            break;
+        case 16:
+            gen_helper_vdsp_vins16(cpu_env, vdsp_insn);
+            break;
+        case 32:
+            gen_helper_vdsp_vins32(cpu_env, vdsp_insn);
+            break;
+        }
+        break;
+    default:
+        rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+        ry = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK);
+        vrz_i = (insn & CSKY_VDSP_REG_MASK);
+        shft = (insn >> CSKY_VDSP_SOP_SHI_S) & 0x3;
+        immd_i = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK) << 4 |
+            ((insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_REG_MASK);
+        TCGv_i64 tmp1 = tcg_temp_new_i64();
+        TCGv_i64 tmp2 = tcg_temp_new_i64();
+        TCGv tmp3 = tcg_temp_new_i32();
+        switch (op3) {
+        case 0x8:       /*VLDD*/
+            tcg_gen_addi_tl(tmp3, cpu_R[rx], immd_i << 3);
+            tcg_gen_qemu_ld64(tmp1, tmp3, s->mem_idx);
+            gen_helper_vdsp_store(vrz, tmp1, cpu_env);
+            break;
+        case 0x9:       /*VLDQ*/
+            tcg_gen_addi_tl(tmp3, cpu_R[rx], immd_i << 3);
+            tcg_gen_qemu_ld64(tmp1, tmp3, s->mem_idx);
+            tcg_gen_addi_tl(tmp3, tmp3, 8);
+            tcg_gen_qemu_ld64(tmp2, tmp3, s->mem_idx);
+            gen_helper_vdsp_store2(vrz, tmp1, tmp2, cpu_env);
+            break;
+        case 0xa:      /*VSTD*/
+            tcg_gen_mov_i64(tmp1, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rl[vrz_i])));
+            tcg_gen_addi_tl(tmp3, cpu_R[rx], immd_i << 3);
+            tcg_gen_qemu_st64(tmp1, tmp3, s->mem_idx);
+            break;
+        case 0xb:      /*VSTQ*/
+            tcg_gen_mov_i64(tmp1, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rl[vrz_i])));
+            tcg_gen_mov_i64(tmp2, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rh[vrz_i])));
+            tcg_gen_addi_tl(tmp3, cpu_R[rx], immd_i << 3);
+            tcg_gen_qemu_st64(tmp1, tmp3, s->mem_idx);
+            tcg_gen_addi_tl(tmp3, tmp3, 8);
+            tcg_gen_qemu_st64(tmp2, tmp3, s->mem_idx);
+            break;
+        case 0xc:      /*VLDRD*/
+            tcg_gen_mov_tl(tmp3, cpu_R[ry]);
+            tcg_gen_shli_tl(tmp3, tmp3, shft);
+            tcg_gen_add_tl(tmp3, cpu_R[rx], tmp3);
+            tcg_gen_qemu_ld64(tmp1, tmp3, s->mem_idx);
+            gen_helper_vdsp_store(vrz, tmp1, cpu_env);
+            break;
+        case 0xd:      /*VLDRQ*/
+            tcg_gen_mov_tl(tmp3, cpu_R[ry]);
+            tcg_gen_shli_tl(tmp3, tmp3, shft);
+            tcg_gen_add_tl(tmp3, cpu_R[rx], tmp3);
+            tcg_gen_qemu_ld64(tmp1, tmp3, s->mem_idx);
+            tcg_gen_addi_tl(tmp3, tmp3, 8);
+            tcg_gen_qemu_ld64(tmp2, tmp3, s->mem_idx);
+            gen_helper_vdsp_store2(vrz, tmp1, tmp2, cpu_env);
+            break;
+        case 0xe:      /*VSTRD*/
+            tcg_gen_mov_i64(tmp1, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rl[vrz_i])));
+            tcg_gen_mov_tl(tmp3, cpu_R[ry]);
+            tcg_gen_shli_tl(tmp3, tmp3, shft);
+            tcg_gen_add_tl(tmp3, cpu_R[rx], tmp3);
+            tcg_gen_qemu_st64(tmp1, tmp3, s->mem_idx);
+            break;
+        case 0xf:      /*VSTRQ*/
+            tcg_gen_mov_i64(tmp1, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rl[vrz_i])));
+            tcg_gen_mov_i64(tmp2, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rh[vrz_i])));
+            tcg_gen_mov_tl(tmp3, cpu_R[ry]);
+            tcg_gen_shli_tl(tmp3, tmp3, shft);
+            tcg_gen_add_tl(tmp3, cpu_R[rx], tmp3);
+            tcg_gen_qemu_st64(tmp1, tmp3, s->mem_idx);
+            tcg_gen_addi_tl(tmp3, tmp3, 8);
+            tcg_gen_qemu_st64(tmp2, tmp3, s->mem_idx);
+            break;
+        default:
+wrong:
+            generate_exception(s, EXCP_CSKY_UDEF);
+            qemu_log_mask(LOG_GUEST_ERROR, "unknown vdsp insn pc=%x opc=%x\n",
+                      s->pc, insn);
+            break;
+        }
+    }
+}
+
+static void disas_vdsp_insn64(CPUState *cs, DisasContext *s, uint32_t insn)
+{
+    int op1, op2, op3, wid, shft, immd_i, rx, ry, vrz_i;
+    op1 = (insn >> CSKY_VDSP_SOP_SHI_M) & CSKY_VDSP_SOP_MASK_M;
+    op2 = (insn >> CSKY_VDSP_SOP_SHI_S) & CSKY_VDSP_SOP_MASK_S;
+    op3 = (insn >> CSKY_VDSP_SOP_SHI_E) & CSKY_VDSP_SOP_MASK_E;
+    wid = ((insn >> CSKY_VDSP_WIDTH_BIT_HI & 0x2) |
+           (insn >> CSKY_VDSP_WIDTH_BIT_LO & 0x1));
+
+    TCGv vrz = tcg_const_tl(insn & CSKY_VDSP_REG_MASK);
+    TCGv vdsp_insn = tcg_const_tl(insn);
+
+    switch (op1) {
+    case VDSP_VADD: /*VADD*/
+        switch (op2) {
+        case 0x0:  /*VADD.T*/
+            gen_helper_vdsp_vadd64(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VADD.ET*/
+            gen_helper_vdsp_vadde64(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VCADD.T*/
+            gen_helper_vdsp_vcadd64(cpu_env, vdsp_insn);
+            break;
+        case 0x3:       /*VCADD.ET*/
+            gen_helper_vdsp_vcadde64(cpu_env, vdsp_insn);
+            break;
+        case 0xa:      /*VADD.XT.SL*/
+            gen_helper_vdsp_vaddxsl64(cpu_env, vdsp_insn);
+            break;
+        case 0xb:      /*VADD.XT*/
+            gen_helper_vdsp_vaddx64(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VADDH.T */
+            gen_helper_vdsp_vaddh64(cpu_env, vdsp_insn);
+            break;
+        case 0xd:      /*VADDH.T.R*/
+            gen_helper_vdsp_vaddhr64(cpu_env, vdsp_insn);
+            break;
+        case 0xe:      /*VADD.T.S*/
+            gen_helper_vdsp_vadds64(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VSUB: /*VSUB*/
+        switch (op2) {
+        case 0x0:       /*VSUB.T*/
+            gen_helper_vdsp_vsub64(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VSUB.ET*/
+            gen_helper_vdsp_vsube64(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VSABS.T*/
+            gen_helper_vdsp_vsabs64(cpu_env, vdsp_insn);
+            break;
+        case 0x3:       /*VSABS.ET*/
+            gen_helper_vdsp_vsabse64(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VSABSA.T*/
+            gen_helper_vdsp_vsabsa64(cpu_env, vdsp_insn);
+            break;
+        case 0x5:       /*VSABSA.ET */
+            gen_helper_vdsp_vsabsae64(cpu_env, vdsp_insn);
+            break;
+        case 0xb:      /*VSUB.XT */
+            gen_helper_vdsp_vsubx64(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VSUBH.T*/
+            gen_helper_vdsp_vsubh64(cpu_env, vdsp_insn);
+            break;
+        case 0xd:      /*VSUBH.T.R*/
+            gen_helper_vdsp_vsubhr64(cpu_env, vdsp_insn);
+            break;
+        case 0xe:      /*VSUB.T.S*/
+            gen_helper_vdsp_vsubs64(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VMUL: /*VMUL*/
+        switch (op2) {
+        case 0x0:       /*VMUL.T*/
+            gen_helper_vdsp_vmul64(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VMUL.ET*/
+            gen_helper_vdsp_vmule64(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VMULA.T*/
+            gen_helper_vdsp_vmula64(cpu_env, vdsp_insn);
+            break;
+        case 0x3:       /*VMULA.ET*/
+            gen_helper_vdsp_vmulae64(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VMULS.T*/
+            gen_helper_vdsp_vmuls64(cpu_env, vdsp_insn);
+            break;
+        case 0x5:       /*VMULS.ET*/
+            gen_helper_vdsp_vmulse64(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VSH:  /*VSH*/
+        switch (op2) {
+        case 0x0:       /*VSHRI.T*/
+        case 0x1:
+            gen_helper_vdsp_vshri64(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VSHRI.T.R*/
+        case 0x3:
+            gen_helper_vdsp_vshrir64(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VSHR.T*/
+            gen_helper_vdsp_vshr64(cpu_env, vdsp_insn);
+            break;
+        case 0x6:       /*VSHR.T.R*/
+            gen_helper_vdsp_vshrr64(cpu_env, vdsp_insn);
+            break;
+        case 0x8:       /*VSHLI.T*/
+        case 0x9:
+            gen_helper_vdsp_vshli64(cpu_env, vdsp_insn);
+            break;
+        case 0xa:      /*VSHLI.T.S*/
+        case 0xb:
+            gen_helper_vdsp_vshlis64(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VSHL.T*/
+            gen_helper_vdsp_vshl64(cpu_env, vdsp_insn);
+            break;
+        case 0xe:      /*VSHL.T.S*/
+            gen_helper_vdsp_vshls64(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VCMP: /*VCMP*/
+        switch (op2) {
+        case 0x0:       /*VCMPHS.T*/
+            gen_helper_vdsp_vcmphs64(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VCMPLT.T*/
+            gen_helper_vdsp_vcmplt64(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VCMPNE.T*/
+            gen_helper_vdsp_vcmpne64(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VCMPHSZ.T*/
+            gen_helper_vdsp_vcmphsz64(cpu_env, vdsp_insn);
+            break;
+        case 0x5:       /*VCMPLTZ.T*/
+            gen_helper_vdsp_vcmpltz64(cpu_env, vdsp_insn);
+            break;
+        case 0x6:       /*VCMPNEZ.T */
+            gen_helper_vdsp_vcmpnez64(cpu_env, vdsp_insn);
+            break;
+        case 0x8:       /*VMAX.T*/
+            gen_helper_vdsp_vmax64(cpu_env, vdsp_insn);
+            break;
+        case 0x9:       /*VMIN.T*/
+            gen_helper_vdsp_vmin64(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VCMAX.T*/
+            gen_helper_vdsp_vcmax64(cpu_env, vdsp_insn);
+            break;
+        case 0xd:      /*VCMIN.T*/
+            gen_helper_vdsp_vcmin64(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VAND: /*VAND*/
+        switch (op2) {
+        case 0x0:       /*VAND.T*/
+            gen_helper_vdsp_vand64(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VANDN.T*/
+            gen_helper_vdsp_vandn64(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VOR.T*/
+            gen_helper_vdsp_vor64(cpu_env, vdsp_insn);
+            break;
+        case 0x3:       /*VNOR.T*/
+            gen_helper_vdsp_vnor64(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VXOR.T*/
+            gen_helper_vdsp_vxor64(cpu_env, vdsp_insn);
+            break;
+        case 0x9:       /*VTST.T */
+            gen_helper_vdsp_vtst64(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VMOV: /*VMOV*/
+        switch (op2) {
+        case 0x0:       /*VMOV*/
+            gen_helper_vdsp_vmov64(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VMOV.ET*/
+            gen_helper_vdsp_vmove64(cpu_env, vdsp_insn);
+            break;
+        case 0x8:       /*VMOV.T.L*/
+            gen_helper_vdsp_vmovl64(cpu_env, vdsp_insn);
+            break;
+        case 0xa:      /*VMOV.T.SL*/
+            gen_helper_vdsp_vmovsl64(cpu_env, vdsp_insn);
+            break;
+        case 0xb:      /*VMOV.T.H*/
+            gen_helper_vdsp_vmovh64(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VMOV.T.RH*/
+            gen_helper_vdsp_vmovrh64(cpu_env, vdsp_insn);
+            break;
+        case 0xe:      /*VSTOU.T.SL*/
+            gen_helper_vdsp_vstousl64(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VSPE: /*VSPE*/
+        switch (op2) {
+        case 0x3:       /*VREV.T */
+            gen_helper_vdsp_vrev64(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VDUP.T*/
+            gen_helper_vdsp_vdup64(cpu_env, vdsp_insn);
+            break;
+        case 0x5:       /*VCNT1.T*/
+            gen_helper_vdsp_vcnt164(cpu_env, vdsp_insn);
+            break;
+        case 0x6:       /*VCLZ.T*/
+            gen_helper_vdsp_vclz64(cpu_env, vdsp_insn);
+            break;
+        case 0x7:       /*VCLS.T*/
+            gen_helper_vdsp_vcls64(cpu_env, vdsp_insn);
+            break;
+        case 0x8:       /*VBPERMZ.T*/
+            gen_helper_vdsp_vbpermz64(cpu_env, vdsp_insn);
+            break;
+        case 0x9:       /*VBPERM.T*/
+            gen_helper_vdsp_vbperm64(cpu_env, vdsp_insn);
+            break;
+        case 0xa:      /*VTRCH.T*/
+            gen_helper_vdsp_vtrch64(cpu_env, vdsp_insn);
+            break;
+        case 0xb:      /*VTRCL.T*/
+            gen_helper_vdsp_vtrcl64(cpu_env, vdsp_insn);
+            break;
+        case 0xc:      /*VICH.T*/
+            gen_helper_vdsp_vich64(cpu_env, vdsp_insn);
+            break;
+        case 0xd:      /*VICL.T*/
+            gen_helper_vdsp_vicl64(cpu_env, vdsp_insn);
+            break;
+        case 0xe:      /*VDCH.T*/
+            gen_helper_vdsp_vdch64(cpu_env, vdsp_insn);
+            break;
+        case 0xf:      /*VDCL.T*/
+            gen_helper_vdsp_vdcl64(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VABS: /*VABS*/
+        switch (op2) {
+        case 0x0:       /*VABS.T*/
+            gen_helper_vdsp_vabs64(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VABS.T.S*/
+            gen_helper_vdsp_vabss64(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VNEG.T*/
+            gen_helper_vdsp_vneg64(cpu_env, vdsp_insn);
+            break;
+        case 0x6:       /*VNEG.T.S*/
+            gen_helper_vdsp_vnegs64(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VMVVR:        /*VM*VR*/
+        switch (op2) {
+        case 0x0:       /*VMFVR.U8*/
+            gen_helper_vdsp_vmfvru8(cpu_env, vdsp_insn);
+            break;
+        case 0x1:       /*VMFVR.U16*/
+            gen_helper_vdsp_vmfvru16(cpu_env, vdsp_insn);
+            break;
+        case 0x2:       /*VMFVR.U32*/
+            gen_helper_vdsp_vmfvru32(cpu_env, vdsp_insn);
+            break;
+        case 0x4:       /*VMFVR.S8*/
+            gen_helper_vdsp_vmfvrs8(cpu_env, vdsp_insn);
+            break;
+        case 0x5:       /*VMFVR.S16*/
+            gen_helper_vdsp_vmfvrs16(cpu_env, vdsp_insn);
+            break;
+        case 0x8:       /*VMTVR.U8*/
+            gen_helper_vdsp_vmtvru8(cpu_env, vdsp_insn);
+            break;
+        case 0x9:       /*VMTVR.U16*/
+            gen_helper_vdsp_vmtvru16(cpu_env, vdsp_insn);
+            break;
+        case 0xa:      /*VMTVR.U32*/
+            gen_helper_vdsp_vmtvru32(cpu_env, vdsp_insn);
+            break;
+        default:
+            goto wrong;
+            break;
+        }
+        break;
+    case VDSP_VINS: /*VINS*/
+        switch ((int)(8 * pow(2, wid))) {
+        case 8:
+            gen_helper_vdsp_vins8(cpu_env, vdsp_insn);
+            break;
+        case 16:
+            gen_helper_vdsp_vins16(cpu_env, vdsp_insn);
+            break;
+        case 32:
+            gen_helper_vdsp_vins32(cpu_env, vdsp_insn);
+            break;
+        }
+        break;
+    default:
+        rx = (insn >> CSKY_VDSP_REG_SHI_VRX) & CSKY_VDSP_REG_MASK;
+        ry = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK);
+        vrz_i = (insn & CSKY_VDSP_REG_MASK);
+        shft = (insn >> CSKY_VDSP_SOP_SHI_S) & 0x3;
+        immd_i = ((insn >> CSKY_VDSP_REG_SHI_VRY) & CSKY_VDSP_REG_MASK) << 4 |
+            ((insn >> CSKY_VDSP_SIGN_SHI) & CSKY_VDSP_REG_MASK);
+        TCGv_i64 tmp1 = tcg_temp_new_i64();
+        TCGv_i64 tmp2 = tcg_temp_new_i64();
+        TCGv tmp3 = tcg_temp_new_i32();
+        switch (op3) {
+        case 0x8:       /*VLDD*/
+            tcg_gen_addi_tl(tmp3, cpu_R[rx], immd_i << 3);
+            tcg_gen_qemu_ld64(tmp1, tmp3, s->mem_idx);
+            gen_helper_vdsp_store(vrz, tmp1, cpu_env);
+            break;
+        case 0x9:       /*VLDQ*/
+            tcg_gen_addi_tl(tmp3, cpu_R[rx], immd_i << 3);
+            tcg_gen_qemu_ld64(tmp1, tmp3, s->mem_idx);
+            tcg_gen_addi_tl(tmp3, tmp3, 8);
+            tcg_gen_qemu_ld64(tmp2, tmp3, s->mem_idx);
+            gen_helper_vdsp_store2(vrz, tmp1, tmp2, cpu_env);
+            break;
+        case 0xa:      /*VSTD*/
+            tcg_gen_mov_i64(tmp1, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rl[vrz_i])));
+            tcg_gen_addi_tl(tmp3, cpu_R[rx], immd_i << 3);
+            tcg_gen_qemu_st64(tmp1, tmp3, s->mem_idx);
+            break;
+        case 0xb:      /*VSTQ*/
+            tcg_gen_mov_i64(tmp1, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rh[vrz_i])));
+            tcg_gen_mov_i64(tmp2, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rl[vrz_i])));
+            tcg_gen_addi_tl(tmp3, cpu_R[rx], immd_i << 3);
+            tcg_gen_qemu_st64(tmp1, tmp3, s->mem_idx);
+            tcg_gen_addi_tl(tmp3, tmp3, 8);
+            tcg_gen_qemu_st64(tmp2, tmp3, s->mem_idx);
+        case 0xc:         /*VLDRD*/
+            /* break; */
+            tcg_gen_mov_tl(tmp3, cpu_R[ry]);
+            tcg_gen_shli_tl(tmp3, tmp3, shft);
+            tcg_gen_add_tl(tmp3, cpu_R[rx], tmp3);
+            tcg_gen_qemu_ld64(tmp1, tmp3, s->mem_idx);
+            gen_helper_vdsp_store(vrz, tmp1, cpu_env);
+            break;
+        case 0xd:         /*VLDRQ*/
+            tcg_gen_mov_tl(tmp3, cpu_R[ry]);
+            tcg_gen_shli_tl(tmp3, tmp3, shft);
+            tcg_gen_add_tl(tmp3, cpu_R[rx], tmp3);
+            tcg_gen_qemu_ld64(tmp1, tmp3, s->mem_idx);
+            tcg_gen_addi_tl(tmp3, tmp3, 8);
+            tcg_gen_qemu_ld64(tmp2, tmp3, s->mem_idx);
+            gen_helper_vdsp_store2(vrz, tmp1, tmp2, cpu_env);
+            break;
+        case 0xe:         /*VSTRD*/
+            tcg_gen_mov_i64(tmp1, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rl[vrz_i])));
+            tcg_gen_mov_tl(tmp3, cpu_R[ry]);
+            tcg_gen_shli_tl(tmp3, tmp3, shft);
+            tcg_gen_add_tl(tmp3, cpu_R[rx], tmp3);
+            tcg_gen_qemu_st64(tmp1, tmp3, s->mem_idx);
+            break;
+        case 0xf:         /*VSTRQ*/
+            tcg_gen_mov_i64(tmp1, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rl[vrz_i])));
+            tcg_gen_mov_i64(tmp2, MAKE_TCGV_I64(GET_TCGV_I32(vdsp_Rh[vrz_i])));
+            tcg_gen_mov_tl(tmp3, cpu_R[ry]);
+            tcg_gen_shli_tl(tmp3, tmp3, shft);
+            tcg_gen_add_tl(tmp3, cpu_R[rx], tmp3);
+            tcg_gen_qemu_st64(tmp1, tmp3, s->mem_idx);
+            tcg_gen_addi_tl(tmp3, tmp3, 8);
+            tcg_gen_qemu_st64(tmp2, tmp3, s->mem_idx);
+        break;
+        default:
+wrong:
+            generate_exception(s, EXCP_CSKY_UDEF);
+            qemu_log_mask(LOG_GUEST_ERROR, "unknown vdsp insn pc=%x opc=%x\n",
+                      s->pc, insn);
+            break;
+        }
+    }
+}
+
+static inline void dspv2_insn_padd_8(int rz, int rx, int ry)
+{
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    /* rz[7:0] = rx[7:0] + ry[7:0]*/
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xff);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xff);
+    tcg_gen_add_i32(t2, t0, t1);
+    tcg_gen_andi_i32(t2, t2, 0xff);
+    /* rz[15:8] = rx[15:8] + ry[15:8]*/
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xff00);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xff00);
+    tcg_gen_add_i32(t0, t0, t1);
+    tcg_gen_andi_i32(t0, t0, 0xff00);
+    tcg_gen_or_i32(t2, t2, t0);
+    /* rz[23:16] = rx[23:16] + ry[23:16]*/
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xff0000);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xff0000);
+    tcg_gen_add_i32(t0, t0, t1);
+    tcg_gen_andi_i32(t0, t0, 0xff0000);
+    tcg_gen_or_i32(t2, t2, t0);
+    /* rz[31:24] = rx[31:24] + ry[31:24]*/
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xff000000);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xff000000);
+    tcg_gen_add_i32(t0, t0, t1);
+    tcg_gen_andi_i32(t0, t0, 0xff000000);
+    tcg_gen_or_i32(cpu_R[rz], t2, t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_padd_16(int rz, int rx, int ry)
+{
+    /* rz = {(hi_x + hi_y)[15:0], (lo_x + lo_y)[15:0]} */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    /* lo_x + lo_y */
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xffff);
+    tcg_gen_add_i32(t2, t0, t1);
+    tcg_gen_andi_i32(t2, t2, 0xffff);
+    /* hi_x + hi_y */
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff0000);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xffff0000);
+    tcg_gen_add_i32(t0, t0, t1);
+    tcg_gen_or_i32(cpu_R[rz], t2, t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_psub_8(int rz, int rx, int ry)
+{
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    /* rz[7:0] = rx[7:0] - ry[7:0]*/
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xff);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xff);
+    tcg_gen_sub_i32(t2, t0, t1);
+    tcg_gen_andi_i32(t2, t2, 0xff);
+    /* rz[15:8] = rx[15:8] - ry[15:8]*/
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xff00);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xff00);
+    tcg_gen_sub_i32(t0, t0, t1);
+    tcg_gen_andi_i32(t0, t0, 0xff00);
+    tcg_gen_or_i32(t2, t2, t0);
+    /* rz[23:16] = rx[23:16] - ry[23:16]*/
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xff0000);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xff0000);
+    tcg_gen_sub_i32(t0, t0, t1);
+    tcg_gen_andi_i32(t0, t0, 0xff0000);
+    tcg_gen_or_i32(t2, t2, t0);
+    /* rz[31:24] = rx[31:24] - ry[31:24]*/
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xff000000);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xff000000);
+    tcg_gen_sub_i32(t0, t0, t1);
+    tcg_gen_andi_i32(t0, t0, 0xff000000);
+    tcg_gen_or_i32(cpu_R[rz], t2, t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_psub_16(int rz, int rx, int ry)
+{
+    /* rz = {(hi_x - hi_y)[15:0], (lo_x - lo_y)[15:0]} */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xffff);
+    tcg_gen_sub_i32(t2, t0, t1);
+    tcg_gen_andi_i32(t2, t2, 0xffff);
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff0000);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xffff0000);
+    tcg_gen_sub_i32(t0, t0, t1);
+    tcg_gen_or_i32(cpu_R[rz], t2, t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_addh_s32(int rz, int rx, int ry)
+{
+    /* rz = (rx[31:0] + ry[31:0]) / 2, signed */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_add_i64(t0, t0, t1);
+    tcg_gen_shri_i64(t0, t0, 1);
+    tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_addh_u32(int rz, int rx, int ry)
+{
+    /* rz = (rx[31:0] + ry[31:0]) / 2, unsigned */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_extu_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_extu_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_add_i64(t0, t0, t1);
+    tcg_gen_shri_i64(t0, t0, 1);
+    tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_subh_s32(int rz, int rx, int ry)
+{
+    /* rz = (rx[31:0] - ry[31:0]) / 2, signed */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_sub_i64(t0, t0, t1);
+    tcg_gen_shri_i64(t0, t0, 1);
+    tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_subh_u32(int rz, int rx, int ry)
+{
+    /* rz = (rx[31:0] - ry[31:0]) / 2, unsigned */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_extu_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_extu_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_sub_i64(t0, t0, t1);
+    tcg_gen_shri_i64(t0, t0, 1);
+    tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_add_64(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t0, cpu_R[rx], cpu_R[(rx + 1) % 32]);
+    tcg_gen_concat_i32_i64(t1, cpu_R[ry], cpu_R[(ry + 1) % 32]);
+    tcg_gen_add_i64(t0, t0, t1);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_sub_64(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t0, cpu_R[rx], cpu_R[(rx + 1) % 32]);
+    tcg_gen_concat_i32_i64(t1, cpu_R[ry], cpu_R[(ry + 1) % 32]);
+    tcg_gen_sub_i64(t0, t0, t1);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_add_s64_s(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t0, cpu_R[rx], cpu_R[(rx + 1) % 32]);
+    tcg_gen_concat_i32_i64(t1, cpu_R[ry], cpu_R[(ry + 1) % 32]);
+    gen_helper_dspv2_add_s64_s(t0, t0, t1);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_add_u64_s(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t0, cpu_R[rx], cpu_R[(rx + 1) % 32]);
+    tcg_gen_concat_i32_i64(t1, cpu_R[ry], cpu_R[(ry + 1) % 32]);
+    gen_helper_dspv2_add_u64_s(t0, t0, t1);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_sub_s64_s(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t0, cpu_R[rx], cpu_R[(rx + 1) % 32]);
+    tcg_gen_concat_i32_i64(t1, cpu_R[ry], cpu_R[(ry + 1) % 32]);
+    gen_helper_dspv2_sub_s64_s(t0, t0, t1);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_sub_u64_s(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t0, cpu_R[rx], cpu_R[(rx + 1) % 32]);
+    tcg_gen_concat_i32_i64(t1, cpu_R[ry], cpu_R[(ry + 1) % 32]);
+    gen_helper_dspv2_sub_u64_s(t0, t0, t1);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_sop_add_sub(CPUState *cs,
+                                     DisasContext *s, uint32_t insn)
+{
+    int thop, rz, rx, ry;
+    thop = (insn >> CSKY_DSPV2_THOP_SHI) & CSKY_DSPV2_THOP_MASK;
+    rz = (insn >> CSKY_DSPV2_REG_SHI_RZ) & CSKY_DSPV2_REG_MASK;
+    rx = (insn >> CSKY_DSPV2_REG_SHI_RX) & CSKY_DSPV2_REG_MASK;
+    ry = (insn >> CSKY_DSPV2_REG_SHI_RY) & CSKY_DSPV2_REG_MASK;
+
+    switch (thop) {
+    case OP_PADD_8_1st:
+    case OP_PADD_8_2nd:
+        dspv2_insn_padd_8(rz, rx, ry);
+        break;
+    case OP_PADD_16_1st:
+    case OP_PADD_16_2nd:
+        dspv2_insn_padd_16(rz, rx, ry);
+        break;
+    case OP_PADD_U8_S:
+        gen_helper_dspv2_padd_u8_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PADD_S8_S:
+        gen_helper_dspv2_padd_s8_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PADD_U16_S:
+        gen_helper_dspv2_padd_u16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PADD_S16_S:
+        gen_helper_dspv2_padd_s16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_ADD_U32_S:
+        gen_helper_dspv2_add_u32_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_ADD_S32_S:
+        gen_helper_dspv2_add_s32_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSUB_8_1st:
+    case OP_PSUB_8_2nd:
+        dspv2_insn_psub_8(rz, rx, ry);
+        break;
+    case OP_PSUB_16_1st:
+    case OP_PSUB_16_2nd:
+        dspv2_insn_psub_16(rz, rx, ry);
+        break;
+    case OP_PSUB_U8_S:
+        gen_helper_dspv2_psub_u8_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSUB_S8_S:
+        gen_helper_dspv2_psub_s8_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSUB_U16_S:
+        gen_helper_dspv2_psub_u16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSUB_S16_S:
+        gen_helper_dspv2_psub_s16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_SUB_U32_S:
+        gen_helper_dspv2_sub_u32_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_SUB_S32_S:
+        gen_helper_dspv2_sub_s32_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PADDH_U8:
+        gen_helper_dspv2_paddh_u8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PADDH_S8:
+        gen_helper_dspv2_paddh_s8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PADDH_U16:
+        gen_helper_dspv2_paddh_u16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PADDH_S16:
+        gen_helper_dspv2_paddh_s16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_ADDH_U32:
+        dspv2_insn_addh_u32(rz, rx, ry);
+        break;
+    case OP_ADDH_S32:
+        dspv2_insn_addh_s32(rz, rx, ry);
+        break;
+    case OP_PSUBH_U8:
+        gen_helper_dspv2_psubh_u8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSUBH_S8:
+        gen_helper_dspv2_psubh_s8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSUBH_U16:
+        gen_helper_dspv2_psubh_u16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSUBH_S16:
+        gen_helper_dspv2_psubh_s16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_SUBH_U32:
+        dspv2_insn_subh_u32(rz, rx, ry);
+        break;
+    case OP_SUBH_S32:
+        dspv2_insn_subh_s32(rz, rx, ry);
+        break;
+    case OP_ADD_64_1st:
+    case OP_ADD_64_2nd:
+        dspv2_insn_add_64(rz, rx, ry);
+        break;
+    case OP_SUB_64_1st:
+    case OP_SUB_64_2nd:
+        dspv2_insn_sub_64(rz, rx, ry);
+        break;
+    case OP_ADD_U64_S:
+        dspv2_insn_add_u64_s(rz, rx, ry);
+        break;
+    case OP_ADD_S64_S:
+        dspv2_insn_add_s64_s(rz, rx, ry);
+        break;
+    case OP_SUB_U64_S:
+        dspv2_insn_sub_u64_s(rz, rx, ry);
+        break;
+    case OP_SUB_S64_S:
+        dspv2_insn_sub_s64_s(rz, rx, ry);
+        break;
+    default:
+        generate_exception(s, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "unknown dspv2 insn pc=%x opc=%x\n",
+                      s->pc, insn);
+        break;
+    }
+}
+
+static inline void dspv2_insn_pasx_16(int rz, int rx, int ry)
+{
+    /* rz[31:16] = (rx[31:16] + ry[15:0]),
+     * rz[15:0] = (rx[15:0] - ry[31:16]) */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff0000);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xffff);
+    tcg_gen_shli_i32(t1, t1, 16);
+    tcg_gen_add_i32(t2, t0, t1);
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xffff0000);
+    tcg_gen_shri_i32(t1, t1, 16);
+    tcg_gen_sub_i32(t0, t0, t1);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    tcg_gen_or_i32(cpu_R[rz], t2, t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_psax_16(int rz, int rx, int ry)
+{
+    /* rz[31:16] = (rx[31:16] - ry[15:0]),
+     * rz[15:0] = (rx[15:0] + ry[31:16]) */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff0000);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xffff);
+    tcg_gen_shli_i32(t1, t1, 16);
+    tcg_gen_sub_i32(t2, t0, t1);
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xffff0000);
+    tcg_gen_shri_i32(t1, t1, 16);
+    tcg_gen_add_i32(t0, t0, t1);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    tcg_gen_or_i32(cpu_R[rz], t2, t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_max_u32(int rz, int rx, int ry)
+{
+    /* rz = max(rx, ry), unsigned */
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    tcg_gen_brcond_i32(TCG_COND_GTU, cpu_R[rx], cpu_R[ry], l1);
+    tcg_gen_mov_i32(cpu_R[rz], cpu_R[ry]);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+    tcg_gen_mov_i32(cpu_R[rz], cpu_R[rx]);
+    gen_set_label(l2);
+}
+
+static inline void dspv2_insn_max_s32(int rz, int rx, int ry)
+{
+    /* rz = max(rx, ry), signed */
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    tcg_gen_brcond_i32(TCG_COND_GT, cpu_R[rx], cpu_R[ry], l1);
+    tcg_gen_mov_i32(cpu_R[rz], cpu_R[ry]);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+    tcg_gen_mov_i32(cpu_R[rz], cpu_R[rx]);
+    gen_set_label(l2);
+}
+
+static inline void dspv2_insn_pmax_u16(int rz, int rx, int ry)
+{
+    /* rz = {max(rx[31:16], ry[31:16], max(rx[15:0], ry[15:0])}, unsigned */
+    TCGv_i32 t0 = tcg_temp_local_new_i32();
+    TCGv_i32 t1 = tcg_temp_local_new_i32();
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    /* lo_rz = max(lo_rx, lo_ry) */
+    tcg_gen_ext16u_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16u_i32(t1, cpu_R[ry]);
+    tcg_gen_brcond_i32(TCG_COND_GTU, t0, t1, l1);
+    tcg_gen_mov_i32(t0, t1);
+    gen_set_label(l1);
+    /* hi_rz = max(hi_rx, hi_ry) */
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_andi_i32(cpu_R[rz], cpu_R[ry], 0xffff0000);
+    tcg_gen_brcond_i32(TCG_COND_GTU, t1, cpu_R[rz], l2);
+    tcg_gen_mov_i32(t1, cpu_R[rz]);
+    gen_set_label(l2);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_insn_pmax_s16(int rz, int rx, int ry)
+{
+    /* rz = {max(rx[31:16], ry[31:16], max(rx[15:0], ry[15:0])}, signed */
+    TCGv_i32 t0 = tcg_temp_local_new_i32();
+    TCGv_i32 t1 = tcg_temp_local_new_i32();
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    /* lo_rz = max(lo_rx, lo_ry) */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_brcond_i32(TCG_COND_GT, t0, t1, l1);
+    tcg_gen_mov_i32(t0, t1);
+    gen_set_label(l1);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    /* hi_rz = max(hi_rx, hi_ry) */
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_andi_i32(cpu_R[rz], cpu_R[ry], 0xffff0000);
+    tcg_gen_brcond_i32(TCG_COND_GT, t1, cpu_R[rz], l2);
+    tcg_gen_mov_i32(t1, cpu_R[rz]);
+    gen_set_label(l2);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_insn_min_u32(int rz, int rx, int ry)
+{
+    /* rz = min(rx, ry), unsigned */
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    tcg_gen_brcond_i32(TCG_COND_LTU, cpu_R[rx], cpu_R[ry], l1);
+    tcg_gen_mov_i32(cpu_R[rz], cpu_R[ry]);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+    tcg_gen_mov_i32(cpu_R[rz], cpu_R[rx]);
+    gen_set_label(l2);
+}
+
+static inline void dspv2_insn_min_s32(int rz, int rx, int ry)
+{
+    /* rz = min(rx, ry), signed */
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    tcg_gen_brcond_i32(TCG_COND_LT, cpu_R[rx], cpu_R[ry], l1);
+    tcg_gen_mov_i32(cpu_R[rz], cpu_R[ry]);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+    tcg_gen_mov_i32(cpu_R[rz], cpu_R[rx]);
+    gen_set_label(l2);
+}
+
+static inline void dspv2_insn_pmin_u16(int rz, int rx, int ry)
+{
+    /* rz = {min(rx[31:16], ry[31:16], min(rx[15:0], ry[15:0])}, unsigned */
+    TCGv_i32 t0 = tcg_temp_local_new_i32();
+    TCGv_i32 t1 = tcg_temp_local_new_i32();
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    /* lo_rz = min(lo_rx, lo_ry) */
+    tcg_gen_ext16u_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16u_i32(t1, cpu_R[ry]);
+    tcg_gen_brcond_i32(TCG_COND_LTU, t0, t1, l1);
+    tcg_gen_mov_i32(t0, t1);
+    gen_set_label(l1);
+    /* hi_rz = min(hi_rx, hi_ry) */
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_andi_i32(cpu_R[rz], cpu_R[ry], 0xffff0000);
+    tcg_gen_brcond_i32(TCG_COND_LTU, t1, cpu_R[rz], l2);
+    tcg_gen_mov_i32(t1, cpu_R[rz]);
+    gen_set_label(l2);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_insn_pmin_s16(int rz, int rx, int ry)
+{
+    /* rz = {min(rx[31:16], ry[31:16], min(rx[15:0], ry[15:0])}, signed */
+    TCGv_i32 t0 = tcg_temp_local_new_i32();
+    TCGv_i32 t1 = tcg_temp_local_new_i32();
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    /* lo_rz = min(lo_rx, lo_ry) */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_brcond_i32(TCG_COND_LT, t0, t1, l1);
+    tcg_gen_mov_i32(t0, t1);
+    gen_set_label(l1);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    /* hi_rz = min(hi_rx, hi_ry) */
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_andi_i32(cpu_R[rz], cpu_R[ry], 0xffff0000);
+    tcg_gen_brcond_i32(TCG_COND_LT, t1, cpu_R[rz], l2);
+    tcg_gen_mov_i32(t1, cpu_R[rz]);
+    gen_set_label(l2);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_sop_cmp(CPUState *cs,
+                                  DisasContext *s, uint32_t insn)
+{
+    int thop, rz, rx, ry;
+    thop = (insn >> CSKY_DSPV2_THOP_SHI) & CSKY_DSPV2_THOP_MASK;
+    rz = (insn >> CSKY_DSPV2_REG_SHI_RZ) & CSKY_DSPV2_REG_MASK;
+    rx = (insn >> CSKY_DSPV2_REG_SHI_RX) & CSKY_DSPV2_REG_MASK;
+    ry = (insn >> CSKY_DSPV2_REG_SHI_RY) & CSKY_DSPV2_REG_MASK;
+
+    switch (thop) {
+    case OP_PASX_16_1st:
+    case OP_PASX_16_2nd:
+        dspv2_insn_pasx_16(rz, rx, ry);
+        break;
+    case OP_PSAX_16_1st:
+    case OP_PSAX_16_2nd:
+        dspv2_insn_psax_16(rz, rx, ry);
+        break;
+    case OP_PASX_U16_S:
+        gen_helper_dspv2_pasx_u16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PASX_S16_S:
+        gen_helper_dspv2_pasx_s16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSAX_U16_S:
+        gen_helper_dspv2_psax_u16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSAX_S16_S:
+        gen_helper_dspv2_psax_s16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PASXH_U16:
+        gen_helper_dspv2_pasxh_u16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PASXH_S16:
+        gen_helper_dspv2_pasxh_s16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSAXH_U16:
+        gen_helper_dspv2_psaxh_u16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSAXH_S16:
+        gen_helper_dspv2_psaxh_s16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCMPNE_8_1st:
+    case OP_PCMPNE_8_2nd:
+        gen_helper_dspv2_pcmpne_8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCMPNE_16_1st:
+    case OP_PCMPNE_16_2nd:
+        gen_helper_dspv2_pcmpne_16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCMPHS_U8:
+        gen_helper_dspv2_pcmphs_u8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCMPHS_S8:
+        gen_helper_dspv2_pcmphs_s8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCMPHS_U16:
+        gen_helper_dspv2_pcmphs_u16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCMPHS_S16:
+        gen_helper_dspv2_pcmphs_s16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCMPLT_U8:
+        gen_helper_dspv2_pcmplt_u8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCMPLT_S8:
+        gen_helper_dspv2_pcmplt_s8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCMPLT_U16:
+        gen_helper_dspv2_pcmplt_u16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCMPLT_S16:
+        gen_helper_dspv2_pcmplt_s16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PMAX_U8:
+        gen_helper_dspv2_pmax_u8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PMAX_S8:
+        gen_helper_dspv2_pmax_s8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PMAX_U16:
+        dspv2_insn_pmax_u16(rz, rx, ry);
+        break;
+    case OP_PMAX_S16:
+        dspv2_insn_pmax_s16(rz, rx, ry);
+        break;
+    case OP_MAX_U32:
+        dspv2_insn_max_u32(rz, rx, ry);
+        break;
+    case OP_MAX_S32:
+        dspv2_insn_max_s32(rz, rx, ry);
+        break;
+    case OP_PMIN_U8:
+        gen_helper_dspv2_pmin_u8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PMIN_S8:
+        gen_helper_dspv2_pmin_s8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PMIN_U16:
+        dspv2_insn_pmin_u16(rz, rx, ry);
+        break;
+    case OP_PMIN_S16:
+        dspv2_insn_pmin_s16(rz, rx, ry);
+        break;
+    case OP_MIN_U32:
+        dspv2_insn_min_u32(rz, rx, ry);
+        break;
+    case OP_MIN_S32:
+        dspv2_insn_min_s32(rz, rx, ry);
+        break;
+    default:
+        generate_exception(s, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "unknown dspv2 insn pc=%x opc=%x\n",
+                      s->pc, insn);
+        break;
+    }
+}
+
+static inline void dspv2_insn_sel(int rz, int rx, int ry, int rs)
+{
+    /* for(i=0;i=31;i++) Rz[i] = Rs[i] ? Rx[i] : Ry[i] */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    tcg_gen_and_i32(t0, cpu_R[rx], cpu_R[rs]);
+    tcg_gen_not_i32(t1, cpu_R[rs]);
+    tcg_gen_and_i32(cpu_R[rz], cpu_R[ry], t1);
+    tcg_gen_or_i32(cpu_R[rz], cpu_R[rz], t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_sop_sel(CPUState *cs,
+                                 DisasContext *s, uint32_t insn)
+{
+    int rz, rx, ry, rs;
+    rz = (insn >> CSKY_DSPV2_REG_SHI_RZ) & CSKY_DSPV2_REG_MASK;
+    rx = (insn >> CSKY_DSPV2_REG_SHI_RX) & CSKY_DSPV2_REG_MASK;
+    ry = (insn >> CSKY_DSPV2_REG_SHI_RY) & CSKY_DSPV2_REG_MASK;
+    rs = (insn >> 5) & CSKY_DSPV2_REG_MASK;
+    if ((insn & (1 << 10)) == 0) {
+        dspv2_insn_sel(rz, rx, ry, rs);
+    } else {
+        generate_exception(s, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "unknown dspv2 insn pc=%x opc=%x\n",
+                      s->pc, insn);
+    }
+}
+
+static inline void dspv2_insn_mulaca_s8(int rz, int rx, int ry)
+{
+    /* rz = rx[7:0] * ry[7:0] + rx[15:8] * ry[15:8]
+     *  + rx[23:16] * ry[23:16] + rx[31:24] * ry[31:24], signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+
+    /* rz = rz + ll_x * ll_y */
+    tcg_gen_ext8s_i32(t0, cpu_R[rx]);
+    tcg_gen_ext8s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t2, t0, t1);
+    /* rz = rz + lh_x * lh_y */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 8);
+    tcg_gen_ext8s_i32(t0, t0);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 8);
+    tcg_gen_ext8s_i32(t1, t1);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_add_i32(t2, t2, t0);
+    /* rz= rz + hl_x * hl_y */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_ext8s_i32(t0, t0);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_ext8s_i32(t1, t1);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_add_i32(t2, t2, t0);
+    /* rz = rz +hh_x * hh_y */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 24);
+    tcg_gen_ext8s_i32(t0, t0);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 24);
+    tcg_gen_ext8s_i32(t1, t1);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_add_i32(cpu_R[rz], t2, t0);
+
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+    tcg_temp_free(t2);
+}
+
+static inline void dspv2_insn_divul(DisasContext *ctx, int rz, int rx, int ry)
+{
+    /* {rz+1, rz} = {rx+1, rx} / ry */
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_R[ry], 0, l1);
+    TCGv_i64  t0 = tcg_temp_new_i64();
+    TCGv_i64  t1 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t0, cpu_R[rx], cpu_R[(rx + 1) % 32]);
+    tcg_gen_extu_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_divu_i64(t0, t0, t1);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+
+    TCGv_i32 t2 = tcg_temp_new();
+    t2 = tcg_const_i32(EXCP_CSKY_DIV);
+    gen_save_pc(ctx->pc);
+    gen_helper_exception(cpu_env, t2);
+    ctx->is_jmp = DISAS_NEXT;
+    tcg_temp_free(t2);
+    gen_set_label(l2);
+}
+
+static inline void dspv2_insn_divsl(DisasContext *ctx, int rz, int rx, int ry)
+{
+    /* {rz+1, rz} = {rx+1, rx} / ry */
+    TCGv_i64  t0 = tcg_temp_local_new_i64();
+    TCGLabel *l1 = gen_new_label();
+    TCGLabel *l2 = gen_new_label();
+    TCGLabel *l3 = gen_new_label();
+    tcg_gen_concat_i32_i64(t0, cpu_R[rx], cpu_R[(rx + 1) % 32]);
+    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_R[ry], 0, l1);
+    tcg_gen_brcondi_i64(TCG_COND_NE, t0, 0x8000000000000000, l3);
+    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[ry], 0xffffffff, l3);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_gen_br(l2);
+
+    gen_set_label(l3);
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_div_i64(t0, t0, t1);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_gen_br(l2);
+    gen_set_label(l1);
+
+    TCGv_i32 t2 = tcg_temp_new();
+    t2 = tcg_const_i32(EXCP_CSKY_DIV);
+    gen_save_pc(ctx->pc);
+    gen_helper_exception(cpu_env, t2);
+    ctx->is_jmp = DISAS_NEXT;
+    tcg_temp_free(t2);
+
+    gen_set_label(l2);
+}
+
+static inline void dspv2_sop_misc(CPUState *cs,
+                                  DisasContext *s, uint32_t insn)
+{
+    int thop, rz, rx, ry;
+    thop = (insn >> CSKY_DSPV2_THOP_SHI) & CSKY_DSPV2_THOP_MASK;
+    rz = (insn >> CSKY_DSPV2_REG_SHI_RZ) & CSKY_DSPV2_REG_MASK;
+    rx = (insn >> CSKY_DSPV2_REG_SHI_RX) & CSKY_DSPV2_REG_MASK;
+    ry = (insn >> CSKY_DSPV2_REG_SHI_RY) & CSKY_DSPV2_REG_MASK;
+
+    switch (thop) {
+    case OP_PSABSA_U8_1st:
+    case OP_PSABSA_U8_2nd:
+        gen_helper_dspv2_psabsa_u8(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PSABSAA_U8_1st:
+    case OP_PSABSAA_U8_2nd:
+        gen_helper_dspv2_psabsaa_u8(cpu_R[rz], cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_DIVUL:
+        dspv2_insn_divul(s, rz, rx, ry);
+        break;
+    case OP_DIVSL:
+        dspv2_insn_divsl(s, rz, rx, ry);
+        break;
+    case OP_MULACA_S8:
+        dspv2_insn_mulaca_s8(rz, rx, ry);
+        break;
+    default:
+        generate_exception(s, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "unknown dspv2 insn pc=%x opc=%x\n",
+                      s->pc, insn);
+        break;
+    }
+}
+
+static inline void dspv2_insn_asri_s32_r(int rz, int rx, int imm)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_shli_i64(t0, t0, 32);
+    tcg_gen_sari_i64(t0, t0, imm);
+    tcg_gen_addi_i64(t0, t0, 0x80000000);
+    tcg_gen_extrh_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_asr_s32_r(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_andi_i64(t1, t1, 0x3f);
+    tcg_gen_shli_i64(t0, t0, 32);
+    tcg_gen_sar_i64(t0, t0, t1);
+    tcg_gen_addi_i64(t0, t0, 0x80000000);
+    tcg_gen_extrh_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_lsri_u32_r(int rz, int rx, int imm)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_shli_i64(t0, t0, 32);
+    tcg_gen_shri_i64(t0, t0, imm);
+    tcg_gen_addi_i64(t0, t0, 0x80000000);
+    tcg_gen_extrh_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_lsr_u32_r(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_andi_i64(t1, t1, 0x3f);
+    tcg_gen_shli_i64(t0, t0, 32);
+    tcg_gen_shr_i64(t0, t0, t1);
+    tcg_gen_addi_i64(t0, t0, 0x80000000);
+    tcg_gen_extrh_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_pasri_s16(int rz, int rx, int imm)
+{
+    /* rz = {rx[31:16] >> imm, rx[15:0] >> imm} */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_sari_i32(t0, t0, imm);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_sari_i32(t1, t1, imm);
+    tcg_gen_andi_i32(t1, t1, 0xffff0000);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_insn_pasr_s16(int rz, int rx, int ry)
+{
+    /* rz = {rx[31:16] >> ry, rx[15:0] >> ry} */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    tcg_gen_andi_i32(t2, cpu_R[ry], 0x1f);
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_sar_i32(t0, t0, t2);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_sar_i32(t1, t1, t2);
+    tcg_gen_andi_i32(t1, t1, 0xffff0000);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_pasri_s16_r(int rz, int rx, int imm)
+{
+    /* rz[31:16] = Round(rx[31:16] >> imm),
+     * rz[15:0] = Round(rx[15:0] >> imm) */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_shri_i32(t2, t0, imm - 1);
+    tcg_gen_andi_i32(t2, t2, 0x1);
+    tcg_gen_sari_i32(t0, t0, imm);
+    tcg_gen_add_i32(t0, t0, t2);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+
+    tcg_gen_sari_i32(t1, cpu_R[rx], imm);
+    tcg_gen_addi_i32(t1, t1, 0x8000);
+    tcg_gen_andi_i32(t1, t1, 0xffff0000);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_pasr_s16_r(int rz, int rx, int ry)
+{
+    /* rz[31:16] = Round(rx[31:16] >> imm),
+     * rz[15:0] = Round(rx[15:0] >> imm) */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    TCGv_i32 t3 = tcg_temp_new_i32();
+
+    tcg_gen_andi_i32(t3, cpu_R[ry], 0x1f);
+    tcg_gen_andi_i32(t2, cpu_R[rx], 0xffff);
+    tcg_gen_shli_i32(t2, t2, 16);
+    tcg_gen_sar_i32(t2, t2, t3);
+    tcg_gen_addi_i32(t2, t2, 0x8000);
+    tcg_gen_shri_i32(t2, t2, 16);
+    tcg_gen_andi_i32(t0, t2, 0xffff);
+
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_sar_i32(t1, t1, t3);
+    tcg_gen_addi_i32(t1, t1, 0x8000);
+    tcg_gen_andi_i32(t1, t1, 0xffff0000);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+    tcg_temp_free_i32(t3);
+}
+
+static inline void dspv2_insn_plsri_u16(int rz, int rx, int imm)
+{
+    /* rz = {rx[31:16] >> imm, rx[15:0] >> imm} logical shift */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    tcg_gen_ext16u_i32(t0, cpu_R[rx]);
+    tcg_gen_shri_i32(t0, t0, imm);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_shri_i32(t1, t1, imm);
+    tcg_gen_andi_i32(t1, t1, 0xffff0000);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_insn_plsr_u16(int rz, int rx, int ry)
+{
+    /* rz = {rx[31:16] >> imm, rx[15:0] >> imm} logical shift */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    tcg_gen_andi_i32(t2, cpu_R[ry], 0x1f);
+    tcg_gen_ext16u_i32(t0, cpu_R[rx]);
+    tcg_gen_shr_i32(t0, t0, t2);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_shr_i32(t1, t1, t2);
+    tcg_gen_andi_i32(t1, t1, 0xffff0000);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_plsri_u16_r(int rz, int rx, int imm)
+{
+    /* rz[31:16] = Round(rx[31:16] >> imm),
+     * rz[15:0] = Round(rx[15:0] >> imm) */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i32 t3 = tcg_temp_new_i32();
+
+    tcg_gen_andi_i32(t3, cpu_R[rx], 0xffff);
+    tcg_gen_ext_i32_i64(t0, t3);
+    tcg_gen_shli_i64(t0, t0, 32);
+    tcg_gen_shri_i64(t0, t0, imm);
+    tcg_gen_addi_i64(t0, t0, 0x80000000);
+    tcg_gen_andi_i64(t0, t0, 0xffff00000000);
+
+
+    tcg_gen_andi_i32(t3, cpu_R[rx], 0xffff0000);
+    tcg_gen_ext_i32_i64(t1, t3);
+    tcg_gen_shli_i64(t1, t1, 32);
+    tcg_gen_shri_i64(t1, t1, imm);
+    tcg_gen_addi_i64(t1, t1, 0x800000000000);
+    tcg_gen_andi_i64(t1, t1, 0xffff000000000000);
+
+
+    tcg_gen_or_i64(t2, t0, t1);
+    tcg_gen_extrh_i64_i32(cpu_R[rz], t2);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i32(t3);
+}
+
+static inline void dspv2_insn_plsr_u16_r(int rz, int rx, int ry)
+{
+    /* rz[31:16] = Round(rx[31:16] >> imm),
+     * rz[15:0] = Round(rx[15:0] >> imm) */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i32 t3 = tcg_temp_new_i32();
+    TCGv_i32 t4 = tcg_temp_new_i32();
+
+    tcg_gen_andi_i32(t3, cpu_R[ry], 0x1f);
+    tcg_gen_ext_i32_i64(t1, t3);
+    tcg_gen_andi_i32(t4, cpu_R[rx], 0xffff);
+    tcg_gen_ext_i32_i64(t0, t4);
+    tcg_gen_shli_i64(t0, t0, 32);
+    tcg_gen_shr_i64(t0, t0, t1);
+    tcg_gen_addi_i64(t0, t0, 0x80000000);
+    tcg_gen_andi_i64(t0, t0, 0xffff00000000);
+
+
+    tcg_gen_andi_i32(t4, cpu_R[rx], 0xffff0000);
+    tcg_gen_ext_i32_i64(t2, t4);
+    tcg_gen_shli_i64(t2, t2, 32);
+    tcg_gen_shr_i64(t2, t2, t1);
+    tcg_gen_addi_i64(t2, t2, 0x800000000000);
+    tcg_gen_andi_i64(t2, t2, 0xffff000000000000);
+
+
+    tcg_gen_or_i64(t1, t0, t2);
+    tcg_gen_extrh_i64_i32(cpu_R[rz], t1);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i32(t3);
+    tcg_temp_free_i32(t4);
+
+}
+
+static inline void dspv2_insn_plsli_u16(int rz, int rx, int imm)
+{
+    /* rz = {rx[31:16] << imm, rx[15:0] << imm} */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff);
+    tcg_gen_shli_i32(t0, t0, imm);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_shli_i32(t1, t1, imm);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_insn_plsl_u16(int rz, int rx, int ry)
+{
+    /* rz = {rx[31:16] >> imm, rx[15:0] >> imm}, logical shift */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    tcg_gen_andi_i32(t2, cpu_R[ry], 0x1f);
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff);
+    tcg_gen_shl_i32(t0, t0, t2);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[rx], 0xffff0000);
+    tcg_gen_shl_i32(t1, t1, t2);
+    tcg_gen_andi_i32(t1, t1, 0xffff0000);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_sop_shift(CPUState *cs,
+                                  DisasContext *s, uint32_t insn)
+{
+    int thop, rz, rx, ry, imm;
+    TCGv t0;
+    thop = (insn >> CSKY_DSPV2_THOP_SHI) & CSKY_DSPV2_THOP_MASK;
+    rz = (insn >> CSKY_DSPV2_REG_SHI_RZ) & CSKY_DSPV2_REG_MASK;
+    rx = (insn >> CSKY_DSPV2_REG_SHI_RX) & CSKY_DSPV2_REG_MASK;
+    ry = (insn >> CSKY_DSPV2_REG_SHI_RY) & CSKY_DSPV2_REG_MASK;
+    imm = ry + 1;  /* bits ry equal to oimm. */
+
+    switch (thop) {
+    case OP_ASRI_S32_R:
+        dspv2_insn_asri_s32_r(rz, rx, imm);
+        break;
+    case OP_ASR_S32_R:
+        dspv2_insn_asr_s32_r(rz, rx, ry);
+        break;
+    case OP_LSRI_U32_R:
+        dspv2_insn_lsri_u32_r(rz, rx, imm);
+        break;
+    case OP_LSR_U32_R:
+        dspv2_insn_lsr_u32_r(rz, rx, ry);
+        break;
+    case OP_LSLI_U32_S:
+        t0 = tcg_temp_new_i32();
+        t0 = tcg_const_tl(imm);
+        gen_helper_dspv2_lsli_u32_s(cpu_R[rz], cpu_R[rx], t0);
+        tcg_temp_free_i32(t0);
+        break;
+    case OP_LSLI_S32_S:
+        t0 = tcg_temp_new_i32();
+        t0 = tcg_const_tl(imm);
+        gen_helper_dspv2_lsli_s32_s(cpu_R[rz], cpu_R[rx], t0);
+        tcg_temp_free_i32(t0);
+        break;
+    case OP_LSL_U32_S:
+        gen_helper_dspv2_lsl_u32_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_LSL_S32_S:
+        gen_helper_dspv2_lsl_s32_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PASRI_S16:
+        dspv2_insn_pasri_s16(rz, rx, imm);
+        break;
+    case OP_PASR_S16:
+        dspv2_insn_pasr_s16(rz, rx, ry);
+        break;
+    case OP_PASRI_S16_R:
+        dspv2_insn_pasri_s16_r(rz, rx, imm);
+        break;
+    case OP_PASR_S16_R:
+        dspv2_insn_pasr_s16_r(rz, rx, ry);
+        break;
+    case OP_PLSRI_U16:
+        dspv2_insn_plsri_u16(rz, rx, imm);
+        break;
+    case OP_PLSR_U16:
+        dspv2_insn_plsr_u16(rz, rx, ry);
+        break;
+    case OP_PLSRI_U16_R:
+        dspv2_insn_plsri_u16_r(rz, rx, imm);
+        break;
+    case OP_PLSR_U16_R:
+        dspv2_insn_plsr_u16_r(rz, rx, ry);
+        break;
+    case OP_PLSLI_U16:
+        dspv2_insn_plsli_u16(rz, rx, imm);
+        break;
+    case OP_PLSL_U16:
+        dspv2_insn_plsl_u16(rz, rx, ry);
+        break;
+    case OP_PLSLI_U16_S:
+        t0 = tcg_temp_new_i32();
+        t0 = tcg_const_tl(imm);
+        gen_helper_dspv2_plsli_u16_s(cpu_R[rz], cpu_R[rx], t0);
+        tcg_temp_free_i32(t0);
+        break;
+    case OP_PLSLI_S16_S:
+        t0 = tcg_temp_new_i32();
+        t0 = tcg_const_tl(imm);
+        gen_helper_dspv2_plsli_s16_s(cpu_R[rz], cpu_R[rx], t0);
+        tcg_temp_free_i32(t0);
+        break;
+    case OP_PLSL_U16_S:
+        gen_helper_dspv2_plsl_u16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PLSL_S16_S:
+        gen_helper_dspv2_plsl_s16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    default:
+        generate_exception(s, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "unknown dspv2 insn pc=%x opc=%x\n",
+                      s->pc, insn);
+        break;
+    }
+}
+
+static inline void dspv2_insn_pkg(int rz, int rx, int imm4a, int ry, int imm4b)
+{
+    /* rz = {(ry >> imm4b)[15:0], (rx >> imm4a)[15:0]}, logical shift */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    tcg_gen_shri_i32(t0, cpu_R[rx], imm4a);
+    tcg_gen_andi_i32(t0, t0, 0xffff);
+    tcg_gen_shli_i32(t1, cpu_R[ry], 16 - imm4b);
+    tcg_gen_andi_i32(t1, t1, 0xffff0000);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_sop_pkg(CPUState *cs,
+                                 DisasContext *s, uint32_t insn)
+{
+    int rz, rx, ry, imm4a, imm4b;
+    rz = (insn >> CSKY_DSPV2_REG_SHI_RZ) & CSKY_DSPV2_REG_MASK;
+    rx = (insn >> CSKY_DSPV2_REG_SHI_RX) & CSKY_DSPV2_REG_MASK;
+    ry = (insn >> CSKY_DSPV2_REG_SHI_RY) & CSKY_DSPV2_REG_MASK;
+    imm4a = (insn >> 5) & 0xf;
+    imm4b = ((insn >> 9) & 0xf) + 1;
+    dspv2_insn_pkg(rz, rx, imm4a, ry, imm4b);
+
+}
+
+static inline void dspv2_insn_dexti(int rz, int rx, int ry, int imm)
+{
+        /* rz = ({ry, rx} >> imm)[31:0] */
+        TCGv_i64 t0 = tcg_temp_new_i64();
+        tcg_gen_concat_i32_i64(t0, cpu_R[rx], cpu_R[ry]);
+        tcg_gen_shri_i64(t0, t0, imm);
+        tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+        tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_dext(int rz, int rx, int ry, int rs)
+{
+        /* rz = ({ry, rx} >> rs)[31:0]
+         * NOTE: 0 <= rs <= 32. */
+        TCGv_i64 t0 = tcg_temp_new_i64();
+        TCGv_i32 t1 = tcg_temp_new_i32();
+        TCGv_i64 t2 = tcg_temp_new_i64();
+        tcg_gen_andi_i32(t1, cpu_R[rs], 0x3f);
+        tcg_gen_ext_i32_i64(t2, t1);
+        tcg_gen_concat_i32_i64(t0, cpu_R[rx], cpu_R[ry]);
+        tcg_gen_shr_i64(t0, t0, t2);
+        tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+        tcg_temp_free_i64(t0);
+        tcg_temp_free_i32(t1);
+        tcg_temp_free_i64(t2);
+}
+
+static inline void dspv2_sop_dext(CPUState *cs,
+                                 DisasContext *s, uint32_t insn)
+{
+    int rz, rx, ry;
+    rz = (insn >> CSKY_DSPV2_REG_SHI_RZ) & CSKY_DSPV2_REG_MASK;
+    rx = (insn >> CSKY_DSPV2_REG_SHI_RX) & CSKY_DSPV2_REG_MASK;
+    ry = (insn >> CSKY_DSPV2_REG_SHI_RY) & CSKY_DSPV2_REG_MASK;
+    if ((insn & (1 << 10)) == 0) {
+        /* dexti */
+        int imm5 = (insn >> 5) & 0x1f;
+        dspv2_insn_dexti(rz, rx, ry, imm5);
+    } else {
+        /* dext */
+        int rs = (insn >> 5) & CSKY_DSPV2_REG_MASK;
+        dspv2_insn_dext(rz, rx, ry, rs);
+    }
+}
+
+static inline void dspv2_insn_pkgll(int rz, int rx, int ry)
+{
+    /* rz = {ry[15:0], rx[15:0]} */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xffff);
+    tcg_gen_shli_i32(t1, t1, 16);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_insn_pkghh(int rz, int rx, int ry)
+{
+    /* rz = {ry[31:16], rx[31:16]} */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    tcg_gen_andi_i32(t0, cpu_R[rx], 0xffff0000);
+    tcg_gen_shri_i32(t0, t0, 16);
+    tcg_gen_andi_i32(t1, cpu_R[ry], 0xffff0000);
+    tcg_gen_or_i32(cpu_R[rz], t0, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+}
+
+static inline void dspv2_sop_pkg_clip(CPUState *cs,
+                                      DisasContext *s, uint32_t insn)
+{
+    int thop, rz, rx, ry, index;
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    thop = (insn >> CSKY_DSPV2_THOP_SHI) & CSKY_DSPV2_THOP_MASK;
+    rz = (insn >> CSKY_DSPV2_REG_SHI_RZ) & CSKY_DSPV2_REG_MASK;
+    rx = (insn >> CSKY_DSPV2_REG_SHI_RX) & CSKY_DSPV2_REG_MASK;
+    ry = (insn >> CSKY_DSPV2_REG_SHI_RY) & CSKY_DSPV2_REG_MASK;
+
+    switch (thop) {
+    case OP_PKGLL_1st:
+    case OP_PKGLL_2nd:
+        dspv2_insn_pkgll(rz, rx, ry);
+        break;
+    case OP_PKGHH_1st:
+    case OP_PKGHH_2nd:
+        dspv2_insn_pkghh(rz, rx, ry);
+        break;
+    case OP_PEXT_U8_E:
+        if (ry == 0) {
+            gen_helper_dspv2_pext_u8_e(t1, cpu_R[rx]);
+            tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t1);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_PEXT_S8_E:
+        if (ry == 0) {
+            gen_helper_dspv2_pext_s8_e(t1, cpu_R[rx]);
+            tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t1);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_PEXTX_U8_E:
+        if (ry == 0) {
+            gen_helper_dspv2_pextx_u8_e(t1, cpu_R[rx]);
+            tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t1);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_PEXTX_S8_E:
+        if (ry == 0) {
+            gen_helper_dspv2_pextx_s8_e(t1, cpu_R[rx]);
+            tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t1);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_NARL_1st:
+    case OP_NARL_2nd:
+        gen_helper_dspv2_narl(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_NARH_1st:
+    case OP_NARH_2nd:
+        gen_helper_dspv2_narh(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_NARLX_1st:
+    case OP_NARLX_2nd:
+        gen_helper_dspv2_narlx(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_NARHX_1st:
+    case OP_NARHX_2nd:
+        gen_helper_dspv2_narhx(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_CLIPI_U32:
+        t0 = tcg_const_i32(ry);
+        gen_helper_dspv2_clipi_u32(cpu_R[rz], cpu_R[rx], t0);
+        break;
+    case OP_CLIPI_S32:
+        t0 = tcg_const_i32(ry);
+        gen_helper_dspv2_clipi_s32(cpu_R[rz], cpu_R[rx], t0);
+        break;
+    case OP_CLIP_U32:
+        gen_helper_dspv2_clip_u32(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_CLIP_S32:
+        gen_helper_dspv2_clip_s32(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCLIPI_U16:
+        t0 = tcg_const_i32(ry);
+        gen_helper_dspv2_pclipi_u16(cpu_R[rz], cpu_R[rx], t0);
+        break;
+    case OP_PCLIPI_S16:
+        t0 = tcg_const_i32(ry);
+        gen_helper_dspv2_pclipi_s16(cpu_R[rz], cpu_R[rx], t0);
+        break;
+    case OP_PCLIP_U16:
+        gen_helper_dspv2_pclip_u16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PCLIP_S16:
+        gen_helper_dspv2_pclip_s16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PABS_S8_S:
+        if (ry == 0) {
+            gen_helper_dspv2_pabs_s8_s(cpu_R[rz], cpu_R[rx]);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_PABS_S16_S:
+        if (ry == 0) {
+            gen_helper_dspv2_pabs_s16_s(cpu_R[rz], cpu_R[rx]);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_ABS_S32_S:
+        if (ry == 0) {
+            gen_helper_dspv2_abs_s32_s(cpu_R[rz], cpu_R[rx]);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_PNEG_S8_S:
+        if (ry == 0) {
+            gen_helper_dspv2_pneg_s8_s(cpu_R[rz], cpu_R[rx]);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_PNEG_S16_S:
+        if (ry == 0) {
+            gen_helper_dspv2_pneg_s16_s(cpu_R[rz], cpu_R[rx]);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_NEG_S32_S:
+        if (ry == 0) {
+            gen_helper_dspv2_neg_s32_s(cpu_R[rz], cpu_R[rx]);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_DUP_8_begin ... OP_DUP_8_end:
+        if (ry == 0) {
+            index = (insn >> 5) & 0x3;
+            t0 = tcg_const_i32(index);
+            gen_helper_dspv2_dup_8(cpu_R[rz], cpu_R[rx], t0);
+        } else {
+            goto wrong;
+        }
+        break;
+    case OP_DUP_16_begin ... OP_DUP_16_end:
+        if (ry == 0) {
+            index = (insn >> 5) & 0x1;
+            t0 = tcg_const_i32(index);
+            gen_helper_dspv2_dup_16(cpu_R[rz], cpu_R[rx], t0);
+        } else {
+            goto wrong;
+        }
+        break;
+    default:
+wrong:
+        generate_exception(s, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "unknown dspv2 insn pc=%x opc=%x\n",
+                      s->pc, insn);
+        break;
+    }
+    tcg_temp_free_i32(t0);
+}
+
+static inline void dspv2_insn_mul_u32(int rz, int rx, int ry)
+{
+    tcg_gen_mulu2_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], cpu_R[rx], cpu_R[ry]);
+}
+
+static inline void dspv2_insn_mul_s32(int rz, int rx, int ry)
+{
+    tcg_gen_muls2_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], cpu_R[rx], cpu_R[ry]);
+}
+
+static inline void dspv2_insn_mula_u32(int rz, int rx, int ry)
+{
+    /* {r[z+1],rz} = (rx * ry) + {r[z+1],rz}, unsigned */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_extu_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_extu_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_concat_i32_i64(t1, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    tcg_gen_add_i64(t0, t0, t1);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_mula_s32(int rz, int rx, int ry)
+{
+    /* {r[z+1],rz} = (rx * ry) + {r[z+1],rz}, signed */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_concat_i32_i64(t1, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    tcg_gen_add_i64(t0, t0, t1);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_muls_u32(int rz, int rx, int ry)
+{
+    /* {Rz+1[31:0],Rz[31:0]} = {Rz+1[31:0],Rz[31:0]} + Rx[31:0] X Ry[31:0] */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_extu_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_extu_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_concat_i32_i64(t1, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    tcg_gen_sub_i64(t0, t1, t0);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_muls_s32(int rz, int rx, int ry)
+{
+    /* {Rz+1[31:0],Rz[31:0]} = {Rz+1[31:0],Rz[31:0]} + Rx[31:0] X Ry[31:0] */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_concat_i32_i64(t1, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    tcg_gen_sub_i64(t0, t1, t0);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_mula_u32_s(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    gen_helper_dspv2_mula_u32_s(t0, cpu_R[rz], cpu_R[(rz + 1) % 32],
+                                cpu_R[rx], cpu_R[ry]);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_mula_s32_s(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    gen_helper_dspv2_mula_s32_s(t0, cpu_R[rz], cpu_R[(rz + 1) % 32],
+                                cpu_R[rx], cpu_R[ry]);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_muls_u32_s(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    gen_helper_dspv2_muls_u32_s(t0, cpu_R[rz], cpu_R[(rz + 1) % 32],
+                                cpu_R[rx], cpu_R[ry]);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_muls_s32_s(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    gen_helper_dspv2_muls_s32_s(t0, cpu_R[rz], cpu_R[(rz + 1) % 32],
+                                cpu_R[rx], cpu_R[ry]);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_mul_s32_h(int rz, int rx, int ry)
+{
+    /* rz = (rx * ry)[63:32], signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    tcg_gen_muls2_i32(t0, cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+    tcg_temp_free_i32(t0);
+}
+
+static inline void dspv2_insn_mul_s32_rh(int rz, int rx, int ry)
+{
+    /* rz = (rx * ry + 0x80000000)[63:32] , signed */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_addi_i64(t0, t0, 0x80000000);
+    tcg_gen_extrh_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_mulll_s16(int rz, int rx, int ry)
+{
+    /* rz = rx[15:0] * ry[15:0], signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16s_i32(cpu_R[rz], cpu_R[ry]);
+    tcg_gen_mul_i32(cpu_R[rz], t0, cpu_R[rz]);
+    tcg_temp_free_i32(t0);
+}
+
+static inline void dspv2_insn_mulhh_s16(int rz, int rx, int ry)
+{
+    /* rz = rx[31:16] * ry[31:16], signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_sari_i32(cpu_R[rz], cpu_R[ry], 16);
+    tcg_gen_mul_i32(cpu_R[rz], t0, cpu_R[rz]);
+    tcg_temp_free_i32(t0);
+}
+
+static inline void dspv2_insn_mulhl_s16(int rz, int rx, int ry)
+{
+    /* rz = rx[31:16] * ry[15:0], signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_ext16s_i32(cpu_R[rz], cpu_R[ry]);
+    tcg_gen_mul_i32(cpu_R[rz], t0, cpu_R[rz]);
+    tcg_temp_free_i32(t0);
+}
+
+static inline void dspv2_insn_mulall_s16_e(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    gen_helper_dspv2_mulall_s16_e(t0, cpu_R[rz], cpu_R[(rz + 1) % 32],
+                                  cpu_R[rx], cpu_R[ry]);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_mulahh_s16_e(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    gen_helper_dspv2_mulahh_s16_e(t0, cpu_R[rz], cpu_R[(rz + 1) % 32],
+                                  cpu_R[rx], cpu_R[ry]);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_mulahl_s16_e(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    gen_helper_dspv2_mulahl_s16_e(t0, cpu_R[rz], cpu_R[(rz + 1) % 32],
+                                  cpu_R[rx], cpu_R[ry]);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_pmul_u16(int rz, int rx, int ry)
+{
+    /* rz = lo_x * lo_y, rn = hi_x * hi_y, unsigned */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    TCGv_i32 t3 = tcg_temp_new_i32();
+    /* lo_x, hi_x */
+    tcg_gen_ext16u_i32(t2, cpu_R[rx]);
+    tcg_gen_shri_i32(t3, cpu_R[rx], 16);
+    /* lo_y, hi_y */
+    tcg_gen_ext16u_i32(t0, cpu_R[ry]);
+    tcg_gen_shri_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(cpu_R[rz], t2, t0);
+    tcg_gen_mul_i32(cpu_R[(rz + 1) % 32], t3, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+    tcg_temp_free_i32(t3);
+}
+
+static inline void dspv2_insn_pmul_s16(int rz, int rx, int ry)
+{
+    /* rz = lo_x * lo_y, rn = hi_x * hi_y, signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    TCGv_i32 t3 = tcg_temp_new_i32();
+    /* lo_x, hi_x */
+    tcg_gen_ext16s_i32(t2, cpu_R[rx]);
+    tcg_gen_sari_i32(t3, cpu_R[rx], 16);
+    /* lo_y, hi_y */
+    tcg_gen_ext16s_i32(t0, cpu_R[ry]);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(cpu_R[rz], t2, t0);
+    tcg_gen_mul_i32(cpu_R[(rz + 1) % 32], t3, t1);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+    tcg_temp_free_i32(t3);
+}
+
+static inline void dspv2_insn_pmulx_u16(int rz, int rx, int ry)
+{
+    /* rz = lo_x * lo_y, rn = hi_x * hi_y, unsigned */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    TCGv_i32 t3 = tcg_temp_new_i32();
+    /* lo_x, hi_x */
+    tcg_gen_ext16u_i32(t2, cpu_R[rx]);
+    tcg_gen_shri_i32(t3, cpu_R[rx], 16);
+    /* lo_y, hi_y */
+    tcg_gen_ext16u_i32(t0, cpu_R[ry]);
+    tcg_gen_shri_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(cpu_R[rz], t2, t1);
+    tcg_gen_mul_i32(cpu_R[(rz + 1) % 32], t3, t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+    tcg_temp_free_i32(t3);
+}
+
+static inline void dspv2_insn_pmulx_s16(int rz, int rx, int ry)
+{
+    /* rz = lo_x * lo_y, rn = hi_x * hi_y, signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    TCGv_i32 t3 = tcg_temp_new_i32();
+    /* lo_x, hi_x */
+    tcg_gen_ext16s_i32(t2, cpu_R[rx]);
+    tcg_gen_sari_i32(t3, cpu_R[rx], 16);
+    /* lo_y, hi_y */
+    tcg_gen_ext16s_i32(t0, cpu_R[ry]);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(cpu_R[rz], t2, t1);
+    tcg_gen_mul_i32(cpu_R[(rz + 1) % 32], t3, t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+    tcg_temp_free_i32(t3);
+}
+
+static inline void dspv2_insn_prmul_s16(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    gen_helper_dspv2_prmul_s16(t0, cpu_R[rx], cpu_R[ry]);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_insn_prmulx_s16(int rz, int rx, int ry)
+{
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    gen_helper_dspv2_prmulx_s16(t0, cpu_R[rx], cpu_R[ry]);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t0);
+    tcg_temp_free_i64(t0);
+}
+
+static inline void dspv2_sop_mul_1st(CPUState *cs,
+                                     DisasContext *s, uint32_t insn)
+{
+    int thop, rz, rx, ry;
+    thop = (insn >> CSKY_DSPV2_THOP_SHI) & CSKY_DSPV2_THOP_MASK;
+    rz = (insn >> CSKY_DSPV2_REG_SHI_RZ) & CSKY_DSPV2_REG_MASK;
+    rx = (insn >> CSKY_DSPV2_REG_SHI_RX) & CSKY_DSPV2_REG_MASK;
+    ry = (insn >> CSKY_DSPV2_REG_SHI_RY) & CSKY_DSPV2_REG_MASK;
+    if (thop != OP_MULA_32_L && thop != OP_MULALL_S16_S
+        && thop != OP_MUL_U32 && thop != OP_MULA_U32
+        && thop != OP_MUL_S32 && thop != OP_MULA_S32) {
+        check_insn(s, ABIV2_EDSP);
+    } else {
+        check_insn(s, ABIV2_803S_R1);
+    }
+    switch (thop) {
+    case OP_MUL_U32:
+        dspv2_insn_mul_u32(rz, rx, ry);
+        break;
+    case OP_MUL_S32:
+        dspv2_insn_mul_s32(rz, rx, ry);
+        break;
+    case OP_MULA_U32:
+        dspv2_insn_mula_u32(rz, rx, ry);
+        break;
+    case OP_MULA_S32:
+        dspv2_insn_mula_s32(rz, rx, ry);
+        break;
+    case OP_MULS_U32:
+        dspv2_insn_muls_u32(rz, rx, ry);
+        break;
+    case OP_MULS_S32:
+        dspv2_insn_muls_s32(rz, rx, ry);
+        break;
+    case OP_MULA_U32_S:
+        dspv2_insn_mula_u32_s(rz, rx, ry);
+        break;
+    case OP_MULA_S32_S:
+        dspv2_insn_mula_s32_s(rz, rx, ry);
+        break;
+    case OP_MULS_U32_S:
+        dspv2_insn_muls_u32_s(rz, rx, ry);
+        break;
+    case OP_MULS_S32_S:
+        dspv2_insn_muls_s32_s(rz, rx, ry);
+        break;
+    case OP_MULA_32_L:
+        gen_helper_dspv2_mula_32_l(cpu_R[rz], cpu_R[rz],
+                                   cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MUL_S32_H:
+        dspv2_insn_mul_s32_h(rz, rx, ry);
+        break;
+    case OP_MUL_S32_RH:
+        dspv2_insn_mul_s32_rh(rz, rx, ry);
+        break;
+    case OP_RMUL_S32_H:
+        gen_helper_dspv2_rmul_s32_h(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_RMUL_S32_RH:
+        gen_helper_dspv2_rmul_s32_rh(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULA_S32_HS:
+        gen_helper_dspv2_mula_s32_hs(cpu_R[rz], cpu_R[rz],
+                                     cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULS_S32_HS:
+        gen_helper_dspv2_muls_s32_hs(cpu_R[rz], cpu_R[rz],
+                                     cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULA_S32_RHS:
+        gen_helper_dspv2_mula_s32_rhs(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULS_S32_RHS:
+        gen_helper_dspv2_muls_s32_rhs(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULLL_S16:
+        dspv2_insn_mulll_s16(rz, rx, ry);
+        break;
+    case OP_MULHH_S16:
+        dspv2_insn_mulhh_s16(rz, rx, ry);
+        break;
+    case OP_MULHL_S16:
+        dspv2_insn_mulhl_s16(rz, rx, ry);
+        break;
+    case OP_RMULLL_S16:
+        gen_helper_dspv2_rmulll_s16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_RMULHH_S16:
+        gen_helper_dspv2_rmulhh_s16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_RMULHL_S16:
+        gen_helper_dspv2_rmulhl_s16(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULALL_S16_S:
+        gen_helper_dspv2_mulall_s16_s(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULAHH_S16_S:
+        gen_helper_dspv2_mulahh_s16_s(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULAHL_S16_S:
+        gen_helper_dspv2_mulahl_s16_s(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULALL_S16_E:
+        dspv2_insn_mulall_s16_e(rz, rx, ry);
+        break;
+    case OP_MULAHH_S16_E:
+        dspv2_insn_mulahh_s16_e(rz, rx, ry);
+        break;
+    case OP_MULAHL_S16_E:
+        dspv2_insn_mulahl_s16_e(rz, rx, ry);
+        break;
+    case OP_PMUL_U16:
+        dspv2_insn_pmul_u16(rz, rx, ry);
+        break;
+    case OP_PMULX_U16:
+        dspv2_insn_pmulx_u16(rz, rx, ry);
+        break;
+    case OP_PMUL_S16:
+        dspv2_insn_pmul_s16(rz, rx, ry);
+        break;
+    case OP_PMULX_S16:
+        dspv2_insn_pmulx_s16(rz, rx, ry);
+        break;
+    case OP_PRMUL_S16:
+        dspv2_insn_prmul_s16(rz, rx, ry);
+        break;
+    case OP_PRMULX_S16:
+        dspv2_insn_prmulx_s16(rz, rx, ry);
+        break;
+    case OP_PRMUL_S16_H:
+        gen_helper_dspv2_prmul_s16_h(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PRMUL_S16_RH:
+        gen_helper_dspv2_prmul_s16_rh(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PRMULX_S16_H:
+        gen_helper_dspv2_prmulx_s16_h(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_PRMULX_S16_RH:
+        gen_helper_dspv2_prmulx_s16_rh(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    default:
+        generate_exception(s, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "unknown dspv2 insn pc=%x opc=%x\n",
+                      s->pc, insn);
+        break;
+    }
+}
+
+static inline void dspv2_insn_mulxl_s32(int rz, int rx, int ry)
+{
+    /* Rz[31:0] = {Rx[31:0] X Ry[15:0]}[47:16] */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_ext16s_i64(t1, t1);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_shri_i64(t0, t0, 16);
+    tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_mulxl_s32_r(int rz, int rx, int ry)
+{
+    /* Rz[31:0] = {Rx[31:0] X Ry[15:0]}[47:16] */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_ext16s_i64(t1, t1);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_addi_i64(t0, t0, 0x8000);
+    tcg_gen_shri_i64(t0, t0, 16);
+    tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_mulxh_s32(int rz, int rx, int ry)
+{
+    /* Rz[31:0] = {Rx[31:0] X Ry[15:0]}[47:16] */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_shri_i64(t1, t1, 16);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_shri_i64(t0, t0, 16);
+    tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_mulxh_s32_r(int rz, int rx, int ry)
+{
+    /* Rz[31:0] = {Rx[31:0] X Ry[15:0]}[47:16] */
+    TCGv_i64 t0 = tcg_temp_new_i64();
+    TCGv_i64 t1 = tcg_temp_new_i64();
+    tcg_gen_ext_i32_i64(t0, cpu_R[rx]);
+    tcg_gen_ext_i32_i64(t1, cpu_R[ry]);
+    tcg_gen_shri_i64(t1, t1, 16);
+    tcg_gen_mul_i64(t0, t0, t1);
+    tcg_gen_addi_i64(t0, t0, 0x8000);
+    tcg_gen_shri_i64(t0, t0, 16);
+    tcg_gen_extrl_i64_i32(cpu_R[rz], t0);
+    tcg_temp_free_i64(t0);
+    tcg_temp_free_i64(t1);
+}
+
+static inline void dspv2_insn_mulcs_s16(int rz, int rx, int ry)
+{
+    /* rz = rx[15:0] * ry[15:0] - rx[31:16] * ry[31:16], signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    /* lo_rx * lo_ry */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t2, t0, t1);
+    /* hi_rx * hi_ry */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_sub_i32(cpu_R[rz], t2, t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_mulcsr_s16(int rz, int rx, int ry)
+{
+    /* rz = rx[31:16] * ry[31:16] - rx[15:0] * ry[15:0], signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    /* lo_rx * lo_ry */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t2, t0, t1);
+    /* hi_rx * hi_ry */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_sub_i32(cpu_R[rz], t0, t2);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_mulcsx_s16(int rz, int rx, int ry)
+{
+    /* rz = rx[15:0] * ry[31:16] - rx[31:16] * ry[15:0], signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i32 t2 = tcg_temp_new_i32();
+    /* lo_rx * hi_ry */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(t2, t0, t1);
+    /* hi_rx * lo_ry */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_sub_i32(cpu_R[rz], t2, t0);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i32(t2);
+}
+
+static inline void dspv2_insn_mulaca_s16_e(int rz, int rx, int ry)
+{
+    /* {rz+1, rz} = {rz+1, rz} + rx[15:0] * ry[15:0] + rx[31:16] * ry[31:16],
+     * signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t2, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    /* {rz+1, rz} = {rz+1, rz} + lo_x * lo_y */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_add_i64(t2, t2, t3);
+    /* {rz+1, rz} = {rz+1, rz} + hi_x * hi_y */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_add_i64(t2, t2, t3);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t2);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+}
+
+static inline void dspv2_insn_mulacax_s16_e(int rz, int rx, int ry)
+{
+    /* {rz+1, rz} = {rz+1, rz} + rx[31:16] * ry[15:0] + rx[15:0] * ry[31:16],
+     * signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t2, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    /* {rz+1, rz} = {rz+1, rz} + hi_x * lo_y */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_add_i64(t2, t2, t3);
+    /* {rz+1, rz} = {rz+1, rz} + lo_x * hi_y */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_add_i64(t2, t2, t3);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t2);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+}
+
+static inline void dspv2_insn_mulacs_s16_e(int rz, int rx, int ry)
+{
+    /* {rz+1, rz} = {rz+1, rz} + rx[15:0] * ry[15:0] - rx[31:16] * ry[31:16],
+     * signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t2, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    /* {rz+1, rz} = {rz+1, rz} + lo_x * lo_y */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_add_i64(t2, t2, t3);
+    /* {rz+1, rz} = {rz+1, rz} - hi_x * hi_y */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_sub_i64(t2, t2, t3);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t2);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+}
+
+static inline void dspv2_insn_mulacsr_s16_e(int rz, int rx, int ry)
+{
+    /* {rz+1, rz} = {rz+1, rz} + rx[31:16] * ry[31:16] - rx[15:0] * ry[15:0],
+     * signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t2, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    /* {rz+1, rz} = {rz+1, rz} - lo_x * lo_y */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_sub_i64(t2, t2, t3);
+    /* {rz+1, rz} = {rz+1, rz} + hi_x * hi_y */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_add_i64(t2, t2, t3);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t2);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+}
+
+static inline void dspv2_insn_mulacsx_s16_e(int rz, int rx, int ry)
+{
+    /* {rz+1, rz} = {rz+1, rz} + rx[15:0] * ry[31:16] - rx[31:16] * ry[15:0],
+     * signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t2, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    /* {rz+1, rz} = {rz+1, rz} - hi_x * lo_y */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_sub_i64(t2, t2, t3);
+    /* {rz+1, rz} = {rz+1, rz} + lo_x * hi_y */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_add_i64(t2, t2, t3);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t2);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+}
+
+static inline void dspv2_insn_mulsca_s16_e(int rz, int rx, int ry)
+{
+    /* {rz+1, rz} = {rz+1, rz} - rx[15:0] * ry[15:0] - rx[31:16] * ry[31:16],
+     * signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t2, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    /* {rz+1, rz} = {rz+1, rz} + lo_x * lo_y */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_sub_i64(t2, t2, t3);
+    /* {rz+1, rz} = {rz+1, rz} + hi_x * hi_y */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_sub_i64(t2, t2, t3);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t2);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+}
+
+static inline void dspv2_insn_mulscax_s16_e(int rz, int rx, int ry)
+{
+    /* {rz+1, rz} = {rz+1, rz} - rx[31:16] * ry[15:0] - rx[15:0] * ry[31:16],
+     * signed */
+    TCGv_i32 t0 = tcg_temp_new_i32();
+    TCGv_i32 t1 = tcg_temp_new_i32();
+    TCGv_i64 t2 = tcg_temp_new_i64();
+    TCGv_i64 t3 = tcg_temp_new_i64();
+    tcg_gen_concat_i32_i64(t2, cpu_R[rz], cpu_R[(rz + 1) % 32]);
+    /* {rz+1, rz} = {rz+1, rz} + hi_x * lo_y */
+    tcg_gen_sari_i32(t0, cpu_R[rx], 16);
+    tcg_gen_ext16s_i32(t1, cpu_R[ry]);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_sub_i64(t2, t2, t3);
+    /* {rz+1, rz} = {rz+1, rz} + lo_x * hi_y */
+    tcg_gen_ext16s_i32(t0, cpu_R[rx]);
+    tcg_gen_sari_i32(t1, cpu_R[ry], 16);
+    tcg_gen_mul_i32(t0, t0, t1);
+    tcg_gen_ext_i32_i64(t3, t0);
+    tcg_gen_sub_i64(t2, t2, t3);
+    tcg_gen_extr_i64_i32(cpu_R[rz], cpu_R[(rz + 1) % 32], t2);
+    tcg_temp_free_i32(t0);
+    tcg_temp_free_i32(t1);
+    tcg_temp_free_i64(t2);
+    tcg_temp_free_i64(t3);
+}
+
+static inline void dspv2_sop_mul_2nd(CPUState *cs,
+                                     DisasContext *s, uint32_t insn)
+{
+    int thop, rz, rx, ry;
+    thop = (insn >> CSKY_DSPV2_THOP_SHI) & CSKY_DSPV2_THOP_MASK;
+    rz = (insn >> CSKY_DSPV2_REG_SHI_RZ) & CSKY_DSPV2_REG_MASK;
+    rx = (insn >> CSKY_DSPV2_REG_SHI_RX) & CSKY_DSPV2_REG_MASK;
+    ry = (insn >> CSKY_DSPV2_REG_SHI_RY) & CSKY_DSPV2_REG_MASK;
+
+    switch (thop) {
+    case OP_MULXL_S32:
+        dspv2_insn_mulxl_s32(rz, rx, ry);
+        break;
+    case OP_MULXL_S32_R:
+        dspv2_insn_mulxl_s32_r(rz, rx, ry);
+        break;
+    case OP_MULXH_S32:
+        dspv2_insn_mulxh_s32(rz, rx, ry);
+        break;
+    case OP_MULXH_S32_R:
+        dspv2_insn_mulxh_s32_r(rz, rx, ry);
+        break;
+    case OP_RMULXL_S32:
+        gen_helper_dspv2_rmulxl_s32(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_RMULXL_S32_R:
+        gen_helper_dspv2_rmulxl_s32_r(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_RMULXH_S32:
+        gen_helper_dspv2_rmulxh_s32(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_RMULXH_S32_R:
+        gen_helper_dspv2_rmulxh_s32_r(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULAXL_S32_S:
+        gen_helper_dspv2_mulaxl_s32_s(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULAXL_S32_RS:
+        gen_helper_dspv2_mulaxl_s32_rs(cpu_R[rz], cpu_R[rz],
+                                       cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULAXH_S32_S:
+        gen_helper_dspv2_mulaxh_s32_s(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULAXH_S32_RS:
+        gen_helper_dspv2_mulaxh_s32_rs(cpu_R[rz], cpu_R[rz],
+                                       cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULCA_S16_S:
+        gen_helper_dspv2_mulca_s16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULCAX_S16_S:
+        gen_helper_dspv2_mulcax_s16_s(cpu_R[rz], cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULCS_S16:
+        dspv2_insn_mulcs_s16(rz, rx, ry);
+        break;
+    case OP_MULCSR_S16:
+        dspv2_insn_mulcsr_s16(rz, rx, ry);
+        break;
+    case OP_MULCSX_S16:
+        dspv2_insn_mulcsx_s16(rz, rx, ry);
+        break;
+    case OP_MULACA_S16_S:
+        gen_helper_dspv2_mulaca_s16_s(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULACAX_S16_S:
+        gen_helper_dspv2_mulacax_s16_s(cpu_R[rz], cpu_R[rz],
+                                       cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULACS_S16_S:
+        gen_helper_dspv2_mulacs_s16_s(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULACSR_S16_S:
+        gen_helper_dspv2_mulacsr_s16_s(cpu_R[rz], cpu_R[rz],
+                                       cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULACSX_S16_S:
+        gen_helper_dspv2_mulacsx_s16_s(cpu_R[rz], cpu_R[rz],
+                                       cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULSCA_S16_S:
+        gen_helper_dspv2_mulsca_s16_s(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULSCAX_S16_S:
+        gen_helper_dspv2_mulscax_s16_s(cpu_R[rz], cpu_R[rz],
+                                      cpu_R[rx], cpu_R[ry]);
+        break;
+    case OP_MULACA_S16_E:
+        dspv2_insn_mulaca_s16_e(rz, rx, ry);
+        break;
+    case OP_MULACAX_S16_E:
+        dspv2_insn_mulacax_s16_e(rz, rx, ry);
+        break;
+    case OP_MULACS_S16_E:
+        dspv2_insn_mulacs_s16_e(rz, rx, ry);
+        break;
+    case OP_MULACSR_S16_E:
+        dspv2_insn_mulacsr_s16_e(rz, rx, ry);
+        break;
+    case OP_MULACSX_S16_E:
+        dspv2_insn_mulacsx_s16_e(rz, rx, ry);
+        break;
+    case OP_MULSCA_S16_E:
+        dspv2_insn_mulsca_s16_e(rz, rx, ry);
+        break;
+    case OP_MULSCAX_S16_E:
+        dspv2_insn_mulscax_s16_e(rz, rx, ry);
+        break;
+    default:
+        generate_exception(s, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "unknown dspv2 insn pc=%x opc=%x\n",
+                      s->pc, insn);
+        break;
+    }
+}
+
+static void disas_dspv2_insn(CPUState *cs, DisasContext *s, uint32_t insn)
+{
+    int sop;
+    sop = (insn >> CSKY_DSPV2_SOP_SHI) & CSKY_DSPV2_SOP_MASK;
+    if (sop != DSPV2_MUL_1st) {
+        check_insn(s, ABIV2_EDSP);
+    }
+    switch (sop) {
+    case DSPV2_ADD_SUB:
+        dspv2_sop_add_sub(cs, s, insn);
+        break;
+    case DSPV2_CMP:
+        dspv2_sop_cmp(cs, s, insn);
+        break;
+    case DSPV2_SEL:
+        dspv2_sop_sel(cs, s, insn);
+        break;
+    case DSPV2_MISC:
+        dspv2_sop_misc(cs, s, insn);
+        break;
+    case DSPV2_SHIFT:
+        dspv2_sop_shift(cs, s, insn);
+        break;
+    case DSPV2_PKG_begin ... DSPV2_PKG_end:
+        dspv2_sop_pkg(cs, s, insn);
+        break;
+    case DSPV2_DEXT:
+        dspv2_sop_dext(cs, s, insn);
+        break;
+    case DSPV2_PKG_CLIP:
+        dspv2_sop_pkg_clip(cs, s, insn);
+        break;
+    case DSPV2_MUL_1st:
+        dspv2_sop_mul_1st(cs, s, insn);
+        break;
+    case DSPV2_MUL_2nd:
+        dspv2_sop_mul_2nd(cs, s, insn);
+        break;
+    default:
+        generate_exception(s, EXCP_CSKY_UDEF);
+        qemu_log_mask(LOG_GUEST_ERROR,
+                      "unknown dspv2 insn pc=%x opc=%x\n", s->pc, insn);
+        break;
+    }
+}
+
+static inline void cp(DisasContext *ctx, int cprz, int rx, uint32_t sop,
+                       int imm)
+{
+    switch (sop) {
+    case 0x0: /*cprgr*/
+        break;
+    case 0x1: /*cpwgr*/
+        break;
+    case 0x2: /*cprcr*/
+        break;
+    case 0x3: /*cpwcr*/
+        break;
+    case 0x4: /*cprc*/
+        break;
+    case 0x8: /*ldcpr*/
+        break;
+    case 0xa: /*stcpr*/
+        break;
+    case 0xc: /*cpop*/
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static void disas_csky_32_insn(CPUCSKYState *env, DisasContext *ctx)
+{
+    uint32_t insn, op, sop, pcode;
+    int rz, rx, ry, imm;
+    CSKYCPU *cpu = csky_env_get_cpu(env);
+    CPUState *cs = CPU(cpu);
+
+    insn = ctx->insn;
+    op = (insn >> 26) & 0xf; /* bits:29-26 */
+
+    switch (op) {
+    case 0x0: /*special*/
+        rx = (insn >> 16) & 0x1f;
+        ry = (insn >> 21) & 0x1f;
+        sop = (insn >> 10) & 0x3f;
+        rz = insn & 0x1f;
+        special(ctx, rx, sop, rz, ry);
+        break;
+    case 0x1:/*arth_reg*/
+        ry = (insn >> 21) & 0x1f;
+        rx = (insn >> 16) & 0x1f;
+        sop = (insn >> 10) & 0x3f;
+        pcode = (insn >> 5) & 0x1f;
+        rz = insn & 0x1f;
+        arth_reg32(ctx, ry, rx, sop, pcode, rz);
+        break;
+    case 0x3:/*lrs_srs*/
+        rz = (insn >> 21) & 0x1f;
+        sop = (insn >> 18) & 0x7;
+        imm = insn & 0x3ffff;
+        lrs(ctx, rz, sop, imm);
+        break;
+    case 0x4:/*ldr*/
+        ry = (insn >> 21) & 0x1f;
+        rx = (insn >> 16) & 0x1f;
+        sop = (insn >> 10) & 0x3f;
+        pcode = (insn >> 5) & 0x1f;
+        rz = insn & 0x1f;
+        ldr(ctx, sop, pcode, rz, rx, ry);
+        break;
+    case 0x5:/*str*/
+        ry = (insn >> 21) & 0x1f;
+        rx = (insn >> 16) & 0x1f;
+        sop = (insn >> 10) & 0x3f;
+        pcode = (insn >> 5) & 0x1f;
+        rz = insn & 0x1f;
+        str(ctx, sop, pcode, rz, rx, ry);
+        break;
+    case 0x6:/*ldi*/
+        rz = (insn >> 21) & 0x1f;
+        rx = (insn >> 16) & 0x1f;
+        sop = (insn >> 12) & 0xf;
+        imm = insn & 0xfff;
+        ldi(ctx, sop, rz, rx, imm);
+        break;
+    case 0x7:/*sti*/
+        rz = (insn >> 21) & 0x1f;
+        rx = (insn >> 16) & 0x1f;
+        sop = (insn >> 12) & 0xf;
+        imm = insn & 0xfff;
+        sti(ctx, sop, rz, rx, imm);
+        break;
+    case 0x8:/*bsr*/
+        imm = insn & 0x3ffffff;
+        tcg_gen_movi_tl(cpu_R[15], ctx->pc + 4);
+        bsr32(ctx, imm);
+        break;
+    case 0x9:/*imm_2op*/
+        rz = (insn >> 21) & 0x1f;
+        rx = (insn >> 16) & 0x1f;
+        sop = (insn >> 12) & 0xf;
+        imm = insn & 0xfff;
+        imm_2op(ctx, rz, rx, sop, imm);
+        break;
+    case 0xa:/*imm_1op*/
+        sop = (insn >> 21) & 0x1f;
+        rx = (insn >> 16) & 0x1f;
+        imm = insn & 0xffff;
+        imm_1op(ctx, sop, rx, imm);
+        break;
+    case 0xb:/*ori*/
+        check_insn_except(ctx, CPU_801);
+        rz = (insn >> 21) & 0x1f;
+        rx = (insn >> 16) & 0x1f;
+        imm = insn & 0xffff;
+        tcg_gen_ori_tl(cpu_R[rz], cpu_R[rx], imm);
+        break;
+    case 0xd:/*vfp*/
+        disas_vfp_insn(env, ctx, insn);
+        gen_save_pc(ctx->pc);
+        gen_helper_vfp_check_exception(cpu_env);
+        break;
+    case 0xe:/*vdsp or dspv2 instructions. */
+        if (has_insn(ctx, ABIV2_VDSP128)) {
+            disas_vdsp_insn128(cs, ctx, insn);
+        } else if (has_insn(ctx, ABIV2_VDSP64)) {
+            disas_vdsp_insn64(cs, ctx, insn);
+        } else if (has_insn(ctx, CPU_803S)) {
+            disas_dspv2_insn(cs, ctx, insn);
+        } else {
+            generate_exception(ctx, EXCP_CSKY_UDEF);
+            qemu_log_mask(LOG_GUEST_ERROR,
+                          "unknown dsp insn pc=%x opc=%x\n", ctx->pc, insn);
+        }
+        break;
+    case 0xf:/*cp*/
+        rz = (insn >> 21) & 0x1f;
+        rx = (insn >> 16) & 0x1f;
+        sop = (insn >> 12) & 0xf;
+        imm = insn & 0xfff;
+        cp(ctx, rz, rx, sop, imm);
+        break;
+    default:
+        generate_exception(ctx, EXCP_CSKY_UDEF);
+        break;
+    }
+}
+
+static void csky_tb_start(CPUCSKYState *env, TranslationBlock *tb)
+{
+    uint32_t tb_pc = (uint32_t)tb->pc;
+    TCGv t0 = tcg_temp_new();
+
+    t0 = tcg_const_tl(tb_pc);
+    gen_helper_tb_trace(cpu_env, t0);
+    tcg_temp_free(t0);
+}
+
+static void csky_dump_tb_map(CPUCSKYState *env, TranslationBlock *tb)
+{
+    uint32_t tb_pc = (uint32_t)tb->pc;
+    uint32_t tb_end =  tb_pc + (uint32_t)tb->size;
+    uint32_t icount = (uint32_t)tb->icount;
+
+    qemu_log_mask(CPU_TB_TRACE, "tb_map: 0x%.8x 0x%.8x %d\n",
+                  tb_pc, tb_end, icount);
+}
+
+static int jcount_start_insn_idx;
+static void gen_csky_jcount_start(CPUCSKYState *env, TranslationBlock *tb)
+{
+    uint32_t tb_pc = (uint32_t)tb->pc;
+    TCGv t0 = tcg_temp_new();
+    TCGv t1 = tcg_temp_new_i32();
+    /* We emit a movi with a dummy immediate argument. Keep the insn index
+     * of the movi so that we later (when we know the actual insn count)
+     * can update the immediate argument with the actual insn count.  */
+    jcount_start_insn_idx = tcg_op_buf_count();
+    tcg_gen_movi_i32(t1, 0xdeadbeef);
+
+    t0 = tcg_const_tl(tb_pc);
+    gen_helper_jcount(cpu_env, t0, t1);
+    tcg_temp_free(t0);
+    tcg_temp_free(t1);
+}
+
+static void gen_csky_jcount_end(int num_insns)
+{
+    tcg_set_insn_param(jcount_start_insn_idx, 1, num_insns);
+}
+
+/* generate intermediate code in tcg_ctx.gen_opc_buf and gen_opparam_buf for
+basic block 'tb'. If search_pc is TRUE, also generate PC
+information for each intermediate instruction. */
+void gen_intermediate_code(CPUCSKYState *env, TranslationBlock *tb)
+{
+    CSKYCPU *cpu = csky_env_get_cpu(env);
+    CPUState *cs = CPU(cpu);
+    DisasContext ctx1, *ctx = &ctx1;
+    target_ulong pc_start;
+    uint32_t next_page_start;
+    int max_insns;
+    int num_insns;
+    uint32_t cond;
+    TCGv t0 = tcg_temp_new();
+
+    cpu_F0s = tcg_temp_new_i32();
+    cpu_F1s = tcg_temp_new_i32();
+    cpu_F0d = tcg_temp_new_i64();
+    cpu_F1d = tcg_temp_new_i64();
+
+    pc_start = tb->pc;
+
+    ctx->pc = pc_start;
+    ctx->tb = tb;
+    ctx->singlestep_enabled = cs->singlestep_enabled;
+    ctx->is_jmp = DISAS_NEXT;
+    ctx->bctm = CSKY_TBFLAG_PSR_BM(tb->flags);
+    ctx->features = env->features;
+
+#ifndef CONFIG_USER_ONLY
+    ctx->super = CSKY_TBFLAG_PSR_S(tb->flags);
+    ctx->trust = CSKY_TBFLAG_PSR_T(tb->flags);
+    ctx->current_cp = CSKY_TBFLAG_CPID(tb->flags);
+    ctx->trace_mode = (TraceMode)CSKY_TBFLAG_PSR_TM(tb->flags);
+#endif
+
+#ifdef CONFIG_USER_ONLY
+    ctx->mem_idx = CSKY_USERMODE;
+#else
+    ctx->mem_idx = ctx->super;
+#endif
+
+    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;
+    num_insns = 0;
+    max_insns = tb->cflags & CF_COUNT_MASK;
+    if (max_insns == 0) {
+        max_insns = CF_COUNT_MASK;
+    }
+    if (max_insns > TCG_MAX_INSNS) {
+        max_insns = TCG_MAX_INSNS;
+    }
+    cond = env->sce_condexec_bits;
+
+    gen_tb_start(tb);
+    if (env->jcount_start != 0) {
+        gen_csky_jcount_start(env, tb);
+    }
+
+    if (env->tb_trace == 1) {
+        csky_tb_start(env, tb);
+    }
+
+    /* for sce */
+    if (unlikely(cond != 1)) {
+        TCGv t0 = tcg_temp_new();
+        do {
+#if !defined(CONFIG_USER_ONLY)
+            ctx->cannot_be_traced = 0;
+            ctx->maybe_change_flow = 0;
+#endif
+#ifdef CONFIG_USER_ONLY
+            if (ctx->pc >= 0x80000000) {
+                generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+                break;
+            }
+#endif
+
+            tcg_gen_insn_start(ctx->pc);
+            num_insns++;
+
+            if (unlikely(cpu_breakpoint_test(cs, ctx->pc, BP_ANY))) {
+                generate_exception(ctx, EXCP_DEBUG);
+                ctx->is_jmp = DISAS_JUMP;
+                ctx->pc += 2;
+                goto done_generating;
+                break;
+            }
+
+            if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {
+                gen_io_start();
+            }
+
+            ctx->insn = cpu_lduw_code(env, ctx->pc);
+
+            if ((cond & 0x1) == 1) {
+                if ((ctx->insn & 0xc000) != 0xc000) {
+                    /* 16 bit instruction*/
+                    disas_csky_16_insn(env, ctx);
+                    ctx->pc += 2;
+                } else {
+                    /*32 bit instruction*/
+                    ctx->insn = (ctx->insn << 16) |
+                        cpu_lduw_code(env, ctx->pc + 2);
+                    disas_csky_32_insn(env, ctx);
+                    ctx->pc += 4;
+                }
+#if !defined(CONFIG_USER_ONLY)
+                if (ctx->trace_mode == INST_TRACE_MODE) {
+                    cond >>= 1;
+                    t0 = tcg_const_tl(cond);
+                    store_cpu_field(t0, sce_condexec_bits);
+                    generate_exception(ctx, EXCP_CSKY_TRACE);
+                    num_insns++;
+                    goto done_translation;
+                }
+#endif
+            } else {
+                if ((ctx->insn & 0xc000) != 0xc000) {
+                    /* 16 bit instruction*/
+                    ctx->pc += 2;
+                } else {
+                    /*32 bit instruction*/
+                    ctx->pc += 4;
+                }
+            }
+            cond >>= 1;
+
+            if (cond == 0x1) {
+                break;
+            }
+        } while (!ctx->is_jmp && !tcg_op_buf_full() &&
+            !cs->singlestep_enabled &&
+            !singlestep &&
+            ctx->pc < next_page_start &&
+            num_insns < max_insns);
+
+        t0 = tcg_const_tl(cond);
+        store_cpu_field(t0, sce_condexec_bits);
+        gen_save_pc(ctx->pc);
+        ctx->is_jmp = DISAS_UPDATE;
+
+        goto done_translation;
+    }
+
+    /* for idly */
+#if !defined(CONFIG_USER_ONLY)
+    uint32_t idly4_counter;
+    idly4_counter = env->idly4_counter;
+    if (unlikely(idly4_counter != 0)) {
+        TCGv t0 = tcg_temp_new();
+        do {
+            tcg_gen_insn_start(ctx->pc);
+            num_insns++;
+
+            if (unlikely(cpu_breakpoint_test(cs, ctx->pc, BP_ANY))) {
+                generate_exception(ctx, EXCP_DEBUG);
+                ctx->is_jmp = DISAS_JUMP;
+                ctx->pc += 2;
+                goto done_generating;
+                break;
+            }
+
+            if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {
+                gen_io_start();
+            }
+
+            ctx->insn = cpu_lduw_code(env, ctx->pc);
+
+            if ((cond & 0x1) == 1) {
+                if ((ctx->insn & 0xc000) != 0xc000) {
+                    /* 16 bit instruction*/
+                    disas_csky_16_insn(env, ctx);
+                    ctx->pc += 2;
+                } else {
+                    /*32 bit instruction*/
+                    ctx->insn = (ctx->insn << 16) |
+                        cpu_lduw_code(env, ctx->pc + 2);
+                    disas_csky_32_insn(env, ctx);
+                    ctx->pc += 4;
+                }
+            } else {
+                if ((ctx->insn & 0xc000) != 0xc000) {
+                    /* 16 bit instruction*/
+                    ctx->pc += 2;
+                } else {
+                    /*32 bit instruction*/
+                    ctx->pc += 4;
+                }
+            }
+
+            idly4_counter--;
+            num_insns++;
+
+            if (!idly4_counter) {
+                break;
+            }
+        } while (!ctx->is_jmp && !tcg_op_buf_full() &&
+            !cs->singlestep_enabled &&
+            !singlestep &&
+            ctx->pc < next_page_start &&
+            num_insns < max_insns);
+
+        t0 = tcg_const_tl(idly4_counter);
+        store_cpu_field(t0, idly4_counter);
+
+        goto done_translation;
+    }
+#endif
+
+    do {
+#if !defined(CONFIG_USER_ONLY)
+        ctx->cannot_be_traced = 0;
+        ctx->maybe_change_flow = 0;
+#endif
+#ifdef CONFIG_USER_ONLY
+        if (ctx->pc >= 0x80000000) {
+            generate_exception(ctx, EXCP_CSKY_PRIVILEGE);
+            break;
+        }
+#endif
+
+        tcg_gen_insn_start(ctx->pc);
+        num_insns++;
+
+        if (unlikely(cpu_breakpoint_test(cs, ctx->pc, BP_ANY))) {
+            generate_exception(ctx, EXCP_DEBUG);
+            ctx->is_jmp = DISAS_JUMP;
+            ctx->pc += 2;
+            goto done_generating;
+            break;
+        }
+
+        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {
+            gen_io_start();
+        }
+
+        ctx->insn = cpu_lduw_code(env, ctx->pc);
+
+        if ((ctx->insn & 0xc000) != 0xc000) {
+            /* 16 bit instruction*/
+            disas_csky_16_insn(env, ctx);
+            ctx->pc += 2;
+        } else {
+            /*32 bit instruction*/
+            ctx->insn = (ctx->insn << 16) | cpu_lduw_code(env, ctx->pc + 2);
+            disas_csky_32_insn(env, ctx);
+            ctx->pc += 4;
+        }
+
+#if !defined(CONFIG_USER_ONLY)
+        if (ctx->cannot_be_traced) {
+            break;
+        }
+        if (ctx->trace_mode == INST_TRACE_MODE) {
+            if (!ctx->maybe_change_flow) {
+                generate_exception(ctx, EXCP_CSKY_TRACE);
+            }
+            break;
+        }
+#endif
+
+    } while (!ctx->is_jmp && !tcg_op_buf_full() &&
+        !cs->singlestep_enabled &&
+        !singlestep &&
+        ctx->pc < next_page_start &&
+        num_insns < max_insns);
+
+done_translation:
+    if (tb->cflags & CF_LAST_IO) {
+        gen_io_end();
+    }
+
+    if (unlikely(cs->singlestep_enabled)) {
+        if (!ctx->is_jmp) {
+            generate_exception(ctx, EXCP_DEBUG);
+        } else if (ctx->is_jmp != DISAS_TB_JUMP) {
+            t0 = tcg_const_tl(EXCP_DEBUG);
+            gen_helper_exception(cpu_env, t0);
+        }
+    } else {
+        switch (ctx->is_jmp) {
+        case DISAS_NEXT:
+            gen_goto_tb(ctx, 1, ctx->pc);
+            break;
+        case DISAS_JUMP:
+        case DISAS_UPDATE:
+            /* indicate that the hash table must be used to find the next TB */
+            tcg_gen_exit_tb(0);
+            break;
+        case DISAS_TB_JUMP:
+            /* nothing more to generate */
+            break;
+        }
+    }
+
+done_generating:
+    if (env->jcount_start != 0) {
+        gen_csky_jcount_end(num_insns);
+    }
+
+    gen_tb_end(tb, num_insns);
+
+    tcg_temp_free(t0);
+    tcg_temp_free_i32(cpu_F0s);
+    tcg_temp_free_i32(cpu_F1s);
+    tcg_temp_free_i64(cpu_F0d);
+    tcg_temp_free_i64(cpu_F1d);
+
+    tb->size = ctx->pc - pc_start;
+    tb->icount = num_insns;
+    if (env->tb_trace == 1) {
+        csky_dump_tb_map(env, tb);
+    }
+}
+
+
+void csky_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,
+                         int flags)
+{
+    CSKYCPU *cpu = CSKY_CPU(cs);
+    CPUCSKYState *env = &cpu->env;
+    int i;
+
+    for (i = 0; i < 32; i++) {
+        cpu_fprintf(f, "R%02d=0x%08x", i, env->regs[i]);
+        if ((i % 4) == 3) {
+            cpu_fprintf(f, "\n");
+        } else {
+            cpu_fprintf(f, " ");
+        }
+    }
+
+    for (i = 0; i < 16; i++) {
+        cpu_fprintf(f, "vr%02d=0x%16llx", i,
+                    (long long unsigned int)env->vfp.reg[i].fpu[0]);
+        if ((i % 3) == 2) {
+            cpu_fprintf(f, "\n");
+        } else {
+            cpu_fprintf(f, " ");
+        }
+    }
+
+    cpu_fprintf(f, "pc=%08x\n", env->pc);
+
+    env->cp0.psr &= ~0x8000c401;
+    env->cp0.psr |= env->psr_s << 31;
+    env->cp0.psr |= env->psr_tm << 14;
+    env->cp0.psr |= env->psr_bm << 10;
+    env->cp0.psr |= env->psr_c;
+    cpu_fprintf(f, "psr=%08x\n", env->cp0.psr);
+    cpu_fprintf(f, "sp=%08x\n", env->regs[14]);
+    cpu_fprintf(f, "spv_sp=%08x\n", env->stackpoint.nt_ssp);
+    cpu_fprintf(f, "epsr=%08x ", env->cp0.epsr);
+    cpu_fprintf(f, "epc=%08x ", env->cp0.epc);
+    cpu_fprintf(f, "cr18=%08x\n", env->cp0.capr);
+}
+
+void restore_state_to_opc(CPUCSKYState *env, TranslationBlock *tb,
+                          target_ulong *data)
+{
+    env->pc = data[0];
+}
diff --git a/tests/csky/board/smartl/ck803s/.gdbinit b/tests/csky/board/smartl/ck803s/.gdbinit
new file mode 100644
index 0000000..28932ca
--- /dev/null
+++ b/tests/csky/board/smartl/ck803s/.gdbinit
@@ -0,0 +1,6 @@
+target jtag jtag://172.16.28.48:1025
+reset
+lo
+run
+i r r0
+quit
diff --git a/tests/csky/board/smartl/ck803s/CSICORE_CK803S.h b/tests/csky/board/smartl/ck803s/CSICORE_CK803S.h
new file mode 100755
index 0000000..ca003fe
--- /dev/null
+++ b/tests/csky/board/smartl/ck803s/CSICORE_CK803S.h
@@ -0,0 +1,1332 @@
+/******************************************************************************
+ * @file     CSICORE_CK803S.h
+ * @brief    CSI CK803S Core Peripheral Access Layer Header File
+ * @version  V1.0
+ * @date     20. July 2016
+ ******************************************************************************/
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+
+
+#ifndef __CORE_CK803S_H_GENERIC
+#define __CORE_CK803S_H_GENERIC
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/**
+  \page CSI_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CSI violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+/*******************************************************************************
+ *                 CSI definitions
+ ******************************************************************************/
+/**
+  \ingroup Ck803s
+  @{
+ */
+
+/*  CSI CK803S definitions */
+#define __CK803S_CSI_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CSI HAL main version */
+#define __CK803S_CSI_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CSI HAL sub version */
+#define __CK803S_CSI_VERSION       ((__CK803S_CSI_VERSION_MAIN << 16U) | \
+                                    __CK803S_CSI_VERSION_SUB           )        /*!< CSI HAL version number */
+
+#define __CK80X                (0x03U)                                         /*!< CK80X Core */
+
+#if defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
+  #define __STATIC_INLINE  static inline
+  #define __ALWAYS_INLINE  __attribute__((always_inline)) static inline
+#else
+  #error Unknown compiler
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not.
+    This core does not support an FPU at all
+*/
+#define __FPU_USED       0U
+
+#if defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+#endif
+
+#include "CSI_GCC.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CORE_CK803S_H_GENERIC */
+
+#ifndef __CSI_GENERIC
+
+#ifndef __CORE_CK803S_H_DEPENDANT
+#define __CORE_CK803S_H_DEPENDANT
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __CK803S_REV
+    #define __CK803S_REV               0x0000U
+    #warning "__CK803S_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          2U
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0U
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+
+  #ifndef __GSR_GCR_PRESENT
+    #define __GSR_GCR_PRESENT         0U
+    #warning "__GSR_GCR_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MGU_PRESENT
+    #define __MGU_PRESENT             0U
+    #warning "__MGU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __ICACHE_PRESENT
+    #define __ICACHE_PRESENT          0U
+    #warning "__ICACHE_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __DCACHE_PRESENT
+    #define __DCACHE_PRESENT          0U
+    #warning "__DCACHE_PRESENT not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CSI_glob_defs CSI Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions */
+
+/* following defines should be used for structure members */
+#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
+#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
+#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
+
+/*@} end of group CK803S */
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SysTick Register
+ ******************************************************************************/
+/**
+  \defgroup CSI_core_register Defines and Type Definitions
+  \brief Type definitions and defines for CK80X processor based devices.
+*/
+
+/**
+  \ingroup    CSI_core_register
+  \defgroup   CSI_CORE  Status and Control Registers
+  \brief      Core Register type definitions.
+  @{
+ */
+
+/**
+  \brief  访问处理器状态寄存器(PSR)的联合体定义.
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t C:1;                        /*!< bit:      0  条件码／进位位 */
+    uint32_t _reserved0:5;               /*!< bit:  2.. 5  保留 */
+    uint32_t IE:1;                       /*!< bit:      6  中断有效控制位 */
+    uint32_t IC:1;                       /*!< bit:      7  中断控制位 */
+    uint32_t EE:1;                       /*!< bit:      8  异常有效控制位 */
+    uint32_t MM:1;                       /*!< bit:      9  不对齐异常掩盖位 */
+    uint32_t _reserved1:6;               /*!< bit: 10..15  保留 */
+    uint32_t VEC:8;                      /*!< bit: 16..23  异常事件向量值 */
+    uint32_t _reserved2:7;               /*!< bit: 24..30  保留 */
+    uint32_t S:1;                        /*!< bit:     31  超级用户模式设置位 */
+  } b;                                   /*!< Structure    用来按位访问 */
+  uint32_t w;                            /*!< Type         整个寄存器访问 */
+} PSR_Type;
+
+/* PSR Register Definitions */
+#define PSR_S_Pos                          31U                                            /*!< PSR: S Position */
+#define PSR_S_Msk                          (1UL << PSR_S_Pos)                             /*!< PSR: S Mask */
+
+#define PSR_VEC_Pos                        16U                                            /*!< PSR: VEC Position */
+#define PSR_VEC_Msk                        (0x7FUL << PSR_VEC_Pos)                        /*!< PSR: VEC Mask */
+
+#define PSR_MM_Pos                         9U                                             /*!< PSR: MM Position */
+#define PSR_MM_Msk                         (1UL << PSR_MM_Pos)                            /*!< PSR: MM Mask */
+
+#define PSR_EE_Pos                         8U                                             /*!< PSR: EE Position */
+#define PSR_EE_Msk                         (1UL << PSR_EE_Pos)                            /*!< PSR: EE Mask */
+
+#define PSR_IC_Pos                         7U                                             /*!< PSR: IC Position */
+#define PSR_IC_Msk                         (1UL << PSR_IC_Pos)                            /*!< PSR: IC Mask */
+
+#define PSR_IE_Pos                         6U                                             /*!< PSR: IE Position */
+#define PSR_IE_Msk                         (1UL << PSR_IE_Pos)                            /*!< PSR: IE Mask */
+
+#define PSR_C_Pos                          0U                                             /*!< PSR: C Position */
+#define PSR_C_Msk                          (1UL << PSR_C_Pos)                             /*!< PSR: C Mask */
+
+/**
+  \brief  访问高速缓存配置寄存器(CCR, CR<18, 0>)的联合体定义.
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t MP:1;                       /*!< bit:      0  内存保护设置位 */
+    uint32_t _reserved0:6;               /*!< bit:  1.. 6  保留 */
+    uint32_t BE:1;                       /*!< bit:      7  Endian模式 */
+    uint32_t SCK:3;                      /*!< bit:  8..10  系统和处理器的时钟比 */
+    uint32_t _reserved1:2;               /*!< bit: 11..12  保留 */
+    uint32_t BE_V2:1;                    /*!< bit:     13  V2版本大小端 */
+    uint32_t _reserved2:18;              /*!< bit: 14..31  保留 */
+  } b;                                   /*!< Structure    用来按位访问 */
+  uint32_t w;                            /*!< Type         整个寄存器访问 */
+} CCR_Type;
+
+/* CCR Register Definitions */
+#define CCR_BE_V2_Pos                     13U                                            /*!< CCR: BE_V2 Position */
+#define CCR_BE_V2_Msk                     (0x1UL << CCR_ISR_Pos)                         /*!< CCR: BE_V2 Mask */
+
+#define CCR_SCK_Pos                       8U                                             /*!< CCR: SCK Position */
+#define CCR_SCK_Msk                       (0x3UL << CCR_SCK_Pos)                         /*!< CCR: SCK Mask */
+
+#define CCR_BE_Pos                        7U                                             /*!< CCR: BE Position */
+#define CCR_BE_Msk                        (0x1UL << CCR_BE_Pos)                          /*!< CCR: BE Mask */
+
+#define CCR_MP_Pos                        0U                                             /*!< CCR: MP Position */
+#define CCR_MP_Msk                        (0x1UL << CCR_MP_Pos)                          /*!< CCR: MP Mask */
+
+/**
+  \brief  访问可高缓和访问权限配置寄存器(CAPR, CR<19,0>)的联合体定义..
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t X0:1;                       /*!< bit:      0  不可执行属性设置位 */
+    uint32_t X1:1;                       /*!< bit:      1  不可执行属性设置位 */
+    uint32_t X2:1;                       /*!< bit:      2  不可执行属性设置位 */
+    uint32_t X3:1;                       /*!< bit:      3  不可执行属性设置位 */
+    uint32_t X4:1;                       /*!< bit:      4  不可执行属性设置位 */
+    uint32_t X5:1;                       /*!< bit:      5  不可执行属性设置位 */
+    uint32_t X6:1;                       /*!< bit:      6  不可执行属性设置位 */
+    uint32_t X7:1;                       /*!< bit:      7  不可执行属性设置位 */
+    uint32_t AP0:2;                      /*!< bit:  8.. 9  访问权限设置位 */
+    uint32_t AP1:2;                      /*!< bit: 10..11  访问权限设置位 */
+    uint32_t AP2:2;                      /*!< bit: 12..13  访问权限设置位 */
+    uint32_t AP3:2;                      /*!< bit: 14..15  访问权限设置位 */
+    uint32_t AP4:2;                      /*!< bit: 16..17  访问权限设置位 */
+    uint32_t AP5:2;                      /*!< bit: 18..19  访问权限设置位 */
+    uint32_t AP6:2;                      /*!< bit: 20..21  访问权限设置位 */
+    uint32_t AP7:2;                      /*!< bit: 22..23  访问权限设置位 */
+    uint32_t S0:1;                       /*!< bit:     24  安全属性设置位 */
+    uint32_t S1:1;                       /*!< bit:     25  安全属性设置位 */
+    uint32_t S2:1;                       /*!< bit:     26  安全属性设置位 */
+    uint32_t S3:1;                       /*!< bit:     27  安全属性设置位 */
+    uint32_t S4:1;                       /*!< bit:     28  安全属性设置位 */
+    uint32_t S5:1;                       /*!< bit:     29  安全属性设置位 */
+    uint32_t S6:1;                       /*!< bit:     30  安全属性设置位 */
+    uint32_t S7:1;                       /*!< bit:     31  安全属性设置位 */
+  } b;                                   /*!< Structure    用来按位访问 */
+  uint32_t w;                            /*!< Type         整个寄存器访问 */
+} CAPR_Type;
+
+/* CAPR Register Definitions */
+#define CAPR_S7_Pos                        31U                                            /*!< CAPR: S7 Position */
+#define CAPR_S7_Msk                        (1UL << CAPR_S7_Pos)                           /*!< CAPR: S7 Mask */
+
+#define CAPR_S6_Pos                        30U                                            /*!< CAPR: S6 Position */
+#define CAPR_S6_Msk                        (1UL << CAPR_S6_Pos)                           /*!< CAPR: S6 Mask */
+
+#define CAPR_S5_Pos                        29U                                            /*!< CAPR: S5 Position */
+#define CAPR_S5_Msk                        (1UL << CAPR_S5_Pos)                           /*!< CAPR: S5 Mask */
+
+#define CAPR_S4_Pos                        28U                                            /*!< CAPR: S4 Position */
+#define CAPR_S4_Msk                        (1UL << CAPR_S4_Pos)                           /*!< CAPR: S4 Mask */
+
+#define CAPR_S3_Pos                        27U                                            /*!< CAPR: S3 Position */
+#define CAPR_S3_Msk                        (1UL << CAPR_S3_Pos)                           /*!< CAPR: S3 Mask */
+
+#define CAPR_S2_Pos                        26U                                            /*!< CAPR: S2 Position */
+#define CAPR_S2_Msk                        (1UL << CAPR_S2_Pos)                           /*!< CAPR: S2 Mask */
+
+#define CAPR_S1_Pos                        25U                                            /*!< CAPR: S1 Position */
+#define CAPR_S1_Msk                        (1UL << CAPR_S1_Pos)                           /*!< CAPR: S1 Mask */
+
+#define CAPR_S0_Pos                        24U                                            /*!< CAPR: S0 Position */
+#define CAPR_S0_Msk                        (1UL << CAPR_S0_Pos)                           /*!< CAPR: S0 Mask */
+
+#define CAPR_AP7_Pos                       22U                                            /*!< CAPR: AP7 Position */
+#define CAPR_AP7_Msk                       (0x3UL << CAPR_AP7_Pos)                        /*!< CAPR: AP7 Mask */
+
+#define CAPR_AP6_Pos                       20U                                            /*!< CAPR: AP6 Position */
+#define CAPR_AP6_Msk                       (0x3UL << CAPR_AP6_Pos)                        /*!< CAPR: AP6 Mask */
+
+#define CAPR_AP5_Pos                       18U                                            /*!< CAPR: AP5 Position */
+#define CAPR_AP5_Msk                       (0x3UL << CAPR_AP5_Pos)                        /*!< CAPR: AP5 Mask */
+
+#define CAPR_AP4_Pos                       16U                                            /*!< CAPR: AP4 Position */
+#define CAPR_AP4_Msk                       (0x3UL << CAPR_AP4_Pos)                        /*!< CAPR: AP4 Mask */
+
+#define CAPR_AP3_Pos                       14U                                            /*!< CAPR: AP3 Position */
+#define CAPR_AP3_Msk                       (0x3UL << CAPR_AP3_Pos)                        /*!< CAPR: AP3 Mask */
+
+#define CAPR_AP2_Pos                       12U                                            /*!< CAPR: AP2 Position */
+#define CAPR_AP2_Msk                       (0x3UL << CAPR_AP2_Pos)                        /*!< CAPR: AP2 Mask */
+
+#define CAPR_AP1_Pos                       10U                                            /*!< CAPR: AP1 Position */
+#define CAPR_AP1_Msk                       (0x3UL << CAPR_AP1_Pos)                        /*!< CAPR: AP1 Mask */
+
+#define CAPR_AP0_Pos                       8U                                             /*!< CAPR: AP0 Position */
+#define CAPR_AP0_Msk                       (0x3UL << CAPR_AP0_Pos)                        /*!< CAPR: AP0 Mask */
+
+#define CAPR_X7_Pos                        7U                                             /*!< CAPR: X7 Position */
+#define CAPR_X7_Msk                        (0x1UL << CAPR_X7_Pos)                         /*!< CAPR: X7 Mask */
+
+#define CAPR_X6_Pos                        6U                                             /*!< CAPR: X6 Position */
+#define CAPR_X6_Msk                        (0x1UL << CAPR_X6_Pos)                         /*!< CAPR: X6 Mask */
+
+#define CAPR_X5_Pos                        5U                                             /*!< CAPR: X5 Position */
+#define CAPR_X5_Msk                        (0x1UL << CAPR_X5_Pos)                         /*!< CAPR: X5 Mask */
+
+#define CAPR_X4_Pos                        4U                                             /*!< CAPR: X4 Position */
+#define CAPR_X4_Msk                        (0x1UL << CAPR_X4_Pos)                         /*!< CAPR: X4 Mask */
+
+#define CAPR_X3_Pos                        3U                                             /*!< CAPR: X3 Position */
+#define CAPR_X3_Msk                        (0x1UL << CAPR_X3_Pos)                         /*!< CAPR: X3 Mask */
+
+#define CAPR_X2_Pos                        2U                                             /*!< CAPR: X2 Position */
+#define CAPR_X2_Msk                        (0x1UL << CAPR_X2_Pos)                         /*!< CAPR: X2 Mask */
+
+#define CAPR_X1_Pos                        1U                                             /*!< CAPR: X1 Position */
+#define CAPR_X1_Msk                        (0x1UL << CAPR_X1_Pos)                         /*!< CAPR: X1 Mask */
+
+#define CAPR_X0_Pos                        0U                                             /*!< CAPR: X0 Position */
+#define CAPR_X0_Msk                        (0x1UL << CAPR_X0_Pos)                         /*!< CAPR: X0 Mask */
+
+/**
+  \brief  访问保护区控制寄存器(PACR, CR<20,0>)的联合体定义.
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t E:1;                        /*!< bit:      0  保护区有效设置 */
+    uint32_t Size:5;                     /*!< bit:  1.. 5  保护区大小 */
+    uint32_t _reserved0:4;               /*!< bit:  6.. 9  保留 */
+    uint32_t base_addr:22;               /*!< bit: 10..31  保护区地址的高位 */
+  } b;                                   /*!< Structure    用来按位访问 */
+  uint32_t w;                            /*!< Type         整个寄存器访问 */
+} PACR_Type;
+
+/* PACR Register Definitions */
+#define PACR_BASE_ADDR_Pos                 10U                                            /*!< PACR: base_addr Position */
+#define PACK_BASE_ADDR_Msk                 (0x3FFFFFUL << PACR_BASE_ADDR_Pos)             /*!< PACR: base_addr Mask */
+
+#define PACR_SIZE_Pos                      1U                                             /*!< PACR: Size Position */
+#define PACK_SIZE_Msk                      (0x1FUL << PACR_SIZE_Pos)                      /*!< PACR: Size Mask */
+
+#define PACR_E_Pos                         0U                                             /*!< PACR: E Position */
+#define PACK_E_Msk                         (0x1UL << PACR_E_Pos)                          /*!< PACR: E Mask */
+
+/**
+  \brief  访问保护区选择寄存器(PRSR,CR<21,0>)的联合体定义.
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t RID:3;                      /*!< bit:  0.. 2  保护区索引值 */
+    uint32_t _reserved0:30;              /*!< bit:  3..31  保留 */
+  } b;                                   /*!< Structure    用来按位访问 */
+  uint32_t w;                            /*!< Type         整个寄存器访问 */
+} PRSR_Type;
+
+/* PRSR Register Definitions */
+#define PRSR_RID_Pos                       0U                                            /*!< PRSR: RID Position */
+#define PRSR_RID_Msk                       (0x7UL << PRSR_RID_Pos)                       /*!< PRSR: RID Mask */
+
+/*@} end of group CSI_CORE */
+
+
+/**
+  \ingroup    CSI_core_register
+  \defgroup   CSI_NVIC Vectored Interrupt Controller (NVIC)
+  \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/**
+  \brief 访问矢量中断控制器的结构体.
+ */
+typedef struct
+{
+  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  中断使能设置寄存器 */
+        uint32_t RESERVED0[15U];
+  __IOM uint32_t IWER[1U];               /*!< Offset: 0x040 (R/W)  中断低功耗唤醒设置寄存器 */
+        uint32_t RESERVED1[15U];
+  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  中断使能清除寄存器 */
+        uint32_t RESERVED2[15U];
+  __IOM uint32_t IWDR[1U];               /*!< Offset: 0x0c0 (R/W)  中断低功耗唤醒清除寄存器 */
+        uint32_t RESERVED3[15U];
+  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  中断等待设置寄存器 */
+        uint32_t RESERVED4[31U];
+  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  中断等待清除寄存器 */
+        uint32_t RESERVED5[31U];
+  __IOM uint32_t IABR[1U];               /*!< Offset: 0x200 (R/W)  中断响应状态寄存器 */
+        uint32_t RESERVED6[63U];
+  __IOM uint32_t IPR[8U];                /*!< Offset: 0x300 (R/W)  中断优先级设置寄存器 */
+        uint32_t RESERVED7[504U];
+  __IM  uint32_t ISR;                    /*!< Offset: 0xB00 (R/ )  中断状态寄存器 */
+  __IOM uint32_t IPTR;                   /*!< Offset: 0xB04 (R/W)  中断优先级阈值寄存器 */
+} NVIC_Type;
+
+/*@} end of group CSI_NVIC */
+
+/**
+  \ingroup    CSI_core_register
+  \defgroup   CSI_CACHE
+  \brief      Type definitions for the cache Registers
+  @{
+ */
+
+/**
+  \brief 片上高速缓存的结构体.
+ */
+typedef struct
+{
+  __IOM uint32_t CER;                    /*!< Offset: 0x000 (R/W)  高速缓存使能寄存器 */
+  __IOM uint32_t CIR;                    /*!< Offset: 0x004 (R/W)  高速缓存无效寄存器 */
+  __IOM uint32_t CRCR[4U];               /*!< Offset: 0x008 (R/W)  可高缓区配置寄存器 */
+        uint32_t RSERVED0[1015U];
+  __IOM uint32_t CPFCR;                  /*!< Offset: 0xFF4 (R/W)  高速缓存性能分析控制寄存器 */
+  __IOM uint32_t CPFATR;                 /*!< Offset: 0xFF8 (R/W)  高速缓存访问次数寄存器 */
+  __IOM uint32_t CPFMTR;                 /*!< Offset: 0xFFC (R/W)  高速缓存缺失次数寄存器 */
+} CACHE_Type;
+
+/* CACHE Register Definitions */
+#define CACHE_CER_EN_Pos                       0U                                            /*!< CACHE CER: EN Position */
+#define CACHE_CER_EN_Msk                       (0x1UL << CACHE_CER_EN_Pos)                   /*!< CACHE CER: EN Mask */
+
+#define CACHE_CER_CFIG_Pos                     1U                                            /*!< CACHE CER: CFIG Position */
+#define CACHE_CER_CFIG_Msk                     (0x1UL << CACHE_CER_CFIG_Pos)                 /*!< CACHE CER: CFIG Mask */
+
+#define CACHE_CER_WB_Pos                       2U                                            /*!< CACHE CER: WB Position */
+#define CACHE_CER_WB_Msk                       (0x1UL << CACHE_CER_WB_Pos)                   /*!< CACHE CER: WB Mask */
+
+#define CACHE_CER_WCFIG_Pos                    3U                                            /*!< CACHE CER: WCFIG Position */
+#define CACHE_CER_WCFIG_Msk                    (0x1UL << CACHE_CER_WCFIG_Pos)                /*!< CACHE CER: WCFIG Mask */
+
+#define CACHE_CER_DCW_Pos                      4U                                            /*!< CACHE CER: DCW Position */
+#define CACHE_CER_DCW_Msk                      (0x1UL << CACHE_CER_DCW_Pos)                  /*!< CACHE CER: DCW Mask */
+
+#define CACHE_CER_CS_Pos                       31U                                           /*!< CACHE CER: CS Position */
+#define CACHE_CER_CS_Msk                       (0x1UL << CACHE_CER_CS_Pos)                   /*!< CACHE CER: CS Mask */
+
+#define CACHE_CIR_INV_ALL_Pos                  0U                                            /*!< CACHE CIR: INV_ALL Position */
+#define CACHE_CIR_INV_ALL_Msk                  (0x1UL << CACHE_CIR_INV_ALL_Pos)              /*!< CACHE CIR: INV_ALL Mask */
+
+#define CACHE_CIR_INV_ONE_Pos                  1U                                            /*!< CACHE CIR: INV_ONE Position */
+#define CACHE_CIR_INV_ONE_Msk                  (0x1UL << CACHE_CIR_INV_ONE_Pos)              /*!< CACHE CIR: INV_ONE Mask */
+
+#define CACHE_CIR_CLR_ALL_Pos                  2U                                            /*!< CACHE CIR: CLR_ALL Position */
+#define CACHE_CIR_CLR_ALL_Msk                  (0x1UL << CACHE_CIR_CLR_ALL_Pos)              /*!< CACHE CIR: CLR_ALL Mask */
+
+#define CACHE_CIR_CLR_ONE_Pos                  3U                                            /*!< CACHE CIR: CLR_ONE Position */
+#define CACHE_CIR_CLR_ONE_Msk                  (0x1UL << CACHE_CIR_CLR_ONE_Pos)              /*!< CACHE CIR: CLR_ONE Mask */
+
+#define CACHE_CIR_INV_ADDR_Pos                 4U                                            /*!< CACHE CIR: INV_ADDR Position */
+#define CACHE_CIR_INV_ADDR_Msk                 (0xFFFFFFFUL << CACHE_CIR_INV_ADDR_Pos)       /*!< CACHE CIR: INV_ADDR Mask */
+
+#define CACHE_CRCR_EN_Pos                      0U                                            /*!< CACHE CRCR: EN Position */
+#define CACHE_CRCR_EN_Msk                      (0x1UL << CACHE_CRCR_EN_Pos)                  /*!< CACHE CRCR: EN Mask */
+
+#define CACHE_CRCR_SIZE_Pos                    1U                                            /*!< CACHE CRCR: Size Position */
+#define CACHE_CRCR_SIZE_Msk                    (0x1FUL << CACHE_CRCR_SIZE_Pos)               /*!< CACHE CRCR: Size Mask */
+
+#define CACHE_CRCR_BASE_ADDR_Pos               10U                                           /*!< CACHE CRCR: base addr Position */
+#define CACHE_CRCR_BASE_ADDR_Msk               (0x3FFFFFUL << CACHE_CRCR_BASE_ADDR_Pos)      /*!< CACHE CRCR: base addr Mask */
+
+#define CACHE_CPFCR_PFEN_Pos                   0U                                            /*!< CACHE CPFCR: PFEN Position */
+#define CACHE_CPFCR_PFEN_Msk                   (0x1UL << CACHE_CPFCR_PFEN_Pos)               /*!< CACHE CPFCR: PFEN Mask */
+
+#define CACHE_CPFCR_PFRST_Pos                  1U                                            /*!< CACHE CPFCR: PFRST Position */
+#define CACHE_CPFCR_PFRST_Msk                  (0x1UL << CACHE_CPFCR_PFRST_Pos)              /*!< CACHE CPFCR: PFRST Mask */
+
+#define CACHE_CRCR_4K                          0xB                                           /* 01011 */
+#define CACHE_CRCR_8K                          0xC                                           /* 01100 */
+#define CACHE_CRCR_16K                         0xD                                           /* 01101 */
+#define CACHE_CRCR_32K                         0xE                                           /* 01110 */
+#define CACHE_CRCR_64K                         0xF                                           /* 01111 */
+#define CACHE_CRCR_128K                        0x10                                          /* 10000 */
+#define CACHE_CRCR_256K                        0x11                                          /* 10001 */
+#define CACHE_CRCR_512K                        0x12                                          /* 10010 */
+#define CACHE_CRCR_1M                          0x13                                          /* 10011 */
+#define CACHE_CRCR_2M                          0x14                                          /* 10100 */
+#define CACHE_CRCR_4M                          0x15                                          /* 10101 */
+#define CACHE_CRCR_8M                          0x16                                          /* 10110 */
+#define CACHE_CRCR_16M                         0x17                                          /* 10111 */
+#define CACHE_CRCR_32M                         0x18                                          /* 11000 */
+#define CACHE_CRCR_64M                         0x19                                          /* 11001 */
+#define CACHE_CRCR_128M                        0x1A                                          /* 11010 */
+#define CACHE_CRCR_256M                        0x1B                                          /* 11011 */
+#define CACHE_CRCR_512M                        0x1C                                          /* 11100 */
+#define CACHE_CRCR_1G                          0x1D                                          /* 11101 */
+#define CACHE_CRCR_2G                          0x1E                                          /* 11110 */
+#define CACHE_CRCR_4G                          0x1F                                          /* 11111 */
+
+/*@} end of group CSI_NVIC */
+
+
+/**
+  \ingroup  CSI_core_register
+  \defgroup CSI_SysTick     System Tick Timer (CORET)
+  \brief    Type definitions for the System Timer Registers.
+  @{
+ */
+
+/**
+  \brief  访问系统计时器的数据结构.
+ */
+typedef struct
+{
+  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  控制状态寄存器 */
+  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  回填值寄存器 */
+  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  当前值寄存器 */
+  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  校准寄存器 */
+} CORET_Type;
+
+/* CORET Control / Status Register Definitions */
+#define CORET_CTRL_COUNTFLAG_Pos           16U                                            /*!< CORET CTRL: COUNTFLAG Position */
+#define CORET_CTRL_COUNTFLAG_Msk           (1UL << CORET_CTRL_COUNTFLAG_Pos)              /*!< CORET CTRL: COUNTFLAG Mask */
+
+#define CORET_CTRL_CLKSOURCE_Pos            2U                                            /*!< CORET CTRL: CLKSOURCE Position */
+#define CORET_CTRL_CLKSOURCE_Msk           (1UL << CORET_CTRL_CLKSOURCE_Pos)              /*!< CORET CTRL: CLKSOURCE Mask */
+
+#define CORET_CTRL_TICKINT_Pos              1U                                            /*!< CORET CTRL: TICKINT Position */
+#define CORET_CTRL_TICKINT_Msk             (1UL << CORET_CTRL_TICKINT_Pos)                /*!< CORET CTRL: TICKINT Mask */
+
+#define CORET_CTRL_ENABLE_Pos               0U                                            /*!< CORET CTRL: ENABLE Position */
+#define CORET_CTRL_ENABLE_Msk              (1UL /*<< CORET_CTRL_ENABLE_Pos*/)             /*!< CORET CTRL: ENABLE Mask */
+
+/* CORET Reload Register Definitions */
+#define CORET_LOAD_RELOAD_Pos               0U                                            /*!< CORET LOAD: RELOAD Position */
+#define CORET_LOAD_RELOAD_Msk              (0xFFFFFFUL /*<< CORET_LOAD_RELOAD_Pos*/)      /*!< CORET LOAD: RELOAD Mask */
+
+/* CORET Current Register Definitions */
+#define CORET_VAL_CURRENT_Pos               0U                                            /*!< CORET VAL: CURRENT Position */
+#define CORET_VAL_CURRENT_Msk              (0xFFFFFFUL /*<< CORET_VAL_CURRENT_Pos*/)      /*!< CORET VAL: CURRENT Mask */
+
+/* CORET Calibration Register Definitions */
+#define CORET_CALIB_NOREF_Pos               31U                                           /*!< CORET CALIB: NOREF Position */
+#define CORET_CALIB_NOREF_Msk              (1UL << CORET_CALIB_NOREF_Pos)                 /*!< CORET CALIB: NOREF Mask */
+
+#define CORET_CALIB_SKEW_Pos                30U                                           /*!< CORET CALIB: SKEW Position */
+#define CORET_CALIB_SKEW_Msk               (1UL << CORET_CALIB_SKEW_Pos)                  /*!< CORET CALIB: SKEW Mask */
+
+#define CORET_CALIB_TENMS_Pos               0U                                            /*!< CORET CALIB: TENMS Position */
+#define CORET_CALIB_TENMS_Msk              (0xFFFFFFUL /*<< CORET_CALIB_TENMS_Pos*/)      /*!< CORET CALIB: TENMS Mask */
+
+/*@} end of group CSI_SysTick */
+
+/**
+  \ingroup    CSI_core_register
+  \defgroup   CSI_core_bitfield     Core register bit field macros
+  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
+  @{
+ */
+
+/**
+  \brief   Mask and shift a bit field value for use in a register bit range.
+  \param[in] field  Name of the register bit field.
+  \param[in] value  Value of the bit field.
+  \return           Masked and shifted value.
+*/
+#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
+
+/**
+  \brief     Mask and shift a register value to extract a bit filed value.
+  \param[in] field  Name of the register bit field.
+  \param[in] value  Value of register.
+  \return           Masked and shifted bit field value.
+*/
+#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
+
+/*@} end of group CSI_core_bitfield */
+
+/**
+  \ingroup    CSI_core_register
+  \defgroup   CSI_core_base     Core Definitions
+  \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of CK803S Hardware */
+#define TCIP_BASE           (0xE000E000UL)                            /*!< Titly Coupled IP Base Address */
+#define CORET_BASE          (TCIP_BASE +  0x0010UL)                   /*!< CORET Base Address */
+#define NVIC_BASE           (TCIP_BASE +  0x0100UL)                   /*!< NVIC Base Address */
+#define CACHE_BASE          (TCIP_BASE +  0x1000UL)                   /*!< CACHE Base Address */
+
+#define CORET               ((CORET_Type   *)     CORET_BASE  )       /*!< SysTick configuration struct */
+#define NVIC                ((NVIC_Type    *)     NVIC_BASE   )       /*!< NVIC configuration struct */
+#define CACHE               ((CACHE_Type   *)     CACHE_BASE  )       /*!< cache configuration struct */
+
+/*@} */
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core VIC Functions
+  - Core CORET Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/**
+  \defgroup CSI_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+/* ##########################   NVIC functions  #################################### */
+/**
+  \ingroup  CSI_Core_FunctionInterface
+  \defgroup CSI_Core_NVICFunctions NVIC Functions
+  \brief    Functions that manage interrupts and exceptions via the NVIC.
+  @{
+ */
+
+/* The following MACROS handle generation of the register offset and byte masks */
+#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
+#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
+#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
+
+/**
+  \brief   Enable External Interrupt
+  \details Enables a device-specific interrupt in the NVIC interrupt controller.
+  \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
+}
+
+/**
+  \brief   Disable External Interrupt
+  \details Disables a device-specific interrupt in the NVIC interrupt controller.
+  \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
+}
+
+/**
+  \brief   Get Pending Interrupt
+  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
+  \param [in]      IRQn  Interrupt number.
+  \return             0  Interrupt status is not pending.
+  \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
+}
+
+/**
+  \brief   Set Pending Interrupt
+  \details Sets the pending bit of an external interrupt.
+  \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
+}
+
+/**
+  \brief   Clear Pending Interrupt
+  \details Clears the pending bit of an external interrupt.
+  \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
+}
+
+/**
+  \brief   Get Wake up Interrupt
+  \details Reads the wake up register in the NVIC and returns the pending bit for the specified interrupt.
+  \param [in]      IRQn  Interrupt number.
+  \return             0  Interrupt is not set as wake up interrupt.
+  \return             1  Interrupt is set as wake up interrupt.
+ */
+__STATIC_INLINE uint32_t NVIC_GetWakeupIRQ(IRQn_Type IRQn)
+{
+  return ((uint32_t)(((NVIC->IWER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
+}
+
+/**
+  \brief   Set Wake up Interrupt
+  \details Sets the wake up bit of an external interrupt.
+  \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetWakeupIRQ(IRQn_Type IRQn)
+{
+  NVIC->IWER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
+}
+
+/**
+  \brief   Clear Wake up Interrupt
+  \details Clears the wake up bit of an external interrupt.
+  \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearWakeupIRQ(IRQn_Type IRQn)
+{
+  NVIC->IWDR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
+}
+
+/**
+  \brief   Get Active Interrupt
+  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
+  \param [in]      IRQn  Device specific interrupt number.
+  \return             0  Interrupt status is not active.
+  \return             1  Interrupt status is active.
+  \note    IRQn must not be negative.
+ */
+__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
+{
+    return ((uint32_t)(((NVIC->IABR[0] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
+}
+
+/**
+  \brief   Set Threshold register
+  \details set the threshold register in the NVIC.
+  \param [in]      VectThreshold  specific vecter threshold.
+  \param [in]      PrioThreshold  specific priority threshold.
+ */
+__STATIC_INLINE void NVIC_SetThreshold(uint32_t VectThreshold, uint32_t PrioThreshold)
+{
+    NVIC->IPTR = 0x80000000 | (((VectThreshold + 32) & 0xFF) << 8) | ((PrioThreshold & 0x3) << 6);
+}
+
+/**
+  \brief   Set Interrupt Priority
+  \details Sets the priority of an interrupt.
+  \note    The priority cannot be set for every core interrupt.
+  \param [in]      IRQn  Interrupt number.
+  \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  NVIC->IPR[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IPR[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
+    (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
+}
+
+/**
+  \brief   Get Interrupt Priority
+  \details Reads the priority of an interrupt.
+           The interrupt number can be positive to specify an external (device specific) interrupt,
+           or negative to specify an internal (core) interrupt.
+  \param [in]   IRQn  Interrupt number.
+  \return             Interrupt Priority.
+                      Value is aligned automatically to the implemented priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+  return((uint32_t)(((NVIC->IPR[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
+}
+
+/**
+  \brief   System Reset
+  \details Initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                          /* Ensure all outstanding memory accesses included
+                                                                       buffered write are completed before reset */
+
+#if       (__SOFTRESET_PRESENT == 1U)
+  __set_SRCR(__RESET_CONST);
+#endif
+
+  __DSB();                                                          /* Ensure completion of memory access */
+
+  for(;;)                                                           /* wait until reset */
+  {
+    __NOP();
+  }
+}
+
+/*@} end of CSI_Core_NVICFunctions */
+
+/* ##################################    SysTick function  ############################################ */
+/**
+  \ingroup  CSI_Core_FunctionInterface
+  \defgroup CSI_Core_SysTickFunctions SysTick Functions
+  \brief    Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0U)
+
+/**
+  \brief   System Tick Configuration
+  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
+           Counter is in free running mode to generate periodic interrupts.
+  \param [in]  ticks  Number of ticks between two interrupts.
+  \return          0  Function succeeded.
+  \return          1  Function failed.
+  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+           must contain a vendor-specific implementation of this function.
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1UL) > CORET_LOAD_RELOAD_Msk)
+  {
+    return (1UL);                                                   /* Reload value impossible */
+  }
+
+  CORET->LOAD  = (uint32_t)(ticks - 1UL);                           /* set reload register */
+  NVIC_SetPriority (CORET_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL);   /* set Priority for Systick Interrupt */
+  CORET->VAL   = 0UL;                                               /* Load the SysTick Counter Value */
+  CORET->CTRL  = CORET_CTRL_CLKSOURCE_Msk |
+                   CORET_CTRL_TICKINT_Msk |
+                   CORET_CTRL_ENABLE_Msk;                           /* Enable SysTick IRQ and SysTick Timer */
+  return (0UL);                                                     /* Function successful */
+}
+
+/**
+  \brief   CORE timer Configuration
+  \details Initializes the Core Timer and its interrupt, and starts the Core Timer.
+           Counter is in free running mode to generate periodic interrupts.
+  \param [in]  ticks  Number of ticks between two interrupts.
+  \return          0  Function succeeded.
+  \return          1  Function failed.
+  \note    When the variable <b>__Vendor_CORETConfig</b> is set to 1, then the
+           function <b>CORET_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+           must contain a vendor-specific implementation of this function.
+ */
+__STATIC_INLINE uint32_t CORET_Config(uint32_t ticks)
+{
+  if ((ticks - 1UL) > CORET_LOAD_RELOAD_Msk)
+  {
+    return (1UL);                                                   /* Reload value impossible */
+  }
+
+  CORET->LOAD  = (uint32_t)(ticks - 1UL);                           /* set reload register */
+  NVIC_SetPriority (CORET_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL);   /* set Priority for Core Timer Interrupt */
+  CORET->VAL   = 0UL;                                               /* Load the Core Timer Counter Value */
+  CORET->CTRL  = CORET_CTRL_CLKSOURCE_Msk |
+                   CORET_CTRL_TICKINT_Msk |
+                   CORET_CTRL_ENABLE_Msk;                           /* Enable Core Timer IRQ and Core Timer */
+  return (0UL);                                                     /* Function successful */
+}
+#endif
+
+/*@} end of CSI_Core_SysTickFunctions */
+
+/* ##########################  Cache functions  #################################### */
+/**
+  \ingroup  CSI_Core_FunctionInterface
+  \defgroup CSI_Core_CacheFunctions Cache Functions
+  \brief    Functions that configure Instruction and Data cache.
+  @{
+ */
+
+#if __CMSIS_COMPATIBLE
+/**
+  \brief   Enable I-Cache
+  \details Turns on I-Cache
+  */
+__STATIC_INLINE void SCB_EnableICache (void)
+{
+  #if (__ICACHE_PRESENT == 1U)
+    __DSB();
+    __ISB();
+    CACHE->CIR = CACHE_CIR_INV_ALL_Msk;         /* invalidate all Cache */
+    CACHE->CER |=  (uint32_t)(CACHE_CER_EN_Msk | CACHE_CER_CFIG_Msk);  /* enable all Cache */
+    __DSB();
+    __ISB();
+  #endif
+}
+
+
+/**
+  \brief   Disable I-Cache
+  \details Turns off I-Cache
+  */
+__STATIC_INLINE void SCB_DisableICache (void)
+{
+  #if (__ICACHE_PRESENT == 1U)
+    __DSB();
+    __ISB();
+    CACHE->CER &=  ~(uint32_t)(CACHE_CER_EN_Msk | CACHE_CER_CFIG_Msk);  /* disable all Cache */
+    CACHE->CIR = CACHE_CIR_INV_ALL_Msk;          /* invalidate all Cache */
+    __DSB();
+    __ISB();
+  #endif
+}
+
+
+/**
+  \brief   Invalidate I-Cache
+  \details Invalidates I-Cache
+  */
+__STATIC_INLINE void SCB_InvalidateICache (void)
+{
+  #if (__ICACHE_PRESENT == 1U)
+    __DSB();
+    __ISB();
+    CACHE->CIR = CACHE_CIR_INV_ALL_Msk;         /* invalidate all Cache */
+    __DSB();
+    __ISB();
+  #endif
+}
+
+
+/**
+  \brief   Enable D-Cache
+  \details Turns on D-Cache
+  \note    I-Cache also turns on.
+  */
+__STATIC_INLINE void SCB_EnableDCache (void)
+{
+  #if (__DCACHE_PRESENT == 1U)
+    __DSB();
+    __ISB();
+    CACHE->CIR = CACHE_CIR_INV_ALL_Msk;         /* invalidate all Cache */
+    CACHE->CER =  (uint32_t)(CACHE_CER_EN_Msk | CACHE_CER_WB_Msk | CACHE_CER_DCW_Msk);  /* enable all Cache */
+    __DSB();
+    __ISB();
+  #endif
+}
+
+
+/**
+  \brief   Disable D-Cache
+  \details Turns off D-Cache
+  \note    I-Cache also turns off.
+  */
+__STATIC_INLINE void SCB_DisableDCache (void)
+{
+  #if (__DCACHE_PRESENT == 1U)
+    __DSB();
+    __ISB();
+    CACHE->CER &=  ~(uint32_t)CACHE_CER_EN_Msk;  /* disable all Cache */
+    CACHE->CIR = CACHE_CIR_INV_ALL_Msk;          /* invalidate all Cache */
+    __DSB();
+    __ISB();
+
+  #endif
+}
+
+
+/**
+  \brief   Invalidate D-Cache
+  \details Invalidates D-Cache
+  \note    I-Cache also invalid
+  */
+__STATIC_INLINE void SCB_InvalidateDCache (void)
+{
+  #if (__DCACHE_PRESENT == 1U)
+    __DSB();
+    __ISB();
+    CACHE->CIR = CACHE_CIR_INV_ALL_Msk;         /* invalidate all Cache */
+    __DSB();
+    __ISB();
+  #endif
+}
+
+
+/**
+  \brief   Clean D-Cache
+  \details Cleans D-Cache
+  \note    I-Cache also cleans
+  */
+__STATIC_INLINE void SCB_CleanDCache (void)
+{
+  #if (__DCACHE_PRESENT == 1U)
+    __DSB();
+    __ISB();
+    CACHE->CIR = _VAL2FLD(CACHE_CIR_CLR_ALL, 1);         /* clean all Cache */
+    __DSB();
+    __ISB();
+  #endif
+}
+
+
+/**
+  \brief   Clean & Invalidate D-Cache
+  \details Cleans and Invalidates D-Cache
+  \note    I-Cache also flush.
+  */
+__STATIC_INLINE void SCB_CleanInvalidateDCache (void)
+{
+  #if (__DCACHE_PRESENT == 1U)
+    __DSB();
+    __ISB();
+    CACHE->CIR = _VAL2FLD(CACHE_CIR_INV_ALL, 1) | _VAL2FLD(CACHE_CIR_CLR_ALL, 1);         /* clean and inv all Cache */
+    __DSB();
+    __ISB();
+  #endif
+}
+
+
+/**
+  \brief   D-Cache Invalidate by address
+  \details Invalidates D-Cache for the given address
+  \param[in]   addr    address (aligned to 16-byte boundary)
+  \param[in]   dsize   size of memory block (in number of bytes)
+*/
+__STATIC_INLINE void SCB_InvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)
+{
+  #if (__DCACHE_PRESENT == 1U)
+     int32_t op_size = dsize;
+    uint32_t op_addr = (uint32_t)addr;
+     int32_t linesize = 16;
+
+    __DSB();
+
+    while (op_size > 0) {
+      CACHE->CIR = op_addr | _VAL2FLD(CACHE_CIR_INV_ONE, 1);
+      op_addr += linesize;
+      op_size -= linesize;
+    }
+
+    __DSB();
+    __ISB();
+  #endif
+}
+
+
+/**
+  \brief   D-Cache Clean by address
+  \details Cleans D-Cache for the given address
+  \param[in]   addr    address (aligned to 16-byte boundary)
+  \param[in]   dsize   size of memory block (in number of bytes)
+*/
+__STATIC_INLINE void SCB_CleanDCache_by_Addr (uint32_t *addr, int32_t dsize)
+{
+  #if (__DCACHE_PRESENT == 1)
+     int32_t op_size = dsize;
+    uint32_t op_addr = (uint32_t) addr & CACHE_CIR_INV_ADDR_Msk;
+     int32_t linesize = 16;
+
+    __DSB();
+
+    while (op_size > 0) {
+      CACHE->CIR = op_addr | _VAL2FLD(CACHE_CIR_CLR_ONE, 1);
+      op_addr += linesize;
+      op_size -= linesize;
+    }
+
+    __DSB();
+    __ISB();
+  #endif
+}
+
+
+/**
+  \brief   D-Cache Clean and Invalidate by address
+  \details Cleans and invalidates D_Cache for the given address
+  \param[in]   addr    address (aligned to 16-byte boundary)
+  \param[in]   dsize   size of memory block (in number of bytes)
+*/
+__STATIC_INLINE void SCB_CleanInvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)
+{
+  #if (__DCACHE_PRESENT == 1U)
+     int32_t op_size = dsize;
+    uint32_t op_addr = (uint32_t) addr;
+     int32_t linesize = 16;
+
+    __DSB();
+
+    while (op_size > 0) {
+      CACHE->CIR = op_addr | _VAL2FLD(CACHE_CIR_CLR_ONE, 1) | _VAL2FLD(CACHE_CIR_INV_ONE, 1);
+      op_addr += linesize;
+      op_size -= linesize;
+    }
+
+    __DSB();
+    __ISB();
+  #endif
+}
+
+#endif
+/**
+  \brief   setup cacheable range Cache
+  \details setup Cache range
+  */
+__STATIC_INLINE void SCB_Cacheable_Range (uint32_t index, uint32_t baseAddr, uint32_t size, uint32_t enable)
+{
+  CACHE->CRCR[index] =  ((baseAddr & CACHE_CRCR_BASE_ADDR_Msk) |
+                         (_VAL2FLD(CACHE_CRCR_SIZE, size)) |
+                         (_VAL2FLD(CACHE_CRCR_EN, enable)));
+}
+
+/**
+  \brief   Enable cache profile
+  \details Turns on Cache profile
+  */
+__STATIC_INLINE void SCB_EnableCacheProfile (void)
+{
+  CACHE->CPFCR |=  (uint32_t)CACHE_CPFCR_PFEN_Msk;
+}
+
+/**
+  \brief   Disable cache profile
+  \details Turns off Cache profile
+  */
+__STATIC_INLINE void SCB_DisableCacheProfile (void)
+{
+  CACHE->CPFCR &=  ~(uint32_t)CACHE_CPFCR_PFEN_Msk;
+}
+
+/**
+  \brief   Reset cache profile
+  \details Reset Cache profile
+  */
+__STATIC_INLINE void SCB_ResetCacheProfile (void)
+{
+  CACHE->CPFCR |=  (uint32_t)CACHE_CPFCR_PFRST_Msk;
+}
+
+/**
+  \brief   cache access times
+  \details Cache access times
+  \note    every 256 access add 1.
+  */
+__STATIC_INLINE uint32_t SCB_CacheAccessTime (void)
+{
+  return CACHE->CPFATR;
+}
+
+/**
+  \brief   cache miss times
+  \details Cache miss times
+  \note    every 256 miss add 1.
+  */
+__STATIC_INLINE uint32_t SCB_CacheMissTime (void)
+{
+  return CACHE->CPFMTR;
+}
+
+/**
+  \brief   Enable Cache
+  \details Turns on Cache
+  */
+__STATIC_INLINE void SCB_EnableCache (void)
+{
+  __DSB();
+  __ISB();
+  CACHE->CIR = CACHE_CIR_INV_ALL_Msk;         /* invalidate all Cache */
+  CACHE->CER = (uint32_t)(CACHE_CER_EN_Msk | CACHE_CER_WB_Msk | CACHE_CER_DCW_Msk);  /* enable all Cache */
+  __DSB();
+  __ISB();
+}
+
+
+/**
+  \brief   Disable Cache
+  \details Turns off Cache
+  */
+__STATIC_INLINE void SCB_DisableCache (void)
+{
+  __DSB();
+  __ISB();
+  CACHE->CER &=  ~(uint32_t)CACHE_CER_EN_Msk;  /* disable all Cache */
+  CACHE->CIR = CACHE_CIR_INV_ALL_Msk;          /* invalidate all Cache */
+  __DSB();
+  __ISB();
+}
+
+
+/**
+  \brief   Invalidate Cache
+  \details Invalidates Cache
+  */
+__STATIC_INLINE void SCB_InvalidateCache (void)
+{
+  __DSB();
+  __ISB();
+  CACHE->CIR = CACHE_CIR_INV_ALL_Msk;         /* invalidate all Cache */
+  __DSB();
+  __ISB();
+}
+
+
+/**
+  \brief   Clean Cache
+  \details Cleans Cache
+  */
+__STATIC_INLINE void SCB_CleanCache (void)
+{
+  __DSB();
+  __ISB();
+  CACHE->CIR = _VAL2FLD(CACHE_CIR_CLR_ALL, 1);         /* clean all Cache */
+  __DSB();
+  __ISB();
+}
+
+
+/**
+  \brief   Clean & Invalidate Cache
+  \details Cleans and Invalidates Cache
+  */
+__STATIC_INLINE void SCB_CleanInvalidateCache (void)
+{
+  __DSB();
+  __ISB();
+  CACHE->CIR = _VAL2FLD(CACHE_CIR_INV_ALL, 1) | _VAL2FLD(CACHE_CIR_CLR_ALL, 1);         /* clean and inv all Cache */
+  __DSB();
+  __ISB();
+}
+
+
+/**
+  \brief   Cache Invalidate by address
+  \details Invalidates Cache for the given address
+  \param[in]   addr    address (aligned to 16-byte boundary)
+  \param[in]   dsize   size of memory block (in number of bytes)
+*/
+__STATIC_INLINE void SCB_InvalidateCache_by_Addr (uint32_t *addr, int32_t dsize)
+{
+   int32_t op_size = dsize;
+  uint32_t op_addr = (uint32_t)addr;
+   int32_t linesize = 16;
+
+  __DSB();
+
+  while (op_size > 0) {
+    CACHE->CIR = op_addr | _VAL2FLD(CACHE_CIR_INV_ONE, 1);
+    op_addr += linesize;
+    op_size -= linesize;
+  }
+
+  __DSB();
+  __ISB();
+}
+
+
+/**
+  \brief   Cache Clean by address
+  \details Cleans Cache for the given address
+  \param[in]   addr    address (aligned to 16-byte boundary)
+  \param[in]   dsize   size of memory block (in number of bytes)
+*/
+__STATIC_INLINE void SCB_CleanCache_by_Addr (uint32_t *addr, int32_t dsize)
+{
+   int32_t op_size = dsize;
+  uint32_t op_addr = (uint32_t) addr;
+   int32_t linesize = 16;
+
+  __DSB();
+
+  while (op_size > 0) {
+    CACHE->CIR = op_addr | _VAL2FLD(CACHE_CIR_CLR_ONE, 1);
+    op_addr += linesize;
+    op_size -= linesize;
+  }
+
+  __DSB();
+  __ISB();
+}
+
+
+/**
+  \brief   Cache Clean and Invalidate by address
+  \details Cleans and invalidates Cache for the given address
+  \param[in]   addr    address (aligned to 16-byte boundary)
+  \param[in]   dsize   size of memory block (in number of bytes)
+*/
+__STATIC_INLINE void SCB_CleanInvalidateCache_by_Addr (uint32_t *addr, int32_t dsize)
+{
+   int32_t op_size = dsize;
+  uint32_t op_addr = (uint32_t) addr;
+   int32_t linesize = 16;
+
+  __DSB();
+
+  while (op_size > 0) {
+    CACHE->CIR = op_addr | _VAL2FLD(CACHE_CIR_CLR_ONE, 1) | _VAL2FLD(CACHE_CIR_INV_ONE, 1);
+    op_addr += linesize;
+    op_size -= linesize;
+  }
+
+  __DSB();
+  __ISB();
+}
+
+/*@} end of CSI_Core_CacheFunctions */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CORE_CK803S_H_DEPENDANT */
+
+#endif /* __CSI_GENERIC */
diff --git a/tests/csky/board/smartl/ck803s/CSI_GCC.h b/tests/csky/board/smartl/ck803s/CSI_GCC.h
new file mode 100644
index 0000000..fa9dc74
--- /dev/null
+++ b/tests/csky/board/smartl/ck803s/CSI_GCC.h
@@ -0,0 +1,2594 @@
+/**************************************************************************//**
+ * @file     CSI_GCC.h
+ * @brief    CSI Core Function/Instruction Header File for GCC.
+ * @version  V1.0
+ * @date     20. July 2016
+ ******************************************************************************/
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+
+#ifndef __CSI_GCC_H
+#define __CSI_GCC_H
+
+/* ###########################  Core Function Access  ########################### */
+/** \ingroup  CSI_Core_FunctionInterface
+    \defgroup CSI_Core_RegAccFunctions CSI Core Register Access Functions
+  @{
+ */
+
+/**
+  \brief   Enable IRQ Interrupts
+  \details Enables IRQ interrupts by setting the IE-bit in the PSR.
+           Can only be executed in Privileged modes.
+ */
+__ALWAYS_INLINE void __enable_irq(void)
+{
+  __ASM volatile ("psrset ie");
+}
+
+
+
+/**
+  \brief   Disable IRQ Interrupts
+  \details Disables IRQ interrupts by clearing the IE-bit in the PSR.
+  Can only be executed in Privileged modes.
+ */
+__ALWAYS_INLINE void __disable_irq(void)
+{
+  __ASM volatile ("psrclr ie");
+}
+
+/**
+  \brief   Get PSR
+  \details Returns the content of the PSR Register.
+  \return               PSR Register value
+ */
+__ALWAYS_INLINE uint32_t __get_PSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, psr" : "=r" (result) );
+  return(result);
+}
+
+/**
+  \brief   Set PSR
+  \details Writes the given value to the PSR Register.
+  \param [in]    psr  PSR Register value to set
+ */
+__ALWAYS_INLINE void __set_PSR(uint32_t psr)
+{
+  __ASM volatile ("mtcr %0, psr" : : "r" (psr) );
+}
+
+/**
+  \brief   Get SP
+  \details Returns the content of the SP Register.
+  \return               SP Register value
+ */
+__ALWAYS_INLINE uint32_t __get_SP(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mov %0, sp" : "=r" (result) );
+  return(result);
+}
+
+/**
+  \brief   Set SP
+  \details Writes the given value to the SP Register.
+  \param [in]    sp  SP Register value to set
+ */
+__ALWAYS_INLINE void __set_SP(uint32_t sp)
+{
+  __ASM volatile ("mov sp, %0" : : "r" (sp):"sp");
+}
+
+
+/**
+  \brief   Get VBR Register
+  \details Returns the content of the VBR Register.
+  \return               VBR Register value
+ */
+__ALWAYS_INLINE uint32_t __get_VBR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, vbr" : "=r" (result) );
+  return(result);
+}
+
+/**
+  \brief   Set VBR
+  \details Writes the given value to the VBR Register.
+  \param [in]    vbr  VBR Register value to set
+ */
+__ALWAYS_INLINE void __set_VBR(uint32_t vbr)
+{
+  __ASM volatile ("mtcr %0, vbr" : : "r" (vbr) );
+}
+
+/**
+  \brief   Get EPC Register
+  \details Returns the content of the EPC Register.
+  \return               EPC Register value
+ */
+__ALWAYS_INLINE uint32_t __get_EPC(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, epc" : "=r" (result) );
+  return(result);
+}
+
+/**
+  \brief   Set EPC
+  \details Writes the given value to the EPC Register.
+  \param [in]    epc  EPC Register value to set
+ */
+__ALWAYS_INLINE void __set_EPC(uint32_t epc)
+{
+  __ASM volatile ("mtcr %0, epc" : : "r" (epc) );
+}
+
+/**
+  \brief   Get EPSR
+  \details Returns the content of the EPSR Register.
+  \return               EPSR Register value
+ */
+__ALWAYS_INLINE uint32_t __get_EPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, epsr" : "=r" (result) );
+  return(result);
+}
+
+/**
+  \brief   Set EPSR
+  \details Writes the given value to the EPSR Register.
+  \param [in]    epsr  EPSR Register value to set
+ */
+__ALWAYS_INLINE void __set_EPSR(uint32_t epsr)
+{
+  __ASM volatile ("mtcr %0, epsr" : : "r" (epsr) );
+}
+
+/**
+  \brief   Get CPUID Register
+  \details Returns the content of the CPUID Register.
+  \return               CPUID Register value
+ */
+__ALWAYS_INLINE uint32_t __get_CPUID(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, cr<13, 0>" : "=r" (result) );
+  return(result);
+}
+
+#if       (__SOFTRESET_PRESENT == 1U)
+/**
+  \brief   Set SRCR
+  \details Assigns the given value to the SRCR.
+  \param [in]    srcr  SRCR value to set
+ */
+__ALWAYS_INLINE void __set_SRCR(uint32_t srcr)
+{
+  __ASM volatile ("mtcr %0, cr<31, 0>\n" : : "r" (srcr) );
+}
+#endif /* __SOFTRESET_PRESENT == 1U */
+
+#if       (__MGU_PRESENT == 1U)
+/**
+  \brief   Get CCR
+  \details Returns the current value of the CCR.
+  \return               CCR Register value
+ */
+__ALWAYS_INLINE uint32_t __get_CCR(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("mfcr %0, cr<18, 0>\n"  : "=r" (result) );
+  return(result);
+}
+
+
+/**
+  \brief   Set CCR
+  \details Assigns the given value to the CCR.
+  \param [in]    ccr  CCR value to set
+ */
+__ALWAYS_INLINE void __set_CCR(uint32_t ccr)
+{
+  __ASM volatile ("mtcr %0, cr<18, 0>\n" : : "r" (ccr) );
+}
+
+
+/**
+  \brief   Get CAPR
+  \details Returns the current value of the CAPR.
+  \return               CAPR Register value
+ */
+__ALWAYS_INLINE uint32_t __get_CAPR(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("mfcr %0, cr<19, 0>\n" : "=r" (result) );
+  return(result);
+}
+
+/**
+  \brief   Set CAPR
+  \details Assigns the given value to the CAPR.
+  \param [in]    capr  CAPR value to set
+ */
+__ALWAYS_INLINE void __set_CAPR(uint32_t capr)
+{
+  __ASM volatile ("mtcr %0, cr<19, 0>\n" : : "r" (capr) );
+}
+
+
+/**
+  \brief   Set PACR
+  \details Assigns the given value to the PACR.
+
+    \param [in]    pacr  PACR value to set
+ */
+__ALWAYS_INLINE void __set_PACR(uint32_t pacr)
+{
+  __ASM volatile ("mtcr %0, cr<20, 0>\n" : : "r" (pacr) );
+}
+
+
+/**
+  \brief   Get PACR
+  \details Returns the current value of PACR.
+  \return               PACR value
+ */
+__ALWAYS_INLINE uint32_t __get_PACR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, cr<20, 0>" : "=r" (result) );
+  return(result);
+}
+
+/**
+  \brief   Set PRSR
+  \details Assigns the given value to the PRSR.
+
+    \param [in]    prsr  PRSR value to set
+ */
+__ALWAYS_INLINE void __set_PRSR(uint32_t prsr)
+{
+  __ASM volatile ("mtcr %0, cr<21, 0>\n" : : "r" (prsr) );
+}
+
+/**
+  \brief   Get PRSR
+  \details Returns the current value of PRSR.
+  \return               PRSR value
+ */
+__ALWAYS_INLINE uint32_t __get_PRSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, cr<21, 0>" : "=r" (result) );
+  return(result);
+}
+#endif /* __MGU_PRESENT == 1U */
+
+/**
+  \brief   Get user sp
+  \details Returns the current value of user r14.
+  \return               UR14 value
+ */
+__ALWAYS_INLINE uint32_t __get_UR14(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, cr<14, 1>" : "=r" (result) );
+  return(result);
+}
+
+/**
+  \brief   Enable interrupts and exceptions
+  \details Enables interrupts and exceptions by setting the IE-bit and EE-bit in the PSR.
+           Can only be executed in Privileged modes.
+ */
+__ALWAYS_INLINE void __enable_excp_irq(void)
+{
+  __ASM volatile ("psrset ee, ie");
+}
+
+
+/**
+  \brief   Disable interrupts and exceptions
+  \details Disables interrupts and exceptions by clearing the IE-bit and EE-bit in the PSR.
+           Can only be executed in Privileged modes.
+ */
+__ALWAYS_INLINE void __disable_excp_irq(void)
+{
+  __ASM volatile ("psrclr ee, ie");
+}
+
+#if       (__GSR_GCR_PRESENT == 1U)
+/**
+  \brief   Get GSR
+  \details Returns the content of the GSR Register.
+  \return               GSR Register value
+ */
+__ALWAYS_INLINE uint32_t __get_GSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, cr<12, 0>" : "=r" (result) );
+  return(result);
+}
+
+/**
+  \brief   Get GCR
+  \details Returns the content of the GCR Register.
+  \return               GCR Register value
+ */
+__ALWAYS_INLINE uint32_t __get_GCR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, cr<11, 0>" : "=r" (result) );
+  return(result);
+}
+
+/**
+  \brief   Set GCR
+  \details Writes the given value to the GCR Register.
+  \param [in]    gcr  GCR Register value to set
+ */
+__ALWAYS_INLINE void __set_GCR(uint32_t gcr)
+{
+  __ASM volatile ("mtcr %0, cr<11, 0>" : : "r" (gcr) );
+}
+
+#endif /* (__GSR_GCR_PRESENT == 1U) */
+
+/*@} end of CSI_Core_RegAccFunctions */
+
+
+/* ##########################  Core Instruction Access  ######################### */
+/** \defgroup CSI_Core_InstructionInterface CSI Core Instruction Interface
+  Access to dedicated instructions
+  @{
+*/
+
+#define __CSI_GCC_OUT_REG(r) "=r" (r)
+#define __CSI_GCC_USE_REG(r) "r" (r)
+
+/**
+  \brief   No Operation
+  \details No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+__ALWAYS_INLINE void __NOP(void)
+{
+  __ASM volatile ("nop");
+}
+
+
+/**
+  \brief   Wait For Interrupt
+  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
+ */
+__ALWAYS_INLINE void __WFI(void)
+{
+  __ASM volatile ("wait");
+}
+
+/**
+  \brief   Wait For Interrupt
+  \details Wait For Interrupt is a hint instruction that suspends execution until one interrupt occurs.
+ */
+__ALWAYS_INLINE void __WAIT(void)
+{
+  __ASM volatile ("wait");
+}
+
+/**
+  \brief   Doze For Interrupt
+  \details Doze For Interrupt is a hint instruction that suspends execution until one interrupt occurs.
+ */
+__ALWAYS_INLINE void __DOZE(void)
+{
+  __ASM volatile ("doze");
+}
+
+/**
+  \brief   Stop For Interrupt
+  \details Stop For Interrupt is a hint instruction that suspends execution until one interrupt occurs.
+ */
+__ALWAYS_INLINE void __STOP(void)
+{
+  __ASM volatile ("stop");
+}
+
+/**
+  \brief   Instruction Synchronization Barrier
+  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
+           so that all instructions following the ISB are fetched from cache or memory,
+           after the instruction has been completed.
+ */
+__ALWAYS_INLINE void __ISB(void)
+{
+  __ASM volatile ("sync":::"memory");
+}
+
+
+/**
+  \brief   Data Synchronization Barrier
+  \details Acts as a special kind of Data Memory Barrier.
+           It completes when all explicit memory accesses before this instruction complete.
+ */
+__ALWAYS_INLINE void __DSB(void)
+{
+  __ASM volatile ("sync":::"memory");
+}
+
+
+/**
+  \brief   Data Memory Barrier
+  \details Ensures the apparent order of the explicit memory operations before
+           and after the instruction, without ensuring their completion.
+ */
+__ALWAYS_INLINE void __DMB(void)
+{
+  __ASM volatile ("sync":::"memory");
+}
+
+
+/**
+  \brief   Reverse byte order (32 bit)
+  \details Reverses the byte order in integer value.
+  \param [in]    value  Value to reverse
+  \return               Reversed value
+ */
+__ALWAYS_INLINE uint32_t __REV(uint32_t value)
+{
+  return __builtin_bswap32(value);
+}
+
+
+/**
+  \brief   Reverse byte order (16 bit)
+  \details Reverses the byte order in two unsigned short values.
+  \param [in]    value  Value to reverse
+  \return               Reversed value
+ */
+__ALWAYS_INLINE uint32_t __REV16(uint32_t value)
+{
+  uint32_t result;
+#if (__CK80X >= 2)
+  __ASM volatile ("revh %0, %1" : __CSI_GCC_OUT_REG (result) : __CSI_GCC_USE_REG (value) );
+#else
+  result = ((value & 0xFF000000) >> 8) | ((value & 0x00FF0000) << 8) |
+           ((value & 0x0000FF00) >> 8) | ((value & 0x000000FF) << 8);
+#endif
+  return(result);
+}
+
+
+/**
+  \brief   Reverse byte order in signed short value
+  \details Reverses the byte order in a signed short value with sign extension to integer.
+  \param [in]    value  Value to reverse
+  \return               Reversed value
+ */
+__ALWAYS_INLINE int32_t __REVSH(int32_t value)
+{
+  return (short)(((value & 0xFF00) >> 8) | ((value & 0x00FF) << 8));
+}
+
+
+/**
+  \brief   Rotate Right in unsigned value (32 bit)
+  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+  \param [in]    value  Value to rotate
+  \param [in]    value  Number of Bits to rotate
+  \return               Rotated value
+ */
+__ALWAYS_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
+{
+  return (op1 >> op2) | (op1 << (32U - op2));
+}
+
+
+/**
+  \brief   Breakpoint
+  \details Causes the processor to enter Debug state.
+           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+  \param [in]    value  is ignored by the processor.
+                 If required, a debugger can use it to store additional information about the breakpoint.
+ */
+__ALWAYS_INLINE void __BKPT()
+{
+  __ASM volatile ("bkpt");
+}
+
+/**
+  \brief   Reverse bit order of value
+  \details Reverses the bit order of the given value.
+  \param [in]    value  Value to reverse
+  \return               Reversed value
+ */
+__ALWAYS_INLINE uint32_t __RBIT(uint32_t value)
+{
+  uint32_t result;
+
+#if       (__CK80X >= 0x03U)
+   __ASM volatile ("brev %0, %1" : "=r" (result) : "r" (value) );
+#else
+  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
+
+  result = value;                      /* r will be reversed bits of v; first get LSB of v */
+  for (value >>= 1U; value; value >>= 1U)
+  {
+    result <<= 1U;
+    result |= value & 1U;
+    s--;
+  }
+  result <<= s;                        /* shift when v's highest bits are zero */
+#endif
+  return(result);
+}
+
+
+/**
+  \brief   Count leading zeros
+  \details Counts the number of leading zeros of a data value.
+  \param [in]  value  Value to count the leading zeros
+  \return             number of leading zeros in value
+ */
+#define __CLZ             __builtin_clz
+/**
+  \details This function saturates a signed value.
+  \param [in]    x   Value to be saturated
+  \param [in]    y   Bit position to saturate to [1..32]
+  \return            Saturated value.
+ */
+__ALWAYS_INLINE int32_t __SSAT(int32_t x, uint32_t y)
+{
+  int32_t posMax, negMin;
+  uint32_t i;
+
+//  posMax = 1;
+//  for (i = 0; i < (y - 1); i++)
+//  {
+//    posMax = posMax * 2;
+//  }
+
+  posMax = 1 << (y - 1);
+
+  if(x > 0)
+  {
+    posMax = (posMax - 1);
+
+    if(x > posMax)
+    {
+      x = posMax;
+    }
+  }
+  else
+  {
+    negMin = -posMax;
+
+    if(x < negMin)
+    {
+      x = negMin;
+    }
+  }
+  return (x);
+}
+
+__ALWAYS_INLINE int32_t __SSAT_31(int32_t x)
+{
+    int32_t res = x;
+    if (x > 0x3fffffff) {
+       res = 0x3fffffff;
+    } else if (x < -1073741824) {
+       res = -1073741824;
+    }
+
+    return res;
+}
+
+__ALWAYS_INLINE int32_t __SSAT_16(int32_t x)
+{
+#if 0
+    int32_t res = 0x7fff;
+    __ASM volatile ("cmplti   %1, 0x8000\n\t"
+                    "bf       1f\n\t"
+                    "nor      %0, %0\n\t"
+                    "cmplt    %1, %0\n\t"
+                    "movf     %0, %1\n\t"
+                    "1:\n\t"
+                    : "=r" (res), "=r" (x): "0" (res), "1" (x));
+#else
+    int32_t res = x;
+    if (x > 0x7fff) {
+       res = 0x7fff;
+    } else if (x < -32768) {
+       res = -32768;
+    }
+#endif
+    return res;
+}
+
+__ALWAYS_INLINE int32_t __SSAT_8(int32_t x)
+{
+    int32_t res = x;
+    if (x > 0x7f) {
+       res = 0x7f;
+    } else if (x < -128) {
+       res = -128;
+    }
+
+    return res;
+}
+
+/**
+  \brief   Unsigned Saturate
+  \details Saturates an unsigned value.
+  \param [in]  value  Value to be saturated
+  \param [in]    sat  Bit position to saturate to (0..31)
+  \return             Saturated value
+ */
+__ALWAYS_INLINE uint32_t __USAT(uint32_t value, uint32_t sat)
+{
+  uint32_t result;
+
+  if ((((0xFFFFFFFF >> sat) << sat) & value) != 0) {
+    result = 0xFFFFFFFF >> (32 - sat);
+  } else {
+    result = value;
+  }
+
+  return (result);
+}
+
+/**
+  \brief   Unsigned Saturate for internal use
+  \details Saturates an unsigned value, should not call directly.
+  \param [in]  value  Value to be saturated
+  \param [in]    sat  Bit position to saturate to (0..31)
+  \return             Saturated value
+ */
+__ALWAYS_INLINE uint32_t __IUSAT(uint32_t value, uint32_t sat)
+{
+  uint32_t result;
+
+  if (value & 0x80000000) { /* only overflow set bit-31 */
+    result = 0;
+  } else if ((((0xFFFFFFFF >> sat) << sat) & value) != 0) {
+    result = 0xFFFFFFFF >> (32 - sat);
+  } else {
+    result = value;
+  }
+
+  return (result);
+}
+
+#if (__CMSIS_COMPATIBLE == 1)
+/**
+  \brief   Rotate Right with Extend
+  \details This function moves each bit of a bitstring right by one bit.
+           The carry input is shifted in at the left end of the bitstring.
+  \note    carry input will always 0.
+  \param [in]    value  Value to rotate
+  \return               Rotated value
+ */
+__ALWAYS_INLINE uint32_t __RRX(uint32_t op1)
+{
+  return (op1 >> 1);
+}
+
+/**
+  \brief   LDRT Unprivileged (8 bit)
+  \details Executes a Unprivileged LDRT instruction for 8 bit value.
+  \param [in]    ptr  Pointer to data
+  \return             value of type uint8_t at (*ptr)
+ */
+__ALWAYS_INLINE uint8_t __LDRBT(volatile uint8_t *addr)
+{
+    uint32_t result;
+//#warning "__LDRBT"
+   __ASM volatile ("ldb %0, (%1, 0)" : "=r" (result) : "r" (addr));
+   return ((uint8_t) result);    /* Add explicit type cast here */
+}
+
+
+/**
+  \brief   LDRT Unprivileged (16 bit)
+  \details Executes a Unprivileged LDRT instruction for 16 bit values.
+  \param [in]    ptr  Pointer to data
+  \return        value of type uint16_t at (*ptr)
+ */
+__ALWAYS_INLINE uint16_t __LDRHT(volatile uint16_t *addr)
+{
+    uint32_t result;
+
+//#warning "__LDRHT"
+   __ASM volatile ("ldh %0, (%1, 0)" : "=r" (result) : "r" (addr) );
+   return ((uint16_t) result);    /* Add explicit type cast here */
+}
+
+
+/**
+  \brief   LDRT Unprivileged (32 bit)
+  \details Executes a Unprivileged LDRT instruction for 32 bit values.
+  \param [in]    ptr  Pointer to data
+  \return        value of type uint32_t at (*ptr)
+ */
+__ALWAYS_INLINE uint32_t __LDRT(volatile uint32_t *addr)
+{
+    uint32_t result;
+
+//#warning "__LDRT"
+   __ASM volatile ("ldw %0, (%1, 0)" : "=r" (result) : "r" (addr) );
+   return(result);
+}
+
+
+/**
+  \brief   STRT Unprivileged (8 bit)
+  \details Executes a Unprivileged STRT instruction for 8 bit values.
+  \param [in]  value  Value to store
+  \param [in]    ptr  Pointer to location
+ */
+__ALWAYS_INLINE void __STRBT(uint8_t value, volatile uint8_t *addr)
+{
+//#warning "__STRBT"
+   __ASM volatile ("stb %1, (%0, 0)" :: "r" (addr), "r" ((uint32_t)value) : "memory");
+}
+
+
+/**
+  \brief   STRT Unprivileged (16 bit)
+  \details Executes a Unprivileged STRT instruction for 16 bit values.
+  \param [in]  value  Value to store
+  \param [in]    ptr  Pointer to location
+ */
+__ALWAYS_INLINE void __STRHT(uint16_t value, volatile uint16_t *addr)
+{
+//#warning "__STRHT"
+   __ASM volatile ("sth %1, (%0, 0)" :: "r" (addr), "r" ((uint32_t)value) : "memory");
+}
+
+
+/**
+  \brief   STRT Unprivileged (32 bit)
+  \details Executes a Unprivileged STRT instruction for 32 bit values.
+  \param [in]  value  Value to store
+  \param [in]    ptr  Pointer to location
+ */
+__ALWAYS_INLINE void __STRT(uint32_t value, volatile uint32_t *addr)
+{
+//#warning "__STRT"
+   __ASM volatile ("stw %1, (%0, 0)" :: "r" (addr), "r" (value) : "memory");
+}
+#endif /* __CMSIS_COMPATIBLE == 1 */
+
+/*@}*/ /* end of group CSI_Core_InstructionInterface */
+
+/* ##########################  FPU functions  #################################### */
+/**
+  \ingroup  CSI_Core_FunctionInterface
+  \defgroup CSI_Core_FpuFunctions FPU Functions
+  \brief    Function that provides FPU type.
+  @{
+ */
+
+/**
+  \brief   get FPU type
+  \details returns the FPU type, always 0.
+  \returns
+   - \b  0: No FPU
+   - \b  1: Single precision FPU
+   - \b  2: Double + Single precision FPU
+ */
+__STATIC_INLINE uint32_t SCB_GetFPUType(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("mfcr %0, cr<13, 0>" : "=r" (result) );
+  return 0;
+}
+
+
+/*@} end of CSI_Core_FpuFunctions */
+
+
+/* ###################  Compiler specific Intrinsics  ########################### */
+/** \defgroup CSI_SIMD_intrinsics CSI SIMD Intrinsics
+  Access to dedicated SIMD instructions \n
+  Single Instruction Multiple Data (SIMD) extensions are provided to simplify development of application software. SIMD extensions increase the processing capability without materially increasing the power consumption. The SIMD extensions are completely transparent to the operating system (OS), allowing existing OS ports to be used.
+
+  @{
+*/
+
+/**
+  \brief   Halfword packing instruction. Combines bits[15:0] of val1 with bits[31:16]
+           of val2 levitated with the val3.
+  \details Combine a halfword from one register with a halfword from another register.
+           The second argument can be left-shifted before extraction of the halfword.
+  \param [in]    val1   first 16-bit operands
+  \param [in]    val2   second 16-bit operands
+  \param [in]    val3   value for left-shifting val2. Value range [0..31].
+  \return               the combination of halfwords.
+  \remark
+                 res[15:0]  = val1[15:0]              \n
+                 res[31:16] = val2[31:16] << val3
+ */
+__ALWAYS_INLINE uint32_t __PKHBT(uint32_t val1, uint32_t val2, uint32_t val3)
+{
+#ifdef CSKY_SIMD
+  uint32_t res;
+  if (val3 == 16) {
+    __ASM volatile ("pkgll %0, %1, %2" :"=r" (res), "=r" (val1), "=r" (val2): "0" (res), "1" (val1), "2" (val2));
+  } else if (val3 == 0){
+    __ASM volatile ("pkg %0, %1, 0, %2, 16" :"=r" (res), "=r" (val1), "=r" (val2): "0" (res), "1" (val1), "2" (val2));
+  } else {
+    return ((((int32_t)(val1) << 0) & (int32_t)0x0000FFFF) | (((int32_t)(val2) << val3) & (int32_t)0xFFFF0000));
+  }
+  return res;
+#else
+  return ((((int32_t)(val1) << 0) & (int32_t)0x0000FFFF) | (((int32_t)(val2) << val3) & (int32_t)0xFFFF0000));
+#endif
+}
+
+/**
+  \brief   Halfword packing instruction. Combines bits[31:16] of val1 with bits[15:0]
+           of val2 right-shifted with the val3.
+  \details Combine a halfword from one register with a halfword from another register.
+           The second argument can be right-shifted before extraction of the halfword.
+  \param [in]    val1   first 16-bit operands
+  \param [in]    val2   second 16-bit operands
+  \param [in]    val3   value for right-shifting val2. Value range [1..32].
+  \return               the combination of halfwords.
+  \remark
+                 res[15:0]  = val2[15:0] >> val3        \n
+                 res[31:16] = val1[31:16]
+ */
+__ALWAYS_INLINE uint32_t __PKHTB(uint32_t val1, uint32_t val2, uint32_t val3)
+{
+  return ((((int32_t)(val1) << 0) & (int32_t)0xFFFF0000) | (((int32_t)(val2) >> val3) & (int32_t)0x0000FFFF));
+}
+
+/**
+  \brief   Dual 16-bit signed saturate.
+  \details This function saturates a signed value.
+  \param [in]    x   two signed 16-bit values to be saturated.
+  \param [in]    y   bit position for saturation, an integral constant expression in the range 1 to 16.
+  \return        the sum of the absolute differences of the following bytes, added to the accumulation value:\n
+                 the signed saturation of the low halfword in val1, saturated to the bit position specified in
+                 val2 and returned in the low halfword of the return value.\n
+                 the signed saturation of the high halfword in val1, saturated to the bit position specified in
+                 val2 and returned in the high halfword of the return value.
+ */
+__ALWAYS_INLINE uint32_t __SSAT16(int32_t x, const uint32_t y)
+{
+  int32_t r = 0, s = 0;
+
+  r = __SSAT((((int32_t)x << 16) >> 16), y) & (int32_t)0x0000FFFF;
+  s = __SSAT((((int32_t)x      ) >> 16), y) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+}
+
+/**
+  \brief   Dual 16-bit unsigned saturate.
+  \details This function enables you to saturate two signed 16-bit values to a selected unsigned range.
+  \param [in]    x   two signed 16-bit values to be saturated.
+  \param [in]    y   bit position for saturation, an integral constant expression in the range 1 to 16.
+  \return        the saturation of the two signed 16-bit values, as non-negative values:
+                 the saturation of the low halfword in val1, saturated to the bit position specified in
+                 val2 and returned in the low halfword of the return value.\n
+                 the saturation of the high halfword in val1, saturated to the bit position specified in
+                 val2 and returned in the high halfword of the return value.
+ */
+__ALWAYS_INLINE uint32_t __USAT16(int32_t x, const uint32_t y)
+{
+  int32_t r = 0, s = 0;
+
+  r = __IUSAT(((x << 16) >> 16), y) & 0x0000FFFF;
+  s = __IUSAT(((x      ) >> 16), y) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Quad 8-bit saturating addition.
+  \details This function enables you to perform four 8-bit integer additions,
+           saturating the results to the 8-bit signed integer range -2^7 <= x <= 2^7 - 1.
+  \param [in]    x   first four 8-bit summands.
+  \param [in]    y   second four 8-bit summands.
+  \return        the saturated addition of the first byte of each operand in the first byte of the return value.\n
+                 the saturated addition of the second byte of each operand in the second byte of the return value.\n
+                 the saturated addition of the third byte of each operand in the third byte of the return value.\n
+                 the saturated addition of the fourth byte of each operand in the fourth byte of the return value.\n
+                 The returned results are saturated to the 8-bit signed integer range -2^7 <= x <= 2^7 - 1.
+  \remark
+                 res[7:0]   = val1[7:0]   + val2[7:0]        \n
+                 res[15:8]  = val1[15:8]  + val2[15:8]       \n
+                 res[23:16] = val1[23:16] + val2[23:16]      \n
+                 res[31:24] = val1[31:24] + val2[31:24]
+ */
+__ALWAYS_INLINE uint32_t __QADD8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = __SSAT_8(((((int32_t)x << 24) >> 24) + (((int32_t)y << 24) >> 24))) & (int32_t)0x000000FF;
+  s = __SSAT_8(((((int32_t)x << 16) >> 24) + (((int32_t)y << 16) >> 24))) & (int32_t)0x000000FF;
+  t = __SSAT_8(((((int32_t)x <<  8) >> 24) + (((int32_t)y <<  8) >> 24))) & (int32_t)0x000000FF;
+  u = __SSAT_8(((((int32_t)x      ) >> 24) + (((int32_t)y      ) >> 24))) & (int32_t)0x000000FF;
+
+  return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
+}
+
+/**
+  \brief   Quad 8-bit unsigned saturating addition.
+  \details This function enables you to perform four unsigned 8-bit integer additions,
+           saturating the results to the 8-bit unsigned integer range 0 < x < 2^8 - 1.
+  \param [in]    x   first four 8-bit summands.
+  \param [in]    y   second four 8-bit summands.
+  \return        the saturated addition of the first byte of each operand in the first byte of the return value.\n
+                 the saturated addition of the second byte of each operand in the second byte of the return value.\n
+                 the saturated addition of the third byte of each operand in the third byte of the return value.\n
+                 the saturated addition of the fourth byte of each operand in the fourth byte of the return value.\n
+                 The returned results are saturated to the 8-bit signed integer range 0 <= x <= 2^8 - 1.
+  \remark
+                 res[7:0]   = val1[7:0]   + val2[7:0]        \n
+                 res[15:8]  = val1[15:8]  + val2[15:8]       \n
+                 res[23:16] = val1[23:16] + val2[23:16]      \n
+                 res[31:24] = val1[31:24] + val2[31:24]
+ */
+__ALWAYS_INLINE uint32_t __UQADD8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = __IUSAT((((x << 24) >> 24) + ((y << 24) >> 24)), 8) & 0x000000FF;
+  s = __IUSAT((((x << 16) >> 24) + ((y << 16) >> 24)), 8) & 0x000000FF;
+  t = __IUSAT((((x <<  8) >> 24) + ((y <<  8) >> 24)), 8) & 0x000000FF;
+  u = __IUSAT((((x      ) >> 24) + ((y      ) >> 24)), 8) & 0x000000FF;
+
+  return ((u << 24) | (t << 16) | (s <<  8) | (r      ));
+}
+
+/**
+  \brief   Quad 8-bit signed addition.
+  \details This function performs four 8-bit signed integer additions.
+  \param [in]    x  first four 8-bit summands.
+  \param [in]    y  second four 8-bit summands.
+  \return        the addition of the first bytes from each operand, in the first byte of the return value.\n
+                 the addition of the second bytes of each operand, in the second byte of the return value.\n
+                 the addition of the third bytes of each operand, in the third byte of the return value.\n
+                 the addition of the fourth bytes of each operand, in the fourth byte of the return value.
+  \remark
+                 res[7:0]   = val1[7:0]   + val2[7:0]        \n
+                 res[15:8]  = val1[15:8]  + val2[15:8]       \n
+                 res[23:16] = val1[23:16] + val2[23:16]      \n
+                 res[31:24] = val1[31:24] + val2[31:24]
+ */
+__ALWAYS_INLINE uint32_t __SADD8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = ((((int32_t)x << 24) >> 24) + (((int32_t)y << 24) >> 24)) & (int32_t)0x000000FF;
+  s = ((((int32_t)x << 16) >> 24) + (((int32_t)y << 16) >> 24)) & (int32_t)0x000000FF;
+  t = ((((int32_t)x <<  8) >> 24) + (((int32_t)y <<  8) >> 24)) & (int32_t)0x000000FF;
+  u = ((((int32_t)x      ) >> 24) + (((int32_t)y      ) >> 24)) & (int32_t)0x000000FF;
+
+  return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
+}
+
+/**
+  \brief   Quad 8-bit unsigned addition.
+  \details This function performs four unsigned 8-bit integer additions.
+  \param [in]    x  first four 8-bit summands.
+  \param [in]    y  second four 8-bit summands.
+  \return        the addition of the first bytes from each operand, in the first byte of the return value.\n
+                 the addition of the second bytes of each operand, in the second byte of the return value.\n
+                 the addition of the third bytes of each operand, in the third byte of the return value.\n
+                 the addition of the fourth bytes of each operand, in the fourth byte of the return value.
+  \remark
+                 res[7:0]   = val1[7:0]   + val2[7:0]        \n
+                 res[15:8]  = val1[15:8]  + val2[15:8]       \n
+                 res[23:16] = val1[23:16] + val2[23:16]      \n
+                 res[31:24] = val1[31:24] + val2[31:24]
+ */
+__ALWAYS_INLINE uint32_t __UADD8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = (((x << 24) >> 24) + ((y << 24) >> 24)) & 0x000000FF;
+  s = (((x << 16) >> 24) + ((y << 16) >> 24)) & 0x000000FF;
+  t = (((x <<  8) >> 24) + ((y <<  8) >> 24)) & 0x000000FF;
+  u = (((x      ) >> 24) + ((y      ) >> 24)) & 0x000000FF;
+
+  return ((u << 24) | (t << 16) | (s <<  8) | (r      ));
+}
+
+/**
+  \brief   Quad 8-bit saturating subtract.
+  \details This function enables you to perform four 8-bit integer subtractions,
+           saturating the results to the 8-bit signed integer range -2^7 <= x <= 2^7 - 1.
+  \param [in]    x   first four 8-bit summands.
+  \param [in]    y   second four 8-bit summands.
+  \return        the subtraction of the first byte of each operand in the first byte of the return value.\n
+                 the subtraction of the second byte of each operand in the second byte of the return value.\n
+                 the subtraction of the third byte of each operand in the third byte of the return value.\n
+                 the subtraction of the fourth byte of each operand in the fourth byte of the return value.\n
+                 The returned results are saturated to the 8-bit signed integer range -2^7 <= x <= 2^7 - 1.
+  \remark
+                 res[7:0]   = val1[7:0]   - val2[7:0]        \n
+                 res[15:8]  = val1[15:8]  - val2[15:8]       \n
+                 res[23:16] = val1[23:16] - val2[23:16]      \n
+                 res[31:24] = val1[31:24] - val2[31:24]
+ */
+__ALWAYS_INLINE uint32_t __QSUB8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = __SSAT_8(((((int32_t)x << 24) >> 24) - (((int32_t)y << 24) >> 24))) & (int32_t)0x000000FF;
+  s = __SSAT_8(((((int32_t)x << 16) >> 24) - (((int32_t)y << 16) >> 24))) & (int32_t)0x000000FF;
+  t = __SSAT_8(((((int32_t)x <<  8) >> 24) - (((int32_t)y <<  8) >> 24))) & (int32_t)0x000000FF;
+  u = __SSAT_8(((((int32_t)x      ) >> 24) - (((int32_t)y      ) >> 24))) & (int32_t)0x000000FF;
+
+  return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
+}
+
+/**
+  \brief   Quad 8-bit unsigned saturating subtraction.
+  \details This function enables you to perform four unsigned 8-bit integer subtractions,
+           saturating the results to the 8-bit unsigned integer range 0 < x < 2^8 - 1.
+  \param [in]    x   first four 8-bit summands.
+  \param [in]    y   second four 8-bit summands.
+  \return        the subtraction of the first byte of each operand in the first byte of the return value.\n
+                 the subtraction of the second byte of each operand in the second byte of the return value.\n
+                 the subtraction of the third byte of each operand in the third byte of the return value.\n
+                 the subtraction of the fourth byte of each operand in the fourth byte of the return value.\n
+                 The returned results are saturated to the 8-bit unsigned integer range 0 <= x <= 2^8 - 1.
+  \remark
+                 res[7:0]   = val1[7:0]   - val2[7:0]        \n
+                 res[15:8]  = val1[15:8]  - val2[15:8]       \n
+                 res[23:16] = val1[23:16] - val2[23:16]      \n
+                 res[31:24] = val1[31:24] - val2[31:24]
+ */
+__ALWAYS_INLINE uint32_t __UQSUB8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = __IUSAT((((x << 24) >> 24) - ((y << 24) >> 24)), 8) & 0x000000FF;
+  s = __IUSAT((((x << 16) >> 24) - ((y << 16) >> 24)), 8) & 0x000000FF;
+  t = __IUSAT((((x <<  8) >> 24) - ((y <<  8) >> 24)), 8) & 0x000000FF;
+  u = __IUSAT((((x      ) >> 24) - ((y      ) >> 24)), 8) & 0x000000FF;
+
+  return ((u << 24) | (t << 16) | (s <<  8) | (r      ));
+}
+
+/**
+  \brief   Quad 8-bit signed subtraction.
+  \details This function enables you to perform four 8-bit signed integer subtractions.
+  \param [in]    x  first four 8-bit operands of each subtraction.
+  \param [in]    y  second four 8-bit operands of each subtraction.
+  \return        the subtraction of the first bytes from each operand, in the first byte of the return value.\n
+                 the subtraction of the second bytes of each operand, in the second byte of the return value.\n
+                 the subtraction of the third bytes of each operand, in the third byte of the return value.\n
+                 the subtraction of the fourth bytes of each operand, in the fourth byte of the return value.
+  \remark
+                 res[7:0]   = val1[7:0]   - val2[7:0]        \n
+                 res[15:8]  = val1[15:8]  - val2[15:8]       \n
+                 res[23:16] = val1[23:16] - val2[23:16]      \n
+                 res[31:24] = val1[31:24] - val2[31:24]
+ */
+__ALWAYS_INLINE uint32_t __SSUB8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = ((((int32_t)x << 24) >> 24) - (((int32_t)y << 24) >> 24)) & (int32_t)0x000000FF;
+  s = ((((int32_t)x << 16) >> 24) - (((int32_t)y << 16) >> 24)) & (int32_t)0x000000FF;
+  t = ((((int32_t)x <<  8) >> 24) - (((int32_t)y <<  8) >> 24)) & (int32_t)0x000000FF;
+  u = ((((int32_t)x      ) >> 24) - (((int32_t)y      ) >> 24)) & (int32_t)0x000000FF;
+
+  return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
+}
+
+/**
+  \brief   Quad 8-bit unsigned subtract.
+  \details This function enables you to perform four 8-bit unsigned integer subtractions.
+  \param [in]    x  first four 8-bit operands of each subtraction.
+  \param [in]    y  second four 8-bit operands of each subtraction.
+  \return        the subtraction of the first bytes from each operand, in the first byte of the return value.\n
+                 the subtraction of the second bytes of each operand, in the second byte of the return value.\n
+                 the subtraction of the third bytes of each operand, in the third byte of the return value.\n
+                 the subtraction of the fourth bytes of each operand, in the fourth byte of the return value.
+  \remark
+                 res[7:0]   = val1[7:0]   - val2[7:0]        \n
+                 res[15:8]  = val1[15:8]  - val2[15:8]       \n
+                 res[23:16] = val1[23:16] - val2[23:16]      \n
+                 res[31:24] = val1[31:24] - val2[31:24]
+ */
+__ALWAYS_INLINE uint32_t __USUB8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = (((x << 24) >> 24) - ((y << 24) >> 24)) & 0x000000FF;
+  s = (((x << 16) >> 24) - ((y << 16) >> 24)) & 0x000000FF;
+  t = (((x <<  8) >> 24) - ((y <<  8) >> 24)) & 0x000000FF;
+  u = (((x      ) >> 24) - ((y      ) >> 24)) & 0x000000FF;
+
+  return ((u << 24) | (t << 16) | (s <<  8) | (r      ));
+}
+
+/**
+  \brief   Unsigned sum of quad 8-bit unsigned absolute difference.
+  \details This function enables you to perform four unsigned 8-bit subtractions, and add the absolute values
+           of the differences together, returning the result as a single unsigned integer.
+  \param [in]    x  first four 8-bit operands of each subtraction.
+  \param [in]    y  second four 8-bit operands of each subtraction.
+  \return        the subtraction of the first bytes from each operand, in the first byte of the return value.\n
+                 the subtraction of the second bytes of each operand, in the second byte of the return value.\n
+                 the subtraction of the third bytes of each operand, in the third byte of the return value.\n
+                 the subtraction of the fourth bytes of each operand, in the fourth byte of the return value.\n
+                 The sum is returned as a single unsigned integer.
+  \remark
+                 absdiff1   = val1[7:0]   - val2[7:0]        \n
+                 absdiff2   = val1[15:8]  - val2[15:8]       \n
+                 absdiff3   = val1[23:16] - val2[23:16]      \n
+                 absdiff4   = val1[31:24] - val2[31:24]      \n
+                 res[31:0]  = absdiff1 + absdiff2 + absdiff3 + absdiff4
+ */
+__ALWAYS_INLINE uint32_t __USAD8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = (((x << 24) >> 24) - ((y << 24) >> 24)) & 0x000000FF;
+  s = (((x << 16) >> 24) - ((y << 16) >> 24)) & 0x000000FF;
+  t = (((x <<  8) >> 24) - ((y <<  8) >> 24)) & 0x000000FF;
+  u = (((x      ) >> 24) - ((y      ) >> 24)) & 0x000000FF;
+
+  return (u + t + s + r);
+}
+
+/**
+  \brief   Unsigned sum of quad 8-bit unsigned absolute difference with 32-bit accumulate.
+  \details This function enables you to perform four unsigned 8-bit subtractions, and add the absolute values
+           of the differences to a 32-bit accumulate operand.
+  \param [in]    x  first four 8-bit operands of each subtraction.
+  \param [in]    y  second four 8-bit operands of each subtraction.
+  \param [in]  sum  accumulation value.
+  \return        the sum of the absolute differences of the following bytes, added to the accumulation value:
+                 the subtraction of the first bytes from each operand, in the first byte of the return value.\n
+                 the subtraction of the second bytes of each operand, in the second byte of the return value.\n
+                 the subtraction of the third bytes of each operand, in the third byte of the return value.\n
+                 the subtraction of the fourth bytes of each operand, in the fourth byte of the return value.
+  \remark
+                 absdiff1 = val1[7:0]   - val2[7:0]        \n
+                 absdiff2 = val1[15:8]  - val2[15:8]       \n
+                 absdiff3 = val1[23:16] - val2[23:16]      \n
+                 absdiff4 = val1[31:24] - val2[31:24]      \n
+                 sum = absdiff1 + absdiff2 + absdiff3 + absdiff4 \n
+                 res[31:0] = sum[31:0] + val3[31:0]
+ */
+__ALWAYS_INLINE uint32_t __USADA8(uint32_t x, uint32_t y, uint32_t sum)
+{
+  int32_t r, s, t, u;
+
+  r = (((x << 24) >> 24) - ((y << 24) >> 24)) & 0x000000FF;
+  s = (((x << 16) >> 24) - ((y << 16) >> 24)) & 0x000000FF;
+  t = (((x <<  8) >> 24) - ((y <<  8) >> 24)) & 0x000000FF;
+  u = (((x      ) >> 24) - ((y      ) >> 24)) & 0x000000FF;
+
+  return (u + t + s + r + sum);
+}
+
+/**
+  \brief   Dual 16-bit saturating addition.
+  \details This function enables you to perform two 16-bit integer arithmetic additions in parallel,
+           saturating the results to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1.
+  \param [in]    x   first two 16-bit summands.
+  \param [in]    y   second two 16-bit summands.
+  \return        the saturated addition of the low halfwords, in the low halfword of the return value.\n
+                 the saturated addition of the high halfwords, in the high halfword of the return value.\n
+                 The returned results are saturated to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1.
+  \remark
+                 res[15:0]  = val1[15:0]  + val2[15:0]        \n
+                 res[31:16] = val1[31:16] + val2[31:16]
+ */
+__ALWAYS_INLINE uint32_t __QADD16(uint32_t x, uint32_t y)
+{
+#ifdef CSKY_SIMD
+  uint32_t result;
+  __ASM volatile("padd.s16.s %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+  return result;
+#else
+  int32_t r = 0, s = 0;
+
+  r = __SSAT_16(((((int32_t)x << 16) >> 16) + (((int32_t)y << 16) >> 16))) & (int32_t)0x0000FFFF;
+  s = __SSAT_16(((((int32_t)x      ) >> 16) + (((int32_t)y      ) >> 16))) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit unsigned saturating addition.
+  \details This function enables you to perform two unsigned 16-bit integer additions, saturating
+           the results to the 16-bit unsigned integer range 0 < x < 2^16 - 1.
+  \param [in]    x   first two 16-bit summands.
+  \param [in]    y   second two 16-bit summands.
+  \return        the saturated addition of the low halfwords, in the low halfword of the return value.\n
+                 the saturated addition of the high halfwords, in the high halfword of the return value.\n
+                 The results are saturated to the 16-bit unsigned integer range 0 < x < 2^16 - 1.
+  \remark
+                 res[15:0]  = val1[15:0]  + val2[15:0]        \n
+                 res[31:16] = val1[31:16] + val2[31:16]
+ */
+__ALWAYS_INLINE uint32_t __UQADD16(uint32_t x, uint32_t y)
+{
+  int32_t r = 0, s = 0;
+
+  r = __IUSAT((((x << 16) >> 16) + ((y << 16) >> 16)), 16) & 0x0000FFFF;
+  s = __IUSAT((((x      ) >> 16) + ((y      ) >> 16)), 16) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit signed addition.
+  \details This function enables you to perform two 16-bit signed integer additions.
+  \param [in]    x   first two 16-bit summands.
+  \param [in]    y   second two 16-bit summands.
+  \return        the addition of the low halfwords in the low halfword of the return value.\n
+                 the addition of the high halfwords in the high halfword of the return value.
+  \remark
+                 res[15:0]  = val1[15:0]  + val2[15:0]        \n
+                 res[31:16] = val1[31:16] + val2[31:16]
+ */
+__ALWAYS_INLINE uint32_t __SADD16(uint32_t x, uint32_t y)
+{
+#ifdef CSKY_SIMD
+  uint32_t result;
+  __ASM volatile("padd.s16 %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+  return result;
+#else
+  int32_t r = 0, s = 0;
+
+  r = ((((int32_t)x << 16) >> 16) + (((int32_t)y << 16) >> 16)) & (int32_t)0x0000FFFF;
+  s = ((((int32_t)x      ) >> 16) + (((int32_t)y      ) >> 16)) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit unsigned addition
+  \details This function enables you to perform two 16-bit unsigned integer additions.
+  \param [in]    x   first two 16-bit summands for each addition.
+  \param [in]    y   second two 16-bit summands for each addition.
+  \return        the addition of the low halfwords in the low halfword of the return value.\n
+                 the addition of the high halfwords in the high halfword of the return value.
+  \remark
+                 res[15:0]  = val1[15:0]  + val2[15:0]        \n
+                 res[31:16] = val1[31:16] + val2[31:16]
+ */
+__ALWAYS_INLINE uint32_t __UADD16(uint32_t x, uint32_t y)
+{
+  int32_t r = 0, s = 0;
+
+  r = (((x << 16) >> 16) + ((y << 16) >> 16)) & 0x0000FFFF;
+  s = (((x      ) >> 16) + ((y      ) >> 16)) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+
+/**
+  \brief   Dual 16-bit signed addition with halved results.
+  \details This function enables you to perform two signed 16-bit integer additions, halving the results.
+  \param [in]    x   first two 16-bit summands.
+  \param [in]    y   second two 16-bit summands.
+  \return        the halved addition of the low halfwords, in the low halfword of the return value.\n
+                 the halved addition of the high halfwords, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = (val1[15:0]  + val2[15:0]) >> 1        \n
+                 res[31:16] = (val1[31:16] + val2[31:16]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __SHADD16(uint32_t x, uint32_t y)
+{
+#ifdef CSKY_SIMD
+  uint32_t result;
+  __ASM volatile("paddh.s16 %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+  return result;
+#else
+  int32_t r, s;
+
+  r = (((((int32_t)x << 16) >> 16) + (((int32_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
+  s = (((((int32_t)x      ) >> 16) + (((int32_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit unsigned addition with halved results.
+  \details This function enables you to perform two unsigned 16-bit integer additions, halving the results.
+  \param [in]    x   first two 16-bit summands.
+  \param [in]    y   second two 16-bit summands.
+  \return        the halved addition of the low halfwords, in the low halfword of the return value.\n
+                 the halved addition of the high halfwords, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = (val1[15:0]  + val2[15:0]) >> 1        \n
+                 res[31:16] = (val1[31:16] + val2[31:16]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __UHADD16(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = ((((x << 16) >> 16) + ((y << 16) >> 16)) >> 1) & 0x0000FFFF;
+  s = ((((x      ) >> 16) + ((y      ) >> 16)) >> 1) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Quad 8-bit signed addition with halved results.
+  \details This function enables you to perform four signed 8-bit integer additions, halving the results.
+  \param [in]    x   first four 8-bit summands.
+  \param [in]    y   second four 8-bit summands.
+  \return        the halved addition of the first bytes from each operand, in the first byte of the return value.\n
+                 the halved addition of the second bytes from each operand, in the second byte of the return value.\n
+                 the halved addition of the third bytes from each operand, in the third byte of the return value.\n
+                 the halved addition of the fourth bytes from each operand, in the fourth byte of the return value.
+  \remark
+                 res[7:0]   = (val1[7:0]   + val2[7:0]  ) >> 1    \n
+                 res[15:8]  = (val1[15:8]  + val2[15:8] ) >> 1    \n
+                 res[23:16] = (val1[23:16] + val2[23:16]) >> 1    \n
+                 res[31:24] = (val1[31:24] + val2[31:24]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __SHADD8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = (((((int32_t)x << 24) >> 24) + (((int32_t)y << 24) >> 24)) >> 1) & (int32_t)0x000000FF;
+  s = (((((int32_t)x << 16) >> 24) + (((int32_t)y << 16) >> 24)) >> 1) & (int32_t)0x000000FF;
+  t = (((((int32_t)x <<  8) >> 24) + (((int32_t)y <<  8) >> 24)) >> 1) & (int32_t)0x000000FF;
+  u = (((((int32_t)x      ) >> 24) + (((int32_t)y      ) >> 24)) >> 1) & (int32_t)0x000000FF;
+
+  return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
+}
+
+/**
+  \brief   Quad 8-bit unsigned addition with halved results.
+  \details This function enables you to perform four unsigned 8-bit integer additions, halving the results.
+  \param [in]    x   first four 8-bit summands.
+  \param [in]    y   second four 8-bit summands.
+  \return        the halved addition of the first bytes from each operand, in the first byte of the return value.\n
+                 the halved addition of the second bytes from each operand, in the second byte of the return value.\n
+                 the halved addition of the third bytes from each operand, in the third byte of the return value.\n
+                 the halved addition of the fourth bytes from each operand, in the fourth byte of the return value.
+  \remark
+                 res[7:0]   = (val1[7:0]   + val2[7:0]  ) >> 1    \n
+                 res[15:8]  = (val1[15:8]  + val2[15:8] ) >> 1    \n
+                 res[23:16] = (val1[23:16] + val2[23:16]) >> 1    \n
+                 res[31:24] = (val1[31:24] + val2[31:24]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __UHADD8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = ((((x << 24) >> 24) + ((y << 24) >> 24)) >> 1) & 0x000000FF;
+  s = ((((x << 16) >> 24) + ((y << 16) >> 24)) >> 1) & 0x000000FF;
+  t = ((((x <<  8) >> 24) + ((y <<  8) >> 24)) >> 1) & 0x000000FF;
+  u = ((((x      ) >> 24) + ((y      ) >> 24)) >> 1) & 0x000000FF;
+
+  return ((u << 24) | (t << 16) | (s <<  8) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit saturating subtract.
+  \details This function enables you to perform two 16-bit integer subtractions in parallel,
+           saturating the results to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1.
+  \param [in]    x   first two 16-bit summands.
+  \param [in]    y   second two 16-bit summands.
+  \return        the saturated subtraction of the low halfwords, in the low halfword of the return value.\n
+                 the saturated subtraction of the high halfwords, in the high halfword of the return value.\n
+                 The returned results are saturated to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1.
+  \remark
+                 res[15:0]  = val1[15:0]  - val2[15:0]        \n
+                 res[31:16] = val1[31:16] - val2[31:16]
+ */
+__ALWAYS_INLINE uint32_t __QSUB16(uint32_t x, uint32_t y)
+{
+#ifdef CSKY_SIMD
+  uint32_t result;
+  __ASM volatile("psub.s16.s %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+  return result;
+#else
+  int32_t r, s;
+
+  r = __SSAT_16(((((int32_t)x << 16) >> 16) - (((int32_t)y << 16) >> 16))) & (int32_t)0x0000FFFF;
+  s = __SSAT_16(((((int32_t)x      ) >> 16) - (((int32_t)y      ) >> 16))) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit unsigned saturating subtraction.
+  \details This function enables you to perform two unsigned 16-bit integer subtractions,
+           saturating the results to the 16-bit unsigned integer range 0 < x < 2^16 - 1.
+  \param [in]    x   first two 16-bit operands for each subtraction.
+  \param [in]    y   second two 16-bit operands for each subtraction.
+  \return        the saturated subtraction of the low halfwords, in the low halfword of the return value.\n
+                 the saturated subtraction of the high halfwords, in the high halfword of the return value.\n
+                 The returned results are saturated to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1.
+  \remark
+                 res[15:0]  = val1[15:0]  - val2[15:0]        \n
+                 res[31:16] = val1[31:16] - val2[31:16]
+ */
+__ALWAYS_INLINE uint32_t __UQSUB16(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = __IUSAT((((x << 16) >> 16) - ((y << 16) >> 16)), 16) & 0x0000FFFF;
+  s = __IUSAT((((x      ) >> 16) - ((y      ) >> 16)), 16) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit signed subtraction.
+  \details This function enables you to perform two 16-bit signed integer subtractions.
+  \param [in]    x   first two 16-bit operands of each subtraction.
+  \param [in]    y   second two 16-bit operands of each subtraction.
+  \return        the subtraction of the low halfword in the second operand from the low
+                 halfword in the first operand, in the low halfword of the return value. \n
+                 the subtraction of the high halfword in the second operand from the high
+                 halfword in the first operand, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = val1[15:0]  - val2[15:0]        \n
+                 res[31:16] = val1[31:16] - val2[31:16]
+ */
+__ALWAYS_INLINE uint32_t __SSUB16(uint32_t x, uint32_t y)
+{
+#ifdef CSKY_SIMD
+  uint32_t result;
+  __ASM volatile("psub.s16 %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+  return result;
+#else
+  int32_t r, s;
+
+  r = ((((int32_t)x << 16) >> 16) - (((int32_t)y << 16) >> 16)) & (int32_t)0x0000FFFF;
+  s = ((((int32_t)x      ) >> 16) - (((int32_t)y      ) >> 16)) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit unsigned subtract.
+  \details This function enables you to perform two 16-bit unsigned integer subtractions.
+  \param [in]    x   first two 16-bit operands of each subtraction.
+  \param [in]    y   second two 16-bit operands of each subtraction.
+  \return        the subtraction of the low halfword in the second operand from the low
+                 halfword in the first operand, in the low halfword of the return value. \n
+                 the subtraction of the high halfword in the second operand from the high
+                 halfword in the first operand, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = val1[15:0]  - val2[15:0]        \n
+                 res[31:16] = val1[31:16] - val2[31:16]
+ */
+__ALWAYS_INLINE uint32_t __USUB16(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = (((x << 16) >> 16) - ((y << 16) >> 16)) & 0x0000FFFF;
+  s = (((x      ) >> 16) - ((y      ) >> 16)) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit signed subtraction with halved results.
+  \details This function enables you to perform two signed 16-bit integer subtractions, halving the results.
+  \param [in]    x   first two 16-bit summands.
+  \param [in]    y   second two 16-bit summands.
+  \return        the halved subtraction of the low halfwords, in the low halfword of the return value.\n
+                 the halved subtraction of the high halfwords, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = (val1[15:0]  - val2[15:0]) >> 1        \n
+                 res[31:16] = (val1[31:16] - val2[31:16]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __SHSUB16(uint32_t x, uint32_t y)
+{
+#ifdef CSKY_SIMD
+  uint32_t result;
+  __ASM volatile("psubh.s16 %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+  return result;
+#else
+  int32_t r, s;
+
+  r = (((((int32_t)x << 16) >> 16) - (((int32_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
+  s = (((((int32_t)x      ) >> 16) - (((int32_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit unsigned subtraction with halved results.
+  \details This function enables you to perform two unsigned 16-bit integer subtractions, halving the results.
+  \param [in]    x   first two 16-bit summands.
+  \param [in]    y   second two 16-bit summands.
+  \return        the halved subtraction of the low halfwords, in the low halfword of the return value.\n
+                 the halved subtraction of the high halfwords, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = (val1[15:0]  - val2[15:0]) >> 1        \n
+                 res[31:16] = (val1[31:16] - val2[31:16]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __UHSUB16(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = ((((x << 16) >> 16) - ((y << 16) >> 16)) >> 1) & 0x0000FFFF;
+  s = ((((x      ) >> 16) - ((y      ) >> 16)) >> 1) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Quad 8-bit signed addition with halved results.
+  \details This function enables you to perform four signed 8-bit integer subtractions, halving the results.
+  \param [in]    x   first four 8-bit summands.
+  \param [in]    y   second four 8-bit summands.
+  \return        the halved subtraction of the first bytes from each operand, in the first byte of the return value.\n
+                 the halved subtraction of the second bytes from each operand, in the second byte of the return value.\n
+                 the halved subtraction of the third bytes from each operand, in the third byte of the return value.\n
+                 the halved subtraction of the fourth bytes from each operand, in the fourth byte of the return value.
+  \remark
+                 res[7:0]   = (val1[7:0]   - val2[7:0]  ) >> 1    \n
+                 res[15:8]  = (val1[15:8]  - val2[15:8] ) >> 1    \n
+                 res[23:16] = (val1[23:16] - val2[23:16]) >> 1    \n
+                 res[31:24] = (val1[31:24] - val2[31:24]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __SHSUB8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = (((((int32_t)x << 24) >> 24) - (((int32_t)y << 24) >> 24)) >> 1) & (int32_t)0x000000FF;
+  s = (((((int32_t)x << 16) >> 24) - (((int32_t)y << 16) >> 24)) >> 1) & (int32_t)0x000000FF;
+  t = (((((int32_t)x <<  8) >> 24) - (((int32_t)y <<  8) >> 24)) >> 1) & (int32_t)0x000000FF;
+  u = (((((int32_t)x      ) >> 24) - (((int32_t)y      ) >> 24)) >> 1) & (int32_t)0x000000FF;
+
+  return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
+}
+
+/**
+  \brief   Quad 8-bit unsigned subtraction with halved results.
+  \details This function enables you to perform four unsigned 8-bit integer subtractions, halving the results.
+  \param [in]    x   first four 8-bit summands.
+  \param [in]    y   second four 8-bit summands.
+  \return        the halved subtraction of the first bytes from each operand, in the first byte of the return value.\n
+                 the halved subtraction of the second bytes from each operand, in the second byte of the return value.\n
+                 the halved subtraction of the third bytes from each operand, in the third byte of the return value.\n
+                 the halved subtraction of the fourth bytes from each operand, in the fourth byte of the return value.
+  \remark
+                 res[7:0]   = (val1[7:0]   - val2[7:0]  ) >> 1    \n
+                 res[15:8]  = (val1[15:8]  - val2[15:8] ) >> 1    \n
+                 res[23:16] = (val1[23:16] - val2[23:16]) >> 1    \n
+                 res[31:24] = (val1[31:24] - val2[31:24]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __UHSUB8(uint32_t x, uint32_t y)
+{
+  int32_t r, s, t, u;
+
+  r = ((((x << 24) >> 24) - ((y << 24) >> 24)) >> 1) & 0x000000FF;
+  s = ((((x << 16) >> 24) - ((y << 16) >> 24)) >> 1) & 0x000000FF;
+  t = ((((x <<  8) >> 24) - ((y <<  8) >> 24)) >> 1) & 0x000000FF;
+  u = ((((x      ) >> 24) - ((y      ) >> 24)) >> 1) & 0x000000FF;
+
+  return ((u << 24) | (t << 16) | (s <<  8) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit add and subtract with exchange.
+  \details This function enables you to exchange the halfwords of the one operand,
+           then add the high halfwords and subtract the low halfwords,
+           saturating the results to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1.
+  \param [in]    x   first operand for the subtraction in the low halfword,
+                     and the first operand for the addition in the high halfword.
+  \param [in]    y   second operand for the subtraction in the high halfword,
+                     and the second operand for the addition in the low halfword.
+  \return        the saturated subtraction of the high halfword in the second operand from the
+                 low halfword in the first operand, in the low halfword of the return value.\n
+                 the saturated addition of the high halfword in the first operand and the
+                 low halfword in the second operand, in the high halfword of the return value.\n
+                 The returned results are saturated to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1.
+  \remark
+                 res[15:0]  = val1[15:0]  - val2[31:16]        \n
+                 res[31:16] = val1[31:16] + val2[15:0]
+ */
+__ALWAYS_INLINE uint32_t __QASX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+#ifdef CSKY_SIMD
+  r = __QSUB16(x, (int32_t)y >> 16) & (int32_t)0x0000FFFF;
+  s = __QADD16(x, (int32_t)y << 16) & (int32_t)0xFFFF0000;
+
+  return r | s;
+#else
+  r = __SSAT_16(((((int32_t)x << 16) >> 16) - (((int32_t)y      ) >> 16))) & (int32_t)0x0000FFFF;
+  s = __SSAT_16(((((int32_t)x      ) >> 16) + (((int32_t)y << 16) >> 16))) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit unsigned saturating addition and subtraction with exchange.
+  \details This function enables you to exchange the halfwords of the second operand and
+           perform one unsigned 16-bit integer addition and one unsigned 16-bit subtraction,
+           saturating the results to the 16-bit unsigned integer range 0 <= x <= 2^16 - 1.
+  \param [in]    x   first operand for the subtraction in the low halfword,
+                     and the first operand for the addition in the high halfword.
+  \param [in]    y   second operand for the subtraction in the high halfword,
+                     and the second operand for the addition in the low halfword.
+  \return        the saturated subtraction of the high halfword in the second operand from the
+                 low halfword in the first operand, in the low halfword of the return value.\n 
+                 the saturated addition of the high halfword in the first operand and the
+                 low halfword in the second operand, in the high halfword of the return value.\n
+                 The returned results are saturated to the 16-bit unsigned integer range 0 <= x <= 2^16 - 1.
+  \remark
+                 res[15:0]  = val1[15:0]  - val2[31:16]        \n
+                 res[31:16] = val1[31:16] + val2[15:0]
+ */
+__ALWAYS_INLINE uint32_t __UQASX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = __IUSAT((((x << 16) >> 16) - ((y      ) >> 16)), 16) & 0x0000FFFF;
+  s = __IUSAT((((x      ) >> 16) + ((y << 16) >> 16)), 16) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit addition and subtraction with exchange.
+  \details It enables you to exchange the halfwords of the second operand, add the high halfwords
+           and subtract the low halfwords.
+  \param [in]    x   first operand for the subtraction in the low halfword,
+                     and the first operand for the addition in the high halfword.
+  \param [in]    y   second operand for the subtraction in the high halfword,
+                     and the second operand for the addition in the low halfword.
+  \return        the subtraction of the high halfword in the second operand from the
+                 low halfword in the first operand, in the low halfword of the return value.\n
+                 the addition of the high halfword in the first operand and the
+                 low halfword in the second operand, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = val1[15:0]  - val2[31:16]        \n
+                 res[31:16] = val1[31:16] + val2[15:0]
+ */
+__ALWAYS_INLINE uint32_t __SASX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = ((((int32_t)x << 16) >> 16) - (((int32_t)y      ) >> 16)) & (int32_t)0x0000FFFF;
+  s = ((((int32_t)x      ) >> 16) + (((int32_t)y << 16) >> 16)) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+}
+
+/**
+  \brief   Dual 16-bit unsigned addition and subtraction with exchange.
+  \details This function enables you to exchange the two halfwords of the second operand,
+           add the high halfwords and subtract the low halfwords.
+  \param [in]    x   first operand for the subtraction in the low halfword,
+                     and the first operand for the addition in the high halfword.
+  \param [in]    y   second operand for the subtraction in the high halfword,
+                     and the second operand for the addition in the low halfword.
+  \return        the subtraction of the high halfword in the second operand from the
+                 low halfword in the first operand, in the low halfword of the return value.\n
+                 the addition of the high halfword in the first operand and the
+                 low halfword in the second operand, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = val1[15:0]  - val2[31:16]        \n
+                 res[31:16] = val1[31:16] + val2[15:0]
+ */
+__ALWAYS_INLINE uint32_t __UASX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = (((x << 16) >> 16) - ((y      ) >> 16)) & 0x0000FFFF;
+  s = (((x      ) >> 16) + ((y << 16) >> 16)) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit signed addition and subtraction with halved results.
+  \details This function enables you to exchange the two halfwords of one operand, perform one
+           signed 16-bit integer addition and one signed 16-bit subtraction, and halve the results.
+  \param [in]    x   first 16-bit operands.
+  \param [in]    y   second 16-bit operands.
+  \return        the halved subtraction of the high halfword in the second operand from the
+                 low halfword in the first operand, in the low halfword of the return value.\n
+                 the halved addition of the low halfword in the second operand from the high
+                 halfword in the first operand, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = (val1[15:0]  - val2[31:16]) >> 1        \n
+                 res[31:16] = (val1[31:16] + val2[15:0]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __SHASX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = (((((int32_t)x << 16) >> 16) - (((int32_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
+  s = (((((int32_t)x      ) >> 16) + (((int32_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+}
+
+/**
+  \brief   Dual 16-bit unsigned addition and subtraction with halved results and exchange.
+  \details This function enables you to exchange the halfwords of the second operand,
+           add the high halfwords and subtract the low halfwords, halving the results.
+  \param [in]    x   first operand for the subtraction in the low halfword, and
+                     the first operand for the addition in the high halfword.
+  \param [in]    y   second operand for the subtraction in the high halfword, and
+                     the second operand for the addition in the low halfword.
+  \return        the halved subtraction of the high halfword in the second operand from the
+                 low halfword in the first operand, in the low halfword of the return value.\n
+                 the halved addition of the low halfword in the second operand from the high
+                 halfword in the first operand, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = (val1[15:0]  - val2[31:16]) >> 1        \n
+                 res[31:16] = (val1[31:16] + val2[15:0]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __UHASX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = ((((x << 16) >> 16) - ((y      ) >> 16)) >> 1) & 0x0000FFFF;
+  s = ((((x      ) >> 16) + ((y << 16) >> 16)) >> 1) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit subtract and add with exchange.
+  \details This function enables you to exchange the halfwords of one operand,
+           then subtract the high halfwords and add the low halfwords,
+           saturating the results to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1.
+  \param [in]    x   first operand for the addition in the low halfword,
+                     and the first operand for the subtraction in the high halfword.
+  \param [in]    y   second operand for the addition in the high halfword,
+                     and the second operand for the subtraction in the low halfword.
+  \return        the saturated addition of the low halfword of the first operand and the high
+                 halfword of the second operand, in the low halfword of the return value.\n
+                 the saturated subtraction of the low halfword of the second operand from the
+                 high halfword of the first operand, in the high halfword of the return value.\n
+                 The returned results are saturated to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1.
+  \remark
+                 res[15:0]  = val1[15:0]  + val2[31:16]        \n
+                 res[31:16] = val1[31:16] - val2[15:0]
+ */
+__ALWAYS_INLINE uint32_t __QSAX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+#ifdef CSKY_SIMD
+  r = __QADD16(x, (int32_t)y >> 16) & (int32_t)0x0000FFFF;
+  s = __QSUB16(x, (int32_t)y << 16) & (int32_t)0xFFFF0000;
+
+  return r | s;
+#else
+  r = __SSAT_16(((((int32_t)x << 16) >> 16) + (((int32_t)y      ) >> 16))) & (int32_t)0x0000FFFF;
+  s = __SSAT_16(((((int32_t)x      ) >> 16) - (((int32_t)y << 16) >> 16))) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit unsigned saturating subtraction and addition with exchange.
+  \details This function enables you to exchange the halfwords of the second operand and perform
+           one unsigned 16-bit integer subtraction and one unsigned 16-bit addition, saturating
+           the results to the 16-bit unsigned integer range 0 <= x <= 2^16 - 1.
+  \param [in]    x   first operand for the addition in the low halfword,
+                     and the first operand for the subtraction in the high halfword.
+  \param [in]    y   second operand for the addition in the high halfword,
+                     and the second operand for the subtraction in the low halfword.
+  \return        the saturated addition of the low halfword of the first operand and the high
+                 halfword of the second operand, in the low halfword of the return value.\n
+                 the saturated subtraction of the low halfword of the second operand from the
+                 high halfword of the first operand, in the high halfword of the return value.\n
+                 The returned results are saturated to the 16-bit unsigned integer range 0 <= x <= 2^16 - 1.
+  \remark
+                 res[15:0]  = val1[15:0]  + val2[31:16]        \n
+                 res[31:16] = val1[31:16] - val2[15:0]
+ */
+__ALWAYS_INLINE uint32_t __UQSAX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = __IUSAT((((x << 16) >> 16) + ((y      ) >> 16)), 16) & 0x0000FFFF;
+  s = __IUSAT((((x      ) >> 16) - ((y << 16) >> 16)), 16) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit unsigned subtract and add with exchange.
+  \details This function enables you to exchange the halfwords of the second operand,
+           subtract the high halfwords and add the low halfwords.
+  \param [in]    x   first operand for the addition in the low halfword,
+                     and the first operand for the subtraction in the high halfword.
+  \param [in]    y   second operand for the addition in the high halfword,
+                     and the second operand for the subtraction in the low halfword.
+  \return        the addition of the low halfword of the first operand and the high
+                 halfword of the second operand, in the low halfword of the return value.\n
+                 the subtraction of the low halfword of the second operand from the
+                 high halfword of the first operand, in the high halfword of the return value.\n
+  \remark
+                 res[15:0]  = val1[15:0]  + val2[31:16]        \n
+                 res[31:16] = val1[31:16] - val2[15:0]
+ */
+__ALWAYS_INLINE uint32_t __USAX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = (((x << 16) >> 16) + ((y      ) >> 16)) & 0x0000FFFF;
+  s = (((x      ) >> 16) - ((y << 16) >> 16)) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit signed subtraction and addition with exchange.
+  \details This function enables you to exchange the two halfwords of one operand and perform one
+           16-bit integer subtraction and one 16-bit addition.
+  \param [in]    x   first operand for the addition in the low halfword, and the first operand
+                     for the subtraction in the high halfword.
+  \param [in]    y   second operand for the addition in the high halfword, and the second
+                     operand for the subtraction in the low halfword.
+  \return        the addition of the low halfword of the first operand and the high
+                 halfword of the second operand, in the low halfword of the return value.\n
+                 the subtraction of the low halfword of the second operand from the
+                 high halfword of the first operand, in the high halfword of the return value.\n
+  \remark
+                 res[15:0]  = val1[15:0]  + val2[31:16]        \n
+                 res[31:16] = val1[31:16] - val2[15:0]
+ */
+__ALWAYS_INLINE uint32_t __SSAX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = ((((int32_t)x << 16) >> 16) + (((int32_t)y      ) >> 16)) & (int32_t)0x0000FFFF;
+  s = ((((int32_t)x      ) >> 16) - (((int32_t)y << 16) >> 16)) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+}
+
+
+/**
+  \brief   Dual 16-bit signed subtraction and addition with halved results.
+  \details This function enables you to exchange the two halfwords of one operand, perform one signed
+           16-bit integer subtraction and one signed 16-bit addition, and halve the results.
+  \param [in]    x   first 16-bit operands.
+  \param [in]    y   second 16-bit operands.
+  \return        the halved addition of the low halfword in the first operand and the
+                 high halfword in the second operand, in the low halfword of the return value.\n
+                 the halved subtraction of the low halfword in the second operand from the
+                 high halfword in the first operand, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = (val1[15:0]  + val2[31:16]) >> 1        \n
+                 res[31:16] = (val1[31:16] - val2[15:0]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __SHSAX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = (((((int32_t)x << 16) >> 16) + (((int32_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
+  s = (((((int32_t)x      ) >> 16) - (((int32_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
+
+  return ((uint32_t)((s << 16) | (r      )));
+}
+
+/**
+  \brief   Dual 16-bit unsigned subtraction and addition with halved results and exchange.
+  \details This function enables you to exchange the halfwords of the second operand,
+           subtract the high halfwords and add the low halfwords, halving the results.
+  \param [in]    x   first operand for the addition in the low halfword, and
+                     the first operand for the subtraction in the high halfword.
+  \param [in]    y   second operand for the addition in the high halfword, and
+                     the second operand for the subtraction in the low halfword.
+  \return        the halved addition of the low halfword in the first operand and the
+                 high halfword in the second operand, in the low halfword of the return value.\n
+                 the halved subtraction of the low halfword in the second operand from the
+                 high halfword in the first operand, in the high halfword of the return value.
+  \remark
+                 res[15:0]  = (val1[15:0]  + val2[31:16]) >> 1        \n
+                 res[31:16] = (val1[31:16] - val2[15:0]) >> 1
+ */
+__ALWAYS_INLINE uint32_t __UHSAX(uint32_t x, uint32_t y)
+{
+  int32_t r, s;
+
+  r = ((((x << 16) >> 16) + ((y      ) >> 16)) >> 1) & 0x0000FFFF;
+  s = ((((x      ) >> 16) - ((y << 16) >> 16)) >> 1) & 0x0000FFFF;
+
+  return ((s << 16) | (r      ));
+}
+
+/**
+  \brief   Dual 16-bit signed multiply with exchange returning difference.
+  \details This function enables you to perform two 16-bit signed multiplications, subtracting
+           one of the products from the other. The halfwords of the second operand are exchanged
+           before performing the arithmetic. This produces top * bottom and bottom * top multiplication.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \return        the difference of the products of the two 16-bit signed multiplications.
+  \remark
+                 p1 = val1[15:0]  * val2[31:16]       \n
+                 p2 = val1[31:16] * val2[15:0]        \n
+                 res[31:0] = p1 - p2
+ */
+__ALWAYS_INLINE uint32_t __SMUSDX(uint32_t x, uint32_t y)
+{
+#ifdef CSKY_SIMD
+  uint32_t result;
+  __ASM volatile("mulcsx.s16 %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+  return result;
+#else
+  return ((uint32_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y      ) >> 16)) -
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y << 16) >> 16))   ));
+#endif
+}
+
+/**
+  \brief   Sum of dual 16-bit signed multiply with exchange.
+  \details This function enables you to perform two 16-bit signed multiplications with exchanged
+           halfwords of the second operand, adding the products together.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \return        the sum of the products of the two 16-bit signed multiplications with exchanged halfwords of the second operand.
+  \remark
+                 p1 = val1[15:0]  * val2[31:16]       \n
+                 p2 = val1[31:16] * val2[15:0]        \n
+                 res[31:0] = p1 + p2
+ */
+__ALWAYS_INLINE uint32_t __SMUADX(uint32_t x, uint32_t y)
+{
+#ifdef CSKY_SIMD
+  uint32_t result;
+  __ASM volatile("mulcax.s16 %0, %2, %1\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+  return result;
+#else
+  return ((uint32_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y      ) >> 16)) +
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y << 16) >> 16))   ));
+#endif
+}
+
+
+/**
+  \brief   Saturating add.
+  \details This function enables you to obtain the saturating add of two integers.
+  \param [in]    x   first summand of the saturating add operation.
+  \param [in]    y   second summand of the saturating add operation.
+  \return        the saturating addition of val1 and val2.
+  \remark
+                 res[31:0] = SAT(val1 + SAT(val2))
+ */
+__ALWAYS_INLINE int32_t __QADD(int32_t x, int32_t y)
+{
+  int32_t result;
+#ifdef CSKY_SIMD
+  __ASM volatile("add.s32.s %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+#else
+  if (y >= 0) {
+    if (x + y >= x) {
+      result = x + y;
+    } else {
+      result = 0x7FFFFFFF;
+    }
+  } else {
+    if (x + y < x) {
+      result = x + y;
+    } else {
+      result = 0x80000000;
+    }
+  }
+#endif
+
+  return result;
+}
+
+/**
+  \brief   Saturating subtract.
+  \details This function enables you to obtain the saturating sub of two integers.
+  \param [in]    x   first summand of the saturating add operation.
+  \param [in]    y   second summand of the saturating add operation.
+  \return        the saturating subtraction of val1 and val2.
+  \remark
+                 res[31:0] = SAT(val1 + SAT(val2))
+ */
+__ALWAYS_INLINE int32_t __QSUB(int32_t x, int32_t y)
+{
+  int32_t result;
+
+#ifdef CSKY_SIMD
+  __ASM volatile("sub.s32.s %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+#else
+  int64_t tmp;
+  tmp = (int64_t)x - (int64_t)y;
+  if (tmp > 0x7fffffff) {
+    tmp = 0x7fffffff;
+  } else if (tmp < (-2147483647 - 1)){
+    tmp = -2147483647-1;
+  }
+
+  result = tmp;
+#endif
+
+  return result;
+}
+
+/**
+  \brief   Dual 16-bit signed multiply with single 32-bit accumulator.
+  \details This function enables you to perform two signed 16-bit multiplications,
+           adding both results to a 32-bit accumulate operand.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \param [in]  sum   accumulate value.
+  \return        the product of each multiplication added to the accumulate value, as a 32-bit integer.
+  \remark
+                 p1 = val1[15:0]  * val2[15:0]      \n
+                 p2 = val1[31:16] * val2[31:16]     \n
+                 res[31:0] = p1 + p2 + val3[31:0]
+ */
+__ALWAYS_INLINE uint32_t __SMUAD(uint32_t x, uint32_t y);
+__ALWAYS_INLINE uint32_t __SMUADX(uint32_t x, uint32_t y);
+__ALWAYS_INLINE uint32_t __SMLAD(uint32_t x, uint32_t y, uint32_t sum)
+{
+#ifdef CSKY_SIMD
+  return sum + __SMUAD(x, y);
+#else
+  return ((uint32_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y << 16) >> 16)) +
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y      ) >> 16)) +
+                     ( ((int32_t)sum    )                                  )   ));
+#endif
+}
+
+/**
+  \brief   Pre-exchanged dual 16-bit signed multiply with single 32-bit accumulator.
+  \details This function enables you to perform two signed 16-bit multiplications with exchanged
+           halfwords of the second operand, adding both results to a 32-bit accumulate operand.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \param [in]  sum   accumulate value.
+  \return        the product of each multiplication with exchanged halfwords of the second
+                 operand added to the accumulate value, as a 32-bit integer.
+  \remark
+                 p1 = val1[15:0]  * val2[31:16]     \n
+                 p2 = val1[31:16] * val2[15:0]      \n
+                 res[31:0] = p1 + p2 + val3[31:0]
+ */
+__ALWAYS_INLINE uint32_t __SMLADX(uint32_t x, uint32_t y, uint32_t sum)
+{
+#ifdef CSKY_SIMD
+  return sum + __SMUADX(x, y);
+#else
+  return ((uint32_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y      ) >> 16)) +
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y << 16) >> 16)) +
+                     ( ((int32_t)sum    )                                  )   ));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit signed multiply with exchange subtract with 32-bit accumulate.
+  \details This function enables you to perform two 16-bit signed multiplications, take the
+           difference of the products, subtracting the high halfword product from the low
+           halfword product, and add the difference to a 32-bit accumulate operand.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \param [in]  sum   accumulate value.
+  \return        the difference of the product of each multiplication, added to the accumulate value.
+  \remark
+                 p1 = val1[15:0]  * val2[15:0]       \n
+                 p2 = val1[31:16] * val2[31:16]      \n
+                 res[31:0] = p1 - p2 + val3[31:0]
+ */
+__ALWAYS_INLINE uint32_t __SMUSD(uint32_t x, uint32_t y);
+__ALWAYS_INLINE uint32_t __SMUSDX(uint32_t x, uint32_t y);
+__ALWAYS_INLINE uint32_t __SMLSD(uint32_t x, uint32_t y, uint32_t sum)
+{
+#ifdef CSKY_SIMD
+  return __SMUSD(x, y) + sum;
+#else
+  return ((uint32_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y << 16) >> 16)) -
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y      ) >> 16)) +
+                     ( ((int32_t)sum    )                                  )   ));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit signed multiply with exchange subtract with 32-bit accumulate.
+  \details This function enables you to exchange the halfwords in the second operand, then perform two 16-bit
+           signed multiplications. The difference of the products is added to a 32-bit accumulate operand.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \param [in]  sum   accumulate value.
+  \return        the difference of the product of each multiplication, added to the accumulate value.
+  \remark
+                 p1 = val1[15:0]  * val2[31:16]     \n
+                 p2 = val1[31:16] * val2[15:0]      \n
+                 res[31:0] = p1 - p2 + val3[31:0]
+ */
+__ALWAYS_INLINE uint32_t __SMLSDX(uint32_t x, uint32_t y, uint32_t sum)
+{
+#ifdef CSKY_SIMD
+  return __SMUSDX(x, y) + sum;
+#else
+  return ((uint32_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y      ) >> 16)) -
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y << 16) >> 16)) +
+                     ( ((int32_t)sum    )                                  )   ));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit signed multiply with single 64-bit accumulator.
+  \details This function enables you to perform two signed 16-bit multiplications, adding both results
+           to a 64-bit accumulate operand. Overflow is only possible as a result of the 64-bit addition.
+           This overflow is not detected if it occurs. Instead, the result wraps around modulo2^64.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \param [in]  sum   accumulate value.
+  \return        the product of each multiplication added to the accumulate value.
+  \remark
+                 p1 = val1[15:0]  * val2[15:0]      \n
+                 p2 = val1[31:16] * val2[31:16]     \n
+                 sum = p1 + p2 + val3[63:32][31:0]  \n
+                 res[63:32] = sum[63:32]            \n
+                 res[31:0]  = sum[31:0]
+ */
+__ALWAYS_INLINE uint64_t __SMLALD(uint32_t x, uint32_t y, uint64_t sum)
+{
+#ifdef CSKY_SIMD
+  __ASM volatile("mulaca.s16.e %0, %R0, %1, %2\n\t"
+                   :"=r" (sum), "=r" (x), "=r" (y) : "0" (sum), "1" (x), "2" (y));
+  return sum;
+#else
+  return ((uint64_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y << 16) >> 16)) +
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y      ) >> 16)) +
+                     ( ((uint64_t)sum    )                                  )   ));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit signed multiply with exchange with single 64-bit accumulator.
+  \details This function enables you to exchange the halfwords of the second operand, and perform two
+           signed 16-bit multiplications, adding both results to a 64-bit accumulate operand. Overflow
+           is only possible as a result of the 64-bit addition. This overflow is not detected if it occurs.
+           Instead, the result wraps around modulo2^64.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \param [in]  sum   accumulate value.
+  \return        the product of each multiplication added to the accumulate value.
+  \remark
+                 p1 = val1[15:0]  * val2[31:16]     \n
+                 p2 = val1[31:16] * val2[15:0]      \n
+                 sum = p1 + p2 + val3[63:32][31:0]  \n
+                 res[63:32] = sum[63:32]            \n
+                 res[31:0]  = sum[31:0]
+ */
+__ALWAYS_INLINE uint64_t __SMLALDX(uint32_t x, uint32_t y, uint64_t sum)
+{
+#ifdef CSKY_SIMD
+  __ASM volatile("mulacax.s16.e %0, %R0, %2, %1\n\t"
+                   :"=r" (sum), "=r" (x), "=r" (y) : "0" (sum), "1" (x), "2" (y));
+  return sum;
+#else
+  return ((uint64_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y      ) >> 16)) +
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y << 16) >> 16)) +
+                     ( ((uint64_t)sum    )                                  )   ));
+#endif
+}
+
+/**
+  \brief   dual 16-bit signed multiply subtract with 64-bit accumulate.
+  \details This function It enables you to perform two 16-bit signed multiplications, take the difference
+           of the products, subtracting the high halfword product from the low halfword product, and add the
+           difference to a 64-bit accumulate operand. Overflow cannot occur during the multiplications or the
+           subtraction. Overflow can occur as a result of the 64-bit addition, and this overflow is not
+           detected. Instead, the result wraps round to modulo2^64.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \param [in]  sum   accumulate value.
+  \return        the difference of the product of each multiplication, added to the accumulate value.
+  \remark
+                 p1 = val1[15:0]  * val2[15:0]      \n
+                 p2 = val1[31:16] * val2[31:16]     \n
+                 res[63:0] = p1 - p2 + val3[63:0]
+ */
+__ALWAYS_INLINE uint64_t __SMLSLD(uint32_t x, uint32_t y, uint64_t sum)
+{
+  return ((uint64_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y << 16) >> 16)) -
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y      ) >> 16)) +
+                     ( ((uint64_t)sum    )                                  )   ));
+}
+
+/**
+  \brief   Dual 16-bit signed multiply with exchange subtract with 64-bit accumulate.
+  \details This function enables you to exchange the halfwords of the second operand, perform two 16-bit multiplications,
+           adding the difference of the products to a 64-bit accumulate operand. Overflow cannot occur during the
+           multiplications or the subtraction. Overflow can occur as a result of the 64-bit addition, and this overflow
+           is not detected. Instead, the result wraps round to modulo2^64.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \param [in]  sum   accumulate value.
+  \return        the difference of the product of each multiplication, added to the accumulate value.
+  \remark
+                 p1 = val1[15:0]  * val2[31:16]      \n
+                 p2 = val1[31:16] * val2[15:0]       \n
+                 res[63:0] = p1 - p2 + val3[63:0]
+ */
+__ALWAYS_INLINE uint64_t __SMLSLDX(uint32_t x, uint32_t y, uint64_t sum)
+{
+  return ((uint64_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y      ) >> 16)) -
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y << 16) >> 16)) +
+                     ( ((uint64_t)sum    )                                  )   ));
+}
+
+/**
+  \brief   32-bit signed multiply with 32-bit truncated accumulator.
+  \details This function enables you to perform a signed 32-bit multiplications, adding the most
+           significant 32 bits of the 64-bit result to a 32-bit accumulate operand.
+  \param [in]    x   first operand for multiplication.
+  \param [in]    y   second operand for multiplication.
+  \param [in]  sum   accumulate value.
+  \return        the product of multiplication (most significant 32 bits) is added to the accumulate value, as a 32-bit integer.
+  \remark
+                 p = val1 * val2      \n
+                 res[31:0] = p[61:32] + val3[31:0]
+ */
+__ALWAYS_INLINE uint32_t __SMMLA(int32_t x, int32_t y, int32_t sum)
+{
+  return (uint32_t)((int32_t)((int64_t)((int64_t)x * (int64_t)y) >> 32) + sum);
+}
+
+/**
+  \brief   Sum of dual 16-bit signed multiply.
+  \details This function enables you to perform two 16-bit signed multiplications, adding the products together.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \return        the sum of the products of the two 16-bit signed multiplications.
+  \remark
+                 p1 = val1[15:0]  * val2[15:0]      \n
+                 p2 = val1[31:16] * val2[31:16]     \n
+                 res[31:0] = p1 + p2
+ */
+__ALWAYS_INLINE uint32_t __SMUAD(uint32_t x, uint32_t y)
+{
+#ifdef CSKY_SIMD
+  uint32_t result;
+  __ASM volatile("mulca.s16 %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+  return result;
+#else
+  return ((uint32_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y << 16) >> 16)) +
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y      ) >> 16))   ));
+#endif
+}
+
+/**
+  \brief   Dual 16-bit signed multiply returning difference.
+  \details This function enables you to perform two 16-bit signed multiplications, taking the difference
+           of the products by subtracting the high halfword product from the low halfword product.
+  \param [in]    x   first 16-bit operands for each multiplication.
+  \param [in]    y   second 16-bit operands for each multiplication.
+  \return        the difference of the products of the two 16-bit signed multiplications.
+  \remark
+                 p1 = val1[15:0]  * val2[15:0]      \n
+                 p2 = val1[31:16] * val2[31:16]     \n
+                 res[31:0] = p1 - p2
+ */
+__ALWAYS_INLINE uint32_t __SMUSD(uint32_t x, uint32_t y)
+{
+#ifdef CSKY_SIMD
+  uint32_t result;
+  __ASM volatile("mulcs.s16 %0, %1, %2\n\t"
+                   :"=r" (result), "=r" (x), "=r" (y) : "0" (result), "1" (x), "2" (y));
+  return result;
+#else
+  return ((uint32_t)(((((int32_t)x << 16) >> 16) * (((int32_t)y << 16) >> 16)) -
+                     ((((int32_t)x      ) >> 16) * (((int32_t)y      ) >> 16))   ));
+#endif
+}
+
+/**
+  \brief   Dual extracted 8-bit to 16-bit signed addition.
+  \details This function enables you to extract two 8-bit values from the second operand (at bit positions
+           [7:0] and [23:16]), sign-extend them to 16-bits each, and add the results to the first operand.
+  \param [in]    x   values added to the sign-extended to 16-bit values.
+  \param [in]    x   two 8-bit values to be extracted and sign-extended.
+  \return        the addition of val1 and val2, where the 8-bit values in val2[7:0] and
+                 val2[23:16] have been extracted and sign-extended prior to the addition.
+  \remark
+                 res[15:0]  = val1[15:0] + SignExtended(val2[7:0])      \n
+                 res[31:16] = val1[31:16] + SignExtended(val2[23:16])
+ */
+__ALWAYS_INLINE uint32_t __SXTAB16(uint32_t x, uint32_t y)
+{
+  return ((uint32_t)((((((int32_t)y << 24) >> 24) + (((int32_t)x << 16) >> 16)) & (int32_t)0x0000FFFF) |
+                     (((((int32_t)y <<  8) >>  8)  + (((int32_t)x >> 16) << 16)) & (int32_t)0xFFFF0000)  ));
+}
+
+/**
+  \brief   Extracted 16-bit to 32-bit unsigned addition.
+  \details This function enables you to extract two 8-bit values from one operand, zero-extend
+           them to 16 bits each, and add the results to two 16-bit values from another operand.
+  \param [in]    x   values added to the zero-extended to 16-bit values.
+  \param [in]    x   two 8-bit values to be extracted and zero-extended.
+  \return        the addition of val1 and val2, where the 8-bit values in val2[7:0] and
+                 val2[23:16] have been extracted and zero-extended prior to the addition.
+  \remark
+                 res[15:0]  = ZeroExt(val2[7:0]   to 16 bits) + val1[15:0]      \n
+                 res[31:16] = ZeroExt(val2[31:16] to 16 bits) + val1[31:16]
+ */
+__ALWAYS_INLINE uint32_t __UXTAB16(uint32_t x, uint32_t y)
+{
+  return ((uint32_t)(((((y << 24) >> 24) + ((x << 16) >> 16)) & 0x0000FFFF) |
+                     ((((y <<  8) >>  8) + ((x >> 16) << 16)) & 0xFFFF0000)  ));
+}
+
+/**
+  \brief   Dual extract 8-bits and sign extend each to 16-bits.
+  \details This function enables you to extract two 8-bit values from an operand and sign-extend them to 16 bits each.
+  \param [in]    x   two 8-bit values in val[7:0] and val[23:16] to be sign-extended.
+  \return        the 8-bit values sign-extended to 16-bit values.\n
+                 sign-extended value of val[7:0] in the low halfword of the return value.\n
+                 sign-extended value of val[23:16] in the high halfword of the return value.
+  \remark
+                 res[15:0]  = SignExtended(val[7:0])       \n
+                 res[31:16] = SignExtended(val[23:16])
+ */
+__ALWAYS_INLINE uint32_t __SXTB16(uint32_t x)
+{
+#ifdef CSKY_SIMD
+  uint32_t res = x;
+  __ASM volatile("plsli.16 %0, %0, 8\n\t"
+                 "pasri.16 %0, %0, 8\n\t"
+                 :"=r" (res) : "0" (res));
+  return res;
+#else
+  return ((uint32_t)(((((int32_t)x << 24) >> 24) & (int32_t)0x0000FFFF) |
+                     ((((int32_t)x <<  8) >>  8) & (int32_t)0xFFFF0000)  ));
+#endif
+}
+
+/**
+  \brief   Dual extract 8-bits and zero-extend to 16-bits.
+  \details This function enables you to extract two 8-bit values from an operand and zero-extend them to 16 bits each.
+  \param [in]    x   two 8-bit values in val[7:0] and val[23:16] to be zero-extended.
+  \return        the 8-bit values sign-extended to 16-bit values.\n
+                 sign-extended value of val[7:0] in the low halfword of the return value.\n
+                 sign-extended value of val[23:16] in the high halfword of the return value.
+  \remark
+                 res[15:0]  = ZeroExtended(val[7:0])       \n
+                 res[31:16] = ZeroExtended(val[23:16])
+ */
+__ALWAYS_INLINE uint32_t __UXTB16(uint32_t x)
+{
+  return ((uint32_t)((((x << 24) >> 24) & 0x0000FFFF) |
+                     (((x <<  8) >>  8) & 0xFFFF0000)  ));
+}
+/*@} end of group CSI_SIMD_intrinsics */
+
+#ifdef CSKY_SIMD
+/* SMMLAR */
+__ALWAYS_INLINE int32_t multAcc_32x32_keep32_R(int32_t a, int32_t x, int32_t y)
+{
+    __ASM volatile("mula.s32.rh %0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y) : "0" (a), "1" (x), "2" (y));
+    return a;
+}
+
+/* SMMLSR */
+__ALWAYS_INLINE int32_t multSub_32x32_keep32_R(int32_t a, int32_t x, int32_t y)
+{
+    __ASM volatile("muls.s32.rh %0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "0" (a), "1" (x), "2" (y));
+    return a;
+}
+
+/* SMMULR */
+__ALWAYS_INLINE int32_t mult_32x32_keep32_R(int32_t x, int32_t y)
+{
+    int32_t a;
+    __ASM volatile("mul.s32.rh %0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "1" (x), "2" (y));
+    return a;
+}
+
+/* SMMLA */
+__ALWAYS_INLINE int32_t multAcc_32x32_keep32(int32_t a, int32_t x, int32_t y)
+{
+    __ASM volatile("mula.s32.h %0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "0" (a), "1" (x), "2" (y));
+    return a;
+}
+
+/* SMMLS */
+__ALWAYS_INLINE int32_t multSub_32x32_keep32(int32_t a, int32_t x, int32_t y)
+{
+    __ASM volatile("muls.s32.h %0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "0" (a), "1" (x), "2" (y));
+    return a;
+}
+
+/* SMMUL */
+__ALWAYS_INLINE int32_t mult_32x32_keep32(int32_t x, int32_t y)
+{
+    int32_t a;
+    __ASM volatile("mul.s32.h %0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "0" (a), "1" (x), "2" (y));
+    return a;
+}
+
+__ALWAYS_INLINE int32_t multAcc_16x16_keep32(int32_t a, int16_t x, int16_t y)
+{
+    __ASM volatile("mulall.s16 %0, %1, %2, %0\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "0" (a), "1" (x), "2" (y));
+    return a;
+}
+
+__ALWAYS_INLINE int64_t multAcc_16x16_keep64(int64_t a, int16_t x, int16_t y)
+{
+    __ASM volatile("mulall.s16.e %0, %R0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "0" (a), "1" (x), "2" (y));
+    return a;
+}
+
+__ALWAYS_INLINE int64_t mult_32x32_keep64(int32_t x, int32_t y)
+{
+    int64_t a;
+    __ASM volatile("mul.s32 %0, %R0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "1" (x), "2" (y));
+    return a;
+}
+
+__ALWAYS_INLINE int64_t multAcc_32x32_keep64(int64_t a, int32_t x, int32_t y)
+{
+    __ASM volatile("mula.s32 %0, %R0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "0" (a), "1" (x), "2" (y));
+    return a;
+}
+
+__ALWAYS_INLINE int32_t mult_32x32_dext_31(int32_t x, int32_t y)
+{
+    int64_t tmp1;
+    int32_t tmp2;
+    __ASM volatile("mul.s32 %0, %R0, %1, %2\n\t"
+                   "dext %3, %0, %R0, 31"
+                   :"=r" (tmp1), "=r" (x), "=r" (y), "=r" (tmp2): "1" (x), "2" (y));
+    return tmp2;
+}
+
+__ALWAYS_INLINE int32_t mult_32x32_dext_30(int32_t x, int32_t y)
+{
+    int64_t tmp1;
+    int32_t tmp2;
+    __ASM volatile("mul.s32 %0, %R0, %1, %2\n\t"
+                   "dext %3, %0, %R0, 30"
+                   :"=r" (tmp1), "=r" (x), "=r" (y), "=r" (tmp2): "1" (x), "2" (y));
+    return tmp2;
+}
+
+__ALWAYS_INLINE int32_t mult_32x32_dext_4(int32_t x, int32_t y)
+{
+    int64_t tmp1;
+    int32_t tmp2;
+    __ASM volatile("mul.s32 %0, %R0, %1, %2\n\t"
+                   "dext %3, %0, %R0, 4"
+                   :"=r" (tmp1), "=r" (x), "=r" (y), "=r" (tmp2): "1" (x), "2" (y));
+    return tmp2;
+}
+
+__ALWAYS_INLINE int32_t mult_32x32_dext_33(int32_t x, int32_t y)
+{
+    int64_t tmp1;
+    int32_t tmp2;
+    __ASM volatile("mul.s32 %0, %R0, %1, %2\n\t"
+                   "lsri %3, %R0, 1"
+                   :"=r" (tmp1), "=r" (x), "=r" (y), "=r" (tmp2): "1" (x), "2" (y));
+    return tmp2;
+}
+
+__ALWAYS_INLINE int32_t dext_31(int64_t x)
+{
+    int32_t tmp1;
+    __ASM volatile(
+                   "dext %0, %1, %R1, 31"
+                   :"=r" (tmp1), "=r" (x) : "1" (x));
+    return tmp1;
+}
+
+__ALWAYS_INLINE int32_t mult_l16xl16_keep32(int32_t x, int32_t y)
+{
+    int32_t a;
+    __ASM volatile("mulll.s16 %0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "1" (x), "2" (y));
+    return a;
+}
+
+__ALWAYS_INLINE int32_t mult_h16xl16_keep32(int32_t x, int32_t y)
+{
+    int32_t a;
+    __ASM volatile("mulhl.s16 %0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "1" (x), "2" (y));
+    return a;
+}
+
+__ALWAYS_INLINE int32_t mult_h16xh16_keep32(int32_t x, int32_t y)
+{
+    int32_t a;
+    __ASM volatile("mulhh.s16 %0, %1, %2\n\t"
+                   :"=r" (a), "=r" (x), "=r" (y): "1" (x), "2" (y));
+    return a;
+}
+//__ALWAYS_INLINE int32_t __CLPSFTS_31(int32_t x)
+//{
+//    int32_t tmp1;
+//    __ASM volatile(
+//                   "clpsfts %0, %1, 1, 0"
+//                   :"=r" (tmp1), "=r" (x) : "1" (x));
+//    return tmp1;
+//}
+
+#endif
+
+#endif /* __CSI_GCC_H */
diff --git a/tests/csky/board/smartl/ck803s/ckcpu.ld b/tests/csky/board/smartl/ck803s/ckcpu.ld
new file mode 100644
index 0000000..4ade5cb
--- /dev/null
+++ b/tests/csky/board/smartl/ck803s/ckcpu.ld
@@ -0,0 +1,86 @@
+
+
+ENTRY(__start)
+
+MEMORY
+{
+	INST   : ORIGIN = 0x00008000 , LENGTH = 0x00020000    /* ROM */
+	DATA   : ORIGIN = 0x20000000 , LENGTH = 0x00010000    /* RAM */
+	EEPROM : ORIGIN = 0x60000000 , LENGTH = 0x00010000
+}
+
+PROVIDE (__stack =  0x20000000 + 0x10000 - 0x10);
+
+SECTIONS
+{
+    .text : {
+		. = ALIGN(0x4) ;
+		*crt0.o(.exp_table)
+		__stext = . ;
+		*(.text)
+		*(.text*)
+		*(.init)
+		*(.fini)
+
+		. = ALIGN(0x10) ;
+		__etext = . ;
+    } > INST
+
+    .rodata : {
+		. = ALIGN(0x4) ;
+		__srodata = .;
+		*(.rdata)
+		*(.rdata*)
+		*(.rodata)
+		*(.rodata*)
+		. = ALIGN(0x10) ;
+		__erodata = .;
+    } > INST
+
+    .data : {
+		. = ALIGN(0x4) ;
+		__sdata = . ;
+		__data_start = . ;
+		data_start = . ;
+		*(.got.plt)
+		*(.got)
+		FILL(0) ;
+		. = ALIGN(0x20) ;
+		LONG(-1)
+		. = ALIGN(0x20) ;
+		*(.gnu.linkonce.r*)
+		*(.data)
+		*(.data*)
+		*(.gnu.linkonce.d*)
+		*(.gcc_except_table)
+		*(.gcc_except_table*)
+		*(.sdata)
+		*(.sdata.*)
+		*(.gnu.linkonce.s.*)
+		*(__libc_atexit)
+		*(__libc_subinit)
+		*(__libc_subfreeres)
+		*(.note.ABI-tag)
+
+		. = ALIGN(0x10) ;
+		__edata = . ;
+	} > INST
+
+    .bss : {
+		. = ALIGN(0x4) ;
+		__sbss = ALIGN(0x4) ;
+		__bss_start = . ;
+		*(.dynsbss)
+		*(.sbss)
+		*(.sbss.*)
+		*(.scommon)
+		*(.dynbss)
+		*(.bss)
+		*(.bss.*)
+		*(COMMON)
+		. = ALIGN(0x10) ;
+		__ebss = . ;
+		__end = . ;
+		end = . ;
+	} > DATA
+}
diff --git a/tests/csky/board/smartl/ck803s/crt0.S b/tests/csky/board/smartl/ck803s/crt0.S
new file mode 100755
index 0000000..6ebe675
--- /dev/null
+++ b/tests/csky/board/smartl/ck803s/crt0.S
@@ -0,0 +1,299 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+/*
+ * crt0.S -- startup codes for CK-CPU.
+ *
+ * Define a exception vector table
+ *
+ * Initial PSR register.
+ * Initial VBR register, relocate exception vector table.
+ * Initial sp(stack pointer) register.
+ * Initial BSS section to "0"
+ * Then goto "main".
+ *
+ * Copyright (C) 2008~2015  Hangzhou C-SKY Microsystems Co., Ltd
+ */
+
+.file "crt0.S"
+
+/*
+ * For importing variable or functions from script file "ckcpu.ld".
+ */
+.import __stack		/* The stack pointer from linking script file */
+.import	__sbss		/* The end of bss from linking script file */
+.import __ebss		/* The end of bss from linking script file */
+
+/*
+ * For importing variable or functions from other c or assemble files.
+ */
+.import main				/* The c codes entry */
+.import coretimer_irq_handler
+.import user1_int_irq_handler
+.import user2_int_irq_handler
+.import user3_int_irq_handler
+.import user4_int_irq_handler
+
+/* For exporting varialbe or functions */
+.export	ckcpu_vsr_table	/* Vector table base address. */
+.export __start				/* The system entry. */
+
+.section .exp_table
+/* Vector table space. */
+
+.align 10
+ckcpu_vsr_table:
+
+.long __start
+.rept 29
+.long default_exception_handler
+.endr
+.long fpu_vsr_autovec
+.long default_exception_handler
+
+.long default_exception_handler
+.long coret_vsr_autovec
+.long default_exception_handler
+/************test CSI use**************************/
+.long user1_vsr_autovec
+/************test CSI use**************************/
+.long user2_vsr_autovec
+/************test CSI use**************************/
+.long user3_vsr_autovec
+/************test CSI use**************************/
+.long user4_vsr_autovec
+.rept 25
+.long default_exception_handler
+.endr
+
+/* The ckcpu startup codes. */
+.text
+	/*
+	 *
+	 * This is the codes first entry point. This is where it all
+	 * begins...
+	 */
+
+__start:
+	/*
+	 * Init psr value, enable exception, disable interrupt and fast interrupt.
+	 * psr = 0x80000100
+	 */
+	lrw	a3, 0x80000100
+	mtcr	a3, psr
+
+	/*
+	 * Setup initial vector base table for interrupts and exceptions
+	 */
+	lrw	a2, ckcpu_vsr_table
+	mtcr	a2, vbr
+
+	/* Initialize the normal stack pointer from the linker definition. */
+	lrw	a1, __stack
+	mov	sp, a1
+
+	/*
+	 * Zero out the bss region.
+	 * NOTE: __sbss must align 4
+	 */
+	lrw	a3, __sbss	/* Get start of bss from linking script file */
+	lrw	a2, __ebss	/* Get end of bss from linking script file */
+	subu	a2, a3		/* Calculate size of bss */
+	lsri	a2, 2		/* Size of whole words */
+	cmpnei	a2, 0
+	bf	__goto_c
+	movi	a1, 0		/* Set zero value to write */
+2:
+	stw	a1, (a3)	/* Zero next word */
+	addi	a3, 4		/* Increase bss pointer */
+	subi	a2, 1		/* Decrease counter */
+	cmpnei	a2, 0
+	bt	2b		/* Repeat for all bss */
+
+	/*
+	 * Assember start up done, C codes start here.
+	 */
+__goto_c:
+	bsr	main
+
+	/* Should never get here. */
+__exit:
+        lrw a1, 0x10002000
+        stw a0, (a1, 0x0)
+	//bkpt
+	br	__exit
+
+/*
+ * default exception service routine, before r0 initialized
+ */
+	.text
+	.balign 4
+default_exception_handler:
+	br	default_exception_handler
+	rte
+
+.weak coretimer_irq_handler
+/*
+ * coret interrupt vector handler
+ */
+	.text
+	.balign 4
+coret_vsr_autovec:
+	/* save context */
+	subi    sp, 28             /* Allocate space for all registers */
+	stw     a0, (sp, 0)
+	stw     a1, (sp, 4)
+	stw     a2, (sp, 8)
+	stw     a3, (sp, 12)
+	stw     t0, (sp, 16)
+	stw     t1, (sp, 20)
+	stw     lr, (sp, 24)
+
+	subi    sp, 8
+	mfcr    a3, epsr
+	stw     a3, (sp, 4)	/* save epsr registwr */
+	mfcr    a2, epc
+	stw     a2, (sp, 0)	/* save epc register */
+	//psrset	ie
+
+	bsr	coretimer_irq_handler
+
+	ldw     a3, (sp, 0)
+	mtcr    a3, epc		/* restore the epc */
+	ldw     a2, (sp, 4)
+	mtcr    a2, epsr	/* restore the epsr */
+	addi    sp, 8
+
+	/* restore all the regs */
+	ldw     a0, (sp, 0)
+	ldw     a1, (sp, 4)
+	ldw     a2, (sp, 8)
+	ldw     a3, (sp, 12)
+	ldw     t0, (sp, 16)
+	ldw     t1, (sp, 20)
+	ldw     lr, (sp, 24)
+	addi    sp, 28
+
+	rte
+
+
+/************test CSI use**************************/
+.weak user1_int_irq_handler
+/*
+ *  user1 interrupt vector handler
+ */
+        .text
+        .balign 4
+user1_vsr_autovec:
+	nie
+	ipush 
+        subi sp,0x4
+        stw lr,(sp,0x0)
+ 
+        jbsr     user1_int_irq_handler
+        ldw lr,(sp,0x0)
+        addi sp,0x4
+        ipop
+        nir
+        
+
+/************test CSI use**************************/
+.weak user2_int_irq_handler
+/*
+ *  user2 interrupt vector handler
+ */
+        .text
+        .balign 4
+user2_vsr_autovec:
+	nie
+	ipush 
+        subi sp,0x4
+        stw lr,(sp,0x0)
+ 
+        jbsr     user2_int_irq_handler
+        ldw lr,(sp,0x0)
+        addi sp,0x4
+        ipop
+        nir
+        
+
+/************test CSI use**************************/
+.weak user3_int_irq_handler
+/*
+ *  user3 interrupt vector handler
+ */
+        .text
+        .balign 4
+user3_vsr_autovec:
+        nie
+        ipush
+        subi sp,0x4
+        stw lr,(sp,0x0)
+
+        jbsr     user3_int_irq_handler
+        ldw lr,(sp,0x0)
+        addi sp,0x4
+        ipop
+        nir
+
+/************test CSI use**************************/
+.weak user4_int_irq_handler
+/*
+ *  user4 interrupt vector handler
+ */
+        .text
+        .balign 4
+user4_vsr_autovec:
+        nie
+        ipush
+        subi sp,0x4
+        stw lr,(sp,0x0)
+
+        jbsr     user4_int_irq_handler
+        ldw lr,(sp,0x0)
+        addi sp,0x4
+        ipop
+        nir
+
+/************test FPU test use**************************/
+/*
+ *  fpu test interrupt vector handler
+ */
+        .text
+        .balign 4
+fpu_vsr_autovec:
+        /* do nothing. */
+        subi sp, 0x4
+        stw  r0, (sp, 0x0)
+        mfcr r0, epc
+        addi r0, r0, 4
+        mtcr r0, epc
+        ldw  r0, (sp, 0x0)
+        addi sp, 0x4
+        rte
+        
+
diff --git a/tests/csky/board/smartl/ck803s/smartl_ck803s.h b/tests/csky/board/smartl/ck803s/smartl_ck803s.h
new file mode 100644
index 0000000..f02f892
--- /dev/null
+++ b/tests/csky/board/smartl/ck803s/smartl_ck803s.h
@@ -0,0 +1,121 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+/******************************************************************************
+ * @file     smart_card_ck803s.h
+ * @brief    CSI Core Peripheral Access Layer Header File for
+ *           CK803 Device Series
+ * @version  V3.00
+ * @date     16. October 2015
+ ******************************************************************************/
+
+#ifndef SMART_CARD_CK803_H
+#define SMART_CARD_CK803_H
+
+#ifdef __cplusplus
+//extern "C" {
+#endif
+
+/* APB frequence definition */
+#define APB_DEFAULT_FREQ       48000000	/* Hz */
+
+/* -------------------------  Interrupt Number Definition  ------------------------ */
+
+typedef enum IRQn {
+/* ----------------------  CK803CM0 Specific Interrupt Numbers  --------------------- */
+	CORET_IRQn = 1,
+	UART0_IRQn = 2,
+} IRQn_Type;
+
+#define __RESET_CONST 0xABCD1234
+
+/* ================================================================================ */
+/* ================      Processor and Core Peripheral Section     ================ */
+/* ================================================================================ */
+
+/* --------  Configuration of the CK803 Processor and Core Peripherals  ------- */
+#define __CM0_REV                 0x0000U	/* Core revision r0p0 */
+#define __MGU_PRESENT             0		/* MGU present or not */
+#define __GSR_GCR_PRESENT         0		/* no GSR/GCR present */
+#define __SOFTRESET_PRESENT       0		/* no soft reset present */
+#define __DCACHE_PRESENT          1
+#define __ICACHE_PRESENT          1
+#define __NVIC_PRIO_BITS          2		/* Number of Bits used for Priority Levels */
+#define __Vendor_SysTickConfig    0		/* Set to 1 if different SysTick Config is used */
+
+#define __CMSIS_COMPATIBLE        1
+#include "CSICORE_CK803S.h"			/* Processor and core peripherals */
+
+/* ================================================================================ */
+/* ================       Device Specific Peripheral Section       ================ */
+/* ================================================================================ */
+
+/* ================================================================================ */
+/* ============== Universal Asyncronous Receiver / Transmitter (UART) ============= */
+/* ================================================================================ */
+typedef struct {
+	union {
+		__IM uint32_t RBR;	/* Offset: 0x000 (R/ )  Receive buffer register */
+		__OM uint32_t THR;	/* Offset: 0x000 ( /W)  Transmission hold register */
+		__IOM uint32_t DLL;	/* Offset: 0x000 (R/W)  Clock frequency division low section register */
+	};
+	union {
+		__IOM uint32_t DLH;	/* Offset: 0x004 (R/W)  Clock frequency division high section register */
+		__IOM uint32_t IER;	/* Offset: 0x004 (R/W)  Interrupt enable register */
+	};
+	__IM uint32_t IIR;		/* Offset: 0x008 (R/ )  Interrupt indicia register */
+	__IOM uint32_t LCR;		/* Offset: 0x00C (R/W)  Transmission control register */
+	uint32_t RESERVED0;
+	__IM uint32_t LSR;		/* Offset: 0x014 (R/ )  Transmission state register */
+	uint32_t RESERVED1[25];
+	__IM uint32_t USR;		/* Offset: 0x07c (R/ )  UART state register */
+} SMARTL_UART_TypeDef;
+
+#define DCACHE_LINE_SIZE 16
+#define DCACHE_SIZE 32*1024
+/* ================================================================================ */
+/* ================              Peripheral memory map             ================ */
+/* ================================================================================ */
+#define SMARTL_UART0_BASE            (0x40015000UL)
+
+/* ================================================================================ */
+/* ================             Peripheral declaration             ================ */
+/* ================================================================================ */
+#define SMARTL_UART0                 ((SMARTL_UART_TypeDef *)    SMARTL_UART0_BASE)
+
+#define SMARTL_UART0                 ((SMARTL_UART_TypeDef *)    SMARTL_UART0_BASE)
+
+#define SMARTL_RAM0_BASE             0x0
+#define SMARTL_CACHE_CRCR0           CACHE_CRCR_1M            
+
+#define SMARTL_RAM1_BASE             0x20000000
+#define SMARTL_CACHE_CRCR1           CACHE_CRCR_1M
+
+#ifdef __cplusplus
+//}
+#endif
+#endif /* SMART_CARD_CK803_H */
diff --git a/tests/csky/board/smartl/ck803s/uart.c b/tests/csky/board/smartl/ck803s/uart.c
new file mode 100644
index 0000000..77868d9
--- /dev/null
+++ b/tests/csky/board/smartl/ck803s/uart.c
@@ -0,0 +1,504 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+/*
+ * Filename: uart.c
+ * Description: this file contains the functions support uart operations
+ * Copyright (C): Hangzhou C-Sky Microsystem Co, Ltd.
+ * Author(s): Shuli Wu (shuli_wu@c-sky.com), YUN YE (yun_ye@c-sky.com).
+ * Contributors:
+ * Date: Otc 10, 2008
+ */
+
+#include <stdio.h>
+#include "uart.h"
+
+/* the table of the uart serial ports */
+static CKStruct_UartInfo CK_Uart_Table[] = {
+    {0, SMARTL_UART0, UART0_IRQn, FALSE, NULL},
+};
+
+/*
+ * Make all the uarts in the idle state;
+ * this function should be called before
+ * INTC module working;
+ */
+void CK_Deactive_UartModule()
+{
+    int i;
+    SMARTL_UART_TypeDef *uart;
+
+    uart = CK_Uart_Table[0].addr;
+    uart->LCR = 0x83;
+    uart->DLL = 0x1;
+    uart->DLH = 0x0;
+
+}
+
+/*
+ * initialize the uart:
+ * baudrate: 19200
+ * date length: 8 bits
+ * paity: None(disabled)
+ * number of stop bits: 1 stop bit
+ * query mode
+ * return: SUCCESS
+ */
+CK_INT32 CK_Uart_Init(CK_Uart_Device uartid)
+{
+    CK_Uart_ChangeBaudrate(uartid, B19200);
+    CK_Uart_SetParity(uartid, NONE);
+    CK_Uart_SetWordSize(uartid, LCR_WORD_SIZE_8);
+    CK_Uart_SetStopBit(uartid, LCR_STOP_BIT_1);
+    CK_Uart_SetRXMode(uartid, TRUE);
+    CK_Uart_SetTXMode(uartid, TRUE);
+    return SUCCESS;
+}
+
+/* open the uart :
+ * set the callback function --- handler(void);
+ * intilize the serial port,sending and receiving buffer;
+ * intilize irqhandler ;
+ * register irqhandler
+ * return: SUCCESS or FAILURE
+ */
+CK_INT32 CK_Uart_Open(CK_Uart_Device uartid, void (*handler) (CK_INT8 error))
+{
+    CKStruct_UartInfo *info;
+    info = &(CK_Uart_Table[uartid]);
+
+    if (info->bopened) {
+        return FAILURE;
+    }
+    CK_Uart_Init(uartid);
+
+    info->handler = handler;
+    info->bopened = TRUE;
+    return SUCCESS;
+}
+
+/* This function is used to close the uart
+ * clear the callback function
+ * free the irq
+ * return: SUCCESS or FAILURE
+ */
+CK_INT32 CK_Uart_Close(CK_Uart_Device uartid)
+{
+    CKStruct_UartInfo *info;
+    SMARTL_UART_TypeDef *uart;
+
+    info = &(CK_Uart_Table[uartid]);
+    uart = info->addr;
+    if (info->bopened) {
+        /* Stop UART interrupt. */
+        uart->IER &= ~IER_RDA_INT_ENABLE;
+        info->handler = NULL;
+        info->bopened = 0;
+        return SUCCESS;
+    }
+    return FAILURE;
+}
+
+/*
+ * This function is used to change the bautrate of uart.
+ * Parameters:
+ * uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ * baudrate--the baudrate that user typed in.
+ * return: SUCCESS or FAILURE
+ */
+
+CK_INT32 CK_Uart_ChangeBaudrate(CK_Uart_Device uartid,
+                                CK_Uart_Baudrate baudrate)
+{
+    CK_INT32 divisor;
+    CK_INT32 timecount;
+    CKStruct_UartInfo *info;
+    SMARTL_UART_TypeDef *uart;
+
+    timecount = 0;
+    info = &(CK_Uart_Table[uartid]);
+    uart = info->addr;
+
+    /*
+     * DLH and DLL may be accessed when the UART is not
+     * busy(USR[0]=0) and the DLAB bit(LCR[7]) is set.
+     */
+    while ((uart->USR & USR_UART_BUSY)
+           && (timecount < UART_BUSY_TIMEOUT)) {
+        timecount++;
+    }
+    if (timecount >= UART_BUSY_TIMEOUT) {
+        return FAILURE;
+    } else {
+        /*baudrate=(seriak clock freq)/(16*divisor). */
+        divisor = ((APB_DEFAULT_FREQ / baudrate) >> 4);
+        uart->LCR |= LCR_SET_DLAB;
+        /* DLL and DLH is lower 8-bits and higher 8-bits of divisor. */
+        uart->DLL = divisor & 0xff;
+        uart->DLH = (divisor >> 8) & 0xff;
+        /*
+         * The DLAB must be cleared after the baudrate is setted
+         * to access other registers.
+         */
+        uart->LCR &= (~LCR_SET_DLAB);
+        info->baudrate = baudrate;
+        return SUCCESS;
+    }
+    return FAILURE;
+}
+
+/*
+ * This function is used to enable or disable parity, also to set ODD or EVEN
+ * parity.
+ * Parameters:
+ *   uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *   parity--ODD=8, EVEN=16, or NONE=0.
+ * return: SUCCESS or FAILURE
+ */
+
+CK_INT32 CK_Uart_SetParity(CK_Uart_Device uartid, CK_Uart_Parity parity)
+{
+    CKStruct_UartInfo *info;
+    SMARTL_UART_TypeDef *uart;
+
+    info = &(CK_Uart_Table[uartid]);
+    uart = info->addr;
+    CK_INT32 timecount;
+    timecount = 0;
+    /* PEN bit(LCR[3]) is writeable when the UART is not busy(USR[0]=0). */
+    while ((uart->USR & USR_UART_BUSY) &&
+           (timecount < UART_BUSY_TIMEOUT)) {
+        timecount++;
+    }
+    if (timecount >= UART_BUSY_TIMEOUT) {
+        return FAILURE;
+    } else {
+        /*CLear the PEN bit(LCR[3]) to disable parity. */
+        uart->LCR &= (~LCR_PARITY_ENABLE);
+
+        info->parity = parity;
+        return SUCCESS;
+    }
+}
+
+/*
+ * We can call this function to set the stop bit--1 bit, 1.5 bits, or 2 bits.
+ * But that it's 1.5 bits or 2, is decided by the wordlenth. When it's 5 bits,
+ * there are 1.5 stop bits, else 2.
+ * Parameters:
+ *  uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *  stopbit--it has two possible value: STOP_BIT_1 and STOP_BIT_2.
+ * return: SUCCESS or FAILURE
+ */
+
+CK_INT32 CK_Uart_SetStopBit(CK_Uart_Device uartid, CK_Uart_StopBit stopbit)
+{
+    CKStruct_UartInfo *info;
+    SMARTL_UART_TypeDef *uart;
+
+    info = &(CK_Uart_Table[uartid]);
+    uart = info->addr;
+    CK_INT32 timecount;
+    timecount = 0;
+    /* PEN bit(LCR[3]) is writeable when the UART is not busy(USR[0]=0). */
+    while ((uart->USR & USR_UART_BUSY) &&
+           (timecount < UART_BUSY_TIMEOUT)) {
+        timecount++;
+    }
+    if (timecount >= UART_BUSY_TIMEOUT) {
+        return FAILURE;
+    } else {
+        /* Clear the STOP bit to set 1 stop bit */
+        uart->LCR &= LCR_STOP_BIT1;
+    }
+    info->stop = stopbit;
+    return SUCCESS;
+}
+
+/*
+ * We can use this function to reset the transmit data length,and we
+ * have four choices:5, 6, 7, and 8 bits.
+ * Parameters:
+ *  uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *  wordsize--the data length that user decides
+ * return: SUCCESS or FAILURE
+ */
+
+CK_INT32 CK_Uart_SetWordSize(CK_Uart_Device uartid, CK_Uart_WordSize wordsize)
+{
+    CKStruct_UartInfo *info;
+    SMARTL_UART_TypeDef *uart;
+    int timecount = 0;
+
+    info = &(CK_Uart_Table[uartid]);
+    uart = info->addr;
+    /* DLS(LCR[1:0]) is writeable when the UART is not busy(USR[0]=0). */
+    while ((uart->USR & USR_UART_BUSY) &&
+           (timecount < UART_BUSY_TIMEOUT)) {
+        timecount++;
+    }
+    if (timecount >= UART_BUSY_TIMEOUT) {
+        return FAILURE;
+    } else {
+        uart->LCR |= LCR_WORD_SIZE_8;
+    }
+    info->word = wordsize;
+    return SUCCESS;
+}
+
+/*
+ * This function is used to set the transmit mode, interrupt mode or
+ * query mode.
+ * Parameters:
+ *  uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *  bQuery--it indicates the transmit mode: TRUE - query mode, FALSE -
+ *  inerrupt mode
+ * return: SUCCESS or FAILURE
+ */
+
+CK_INT32 CK_Uart_SetTXMode(CK_Uart_Device uartid, BOOL bQuery)
+{
+    CKStruct_UartInfo *info;
+    SMARTL_UART_TypeDef *uart;
+
+    info = &(CK_Uart_Table[uartid]);
+    uart = info->addr;
+    CK_INT32 timecount;
+    timecount = 0;
+    while ((uart->USR & USR_UART_BUSY) &&
+           (timecount < UART_BUSY_TIMEOUT)) {
+        timecount++;
+    }
+    if (timecount >= UART_BUSY_TIMEOUT) {
+        return FAILURE;
+    } else {
+        if (bQuery) {
+            /* When query mode, disable the Transmit Holding Register Empty
+             * Interrupt. To do this, we clear the ETBEI bit(IER[1]).
+             */
+            uart->IER &= (~IER_THRE_INT_ENABLE);
+            /* Refresh the uart info: transmit mode - query. */
+            info->btxquery = TRUE;
+        } else {
+            /* When interrupt mode, inable the Transmit Holding Register
+             * Empty Interrupt. To do this, we set the ETBEI bit(IER[1]).
+             */
+            uart->IER |= IER_THRE_INT_ENABLE;
+            /* Refresh the uart info: transmit mode - interrupt. */
+            info->btxquery = FALSE;
+        }
+    }
+    return SUCCESS;
+}
+
+/*
+ * This function is used to set the receive mode, interrupt mode or
+ * query mode.
+ * Parameters:
+ *  uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *  bQuery--it indicates the receive mode: TRUE - query mode, FALSE -
+ *  interrupt mode
+ * return: SUCCESS or FAILURE
+
+ */
+CK_INT32 CK_Uart_SetRXMode(CK_Uart_Device uartid, BOOL bQuery)
+{
+    CKStruct_UartInfo *info;
+    SMARTL_UART_TypeDef *uart;
+
+    info = &(CK_Uart_Table[uartid]);
+    uart = info->addr;
+    CK_INT32 timecount;
+    timecount = 0;
+    /* PEN bit(LCR[3]) is writeable when the UART is not busy(USR[0]=0). */
+    while ((uart->USR & USR_UART_BUSY) &&
+           (timecount < UART_BUSY_TIMEOUT)) {
+        timecount++;
+    }
+    if (timecount >= UART_BUSY_TIMEOUT) {
+        return FAILURE;
+    } else {
+        if (bQuery) {
+            /* When query mode, disable the Received Data Available
+             * Interrupt. To do this, we clear the ERBFI bit(IER[0]).
+             */
+            uart->IER &= (~IER_RDA_INT_ENABLE);
+            /* Refresh the uart info: receive mode - query. */
+            info->brxquery = TRUE;
+        } else {
+            /* When interrupt mode, inable the Received Data Available
+             * Interrupt. To do this, we set the ERBFI bit(IER[0]).
+             */
+            uart->IER |= IER_RDA_INT_ENABLE;
+            /* Refresh the uart info: receive mode - interrupt. */
+            info->brxquery = FALSE;
+        }
+    }
+    return SUCCESS;
+}
+
+/*
+ * Register uart into powermanager.
+ */
+CK_INT32 CK_Uart_DriverInit()
+{
+    CK_Deactive_UartModule();
+    return SUCCESS;
+}
+
+/* This function is used to get character,in query mode or interrupt mode.
+ * Parameters:
+ *   uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *   brxquery--it indicates the receive mode: TRUE - query mode, FALSE -
+ *   interrupt mode
+ * return: SUCCESS or FAILURE
+ */
+CK_INT32 CK_Uart_GetChar(IN CK_Uart_Device uartid, OUT CK_UINT8 * ch)
+{
+    CKStruct_UartInfo *info;
+    SMARTL_UART_TypeDef *uart;
+
+    info = &(CK_Uart_Table[uartid]);
+    uart = info->addr;
+    if (!(info->bopened)) {
+        return FAILURE;
+    }
+
+    if (info->brxquery) {
+        while (!(uart->LSR & LSR_DATA_READY)) {
+            /* nothing */
+        };
+
+        *ch = uart->RBR;
+        return SUCCESS;
+    }
+
+    return FAILURE;
+}
+
+/* This function is used to get character,in query mode or interrupt mode.
+ * Parameters:
+ *       uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *   brxquery--it indicates the receive mode: TRUE - query mode, FALSE -
+ *   interrupt mode
+ * return: SUCCESS or FAILURE
+ */
+CK_INT32 CK_Uart_GetCharUnBlock(IN CK_Uart_Device uartid, OUT CK_UINT8 * ch)
+{
+    CKStruct_UartInfo *info;
+    SMARTL_UART_TypeDef *uart;
+
+    info = &(CK_Uart_Table[uartid]);
+    uart = info->addr;
+    if (!(info->bopened)) {
+        return FAILURE;
+    }
+
+    /*query mode */
+    if (info->brxquery) {
+        if (uart->LSR & LSR_DATA_READY) {
+            *ch = uart->RBR;
+            return SUCCESS;
+        }
+    }
+    return FAILURE;
+}
+
+/* This function is used to transmit character,in query mode or interrupt mode.
+ * Parameters:
+ *   uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *   brxquery--it indicates the receive mode: TRUE - query mode, FALSE -
+ *   interrupt mode
+ * Return: SUCCESS or FAILURE.
+ */
+CK_INT32 CK_Uart_PutChar(CK_Uart_Device uartid, CK_UINT8 ch)
+{
+    CKStruct_UartInfo *info;
+    SMARTL_UART_TypeDef *uart;
+    CK_UINT8 temp;
+
+    info = &(CK_Uart_Table[uartid]);
+    uart = info->addr;
+    if (!(info->bopened)) {
+        return FAILURE;
+    }
+    /*query mode */
+    if (info->btxquery) {
+        while ((!(uart->LSR & CK_LSR_TRANS_EMPTY))) {
+            /* nothing */
+        };
+        if (ch == '\n') {
+            uart->THR = '\r';
+        }
+
+        while ((!(uart->LSR & CK_LSR_TRANS_EMPTY))) {
+            /* nothing */
+        };
+        uart->THR = ch;
+
+        return SUCCESS;
+    }
+
+    return SUCCESS;
+}
+
+static int i = 1;
+
+static void CK_Console_CallBack(signed char error)
+{
+}
+
+int getchar1(void)
+{
+    char ch;
+    if (i == 1) {
+        CK_Uart_Open(UART0, CK_Console_CallBack);
+        i = 0;
+    }
+
+    CK_Uart_GetChar(UART0, &ch);
+    return (int)ch;
+}
+
+int fputc(int ch, FILE *stream)
+{
+    if (i == 1) {
+        CK_Uart_Open(UART0, CK_Console_CallBack);
+        i = 0;
+    }
+
+    CK_Uart_PutChar(UART0, ch);
+}
+
+int fgetc(FILE *stream)
+{
+    int ch = getchar1();
+    fputc(ch, stream);
+    return ch;
+}
+
+
diff --git a/tests/csky/board/smartl/ck803s/uart.h b/tests/csky/board/smartl/ck803s/uart.h
new file mode 100644
index 0000000..8dadbc0
--- /dev/null
+++ b/tests/csky/board/smartl/ck803s/uart.h
@@ -0,0 +1,320 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+/*
+ * File : uart.h
+ * Description: this file contains the macros support uart operations
+ * Copyright (C):  2008 C-SKY Microsystem  Ltd.
+ * Author(s):   Shuli wu
+ * E_mail:  shuli_wu@c-sky.com
+ * Contributors: Yun Ye
+ * Date:  2008-9-25
+ */
+
+#ifndef __UART_H__
+#define __UART_H__
+
+#include "smartl_ck803s.h"
+
+#ifndef NULL
+#define NULL  0x00
+#endif
+
+#ifndef TRUE
+#define TRUE  0x01
+#endif
+#ifndef FALSE
+#define FALSE 0x00
+#endif
+
+#ifndef SUCCESS
+#define SUCCESS  0
+#endif
+#ifndef FAILURE
+#define FAILURE  -1
+#endif
+
+typedef unsigned char CK_UINT8;
+typedef unsigned short CK_UINT16;
+typedef unsigned int CK_UINT32;
+typedef signed char CK_INT8;
+typedef signed short CK_INT16;
+typedef signed int CK_INT32;
+typedef signed long CK_INT64;
+typedef unsigned int BOOL;
+#ifndef BYTE
+typedef unsigned char BYTE;
+#endif
+#ifndef WORD
+typedef unsigned short WORD;
+#endif
+
+#define  IN
+#define  OUT
+#define INOUT
+
+#define UART_BUSY_TIMEOUT      1000000
+#define UART_RECEIVE_TIMEOUT   1000
+#define UART_TRANSMIT_TIMEOUT  1000
+
+
+/* UART register bit definitions */
+/* CK5108 */
+
+#define USR_UART_BUSY           0x01
+#define LSR_DATA_READY          0x01
+#define LSR_THR_EMPTY           0x20
+#define IER_RDA_INT_ENABLE      0x01
+#define IER_THRE_INT_ENABLE     0x02
+#define IIR_NO_ISQ_PEND         0x01
+
+#define LCR_SET_DLAB            0x80   /* enable r/w DLR to set the baud rate */
+#define LCR_PARITY_ENABLE       0x08   /* parity enabled */
+#define LCR_PARITY_EVEN         0x10   /* Even parity enabled */
+#define LCR_PARITY_ODD          0xef   /* Odd parity enabled */
+#define LCR_WORD_SIZE_5         0xfc   /* the data length is 5 bits */
+#define LCR_WORD_SIZE_6         0x01   /* the data length is 6 bits */
+#define LCR_WORD_SIZE_7         0x02   /* the data length is 7 bits */
+#define LCR_WORD_SIZE_8         0x03   /* the data length is 8 bits */
+#define LCR_STOP_BIT1           0xfb   /* 1 stop bit */
+#define LCR_STOP_BIT2           0x04   /* 1.5 stop bit */
+
+#define CK_LSR_PFE              0x80
+#define CK_LSR_TEMT             0x40
+#define CK_LSR_THRE             0x40
+#define CK_LSR_BI               0x10
+#define CK_LSR_FE               0x08
+#define CK_LSR_PE               0x04
+#define CK_LSR_OE               0x02
+#define CK_LSR_DR               0x01
+#define CK_LSR_TRANS_EMPTY      0x20
+
+/************************************
+ * (8 data bitbs, ODD, 1 stop bits)
+ ***********************************/
+#define BAUDRATE   19200
+/*
+ * Terminal uart to use
+ */
+#define  CONFIG_TERMINAL_UART UART0
+
+typedef enum {
+    B4800 = 4800,
+    B9600 = 9600,
+    B14400 = 14400,
+    B19200 = 19200,
+    B56000 = 56000,
+    B38400 = 38400,
+    B57600 = 57600,
+    B115200 = 115200
+} CK_Uart_Baudrate;
+
+
+typedef enum {
+    UART0,
+    UART1,
+    UART2,
+    UART3
+} CK_Uart_Device;
+
+typedef enum {
+    WORD_SIZE_5,
+    WORD_SIZE_6,
+    WORD_SIZE_7,
+    WORD_SIZE_8
+} CK_Uart_WordSize;
+
+typedef enum {
+    ODD,
+    EVEN,
+    NONE
+} CK_Uart_Parity;
+
+typedef enum {
+    LCR_STOP_BIT_1,
+    LCR_STOP_BIT_2
+} CK_Uart_StopBit;
+
+
+typedef enum {
+    CK_Uart_CTRL_C = 0,
+    CK_Uart_FrameError = 1,
+    CK_Uart_ParityError = 2
+} CKEnum_Uart_Error;
+
+typedef struct CK_UART_Info_t {
+    CK_UINT32 id;
+    SMARTL_UART_TypeDef *addr;
+    CK_UINT32 irq ;
+    BOOL bopened;
+    void  (*handler)(CK_INT8 error);
+    CK_Uart_Baudrate baudrate;
+    CK_Uart_Parity parity;
+    CK_Uart_WordSize word;
+    CK_Uart_StopBit stop;
+    BOOL btxquery;
+    BOOL brxquery;
+} CKStruct_UartInfo, *PCKStruct_UartInfo;
+
+CK_INT32 CK_Uart_DriverInit();
+
+
+/* open the uart :
+ * set the callback function --- handler(void);
+ * intilize the serial port,sending and receiving buffer;
+ * intilize irqhandler ;
+ * register irqhandler
+ * return: SUCCESS or FAILURE
+ */
+CK_INT32 CK_Uart_Open(CK_Uart_Device uartid, void (*handler)(CK_INT8 error));
+
+/* This function is used to close the uart
+ * clear the callback function
+ * free the irq
+ * return: SUCCESS or FAILURE
+ */
+CK_INT32 CK_Uart_Close(CK_Uart_Device uartid);
+
+/*
+ * This function is used to change the bautrate of uart.
+ * Parameters:
+ * uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ * baudrate--the baudrate that user typed in.
+ * return: SUCCESS or FAILURE
+ */
+
+CK_INT32 CK_Uart_ChangeBaudrate(CK_Uart_Device uartid,
+                                CK_Uart_Baudrate baudrate);
+
+/*
+ * This function is used to enable or disable parity, also to set ODD or EVEN
+ * parity.
+ * Parameters:
+ *   uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *   parity--ODD=8, EVEN=16, or NONE=0.
+ * return: SUCCESS or FAILURE
+ */
+
+CK_INT32 CK_Uart_SetParity(
+                           CK_Uart_Device uartid,  CK_Uart_Parity parity);
+
+/*
+ * We can call this function to set the stop bit--1 bit, 1.5 bits, or 2 bits.
+ * But that it's 1.5 bits or 2, is decided by the wordlenth. When it's 5 bits,
+ * there are 1.5 stop bits, else 2.
+ * Parameters:
+ *   uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *   stopbit--it has two possible value: STOP_BIT_1 and STOP_BIT_2.
+ * return: SUCCESS or FAILURE
+ */
+
+CK_INT32 CK_Uart_SetStopBit(
+                            CK_Uart_Device uartid,  CK_Uart_StopBit stopbit);
+
+/*
+ * We can use this function to reset the transmit data length,and we
+ * have four choices:5, 6, 7, and 8 bits.
+ * Parameters:
+ *  uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *  wordsize--the data length that user decides
+ * return: SUCCESS or FAILURE
+ */
+
+CK_INT32 CK_Uart_SetWordSize(CK_Uart_Device uartid,  CK_Uart_WordSize wordsize);
+
+/*
+ * This function is used to set the transmit mode, interrupt mode or
+ * query mode.
+ * Parameters:
+ *  uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *  bQuery--it indicates the transmit mode: TRUE - query mode, FALSE -
+ *  inerrupt mode
+ * return: SUCCESS or FAILURE
+ */
+
+CK_INT32 CK_Uart_SetTXMode(CK_Uart_Device uartid, BOOL  bQuery);
+
+/*
+ * This function is used to set the receive mode, interrupt mode or
+ * query mode.
+ * Parameters:
+ *  uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *  bQuery--it indicates the receive mode: TRUE - query mode, FALSE -
+ *  interrupt mode
+ * return: SUCCESS or FAILURE
+
+ */
+CK_INT32 CK_Uart_SetRXMode(CK_Uart_Device uartid, BOOL bQuery);
+
+/* This function is used to get character,in query mode or interrupt mode.
+ * Parameters:
+ *   uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *   brxquery--it indicates the receive mode: TRUE - query mode, FALSE -
+ *   interrupt mode
+ * return: SUCCESS or FAILURE
+ */
+CK_INT32 CK_Uart_GetChar(CK_Uart_Device uartid,  CK_UINT8 *ch);
+
+/* This function is used to transmit character,in query mode or interrupt mode.
+ * Parameters:
+ *   uartid--a basepointer, could be one of UART0, UART1, UART2 or UART3.
+ *   brxquery--it indicates the receive mode: TRUE - query mode, FALSE -
+ *   interrupt mode
+ * Return: SUCCESS or FAILURE.
+ */
+CK_INT32 CK_Uart_PutChar(CK_Uart_Device uartid, CK_UINT8 ch);
+
+/*
+ * initialize the uart:
+ * baudrate: 19200
+ * date length: 8 bits
+ * paity: None(disabled)
+ * number of stop bits: 1 stop bit
+ * query mode
+ * return: SUCCESS
+ */
+CK_INT32 CK_Uart_Init(CK_Uart_Device uartid);
+
+/*
+ */
+CK_INT32 CK_Uart_ConfigDMA(
+                           CK_Uart_Device uartid,
+                           char *buffer,
+                           BOOL btx,
+                           CK_INT32 txrxsize,
+                           void (*handler)()
+                          );
+
+    /*
+     */
+    void CK_Uart_StartDMARxTx (void);
+
+    void CK_UART_ClearRxBuffer(CK_Uart_Device uartid);
+
+    /* This function is used to get character,in query mode or interrupt mode*/
+    CK_INT32 CK_Uart_GetCharUnBlock(IN CK_Uart_Device uartid, OUT CK_UINT8 *ch);
+#endif
diff --git a/tests/csky/ck803s-dsp/Makefile b/tests/csky/ck803s-dsp/Makefile
new file mode 100644
index 0000000..4e92476
--- /dev/null
+++ b/tests/csky/ck803s-dsp/Makefile
@@ -0,0 +1,71 @@
+CORE_OBJ = csi.core.elf
+BOARD_DIR = ../board/smartl/ck803s
+CFLAGS = -g2 -mcpu=ck803s -Wa,-mcpu=803sef -Wa,-medsp -msoft-float
+TARGET_CROSS = csky-abiv2-elf
+
+CC = $(TARGET_CROSS)-gcc
+
+ROOTDIR = $(shell pwd)/
+srcdir = $(ROOTDIR)../
+EXPECT = expect
+RUNTEST = runtest
+RUNTESTFLAGS =
+
+all: core
+
+core:
+	@echo "  CC    $(BOARD_DIR)/crt0.o"
+	@$(CC) -c $(CFLAGS) $(BOARD_DIR)/crt0.S -o $(BOARD_DIR)/crt0.o
+	@echo "  CC    $(BOARD_DIR)/uart.o"
+	@$(CC) -c $(CFLAGS) $(BOARD_DIR)/uart.c -o $(BOARD_DIR)/uart.o
+	make -C case
+
+clean:
+	rm -f $(BOARD_DIR)/*.o
+	rm -f site.exp
+	rm -rf testresult
+	make -C case clean
+
+
+site.exp:
+	@echo 'Making a new site.exp file...'
+	@echo '## these variables are automatically generated by make ##' >site.tmp
+	@echo '# Do not edit here.  If you wish to override these values' >>site.tmp
+	@echo '# edit the last section' >>site.tmp
+	@echo "set rootme $(srcdir)" >>site.tmp
+	@echo 'set srcdir $(srcdir)' >>site.tmp
+	@echo "set objdir `pwd`/testresult/" >>site.tmp
+	@echo "set tmpdir `pwd`/testresult/" >>site.tmp
+	@echo "set CFLAGS \"$(CFLAGSDEJA) $(INCLUDEDIRS) -L$(srcdir)lib/  -L$(srcdir)tests/arch  -lc -lgcc  \"" >> site.tmp
+	@echo "set host_triplet x86_64-pc-linux-gnu" >> site.tmp
+	@echo "set build_triplet x86_64-pc-linux-gnu" >> site.tmp
+	@echo "set target_triplet csky-unknown-elf">> site.tmp
+	@echo "set target_alias $(TARGET_CROSS)" >> site.tmp
+	@echo "set HOSTCC gcc" >> site.tmp
+	@echo "set tool csi" >> site.tmp
+	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
+	@test ! -f site.exp || \
+	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
+	@-rm -f site.bak
+	@test ! -f site.exp || mv site.exp site.bak
+	@mv site.tmp site.exp
+
+check:site.exp
+	if [ -d testresult/ ]; then \
+	  true; \
+	else \
+	  mkdir testresult/; \
+	fi
+	echo "cflag ${CFLAGS}"
+	rm -f testresult/*
+	cp site.exp testresult/site.exp
+	rootme=`pwd`/testresult; export rootme; \
+	srcdir=`cd ${srcdir}/; pwd` ; export srcdir ; \
+	EXPECT=${EXPECT} ; export EXPECT ; \
+	runtest=$(RUNTEST); \
+	cd testresult; \
+	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
+	   $$runtest --srcdir $${srcdir}/testsuite \
+	   $(RUNTESTFLAGS); \
+	else  echo "WARNING: could not find \`runtest'" 1>&2; :;\
+	fi
diff --git a/tests/csky/ck803s-dsp/case/Makefile b/tests/csky/ck803s-dsp/case/Makefile
new file mode 100644
index 0000000..76db20d
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/Makefile
@@ -0,0 +1,22 @@
+SRC = $(wildcard *.c)
+SRS = $(wildcard *.S)
+OBJFILE = $(SRS:%.S=%.o) $(SRC:%.c=%)
+BOARD_DIR = ../../board/smartl/ck803s
+INCLUDE = -I../../include -I$(BOARD_DIR)
+CFLAGS = -g2 -O2 -mcpu=ck803efr1 -msoft-float
+all: case
+
+case: $(OBJFILE)
+
+%.o: %.S
+	@echo "  CC    case/$@"
+	@csky-abiv2-elf-gcc $(CFLAGS) -c $(INCLUDE) -o $@  $<
+
+%: %.c
+	@echo "  CC    case/$@.o"
+	@csky-abiv2-elf-gcc $(CFLAGS) -c $(INCLUDE) -O2 -o $@.o  $<
+	@echo "  CC    case/$@.elf"
+	@csky-abiv2-elf-gcc $(CFLAGS) $(BOARD_DIR)/uart.o $(BOARD_DIR)/crt0.o dsp_insn.o -T$(BOARD_DIR)/ckcpu.ld -nostartfiles -lgcc $@.o -o $@.elf
+	@#csky-abiv2-elf-objdump -S $@.elf > $@.asm
+clean:
+	rm -rf  *.o *.a *.asm *.elf
diff --git a/tests/csky/ck803s-dsp/case/add_s32_s.c b/tests/csky/ck803s-dsp/case/add_s32_s.c
new file mode 100644
index 0000000..04af23e
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/add_s32_s.c
@@ -0,0 +1,69 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      15
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn ADD.S32.S \n");
+
+    /*
+     * ADD.S32.S
+     * rz = rx + ry, signed & saturated
+     *
+     * TEST(test_add_s32_s(0x12345678, 0x12345678) == 0x2468acf0)
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x12345678, 0x12345678, 0x2468acf0},
+        {0x12345678, 0x7f000000, 0x7fffffff},
+        {0x92345678, 0xf2345678, 0x8468acf0},
+        {0x92345678, 0x92345678, 0x80000000},
+        {0x00000000, 0x80000000, 0x80000000},
+        {0x80000000, 0x80000000, 0x80000000},
+        {0x00000001, 0x00000001, 0x00000002},
+        {0xffffffff, 0x00000001, 0x00000000},
+        {0x00000001, 0xffffffff, 0x00000000},
+        {0xffffffff, 0xffffffff, 0xfffffffe},
+        {0x30000000, 0x60000000, 0x7fffffff},
+        {0x80000001, 0x80000001, 0x80000000},
+        {0x7fffffff, 0x7fffffff, 0x7fffffff},
+        {0x80000000, 0x80000000, 0x80000000},
+        {0x7fffffff, 0x80000000, 0xffffffff},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_add_s32_s(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/addx_s32.c b/tests/csky/ck803s-dsp/case/addx_s32.c
new file mode 100644
index 0000000..8adb062
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/addx_s32.c
@@ -0,0 +1,76 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      23
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn ADDX.S32 \n");
+
+    /*
+     * ADDX.S32
+     * rz = rx + ry[15:0], unsigned
+     *
+     * TEST(test_addx_s32(0x12345678, 0x12345678) == 0x2468acf0)
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x12345678, 0x12345678, 0x1234acf0},
+        {0x12345678, 0x7f000000, 0x12345678},
+        {0xffffffff, 0x11111111, 0x00001110},
+        {0x12345678, 0x88888888, 0x1233df00},
+        {0xa0a0a0a0, 0x90909090, 0xa0a03130},
+        {0x80000000, 0x80000000, 0x80000000},
+        {0X00000000, 0X00000000, 0x00000000},
+        {0X00000000, 0X00000001, 0x00000001},
+        {0X00000000, 0XFFFFFFFF, 0xffffffff},
+        {0X00000001, 0X00000000, 0x00000001},
+        {0X00000001, 0X00000001, 0x00000002},
+        {0X00000001, 0XFFFFFFFF, 0x00000000},
+        {0XFFFFFFFF, 0X00000000, 0xffffffff},
+        {0XFFFFFFFF, 0X00000001, 0x00000000},
+        {0XFFFFFFFF, 0XFFFFFFFF, 0xfffffffe},
+        {0X00000000, 0XFFFF0000, 0x00000000},
+        {0X00000000, 0X00008000, 0xffff8000},
+        {0X00000001, 0XFFFF0000, 0x00000001},
+        {0X00000001, 0X00008000, 0xffff8001},
+        {0XFFFFFFFF, 0XFFFF0000, 0xffffffff},
+        {0XFFFFFFFF, 0X00008000, 0xffff7fff},
+        {0X7FFFFFFF, 0XFFFF7FFF, 0x80007ffe},
+        {0X80000000, 0X00008000, 0x7fff8000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_addx_s32(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/addx_u32.c b/tests/csky/ck803s-dsp/case/addx_u32.c
new file mode 100644
index 0000000..651b082
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/addx_u32.c
@@ -0,0 +1,76 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      22
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn ADDX.U32 \n");
+
+    /*
+     * ADDX.U32
+     * rz = rx + ry[15:0], unsigned
+     *
+     * TEST(test_addx_u32(0x12345678, 0x12345678) == 0x2468acf0)
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x12345678, 0x12345678, 0x1234acf0},
+        {0x12345678, 0x7f000000, 0x12345678},
+        {0xffffffff, 0x11111111, 0x00001110},
+        {0x12345678, 0x88888888, 0x1234df00},
+        {0x00000000, 0x80000000, 0x00000000},
+        {0X00000000, 0X00000000, 0x00000000},
+        {0X00000000, 0X00000001, 0x00000001},
+        {0X00000000, 0XFFFFFFFF, 0x0000ffff},
+        {0X00000001, 0X00000000, 0x00000001},
+        {0X00000001, 0X00000001, 0x00000002},
+        {0X00000001, 0XFFFFFFFF, 0x00010000},
+        {0XFFFFFFFF, 0X00000000, 0xffffffff},
+        {0XFFFFFFFF, 0X00000001, 0x00000000},
+        {0XFFFFFFFF, 0XFFFFFFFF, 0x0000fffe},
+        {0X00000000, 0XFFFF0000, 0x00000000},
+        {0X00000000, 0X00008000, 0x00008000},
+        {0X00000001, 0XFFFF0000, 0x00000001},
+        {0X00000001, 0X00008000, 0x00008001},
+        {0XFFFFFFFF, 0XFFFF0000, 0xffffffff},
+        {0XFFFFFFFF, 0X00008000, 0x00007fff},
+        {0X7FFFFFFF, 0XFFFF7FFF, 0x80007ffe},
+        {0X80000000, 0X00008000, 0x80008000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_addx_u32(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/dext.c b/tests/csky/ck803s-dsp/case/dext.c
new file mode 100644
index 0000000..c6396fb
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/dext.c
@@ -0,0 +1,54 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      3
+int main(void)
+{
+    init_testsuite("Testing insn DEXT \n");
+
+    /*
+     * DEXT
+     * rz = ({ry, rx} >> imm5)[31:0]
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0Xffffffff, 0X00000000, 0x0000ffff}, /* imm5 = 16 */
+        {0Xffffffff, 0X00000000, 0xffffffff}, /* imm5 = 0  */
+        {0Xffffffff, 0X00000000, 0x00000001}, /* imm5 = 31 */
+    };
+
+    TEST(test_dext_16(bin_sample[0].op1, bin_sample[0].op2)
+         == bin_sample[0].result);
+    TEST(test_dext_0(bin_sample[1].op1, bin_sample[1].op2)
+         == bin_sample[1].result);
+    TEST(test_dext_31(bin_sample[2].op1, bin_sample[2].op2)
+         == bin_sample[2].result);
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/divsl.c b/tests/csky/ck803s-dsp/case/divsl.c
new file mode 100644
index 0000000..e7f46d7
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/divsl.c
@@ -0,0 +1,64 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      11
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn DIVSL \n");
+
+    /*
+     * DIVSL
+     * rz = {rx,32'b0}/ry, signed
+     */
+    struct binary_calculation sample[TEST_TIMES] = {
+        {0x12345678, 0x00000005, 0x03a4114b},
+        {0x00000005, 0x12345678, 0x00000000},
+        {0x77654321, 0x12345678, 0x00000006},
+        {0xffff21ce, 0x00000004, 0xffffc873},
+        {0xfffffffd, 0x00000008, 0xffffffff},
+        {0xfffffffb, 0x00000004, 0xfffffffe},
+        {0x77654321, 0xfffffff2, 0xf778c459},
+        {0xfffffffb, 0x00000004, 0xfffffffe},
+        {0xfffffff3, 0xfffffff5, 0x00000001},
+        {0x00000000, 0xffffffff, 0x00000000},
+        {0x80000000, 0xffffffff, 0x80000000},
+        /* {0xffffffff, 0x00000000, 0x00000000}, */
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_divsl(sample[i].op1, sample[i].op2)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/divsr.c b/tests/csky/ck803s-dsp/case/divsr.c
new file mode 100644
index 0000000..7749f5e
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/divsr.c
@@ -0,0 +1,64 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      11
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn DIVSR \n");
+
+    /*
+     * DIVSR
+     * rz = rx / ry, rn = rx % ry, signed
+     */
+    struct binary64_calculation bin64_sample[TEST_TIMES] = {
+        {0x7fffffff, 0x00000001, 0x000000007FFFFFFF},
+        {0x7fffffff, 0x00000002, 0x000000013FFFFFFF},
+        {0x00000001, 0x7fffffff, 0x0000000100000000},
+        {0x7fffffff, 0x7fffffff, 0x0000000000000001},
+        {0x7fffffff, 0xffffffff, 0x0000000080000001},
+        {0x7fffffff, 0x80000000, 0x7fffffff00000000},
+        {0x80000001, 0x00000002, 0xffffffffc0000001},
+        {0xffffffff, 0x7fffffff, 0xffffffff00000000},
+        {0x80000001, 0xfffffffe, 0xffffffff3fffffff},
+        {0x00000000, 0xffffffff, 0x0000000000000000},
+        {0x80000000, 0xffffffff, 0x0000000080000000},
+        /* {0xffffffff, 0x00000000, 0x0000000000000000}, */
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_divsr(bin64_sample[i].op1, bin64_sample[i].op2)
+                     == bin64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/divul.c b/tests/csky/ck803s-dsp/case/divul.c
new file mode 100644
index 0000000..113bb37
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/divul.c
@@ -0,0 +1,64 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      11
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn DIVUL \n");
+
+    /*
+     * DIVUL
+     * rz = {rx,32'b0}/ry, signed
+     */
+    struct binary_calculation sample[TEST_TIMES] = {
+        {0x12345678, 0x00000005, 0x03a4114b},
+        {0x00000005, 0x12345678, 0x00000000},
+        {0x77654321, 0x12345678, 0x00000006},
+        {0xffff21ce, 0x00000004, 0x3fffc873},
+        {0xfffffffd, 0x00000008, 0x1fffffff},
+        {0xfffffffb, 0x00000004, 0x3ffffffe},
+        {0x77654321, 0xfffffff2, 0x00000000},
+        {0xfffffffb, 0x00000004, 0x3ffffffe},
+        {0xfffffff3, 0xfffffff5, 0x00000000},
+        {0x00000000, 0xffffffff, 0x00000000},
+        {0x80000000, 0xffffffff, 0x00000000},
+        /* {0xffffffff, 0x00000000, 0x00000000}, */
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_divul(sample[i].op1, sample[i].op2)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/divur.c b/tests/csky/ck803s-dsp/case/divur.c
new file mode 100644
index 0000000..b27b04c
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/divur.c
@@ -0,0 +1,65 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      12
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn DIVUR \n");
+
+    /*
+     * DIVUR
+     * rz = rx / ry, rn = rx % ry, unsigned
+     */
+    struct binary64_calculation bin64_sample[TEST_TIMES] = {
+        {0x7fffffff, 0x00000001, 0x000000007FFFFFFF},
+        {0x7fffffff, 0x00000002, 0x000000013FFFFFFF},
+        {0x00000001, 0x7fffffff, 0x0000000100000000},
+        {0x7fffffff, 0x7fffffff, 0x0000000000000001},
+        {0x7fffffff, 0xffffffff, 0x7fffffff00000000},
+        {0x7fffffff, 0x80000000, 0x7fffffff00000000},
+        {0x00000001, 0xfffffffe, 0x0000000100000000},
+        {0x80000001, 0x00000002, 0x0000000140000000},
+        {0xffffffff, 0x7fffffff, 0x0000000100000002},
+        {0x80000000, 0xffffffff, 0x8000000000000000},
+        {0x80000001, 0xfffffffe, 0x8000000100000000},
+        {0x00000000, 0xffffffff, 0x0000000000000000},
+        /* {0xffffffff, 0x00000000, 0x0000000000000000}, */
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_divur(bin64_sample[i].op1, bin64_sample[i].op2)
+                     == bin64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/dsp_insn.S b/tests/csky/ck803s-dsp/case/dsp_insn.S
new file mode 100644
index 0000000..ec2fd72
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/dsp_insn.S
@@ -0,0 +1,709 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+   .file   "dsp_insn.S"
+
+#undef  TEST_FUNC
+#define TEST_FUNC(name) TEST_FUNC_M name
+    .macro TEST_FUNC_M name
+    .text
+    .align  2
+    .global \name
+    .type   \name, @function
+\name:
+    .endm
+
+TEST_FUNC(test_add_s32_s)
+    add.s32.s   a0, a0, a1
+    rts
+    .size   test_add_s32_s, .-test_add_s32_s
+
+TEST_FUNC(test_addx_u32)
+    addx.u32    a0, a0, a1
+    rts
+    .size   test_addx_u32, .-test_addx_u32
+
+TEST_FUNC(test_addx_s32)
+    addx.s32    a0, a0, a1
+    rts
+    .size   test_addx_s32, .-test_addx_s32
+
+TEST_FUNC(test_padd_s16_s)
+    mov         a2, a0
+    padd.s16.s  a0, a2, a1
+    rts
+    .size   test_padd_s16_s, .-test_padd_s16_s
+
+TEST_FUNC(test_padd_s16)
+    mov         a2, a0
+    padd.s16  a3, a2, a1
+    mov         a0, a3
+    rts
+    .size   test_padd_s16, .-test_padd_s16
+
+TEST_FUNC(test_paddh_s16)
+    paddh.s16    a0, a0, a1
+    rts
+    .size   test_paddh_s16, .-test_paddh_s16
+
+TEST_FUNC(test_pmul_s16)
+    pmul.s16    a0, a1, a0, a1
+    rts
+    .size   test_pmul_s16, .-test_pmul_s16
+
+TEST_FUNC(test_pmul_s16_f)
+    pmul.s16.f  a0, a1, a0, a1
+    rts
+    .size   test_pmul_s16_f, .-test_pmul_s16_f
+
+TEST_FUNC(test_mul_32_l)
+    mul.32.l    a0, a0, a1
+    rts
+    .size   test_mul_32_l, .-test_mul_32_l
+
+TEST_FUNC(test_mul_32_lf)
+    mul.32.lf   a0, a0, a1
+    rts
+    .size   test_mul_32_lf, .-test_mul_32_lf
+
+TEST_FUNC(test_mulll_s16)
+    mulll.s16   a0, a0, a1
+    rts
+    .size   test_mulll_s16, .-test_mulll_s16
+
+TEST_FUNC(test_mulll_s16_f)
+    mulll.s16.f a0, a0, a1
+    rts
+    .size   test_mulll_s16_f, .-test_mulll_s16_f
+
+TEST_FUNC(test_mulhl_s16)
+    mulhl.s16   a0, a0, a1
+    rts
+    .size   test_mulhl_s16, .-test_mulhl_s16
+
+TEST_FUNC(test_mulhl_s16_f)
+    mulhl.s16.f a0, a0, a1
+    rts
+    .size   test_mulhl_s16_f, .-test_mulhl_s16_f
+
+TEST_FUNC(test_mulhh_s16)
+    mulhh.s16   a0, a0, a1
+    rts
+    .size   test_mulhh_s16, .-test_mulhh_s16
+
+TEST_FUNC(test_mulhh_s16_f)
+    mulhh.s16.f a0, a0, a1
+    rts
+    .size   test_mulhh_s16_f, .-test_mulhh_s16_f
+
+TEST_FUNC(test_mulca_s16)
+    mulca.s16   a0, a0, a1
+    rts
+    .size   test_mulca_s16, .-test_mulca_s16
+
+TEST_FUNC(test_mulca_s16_f)
+    mulca.s16.f a0, a0, a1
+    rts
+    .size   test_mulca_s16_f, .-test_mulca_s16_f
+
+TEST_FUNC(test_mulcax_s16)
+    mulcax.s16   a0, a0, a1
+    rts
+    .size   test_mulcax_s16, .-test_mulcax_s16
+
+TEST_FUNC(test_mulcax_s16_f)
+    mulcax.s16.f a0, a0, a1
+    rts
+    .size   test_mulcax_s16_f, .-test_mulcax_s16_f
+
+TEST_FUNC(test_mulcs_s16)
+    mulcs.s16   a0, a0, a1
+    rts
+    .size   test_mulcs_s16, .-test_mulcs_s16
+
+TEST_FUNC(test_mulcs_s16_f)
+    mulcs.s16.f a0, a0, a1
+    rts
+    .size   test_mulcs_s16_f, .-test_mulcs_s16_f
+
+TEST_FUNC(test_mulcsx_s16)
+    mulcsx.s16   a0, a0, a1
+    rts
+    .size   test_mulcsx_s16, .-test_mulcsx_s16
+
+TEST_FUNC(test_mulcsx_s16_f)
+    mulcsx.s16.f a0, a0, a1
+    rts
+    .size   test_mulcsx_s16_f, .-test_mulcsx_s16_f
+
+TEST_FUNC(test_max_u32)
+    max.u32 a0, a0, a1
+    rts
+    .size   test_max_u32, .-test_max_u32
+
+TEST_FUNC(test_max_s32)
+    max.s32 a0, a0, a1
+    rts
+    .size   test_max_s32, .-test_max_s32
+
+TEST_FUNC(test_min_u32)
+    min.u32 a0, a0, a1
+    rts
+    .size   test_min_u32, .-test_min_u32
+
+TEST_FUNC(test_min_s32)
+    min.s32 a0, a0, a1
+    rts
+    .size   test_min_s32, .-test_min_s32
+
+TEST_FUNC(test_pmax_u16)
+    pmax.u16 a0, a0, a1
+    rts
+    .size   test_pmax_u16, .-test_pmax_u16
+
+TEST_FUNC(test_pmax_s16)
+    pmax.s16 a0, a0, a1
+    rts
+    .size   test_pmax_s16, .-test_pmax_s16
+
+TEST_FUNC(test_pmin_u16)
+    pmin.u16 a0, a0, a1
+    rts
+    .size   test_pmin_u16, .-test_pmin_u16
+
+TEST_FUNC(test_pmin_s16)
+    pmin.s16 a0, a0, a1
+    rts
+    .size   test_pmin_s16, .-test_pmin_s16
+
+TEST_FUNC(test_plsli_16)
+    plsli.16 a0, a0, 0
+    rts
+    .size   test_plsli_16, .-test_plsli_16
+
+TEST_FUNC(test_pasri_16)
+    pasri.16 a0, a0, 0
+    rts
+    .size   test_pasri_16, .-test_pasri_16
+
+TEST_FUNC(test_plsli_32)
+    plsli.32 a0, a0, 16
+    rts
+    .size   test_plsli_32, .-test_plsli_32
+
+TEST_FUNC(test_pasri_32)
+    pasri.32 a0, a0, 16
+    rts
+    .size   test_pasri_32, .-test_pasri_32
+
+TEST_FUNC(test_divsr)
+    divsr a0, a1, a0, a1
+    rts
+    .size   test_divsr, .-test_divsr
+
+TEST_FUNC(test_divur)
+    divur a0, a1, a0, a1
+    rts
+    .size   test_divur, .-test_divur
+
+TEST_FUNC(test_mula_32_l)
+    mula.32.l a0, a0, a1, a2
+    rts
+    .size   test_mula_32_l, .-test_mula_32_l
+
+TEST_FUNC(test_mula_32_lf)
+    mula.32.lf a0, a0, a1, a2
+    rts
+    .size   test_mula_32_lf, .-test_mula_32_lf
+
+TEST_FUNC(test_muls_32_l)
+    muls.32.l a0, a0, a1, a2
+    rts
+    .size   test_muls_32_l, .-test_muls_32_l
+
+TEST_FUNC(test_muls_32_lf)
+    muls.32.lf a0, a0, a1, a2
+    rts
+    .size   test_muls_32_lf, .-test_muls_32_lf
+
+TEST_FUNC(test_mul_u32)
+    mul.u32 a0, a1, a0, a1
+    rts
+    .size   test_mul_u32, .-test_mul_u32
+
+TEST_FUNC(test_mul_s32)
+    mul.s32 a0, a1, a0, a1
+    rts
+    .size   test_mul_s32, .-test_mul_s32
+
+TEST_FUNC(test_mul_s32_f)
+    mul.s32.f a0, a1, a0, a1
+    rts
+    .size   test_mul_s32_f, .-test_mul_s32_f
+
+TEST_FUNC(test_mula_u32)
+    mula.u32 a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_mula_u32, .-test_mula_u32
+
+TEST_FUNC(test_mula_s32)
+    mula.s32 a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_mula_s32, .-test_mula_s32
+
+TEST_FUNC(test_mula_s32_f)
+    mula.s32.f a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_mula_s32_f, .-test_mula_s32_f
+
+TEST_FUNC(test_mulaca_s16_e)
+    mulaca.s16.e a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_mulaca_s16_e, .-test_mulaca_s16_e
+
+TEST_FUNC(test_mulacax_s16_e)
+    mulacax.s16.e a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_mulacax_s16_e, .-test_mulaca_s16_e
+
+TEST_FUNC(test_mulall_s16)
+    mulall.s16 a0, a0, a1, a2
+    rts
+    .size   test_mulall_s16, .-test_mulaca_s16
+
+TEST_FUNC(test_mulall_s16_f)
+    mulall.s16.f a0, a0, a1, a2
+    rts
+    .size   test_mulall_s16_f, .-test_mulaca_s16_f
+
+TEST_FUNC(test_mulall_s16_e)
+    mulall.s16.e a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_mulall_s16_e, .-test_mulaca_s16_e
+
+TEST_FUNC(test_sub_s32_s)
+    sub.s32.s   a0, a0, a1
+    rts
+    .size   test_sub_s32_s, .-test_sub_s32_s
+
+TEST_FUNC(test_psub_s16_s)
+    mov         a2, a0
+    psub.s16.s  a0, a2, a1
+    rts
+    .size   test_psub_s16_s, .-test_psub_s16_s
+
+TEST_FUNC(test_psub_s16)
+    mov         a2, a0
+    psub.s16  a3, a2, a1
+    mov         a0, a3
+    rts
+    .size   test_psub_s16, .-test_psub_s16
+
+TEST_FUNC(test_psubh_s16)
+    psubh.s16    a0, a0, a1
+    rts
+    .size   test_psubh_s16, .-test_psubh_s16
+
+TEST_FUNC(test_paddx_s32)
+    paddx.s32 a0, a0, a1, a2
+    rts
+    .size   test_paddx_s32, .-test_mulaca_s16_e
+
+TEST_FUNC(test_psubx_s32)
+    psubx.s32 a0, a0, a1, a2
+    rts
+    .size   test_psubx_s32, .-test_mulaca_s16_e
+
+TEST_FUNC(test_pabs_s16_s)
+    pabs.s16.s a0, a0
+    rts
+    .size   test_pabs_s16_s, .-test_pabs_s16_s
+
+TEST_FUNC(test_pneg_s16_s)
+    pneg.s16.s a0, a0
+    rts
+    .size   test_pneg_s16_s, .-test_pneg_s16_s
+
+TEST_FUNC(test_sel_32)
+    cmpne a0, a2
+    sel.32 a0, a0, a1
+    rts
+    .size   test_sel_32, .-test_sel_32
+
+TEST_FUNC(test_pkg_0_16)
+    pkg a0, a0, 0, a1, 16
+    rts
+    .size   test_pkg_0_16, .-test_pkg_0_16
+
+TEST_FUNC(test_pkg_15_1)
+    pkg a0, a0, 15, a1, 1
+    rts
+    .size   test_pkg_15_1, .-test_pkg_15_1
+
+TEST_FUNC(test_pkg_0_1)
+    pkg a0, a0, 0, a1, 1
+    rts
+    .size   test_pkg_0_1, .-test_pkg_0_1
+
+TEST_FUNC(test_pkg_15_16)
+    pkg a0, a0, 15, a1, 16
+    rts
+    .size   test_pkg_15_16, .-test_pkg_15_16
+
+TEST_FUNC(test_pkgll)
+    pkgll a0, a0, a1
+    rts
+    .size   test_pkgll, .-test_pkgll
+
+TEST_FUNC(test_pkghh)
+    pkghh a0, a0, a1
+    rts
+    .size   test_pkghh, .-test_pkghh
+
+TEST_FUNC(test_dext_16)
+    dext a0, a0, a1, 16
+    rts
+    .size   test_dext_16, .-test_dext_16
+
+TEST_FUNC(test_dext_0)
+    dext a0, a0, a1, 0
+    rts
+    .size   test_dext_0, .-test_dext_0
+
+TEST_FUNC(test_dext_31)
+    dext a0, a0, a1, 31
+    rts
+    .size   test_dext_31, .-test_dext_31
+
+TEST_FUNC(test_pmula_s16)
+    pmula.s16 a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_pmula_s16, .-test_pmula_s16
+
+TEST_FUNC(test_pmula_s16_f)
+    pmula.s16.f a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_pmula_s16_f, .-test_pmula_s16_f
+
+TEST_FUNC(test_pmulwh_s16)
+    pmulwh.s16    a0, a1, a0, a1
+    rts
+    .size   test_pmulwh_s16, .-test_pmulwh_s16
+
+TEST_FUNC(test_pmulwh_s16_f)
+    pmulwh.s16.f    a0, a1, a0, a1
+    rts
+    .size   test_pmulwh_s16_f, .-test_pmulwh_s16_f
+
+TEST_FUNC(test_pmulwl_s16)
+    pmulwl.s16    a0, a1, a0, a1
+    rts
+    .size   test_pmulwl_s16, .-test_pmulwl_s16
+
+TEST_FUNC(test_pmulwl_s16_f)
+    pmulwl.s16.f    a0, a1, a0, a1
+    rts
+    .size   test_pmulwl_s16_f, .-test_pmulwl_s16_f
+
+TEST_FUNC(test_pmulawh_s16)
+    pmulawh.s16 a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_pmulawh_s16, .-test_pmulawh_s16
+
+TEST_FUNC(test_pmulawh_s16_f)
+    pmulawh.s16.f a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_pmulawh_s16_f, .-test_pmulawh_s16_f
+
+TEST_FUNC(test_pmulawl_s16)
+    pmulawl.s16 a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_pmulawl_s16, .-test_pmulawl_s16
+
+TEST_FUNC(test_pmulawl_s16_f)
+    pmulawl.s16.f a2, a3, a0, a1
+    mov       a0, a2
+    mov       a1, a3
+    rts
+    .size   test_pmulawl_s16_f, .-test_pmulawl_s16_f
+
+TEST_FUNC(test_plsli_16_0)
+    plsli.16 a0, a0, 0
+    rts
+    .size  test_plsli_16_0, .-test_plsli_16_0
+
+TEST_FUNC(test_plsli_16_1)
+    plsli.16 a0, a0, 1
+    rts
+    .size  test_plsli_16_1, .-test_plsli_16_1
+
+TEST_FUNC(test_plsli_16_9)
+    plsli.16 a0, a0, 9
+    rts
+    .size  test_plsli_16_9, .-test_plsli_16_9
+
+TEST_FUNC(test_plsli_16_15)
+    plsli.16 a0, a0, 15
+    rts
+    .size  test_plsli_16_15, .-test_plsli_16_15
+
+TEST_FUNC(test_pasri_16_0)
+    pasri.16 a0, a0, 0
+    rts
+    .size  test_pasri_16_0, .-test_pasri_16_0
+
+TEST_FUNC(test_pasri_16_1)
+    pasri.16 a0, a0, 1
+    rts
+    .size  test_pasri_16_1, .-test_pasri_16_1
+
+TEST_FUNC(test_pasri_16_9)
+    pasri.16 a0, a0, 9
+    rts
+    .size  test_pasri_16_9, .-test_pasri_16_9
+
+TEST_FUNC(test_pasri_16_15)
+    pasri.16 a0, a0, 15
+    rts
+    .size  test_pasri_16_15, .-test_pasri_16_15
+
+TEST_FUNC(test_plsli_32_0)
+    plsli.32 a0, a0, 0
+    rts
+    .size  test_plsli_32_0, .-test_plsli_32_0
+
+TEST_FUNC(test_plsli_32_1)
+    plsli.32 a0, a0, 1
+    rts
+    .size  test_plsli_32_1, .-test_plsli_32_1
+
+TEST_FUNC(test_plsli_32_20)
+    plsli.32 a0, a0, 20
+    rts
+    .size  test_plsli_32_20, .-test_plsli_32_20
+
+TEST_FUNC(test_plsli_32_31)
+    plsli.32 a0, a0, 31
+    rts
+    .size  test_plsli_32_31, .-test_plsli_32_31
+
+TEST_FUNC(test_pasri_32_0)
+    pasri.32 a0, a0, 0
+    rts
+    .size  test_pasri_32_0, .-test_pasri_32_0
+
+TEST_FUNC(test_pasri_32_1)
+    pasri.32 a0, a0, 1
+    rts
+    .size  test_pasri_32_1, .-test_pasri_32_1
+
+TEST_FUNC(test_pasri_32_20)
+    pasri.32 a0, a0, 20
+    rts
+    .size  test_pasri_32_20, .-test_pasri_32_20
+
+TEST_FUNC(test_pasri_32_31)
+    pasri.32 a0, a0, 31
+    rts
+    .size  test_pasri_32_31, .-test_pasri_32_31
+
+    .text
+    .align 2
+LD_DATA:
+    .long  0x0001ffff
+    .long  0x80007fff
+
+TEST_FUNC(test_ldhe_h_1)
+    grs a1, LD_DATA
+    movi a0, 0
+    ldhe.h a0, (a1, 0)
+    rts
+    .size  test_ldhe_h_1, .-test_ldhe_h_1
+
+TEST_FUNC(test_ldhe_h_2)
+    grs a1, LD_DATA
+    movi a0, 0
+    ldhe.h a0, (a1, 4)
+    rts
+    .size  test_ldhe_h_2, .-test_ldhe_h_2
+
+TEST_FUNC(test_ldle_h_1)
+    grs a1, LD_DATA
+    movi a0, 0
+    ldle.h a0, (a1, 0)
+    rts
+    .size  test_ldle_h_1, .-test_ldle_h_1
+
+TEST_FUNC(test_ldle_h_2)
+    grs a1, LD_DATA
+    movi a0, 0
+    ldle.h a0, (a1, 4)
+    rts
+    .size  test_ldle_h_2, .-test_ldle_h_2
+
+TEST_FUNC(test_ldxe_h_1)
+    grs a2, LD_DATA
+    movi a0, 0
+    movi a1, 0
+    ldxe.h a0, (a2, 0)
+    rts
+    .size  test_ldxe_h_1, .-test_ldxe_h_1
+
+TEST_FUNC(test_ldxe_h_2)
+    grs a2, LD_DATA
+    movi a0, 0
+    movi a1, 0
+    ldxe.h a0, (a2, 4)
+    rts
+    .size  test_ldxe_h_2, .-test_ldxe_h_2
+
+TEST_FUNC(test_ldrhe_h)
+    grs a1, LD_DATA
+    movi a2, 0
+    ldrhe.h a2, (a1, a0)
+    mov  a0, a2
+    rts
+    .size  test_ldrhe_h, .-test_ldrhe_h
+
+TEST_FUNC(test_ldrle_h)
+    grs a1, LD_DATA
+    movi a2, 0
+    ldrle.h a2, (a1, a0)
+    mov  a0, a2
+    rts
+    .size  test_ldrle_h, .-test_ldrle_h
+
+
+TEST_FUNC(test_ldrxe_h)
+    grs a1, LD_DATA
+    movi a2, 0
+    movi a3, 0
+    ldrxe.h a2, (a1, a0)
+    mov  a0, a2
+    mov  a1, a3
+    rts
+    .size  test_ldrxe_h, .-test_ldrxe_h
+
+TEST_FUNC(test_mul_s32_h)
+    mul.s32.h a0, a0, a1
+    rts
+    .size   test_mul_s32_h, .-test_mul_s32_h
+
+TEST_FUNC(test_mul_u32_h)
+    mul.u32.h a0, a0, a1
+    rts
+    .size   test_mul_u32_h, .-test_mul_u32_h
+
+TEST_FUNC(test_mul_s32_rh)
+    mul.s32.rh a0, a0, a1
+    rts
+    .size   test_mul_s32_rh, .-test_mul_s32_rh
+
+TEST_FUNC(test_mul_u32_rh)
+    mul.u32.rh a0, a0, a1
+    rts
+    .size   test_mul_u32_rh, .-test_mul_u32_rh
+
+TEST_FUNC(test_mula_s32_h)
+    mula.s32.h a2, a0, a1
+    mov a0, a2
+    rts
+    .size   test_mula_s32_h, .-test_mula_s32_h
+
+TEST_FUNC(test_mula_u32_h)
+    mula.u32.h a2, a0, a1
+    mov a0, a2
+    rts
+    .size   test_mula_u32_h, .-test_mula_u32_h
+
+TEST_FUNC(test_mula_s32_rh)
+    mula.s32.rh a2, a0, a1
+    mov a0, a2
+    rts
+    .size   test_mula_s32_rh, .-test_mula_s32_rh
+
+TEST_FUNC(test_mula_u32_rh)
+    mula.u32.rh a2, a0, a1
+    mov a0, a2
+    rts
+    .size   test_mula_u32_rh, .-test_mula_u32_rh
+
+TEST_FUNC(test_muls_s32_h)
+    muls.s32.h a2, a0, a1
+    mov a0, a2
+    rts
+    .size   test_muls_s32_h, .-test_muls_s32_h
+
+TEST_FUNC(test_muls_u32_h)
+    muls.u32.h a2, a0, a1
+    mov a0, a2
+    rts
+    .size   test_muls_u32_h, .-test_muls_u32_h
+
+TEST_FUNC(test_muls_s32_rh)
+    muls.s32.rh a2, a0, a1
+    mov a0, a2
+    rts
+    .size   test_muls_s32_rh, .-test_muls_s32_rh
+
+TEST_FUNC(test_muls_u32_rh)
+    muls.u32.rh a2, a0, a1
+    mov a0, a2
+    rts
+    .size   test_muls_u32_rh, .-test_muls_u32_rh
+
+TEST_FUNC(test_divsl)
+    divsl a0, a0, a1
+    rts
+    .size   test_divsl, .-test_divsl
+
+TEST_FUNC(test_divul)
+    divul a0, a0, a1
+    rts
+    .size   test_divul, .-test_divul
diff --git a/tests/csky/ck803s-dsp/case/dsp_insn.h b/tests/csky/ck803s-dsp/case/dsp_insn.h
new file mode 100644
index 0000000..579dd72
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/dsp_insn.h
@@ -0,0 +1,148 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#ifndef DSP_INSN_H
+#define DSP_INSN_H
+
+int32_t test_add_s32_s(int32_t a, int32_t b);
+int32_t test_addx_u32(int32_t a, int32_t b);
+int32_t test_addx_s32(int32_t a, int32_t b);
+int32_t test_padd_s16_s(int32_t a, int32_t b);
+int32_t test_padd_s16(int32_t a, int32_t b);
+int32_t test_paddh_s16(int32_t a, int32_t b);
+int64_t test_pmul_s16(int32_t a, int32_t b);
+int64_t test_pmul_s16_f(int32_t a, int32_t b);
+int32_t test_mul_32_l(int32_t a, int32_t b);
+int32_t test_mul_32_lf(int32_t a, int32_t b);
+int32_t test_mulll_s16(int32_t a, int32_t b);
+int32_t test_mulll_s16_f(int32_t a, int32_t b);
+int32_t test_mulhl_s16(int32_t a, int32_t b);
+int32_t test_mulhl_s16_f(int32_t a, int32_t b);
+int32_t test_mulhh_s16(int32_t a, int32_t b);
+int32_t test_mulhh_s16_f(int32_t a, int32_t b);
+int32_t test_mulca_s16(int32_t a, int32_t b);
+int32_t test_mulca_s16_f(int32_t a, int32_t b);
+int32_t test_mulcax_s16(int32_t a, int32_t b);
+int32_t test_mulcax_s16_f(int32_t a, int32_t b);
+int32_t test_mulcs_s16(int32_t a, int32_t b);
+int32_t test_mulcs_s16_f(int32_t a, int32_t b);
+int32_t test_mulcsx_s16(int32_t a, int32_t b);
+int32_t test_mulcsx_s16_f(int32_t a, int32_t b);
+int32_t test_max_u32(int32_t a, int32_t b);
+int32_t test_max_s32(int32_t a, int32_t b);
+int32_t test_min_u32(int32_t a, int32_t b);
+int32_t test_min_s32(int32_t a, int32_t b);
+int32_t test_pmax_u16(int32_t a, int32_t b);
+int32_t test_pmax_s16(int32_t a, int32_t b);
+int32_t test_pmin_u16(int32_t a, int32_t b);
+int32_t test_pmin_s16(int32_t a, int32_t b);
+int64_t test_divsr(int32_t a, int32_t b);
+int64_t test_divur(int32_t a, int32_t b);
+int32_t test_mula_32_l(int32_t a, int32_t b, int32_t c);
+int32_t test_mula_32_lf(int32_t a, int32_t b, int32_t c);
+int32_t test_muls_32_l(int32_t a, int32_t b, int32_t c);
+int32_t test_muls_32_lf(int32_t a, int32_t b, int32_t c);
+int64_t test_mul_u32(int32_t a, int32_t b);
+int64_t test_mul_s32(int32_t a, int32_t b);
+int64_t test_mul_s32_f(int32_t a, int32_t b);
+int64_t test_mula_u32(int32_t a, int32_t b, int64_t c);
+int64_t test_mula_s32(int32_t a, int32_t b, int64_t c);
+int64_t test_mula_s32_f(int32_t a, int32_t b, int64_t c);
+int64_t test_mulaca_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_mulacax_s16_e(int32_t a, int32_t b, int64_t c);
+int32_t test_mulall_s16(int32_t a, int32_t b, int32_t c);
+int32_t test_mulall_s16_f(int32_t a, int32_t b, int32_t c);
+int64_t test_mulall_s16_e(int32_t a, int32_t b, int64_t c);
+int32_t test_sub_s32_s(int32_t a, int32_t b);
+int32_t test_psub_s16_s(int32_t a, int32_t b);
+int32_t test_psub_s16(int32_t a, int32_t b);
+int32_t test_psubh_s16(int32_t a, int32_t b);
+int64_t test_paddx_s32(int32_t a, int32_t b, int64_t c);
+int64_t test_psubx_s32(int32_t a, int32_t b, int64_t c);
+int32_t test_pabs_s16_s(int32_t a);
+int32_t test_pneg_s16_s(int32_t a);
+int32_t test_sel_32(int32_t a, int32_t b, int32_t equ_a);
+int32_t test_pkg_0_16(int32_t a, int32_t b);
+int32_t test_pkg_15_1(int32_t a, int32_t b);
+int32_t test_pkg_0_1(int32_t a, int32_t b);
+int32_t test_pkg_15_16(int32_t a, int32_t b);
+int32_t test_pkgll(int32_t a, int32_t b);
+int32_t test_pkghh(int32_t a, int32_t b);
+int32_t test_dext_16(int32_t a, int32_t b);
+int32_t test_dext_0(int32_t a, int32_t b);
+int32_t test_dext_31(int32_t a, int32_t b);
+int64_t test_pmula_s16(int32_t a, int32_t b, int64_t c);
+int64_t test_pmula_s16_f(int32_t a, int32_t b, int64_t c);
+int64_t test_pmulwh_s16(int32_t a, int32_t b);
+int64_t test_pmulwh_s16_f(int32_t a, int32_t b);
+int64_t test_pmulwl_s16(int32_t a, int32_t b);
+int64_t test_pmulwl_s16_f(int32_t a, int32_t b);
+int64_t test_pmulawh_s16(int32_t a, int32_t b, int64_t c);
+int64_t test_pmulawh_s16_f(int32_t a, int32_t b, int64_t c);
+int64_t test_pmulawl_s16(int32_t a, int32_t b, int64_t c);
+int64_t test_pmulawl_s16_f(int32_t a, int32_t b, int64_t c);
+int32_t test_plsli_16_0(int32_t a);
+int32_t test_plsli_16_1(int32_t a);
+int32_t test_plsli_16_9(int32_t a);
+int32_t test_plsli_16_15(int32_t a);
+int32_t test_pasri_16_0(int32_t a);
+int32_t test_pasri_16_1(int32_t a);
+int32_t test_pasri_16_9(int32_t a);
+int32_t test_pasri_16_15(int32_t a);
+int64_t test_plsli_32_0(int32_t a, int32_t b);
+int64_t test_plsli_32_1(int32_t a, int32_t b);
+int64_t test_plsli_32_20(int32_t a, int32_t b);
+int64_t test_plsli_32_31(int32_t a, int32_t b);
+int64_t test_pasri_32_0(int32_t a, int32_t b);
+int64_t test_pasri_32_1(int32_t a, int32_t b);
+int64_t test_pasri_32_20(int32_t a, int32_t b);
+int64_t test_pasri_32_31(int32_t a, int32_t b);
+int32_t test_ldhe_h_1(void);
+int32_t test_ldhe_h_2(void);
+int32_t test_ldle_h_1(void);
+int32_t test_ldle_h_2(void);
+int64_t test_ldxe_h_1(void);
+int64_t test_ldxe_h_2(void);
+int32_t test_ldrhe_h(int32_t a);
+int32_t test_ldrle_h(int32_t a);
+int64_t test_ldrxe_h(int32_t a);
+int32_t test_mul_s32_h(int32_t a, int32_t b);
+int32_t test_mul_u32_h(int32_t a, int32_t b);
+int32_t test_mul_s32_rh(int32_t a, int32_t b);
+int32_t test_mul_u32_rh(int32_t a, int32_t b);
+int32_t test_mula_s32_h(int32_t a, int32_t b, int32_t c);
+int32_t test_mula_u32_h(int32_t a, int32_t b, int32_t c);
+int32_t test_mula_s32_rh(int32_t a, int32_t b, int32_t c);
+int32_t test_mula_u32_rh(int32_t a, int32_t b, int32_t c);
+int32_t test_muls_s32_h(int32_t a, int32_t b, int32_t c);
+int32_t test_muls_u32_h(int32_t a, int32_t b, int32_t c);
+int32_t test_muls_s32_rh(int32_t a, int32_t b, int32_t c);
+int32_t test_muls_u32_rh(int32_t a, int32_t b, int32_t c);
+int32_t test_divsl(int32_t a, int32_t b);
+int32_t test_divul(int32_t a, int32_t b);
+
+#endif /* DSP_INSN_H */
diff --git a/tests/csky/ck803s-dsp/case/ldhe_h.c b/tests/csky/ck803s-dsp/case/ldhe_h.c
new file mode 100644
index 0000000..61432e0
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/ldhe_h.c
@@ -0,0 +1,47 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      2
+int main(void)
+{
+    init_testsuite("Testing insn LDHE.H \n");
+
+    /*
+     * LDHE.H
+     * rz = {mem(rx+offset<<1)[15:0], rz[15:0]}
+     */
+    int32_t sample[TEST_TIMES] = {0xffff0000, 0x7fff0000};
+
+    TEST(test_ldhe_h_1() == sample[0]);
+    TEST(test_ldhe_h_2() == sample[1]);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/ldle_h.c b/tests/csky/ck803s-dsp/case/ldle_h.c
new file mode 100644
index 0000000..d14f02c
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/ldle_h.c
@@ -0,0 +1,47 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      2
+int main(void)
+{
+    init_testsuite("Testing insn LDLE.H \n");
+
+    /*
+     * LDLE.H
+     * rz = {rz[31:16], mem(rx+offset<<1)[15:0]}
+     */
+    int32_t sample[TEST_TIMES] = {0x0000ffff, 0x00007fff};
+
+    TEST(test_ldle_h_1() == sample[0]);
+    TEST(test_ldle_h_2() == sample[1]);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/ldrhe_h.c b/tests/csky/ck803s-dsp/case/ldrhe_h.c
new file mode 100644
index 0000000..2eed7cc
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/ldrhe_h.c
@@ -0,0 +1,51 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      2
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn LDRHE.H \n");
+
+    /*
+     * LDRHE.H
+     * rz = {mem(rx+ry)[15:0], rz[15:0]}
+     */
+    struct unary_calculation sample[TEST_TIMES] = {
+        {0, 0xffff0000},
+        {4, 0x7fff0000},
+    };
+    for (i = 0; i< TEST_TIMES; i++) {
+        TEST(test_ldrhe_h(sample[i].op1) == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/ldrle_h.c b/tests/csky/ck803s-dsp/case/ldrle_h.c
new file mode 100644
index 0000000..f16662a
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/ldrle_h.c
@@ -0,0 +1,51 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      2
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn LDRLE.H \n");
+
+    /*
+     * LDRLE.H
+     * rz = {rz[31:16], mem(rx+ry)[15:0]}
+     */
+    struct unary_calculation sample[TEST_TIMES] = {
+        {0, 0x0000ffff},
+        {4, 0x00007fff},
+    };
+    for (i = 0; i< TEST_TIMES; i++) {
+        TEST(test_ldrle_h(sample[i].op1) == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/ldrxe_h.c b/tests/csky/ck803s-dsp/case/ldrxe_h.c
new file mode 100644
index 0000000..b57bd6f
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/ldrxe_h.c
@@ -0,0 +1,52 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      2
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn LDRXE.H \n");
+
+    /*
+     * LDRXE.H
+     * rz = {mem(rx+ry)[15:0], rz[15:0]}
+     * r(z+1) = {r(z+1)[31:16], mem(rx+ry)[15:0]}
+     */
+    struct unary64_calculation sample[TEST_TIMES] = {
+        {0, 0x0000ffffffff0000},
+        {4, 0x00007fff7fff0000},
+    };
+    for (i = 0; i< TEST_TIMES; i++) {
+        TEST(test_ldrxe_h(sample[i].op1) == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/ldxe_h.c b/tests/csky/ck803s-dsp/case/ldxe_h.c
new file mode 100644
index 0000000..e4f1c94
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/ldxe_h.c
@@ -0,0 +1,48 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      2
+int main(void)
+{
+    init_testsuite("Testing insn LDXE.H \n");
+
+    /*
+     * LDXE.H
+     * rz = {mem(rx+offset<<1)[15:0], rz[15:0]}
+     * r(z+1) = {r(z+1)[31:16], mem(rx+offset<<1)[15:0]}
+     */
+    int64_t sample[TEST_TIMES] = {0x0000ffffffff0000, 0x00007fff7fff0000};
+
+    TEST(test_ldxe_h_1() == sample[0]);
+    TEST(test_ldxe_h_2() == sample[1]);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/max_s32.c b/tests/csky/ck803s-dsp/case/max_s32.c
new file mode 100644
index 0000000..0ac27e1
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/max_s32.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MAX.S32 \n");
+
+    /*
+     * MAX.S32
+     * rz = max(rx, ry), signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x80000000, 0x80000000, 0x80000000},
+        {0x80000000, 0x00000000, 0x00000000},
+        {0x80000000, 0x7FFFFFFF, 0x7FFFFFFF},
+        {0x00000000, 0x80000000, 0x00000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x7FFFFFFF},
+        {0x7FFFFFFF, 0x80000000, 0x7FFFFFFF},
+        {0x7FFFFFFF, 0x00000000, 0x7FFFFFFF},
+        {0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_max_s32(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/max_u32.c b/tests/csky/ck803s-dsp/case/max_u32.c
new file mode 100644
index 0000000..a13cc3d
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/max_u32.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MAX.U32 \n");
+
+    /*
+     * MAX.U32
+     * rz = max(rx, ry), unsigned
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},
+        {0xFFFFFFFF, 0x00000000, 0xFFFFFFFF},
+        {0xFFFFFFFF, 0x7FFFFFFF, 0xFFFFFFFF},
+        {0x00000000, 0xFFFFFFFF, 0xFFFFFFFF},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x7FFFFFFF},
+        {0x7FFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},
+        {0x7FFFFFFF, 0x00000000, 0x7FFFFFFF},
+        {0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_max_u32(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/min_s32.c b/tests/csky/ck803s-dsp/case/min_s32.c
new file mode 100644
index 0000000..39092af
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/min_s32.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MIN.S32 \n");
+
+    /*
+     * MIN.S32
+     * rz = min(rx, ry), signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x80000000, 0x80000000, 0x80000000},
+        {0x80000000, 0x00000000, 0x80000000},
+        {0x80000000, 0x7FFFFFFF, 0x80000000},
+        {0x00000000, 0x80000000, 0x80000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x00000000},
+        {0x7FFFFFFF, 0x80000000, 0x80000000},
+        {0x7FFFFFFF, 0x00000000, 0x00000000},
+        {0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_min_s32(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/min_u32.c b/tests/csky/ck803s-dsp/case/min_u32.c
new file mode 100644
index 0000000..8b33dec
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/min_u32.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MIN.U32 \n");
+
+    /*
+     * MIN.U32
+     * rz = MIN(rx, ry), unsigned
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},
+        {0xFFFFFFFF, 0x00000000, 0x00000000},
+        {0xFFFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF},
+        {0x00000000, 0xFFFFFFFF, 0x00000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x00000000},
+        {0x7FFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF},
+        {0x7FFFFFFF, 0x00000000, 0x00000000},
+        {0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_min_u32(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mul_32_l.c b/tests/csky/ck803s-dsp/case/mul_32_l.c
new file mode 100644
index 0000000..3f7dbf8
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mul_32_l.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MUL.32.L \n");
+
+    /*
+     * MUL.32.L
+     * rz = (rx * ry)[31:0]
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000001},
+        {0x00000001, 0x7FFF7FFF, 0x7FFF7FFF},
+        {0x00000001, 0xFFFFFFFF, 0xFFFFFFFF},
+        {0x7FFF7FFF, 0xFFFFFFFF, 0x80008001},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000001},
+        {0x00008000, 0x80008000, 0x40000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x00000000},
+        {0x80000000, 0x00008000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mul_32_l(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mul_32_lf.c b/tests/csky/ck803s-dsp/case/mul_32_lf.c
new file mode 100644
index 0000000..e1642f0
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mul_32_lf.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MUL.32.LF \n");
+
+    /*
+     * MUL.32.LF
+     * rz = (rx * ry)[31:0] << 1
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000002},
+        {0x00000001, 0x7FFF7FFF, 0xFFFEFFFE},
+        {0x00000001, 0xFFFFFFFF, 0xFFFFFFFE},
+        {0x7FFF7FFF, 0xFFFFFFFF, 0x00010002},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000002},
+        {0x00008000, 0x80008000, 0x80000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x00000000},
+        {0x80000000, 0x00008000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mul_32_lf(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mul_s32.c b/tests/csky/ck803s-dsp/case/mul_s32.c
new file mode 100644
index 0000000..2bd0475
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mul_s32.c
@@ -0,0 +1,68 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      16
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MUL.S32 \n");
+
+    /*
+     * MUL.S32
+     * {rn,rz} = rx * ry, signed
+     */
+    struct binary64_calculation bin64_sample[TEST_TIMES] = {
+        {0x7fffffff, 0x7fffffff, 0x3fffffff00000001},
+        {0x80000000, 0x80000000, 0x4000000000000000},
+        {0xffffffff, 0xffffffff, 0x0000000000000001},
+        {0x00000000, 0x00000000, 0x0000000000000000},
+        {0x7fffffff, 0x80000000, 0xc000000080000000},
+        {0x80000000, 0x7fffffff, 0xc000000080000000},
+        {0x7fffffff, 0xffffffff, 0xffffffff80000001},
+        {0xffffffff, 0x7fffffff, 0xffffffff80000001},
+        {0x7fffffff, 0x00000000, 0x0000000000000000},
+        {0x00000000, 0x7fffffff, 0x0000000000000000},
+        {0x80000000, 0xffffffff, 0x0000000080000000},
+        {0xffffffff, 0x80000000, 0x0000000080000000},
+        {0x00000000, 0x80000000, 0x0000000000000000},
+        {0x80000000, 0x00000000, 0x0000000000000000},
+        {0xffffffff, 0x00000000, 0x0000000000000000},
+        {0x00000000, 0xffffffff, 0x0000000000000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mul_s32(bin64_sample[i].op1, bin64_sample[i].op2)
+                     == bin64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mul_s32_f.c b/tests/csky/ck803s-dsp/case/mul_s32_f.c
new file mode 100644
index 0000000..a8756b8
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mul_s32_f.c
@@ -0,0 +1,68 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      16
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MUL.S32.F \n");
+
+    /*
+     * MUL.S32.F
+     * {rn,rz} = rx * ry << 1, signed & fraction
+     */
+    struct binary64_calculation bin64_sample[TEST_TIMES] = {
+        {0x7fffffff, 0x7fffffff, 0x7ffffffe00000002},
+        {0x80000000, 0x80000000, 0x8000000000000000},
+        {0xffffffff, 0xffffffff, 0x0000000000000002},
+        {0x00000000, 0x00000000, 0x0000000000000000},
+        {0x7fffffff, 0x80000000, 0x8000000100000000},
+        {0x80000000, 0x7fffffff, 0x8000000100000000},
+        {0x7fffffff, 0xffffffff, 0xffffffff00000002},
+        {0xffffffff, 0x7fffffff, 0xffffffff00000002},
+        {0x7fffffff, 0x00000000, 0x0000000000000000},
+        {0x00000000, 0x7fffffff, 0x0000000000000000},
+        {0x80000000, 0xffffffff, 0x0000000100000000},
+        {0xffffffff, 0x80000000, 0x0000000100000000},
+        {0x00000000, 0x80000000, 0x0000000000000000},
+        {0x80000000, 0x00000000, 0x0000000000000000},
+        {0xffffffff, 0x00000000, 0x0000000000000000},
+        {0x00000000, 0xffffffff, 0x0000000000000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mul_s32_f(bin64_sample[i].op1, bin64_sample[i].op2)
+                     == bin64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mul_s32_h.c b/tests/csky/ck803s-dsp/case/mul_s32_h.c
new file mode 100644
index 0000000..db05f9b
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mul_s32_h.c
@@ -0,0 +1,68 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      16
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MUL.S32.H \n");
+
+    /*
+     * MUL.S32.H
+     * rz = (rx * ry)[63:32], signed
+     */
+    struct binary_calculation sample[TEST_TIMES] = {
+        {0x7fffffff, 0x7fffffff, 0x3fffffff},
+        {0x80000000, 0x80000000, 0x40000000},
+        {0xffffffff, 0xffffffff, 0x00000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x7fffffff, 0x80000000, 0xc0000000},
+        {0x80000000, 0x7fffffff, 0xc0000000},
+        {0x7fffffff, 0xffffffff, 0xffffffff},
+        {0xffffffff, 0x7fffffff, 0xffffffff},
+        {0x7fffffff, 0x00000000, 0x00000000},
+        {0x00000000, 0x7fffffff, 0x00000000},
+        {0x80000000, 0xffffffff, 0x00000000},
+        {0xffffffff, 0x80000000, 0x00000000},
+        {0x00000000, 0x80000000, 0x00000000},
+        {0x80000000, 0x00000000, 0x00000000},
+        {0xffffffff, 0x00000000, 0x00000000},
+        {0x00000000, 0xffffffff, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mul_s32_h(sample[i].op1, sample[i].op2)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mul_s32_rh.c b/tests/csky/ck803s-dsp/case/mul_s32_rh.c
new file mode 100644
index 0000000..48c1f6b
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mul_s32_rh.c
@@ -0,0 +1,68 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      16
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MUL.S32.RH \n");
+
+    /*
+     * MUL.S32.RH
+     * rz = (rx * ry + 0x80000000)[63:32] , signed
+     */
+    struct binary_calculation sample[TEST_TIMES] = {
+        {0x7fffffff, 0x7fffffff, 0x3fffffff},
+        {0x80000000, 0x80000000, 0x40000000},
+        {0xffffffff, 0xffffffff, 0x00000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x7fffffff, 0x80000000, 0xc0000001},
+        {0x80000000, 0x7fffffff, 0xc0000001},
+        {0x7fffffff, 0xffffffff, 0x00000000},
+        {0xffffffff, 0x7fffffff, 0x00000000},
+        {0x7fffffff, 0x00000000, 0x00000000},
+        {0x00000000, 0x7fffffff, 0x00000000},
+        {0x80000000, 0xffffffff, 0x00000001},
+        {0xffffffff, 0x80000000, 0x00000001},
+        {0x00000000, 0x80000000, 0x00000000},
+        {0x80000000, 0x00000000, 0x00000000},
+        {0xffffffff, 0x00000000, 0x00000000},
+        {0x00000000, 0xffffffff, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mul_s32_rh(sample[i].op1, sample[i].op2)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mul_u32.c b/tests/csky/ck803s-dsp/case/mul_u32.c
new file mode 100644
index 0000000..341facf
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mul_u32.c
@@ -0,0 +1,68 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      16
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MUL.U32 \n");
+
+    /*
+     * MUL.U32
+     * {rn,rz} = rx * ry, unsigned
+     */
+    struct binary64_calculation bin64_sample[TEST_TIMES] = {
+        {0x7fffffff, 0x7fffffff, 0x3fffffff00000001},
+        {0x80000000, 0x80000000, 0x4000000000000000},
+        {0xffffffff, 0xffffffff, 0xfffffffe00000001},
+        {0x00000000, 0x00000000, 0x0000000000000000},
+        {0x7fffffff, 0x80000000, 0x3fffffff80000000},
+        {0x80000000, 0x7fffffff, 0x3fffffff80000000},
+        {0x7fffffff, 0xffffffff, 0x7ffffffe80000001},
+        {0xffffffff, 0x7fffffff, 0x7ffffffe80000001},
+        {0x7fffffff, 0x00000000, 0x0000000000000000},
+        {0x00000000, 0x7fffffff, 0x0000000000000000},
+        {0x80000000, 0xffffffff, 0x7fffffff80000000},
+        {0xffffffff, 0x80000000, 0x7fffffff80000000},
+        {0x00000000, 0x80000000, 0x0000000000000000},
+        {0x80000000, 0x00000000, 0x0000000000000000},
+        {0xffffffff, 0x00000000, 0x0000000000000000},
+        {0x00000000, 0xffffffff, 0x0000000000000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mul_u32(bin64_sample[i].op1, bin64_sample[i].op2)
+                     == bin64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mul_u32_h.c b/tests/csky/ck803s-dsp/case/mul_u32_h.c
new file mode 100644
index 0000000..5798963
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mul_u32_h.c
@@ -0,0 +1,68 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      16
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MUL.U32.H \n");
+
+    /*
+     * MUL.U32.H
+     * rz = (rx * ry)[63:32], unsigned
+     */
+    struct binary_calculation sample[TEST_TIMES] = {
+        {0x7fffffff, 0x7fffffff, 0x3fffffff},
+        {0x80000000, 0x80000000, 0x40000000},
+        {0xffffffff, 0xffffffff, 0xfffffffe},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x7fffffff, 0x80000000, 0x3fffffff},
+        {0x80000000, 0x7fffffff, 0x3fffffff},
+        {0x7fffffff, 0xffffffff, 0x7ffffffe},
+        {0xffffffff, 0x7fffffff, 0x7ffffffe},
+        {0x7fffffff, 0x00000000, 0x00000000},
+        {0x00000000, 0x7fffffff, 0x00000000},
+        {0x80000000, 0xffffffff, 0x7fffffff},
+        {0xffffffff, 0x80000000, 0x7fffffff},
+        {0x00000000, 0x80000000, 0x00000000},
+        {0x80000000, 0x00000000, 0x00000000},
+        {0xffffffff, 0x00000000, 0x00000000},
+        {0x00000000, 0xffffffff, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mul_u32_h(sample[i].op1, sample[i].op2)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mul_u32_rh.c b/tests/csky/ck803s-dsp/case/mul_u32_rh.c
new file mode 100644
index 0000000..7840fce
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mul_u32_rh.c
@@ -0,0 +1,68 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      16
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MUL.U32.RH \n");
+
+    /*
+     * MUL.U32.RH
+     * rz = (rx * ry + 0x80000000)[63:32] , unsigned
+     */
+    struct binary_calculation sample[TEST_TIMES] = {
+        {0x7fffffff, 0x7fffffff, 0x3fffffff},
+        {0x80000000, 0x80000000, 0x40000000},
+        {0xffffffff, 0xffffffff, 0xfffffffe},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x7fffffff, 0x80000000, 0x40000000},
+        {0x80000000, 0x7fffffff, 0x40000000},
+        {0x7fffffff, 0xffffffff, 0x7fffffff},
+        {0xffffffff, 0x7fffffff, 0x7fffffff},
+        {0x7fffffff, 0x00000000, 0x00000000},
+        {0x00000000, 0x7fffffff, 0x00000000},
+        {0x80000000, 0xffffffff, 0x80000000},
+        {0xffffffff, 0x80000000, 0x80000000},
+        {0x00000000, 0x80000000, 0x00000000},
+        {0x80000000, 0x00000000, 0x00000000},
+        {0xffffffff, 0x00000000, 0x00000000},
+        {0x00000000, 0xffffffff, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mul_u32_rh(sample[i].op1, sample[i].op2)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mula_32_l.c b/tests/csky/ck803s-dsp/case/mula_32_l.c
new file mode 100644
index 0000000..1a927f8
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mula_32_l.c
@@ -0,0 +1,70 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      18
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULA.32.L \n");
+
+    /*
+     * MULA.32.L
+     * rz = rn + rx * ry
+     */
+    struct ternary_calculation ter_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000000, 0x00000001},
+        {0x00000002, 0x40000000, 0x00000000, 0x80000000},
+        {0x00000001, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF},
+        {0x00000001, 0x00000001, 0x00000001, 0x00000002},
+        {0x00000002, 0x20000000, 0x40000000, 0x80000000},
+        {0x00000002, 0x80000000, 0x00000000, 0x00000000},
+        {0x00000002, 0x80000001, 0x00000000, 0x00000002},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000001},
+        {0x80000000, 0x80000000, 0x00000000, 0x00000000},
+        {0x80000000, 0x80000000, 0x80000000, 0x80000000},
+        {0x00000100, 0x10000001, 0xFFFFFFFF, 0x000000FF},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000},
+        {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000000, 0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0xFFFFFFFF, 0x00000000, 0x00000000},
+        {0x00000000, 0x00000001, 0x00000001, 0x00000001},
+        {0x00000000, 0x00000000, 0x00000001, 0x00000001},
+        {0x00000000, 0xFFFFFFFF, 0x00000001, 0x00000001},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mula_32_l(ter_sample[i].op1, ter_sample[i].op2,
+                            ter_sample[i].op3) == ter_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mula_32_lf.c b/tests/csky/ck803s-dsp/case/mula_32_lf.c
new file mode 100644
index 0000000..82aa585
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mula_32_lf.c
@@ -0,0 +1,69 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      17
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULA.32.LF \n");
+
+    /*
+     * MULA.32.LF
+     * rz = rn + (rx * ry) << 1, fraction
+     */
+    struct ternary_calculation ter_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000000, 0x00000002},
+        {0x00000002, 0x20000000, 0x00000000, 0x80000000},
+        {0x00000001, 0x7FFFFFFF, 0x00000000, 0xFFFFFFFE},
+        {0x00000001, 0x00000001, 0x00000001, 0x00000003},
+        {0x00000001, 0xFFFFFFFF, 0x80000000, 0x7FFFFFFE},
+        {0x00000002, 0x80000000, 0x00000000, 0x00000000},
+        {0x00000002, 0x80000001, 0x00000000, 0x00000004},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000002},
+        {0x80000000, 0x80000000, 0x00000000, 0x00000000},
+        {0x00000100, 0x10000001, 0xFFFFFFFF, 0x000001FF},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000001},
+        {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000000, 0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0xFFFFFFFF, 0x00000000, 0x00000000},
+        {0x00000000, 0x00000001, 0x00000001, 0x00000001},
+        {0x00000000, 0x00000000, 0x00000001, 0x00000001},
+        {0x00000000, 0xFFFFFFFF, 0x00000001, 0x00000001},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mula_32_lf(ter_sample[i].op1, ter_sample[i].op2,
+                            ter_sample[i].op3) == ter_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mula_s32.c b/tests/csky/ck803s-dsp/case/mula_s32.c
new file mode 100644
index 0000000..c907fec
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mula_s32.c
@@ -0,0 +1,67 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      17
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULA.S32 \n");
+
+    /*
+     * MULA.S32
+     * {rn,rz} = (rx * ry) + {rn,rz}, signed
+     */
+    struct ternary64_calculation ter64_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000002},
+        {0x00000001, 0x00000001, 0xffffffffffffffff, 0x0000000000000000},
+        {0x00000001, 0x00000001, 0x8000000000000000, 0x8000000000000001},
+        {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x8000000000000000},
+        {0x00000001, 0xffffffff, 0xffffffffffffffff, 0xfffffffffffffffe},
+        {0x00000001, 0xffffffff, 0x8000000000000000, 0x7fffffffffffffff},
+        {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x7ffffffffffffffe},
+        {0x80000000, 0x80000000, 0xffffffffffffffff, 0x3fffffffffffffff},
+        {0x80000000, 0x80000000, 0x8000000000000000, 0xc000000000000000},
+        {0x80000000, 0x80000000, 0x7fffffffffffffff, 0xbfffffffffffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0xffffffff80000000},
+        {0x7fffffff, 0xffffffff, 0x8000000000000000, 0x7fffffff80000001},
+        {0x7fffffff, 0xffffffff, 0x7fffffffffffffff, 0x7fffffff80000000},
+        {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+        {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mula_s32(ter64_sample[i].op1, ter64_sample[i].op2,
+                           ter64_sample[i].op3) == ter64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mula_s32_f.c b/tests/csky/ck803s-dsp/case/mula_s32_f.c
new file mode 100644
index 0000000..651ce0a
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mula_s32_f.c
@@ -0,0 +1,67 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      17
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULA.S32.F \n");
+
+    /*
+     * MULA.S32.F
+     * {rn,rz} = (rx * ry) << 1 + {rn,rz}, signed & fraction
+     */
+    struct ternary64_calculation ter64_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000003},
+        {0x00000001, 0x00000001, 0xffffffffffffffff, 0x0000000000000001},
+        {0x00000001, 0x00000001, 0x8000000000000000, 0x8000000000000002},
+        {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x8000000000000001},
+        {0x00000001, 0xffffffff, 0xffffffffffffffff, 0xfffffffffffffffd},
+        {0x00000001, 0xffffffff, 0x8000000000000000, 0x7ffffffffffffffe},
+        {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x7ffffffffffffffd},
+        {0x80000000, 0x80000000, 0xffffffffffffffff, 0x7fffffffffffffff},
+        {0x80000000, 0x80000000, 0x8000000000000000, 0x0000000000000000},
+        {0x80000000, 0x80000000, 0x7fffffffffffffff, 0xffffffffffffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0xffffffff00000001},
+        {0x7fffffff, 0xffffffff, 0x8000000000000000, 0x7fffffff00000002},
+        {0x7fffffff, 0xffffffff, 0x7fffffffffffffff, 0x7fffffff00000001},
+        {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+        {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mula_s32_f(ter64_sample[i].op1, ter64_sample[i].op2,
+                           ter64_sample[i].op3) == ter64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mula_s32_h.c b/tests/csky/ck803s-dsp/case/mula_s32_h.c
new file mode 100644
index 0000000..5268b76
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mula_s32_h.c
@@ -0,0 +1,67 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      15
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULA.S32.H \n");
+
+    /*
+     * MULA.S32.H
+     * rz = rz + (rx * ry)[63:32], signed
+     */
+    struct ternary_calculation sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000001, 0xffffffff, 0xffffffff},
+        {0x00000001, 0x00000001, 0x80000000, 0x80000000},
+        {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+        {0x00000001, 0xffffffff, 0xffffffff, 0xfffffffe},
+        {0x00000001, 0xffffffff, 0x80000000, 0x7fffffff},
+        {0x00000001, 0xffffffff, 0x7fffffff, 0x7ffffffe},
+        {0x80000000, 0x80000000, 0xffffffff, 0x3fffffff},
+        {0x80000000, 0x80000000, 0x80000000, 0xc0000000},
+        {0x80000000, 0x80000000, 0x7fffffff, 0xbfffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffff, 0xfffffffe},
+        {0x7fffffff, 0xffffffff, 0x80000000, 0x7fffffff},
+        {0x7fffffff, 0xffffffff, 0x7fffffff, 0x7ffffffe},
+        {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mula_s32_h(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mula_s32_rh.c b/tests/csky/ck803s-dsp/case/mula_s32_rh.c
new file mode 100644
index 0000000..a949fca
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mula_s32_rh.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      15
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULA.S32.RH \n");
+
+    /*
+     * MULA.S32.RH
+     * rz = rz + (rx * ry + 0x80000000)[63:32], signed
+     */
+    struct ternary_calculation sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000001, 0xffffffff, 0xffffffff},
+        {0x00000001, 0x00000001, 0x80000000, 0x80000000},
+        {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+        {0x00000001, 0xffffffff, 0xffffffff, 0xffffffff},
+        {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+        {0x00000001, 0xffffffff, 0x7fffffff, 0x7fffffff},
+        {0x80000000, 0x80000000, 0xffffffff, 0x3fffffff},
+        {0x80000000, 0x80000000, 0x80000000, 0xc0000000},
+        {0x80000000, 0x80000000, 0x7fffffff, 0xbfffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff},
+        {0x7fffffff, 0xffffffff, 0x80000000, 0x80000000},
+        {0x7fffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+        {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mula_s32_rh(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
diff --git a/tests/csky/ck803s-dsp/case/mula_u32.c b/tests/csky/ck803s-dsp/case/mula_u32.c
new file mode 100644
index 0000000..e1c262e
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mula_u32.c
@@ -0,0 +1,67 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      17
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULA.U32 \n");
+
+    /*
+     * MULA.U32
+     * {rn,rz} = (rx * ry) + {rn,rz}, unsigned
+     */
+    struct ternary64_calculation ter64_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000002},
+        {0x00000001, 0x00000001, 0xffffffffffffffff, 0x0000000000000000},
+        {0x00000001, 0x00000001, 0x8000000000000000, 0x8000000000000001},
+        {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x8000000000000000},
+        {0x00000001, 0xffffffff, 0xffffffffffffffff, 0x00000000fffffffe},
+        {0x00000001, 0xffffffff, 0x8000000000000000, 0x80000000ffffffff},
+        {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x80000000fffffffe},
+        {0x80000000, 0x80000000, 0xffffffffffffffff, 0x3fffffffffffffff},
+        {0x80000000, 0x80000000, 0x8000000000000000, 0xc000000000000000},
+        {0x80000000, 0x80000000, 0x7fffffffffffffff, 0xbfffffffffffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0x7ffffffe80000000},
+        {0x7fffffff, 0xffffffff, 0x8000000000000000, 0xfffffffe80000001},
+        {0x7fffffff, 0xffffffff, 0x7fffffffffffffff, 0xfffffffe80000000},
+        {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+        {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mula_u32(ter64_sample[i].op1, ter64_sample[i].op2,
+                           ter64_sample[i].op3) == ter64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mula_u32_h.c b/tests/csky/ck803s-dsp/case/mula_u32_h.c
new file mode 100644
index 0000000..5be37d7
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mula_u32_h.c
@@ -0,0 +1,67 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      15
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULA.U32.H \n");
+
+    /*
+     * MULA.U32.H
+     * rz = rz + (rx * ry)[63:32], unsigned
+     */
+    struct ternary_calculation sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000001, 0xffffffff, 0xffffffff},
+        {0x00000001, 0x00000001, 0x80000000, 0x80000000},
+        {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+        {0x00000001, 0xffffffff, 0xffffffff, 0xffffffff},
+        {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+        {0x00000001, 0xffffffff, 0x7fffffff, 0x7fffffff},
+        {0x80000000, 0x80000000, 0xffffffff, 0x3fffffff},
+        {0x80000000, 0x80000000, 0x80000000, 0xc0000000},
+        {0x80000000, 0x80000000, 0x7fffffff, 0xbfffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffff, 0x7ffffffd},
+        {0x7fffffff, 0xffffffff, 0x80000000, 0xfffffffe},
+        {0x7fffffff, 0xffffffff, 0x7fffffff, 0xfffffffd},
+        {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mula_u32_h(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mula_u32_rh.c b/tests/csky/ck803s-dsp/case/mula_u32_rh.c
new file mode 100644
index 0000000..5d04a2c
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mula_u32_rh.c
@@ -0,0 +1,67 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      15
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULA.U32.RH \n");
+
+    /*
+     * MULA.U32.RH
+     * rz = rz + (rx * ry + 0x80000000)[63:32], unsigned
+     */
+    struct ternary_calculation sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000001, 0xffffffff, 0xffffffff},
+        {0x00000001, 0x00000001, 0x80000000, 0x80000000},
+        {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+        {0x00000001, 0xffffffff, 0xffffffff, 0x00000000},
+        {0x00000001, 0xffffffff, 0x80000000, 0x80000001},
+        {0x00000001, 0xffffffff, 0x7fffffff, 0x80000000},
+        {0x80000000, 0x80000000, 0xffffffff, 0x3fffffff},
+        {0x80000000, 0x80000000, 0x80000000, 0xc0000000},
+        {0x80000000, 0x80000000, 0x7fffffff, 0xbfffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffff, 0x7ffffffe},
+        {0x7fffffff, 0xffffffff, 0x80000000, 0xffffffff},
+        {0x7fffffff, 0xffffffff, 0x7fffffff, 0xfffffffe},
+        {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mula_u32_rh(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulaca_s16_e.c b/tests/csky/ck803s-dsp/case/mulaca_s16_e.c
new file mode 100644
index 0000000..bbb49da
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulaca_s16_e.c
@@ -0,0 +1,74 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      21
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULACA.S16.E \n");
+
+    /*
+     * MULACA.S16.E
+     * {rn, rz} = {rn, rz} + rx[15:0] * ry[15:0] + rx[31:16] * ry[31:16],
+     * signed
+     */
+    struct ternary64_calculation ter64_sample[TEST_TIMES] = {
+        {0x00010001, 0x00010001, 0x0000000000000001, 0x0000000000000003},
+        {0x80007fff, 0x80007fff, 0x8000000000000000, 0x800000007fff0001},
+        {0x80007fff, 0x80007fff, 0xffffffffffffffff, 0x000000007fff0000},
+        {0x80007fff, 0x80007fff, 0x7fffffffffffffff, 0x800000007fff0000},
+        {0x7fff7fff, 0x80008000, 0x8000000000000000, 0x7fffffff80010000},
+        {0x7fff7fff, 0x80008000, 0xffffffffffffffff, 0xffffffff8000ffff},
+        {0x7fff7fff, 0x80008000, 0x7fffffffffffffff, 0x7fffffff8000ffff},
+        {0xffffffff, 0xffffffff, 0x8000000000000000, 0x8000000000000002},
+        {0xffffffff, 0xffffffff, 0xffffffffffffffff, 0x0000000000000001},
+        {0xffffffff, 0xffffffff, 0x7fffffffffffffff, 0x8000000000000001},
+        {0xffffffff, 0x80008000, 0x8000000000000000, 0x8000000000010000},
+        {0xffffffff, 0x80008000, 0xffffffffffffffff, 0x000000000000ffff},
+        {0xffffffff, 0x80008000, 0x7fffffffffffffff, 0x800000000000ffff},
+        {0x8000ffff, 0x8000ffff, 0x8000000000000000, 0x8000000040000001},
+        {0x8000ffff, 0x8000ffff, 0xffffffffffffffff, 0x0000000040000000},
+        {0x8000ffff, 0x8000ffff, 0x7fffffffffffffff, 0x8000000040000000},
+        {0x00010000, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+        {0x0001ffff, 0xffff0000, 0x0000000000000000, 0xffffffffffffffff},
+        {0x00000001, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+        {0x0000ffff, 0xffff0001, 0x0000000000000000, 0xffffffffffffffff},
+        {0x00000000, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulaca_s16_e(ter64_sample[i].op1, ter64_sample[i].op2,
+                               ter64_sample[i].op3) == ter64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulacax_s16_e.c b/tests/csky/ck803s-dsp/case/mulacax_s16_e.c
new file mode 100644
index 0000000..9aa51b2
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulacax_s16_e.c
@@ -0,0 +1,74 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      21
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULACAX.S16.E \n");
+
+    /*
+     * MULACAX.S16.E
+     * {rn, rz} = {rn, rz} + rx[15:0] * ry[31:16] + rx[31:16] * ry[15:0],
+     * signed
+     */
+    struct ternary64_calculation ter64_sample[TEST_TIMES] = {
+        {0x00010001, 0x00010001, 0x0000000000000001, 0x0000000000000003},
+        {0x80007fff, 0x7fff8000, 0x8000000000000000, 0x800000007fff0001},
+        {0x80007fff, 0x7fff8000, 0xffffffffffffffff, 0x000000007fff0000},
+        {0x80007fff, 0x7fff8000, 0x7fffffffffffffff, 0x800000007fff0000},
+        {0x7fff7fff, 0x80008000, 0x8000000000000000, 0x7fffffff80010000},
+        {0x7fff7fff, 0x80008000, 0xffffffffffffffff, 0xffffffff8000ffff},
+        {0x7fff7fff, 0x80008000, 0x7fffffffffffffff, 0x7fffffff8000ffff},
+        {0xffffffff, 0xffffffff, 0x8000000000000000, 0x8000000000000002},
+        {0xffffffff, 0xffffffff, 0xffffffffffffffff, 0x0000000000000001},
+        {0xffffffff, 0xffffffff, 0x7fffffffffffffff, 0x8000000000000001},
+        {0xffffffff, 0x80008000, 0x8000000000000000, 0x8000000000010000},
+        {0xffffffff, 0x80008000, 0xffffffffffffffff, 0x000000000000ffff},
+        {0xffffffff, 0x80008000, 0x7fffffffffffffff, 0x800000000000ffff},
+        {0x8000ffff, 0xffff8000, 0x8000000000000000, 0x8000000040000001},
+        {0x8000ffff, 0xffff8000, 0xffffffffffffffff, 0x0000000040000000},
+        {0x8000ffff, 0xffff8000, 0x7fffffffffffffff, 0x8000000040000000},
+        {0x00010000, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+        {0x0001ffff, 0x0000ffff, 0x0000000000000000, 0xffffffffffffffff},
+        {0x00000001, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+        {0x0000ffff, 0x0001ffff, 0x0000000000000000, 0xffffffffffffffff},
+        {0x00000000, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulacax_s16_e(ter64_sample[i].op1, ter64_sample[i].op2,
+                               ter64_sample[i].op3) == ter64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulall_s16.c b/tests/csky/ck803s-dsp/case/mulall_s16.c
new file mode 100644
index 0000000..f1bdd3c
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulall_s16.c
@@ -0,0 +1,73 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      21
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULALL.S16 \n");
+
+    /*
+     * MULALL.S16
+     * rz = rx[15:0] * ry[15:0] + rn, signed
+     */
+    struct ternary_calculation ter_sample[TEST_TIMES] = {
+        {0x00017fff, 0x00007fff, 0x80000000, 0xbfff0001},
+        {0x00017fff, 0x00007fff, 0xffffffff, 0x3fff0000},
+        {0x00017fff, 0x00007fff, 0x7fffffff, 0xbfff0000},
+        {0xFFFF8000, 0x00008000, 0x80000000, 0xc0000000},
+        {0x80008000, 0x7FFF8000, 0xffffffff, 0x3fffffff},
+        {0xFFFF8000, 0x80008000, 0x7fffffff, 0xbfffffff},
+        {0xFFFFffff, 0x0000ffff, 0x80000000, 0x80000001},
+        {0x8000ffff, 0x7FFFffff, 0xffffffff, 0x00000000},
+        {0x8000ffff, 0x8000ffff, 0x7fffffff, 0x80000000},
+        {0x00007fff, 0x00008000, 0x80000000, 0x40008000},
+        {0x7FFF8000, 0x7FFF7fff, 0xffffffff, 0xc0007fff},
+        {0x80008000, 0x80007fff, 0x7fffffff, 0x40007fff},
+        {0x0000ffff, 0x00018000, 0x80000000, 0x80008000},
+        {0x00008000, 0x0001ffff, 0xffffffff, 0x00007fff},
+        {0x00008000, 0x0001ffff, 0x7fffffff, 0x80007fff},
+        {0x00000000, 0xFFFFffff, 0x00000000, 0x00000000},
+        {0x7FFF0000, 0x8000ffff, 0xffffffff, 0xffffffff},
+        {0x8000ffff, 0xFFFF0000, 0x00000000, 0x00000000},
+        {0x0000ffff, 0xFFFF0000, 0xffffffff, 0xffffffff},
+        {0x7FFF0000, 0x80000000, 0x00000000, 0x00000000},
+        {0x80000000, 0x80000000, 0xffffffff, 0xffffffff},
+     };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulall_s16(ter_sample[i].op1, ter_sample[i].op2,
+                             ter_sample[i].op3) == ter_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulall_s16_e.c b/tests/csky/ck803s-dsp/case/mulall_s16_e.c
new file mode 100644
index 0000000..70612eb
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulall_s16_e.c
@@ -0,0 +1,74 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      21
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULALL.S16.E \n");
+
+    /*
+     * MULALL.S16.E
+     * {rn, rz} = {rn, rz} + rx[15:0] * ry[15:0] + rx[31:16] * ry[31:16],
+     * signed
+     */
+    struct ternary64_calculation ter64_sample[TEST_TIMES] = {
+        {0x00017fff, 0x00007fff, 0x8000000000000000, 0x800000003fff0001},
+        {0x00017fff, 0x00007fff, 0xffffffffffffffff, 0x000000003fff0000},
+        {0x00017fff, 0x00007fff, 0x7fffffffffffffff, 0x800000003fff0000},
+        {0xFFFF8000, 0x00008000, 0x8000000000000000, 0x8000000040000000},
+        {0x80008000, 0x7FFF8000, 0xffffffffffffffff, 0x000000003fffffff},
+        {0xFFFF8000, 0x80008000, 0x7fffffffffffffff, 0x800000003fffffff},
+        {0xFFFF7fff, 0x00008000, 0x8000000000000000, 0x7fffffffc0008000},
+        {0x80007fff, 0x7FFF8000, 0xffffffffffffffff, 0xffffffffc0007fff},
+        {0x80007fff, 0x80008000, 0x7fffffffffffffff, 0x7fffffffc0007fff},
+        {0x0000ffff, 0x0000ffff, 0x8000000000000000, 0x8000000000000001},
+        {0x7FFFffff, 0x7FFFffff, 0xffffffffffffffff, 0x0000000000000000},
+        {0x8000ffff, 0x8000ffff, 0x7fffffffffffffff, 0x8000000000000000},
+        {0x0000ffff, 0x00018000, 0x8000000000000000, 0x8000000000008000},
+        {0x00008000, 0x0001ffff, 0xffffffffffffffff, 0x0000000000007fff},
+        {0x00008000, 0x0001ffff, 0x7fffffffffffffff, 0x8000000000007fff},
+        {0x00000000, 0xFFFFffff, 0x0000000000000000, 0x0000000000000000},
+        {0x7FFF0000, 0x8000ffff, 0xffffffffffffffff, 0xffffffffffffffff},
+        {0x8000ffff, 0xFFFF0000, 0x0000000000000000, 0x0000000000000000},
+        {0x0000ffff, 0xFFFF0000, 0xffffffffffffffff, 0xffffffffffffffff},
+        {0x7FFF0000, 0x80000000, 0x0000000000000000, 0x0000000000000000},
+        {0x80000000, 0x80000000, 0xffffffffffffffff, 0xffffffffffffffff},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulall_s16_e(ter64_sample[i].op1, ter64_sample[i].op2,
+                               ter64_sample[i].op3) == ter64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulall_s16_f.c b/tests/csky/ck803s-dsp/case/mulall_s16_f.c
new file mode 100644
index 0000000..b054a35
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulall_s16_f.c
@@ -0,0 +1,73 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      21
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULALL.S16.F \n");
+
+    /*
+     * MULALL.S16.F
+     * rz = (rx[15:0] * ry[15:0]) << 1 + rn, signed
+     */
+    struct ternary_calculation ter_sample[TEST_TIMES] = {
+        {0x00017fff, 0x00007fff, 0x80000000, 0xfffe0002},
+        {0x00017fff, 0x00007fff, 0xffffffff, 0x7ffe0001},
+        {0x00017fff, 0x00007fff, 0x7fffffff, 0xfffe0001},
+        {0xFFFF8000, 0x00008000, 0x80000000, 0x00000000},
+        {0x80008000, 0x7FFF8000, 0xffffffff, 0x7fffffff},
+        {0xFFFF8000, 0x80008000, 0x7fffffff, 0xffffffff},
+        {0xFFFFffff, 0x0000ffff, 0x80000000, 0x80000002},
+        {0x8000ffff, 0x7FFFffff, 0xffffffff, 0x00000001},
+        {0x8000ffff, 0x8000ffff, 0x7fffffff, 0x80000001},
+        {0x00007fff, 0x00008000, 0x80000000, 0x00010000},
+        {0x7FFF8000, 0x7FFF7fff, 0xffffffff, 0x8000ffff},
+        {0x80008000, 0x80007fff, 0x7fffffff, 0x0000ffff},
+        {0x0000ffff, 0x00018000, 0x80000000, 0x80010000},
+        {0x00008000, 0x0001ffff, 0xffffffff, 0x0000ffff},
+        {0x00008000, 0x0001ffff, 0x7fffffff, 0x8000ffff},
+        {0x00000000, 0xFFFFffff, 0x00000000, 0x00000000},
+        {0x7FFF0000, 0x8000ffff, 0xffffffff, 0xffffffff},
+        {0x8000ffff, 0xFFFF0000, 0x00000000, 0x00000000},
+        {0x0000ffff, 0xFFFF0000, 0xffffffff, 0xffffffff},
+        {0x7FFF0000, 0x80000000, 0x00000000, 0x00000000},
+        {0x80000000, 0x80000000, 0xffffffff, 0xffffffff},
+     };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulall_s16_f(ter_sample[i].op1, ter_sample[i].op2,
+                             ter_sample[i].op3) == ter_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulca_s16.c b/tests/csky/ck803s-dsp/case/mulca_s16.c
new file mode 100644
index 0000000..c5f9328
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulca_s16.c
@@ -0,0 +1,64 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      12
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULCA.S16 \n");
+
+    /*
+     * MULCA.S16
+     * rz = rx[15:0] * ry[15:0] + rx[31:16] * ry[31:16], signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010001, 0x00000001, 0x00000001},
+        {0x00010001, 0x00000001, 0x00000001},
+        {0x00010001, 0x00000001, 0x00000001},
+        {0x00010001, 0x0000FFFF, 0xFFFFFFFF},
+        {0x00010002, 0x7FFF8000, 0xFFFF7FFF},
+        {0x00017FFF, 0x8000FFFF, 0xFFFF0001},
+        {0x0001FFFF, 0x0000FFFF, 0x00000001},
+        {0x0001FFFF, 0x7FFF8000, 0x0000FFFF},
+        {0x00018000, 0x80008000, 0x3FFF8000},
+        {0x00010000, 0x00000000, 0x00000000},
+        {0x00010000, 0x7FFF7FFF, 0x00007FFF},
+        {0x00010000, 0x80008000, 0xFFFF8000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulca_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulca_s16_f.c b/tests/csky/ck803s-dsp/case/mulca_s16_f.c
new file mode 100644
index 0000000..278f507
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulca_s16_f.c
@@ -0,0 +1,65 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      12
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULCA.S16.F \n");
+
+    /*
+     * MULCA.S16.F
+     * rz = (rx[15:0] * ry[15:0] + rx[31:16] * ry[31:16]) << 1,
+     * signed & fraction
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010001, 0x00000001, 0x00000002},
+        {0x00010001, 0x00000001, 0x00000002},
+        {0x00010001, 0x00000001, 0x00000002},
+        {0x00010001, 0x0000FFFF, 0xFFFFFFFE},
+        {0x00010002, 0x7FFF8000, 0xFFFEFFFE},
+        {0x00017FFF, 0x8000FFFF, 0xFFFE0002},
+        {0x0001FFFF, 0x0000FFFF, 0x00000002},
+        {0x0001FFFF, 0x7FFF8000, 0x0001FFFE},
+        {0x00018000, 0x80008000, 0x7FFF0000},
+        {0x00010000, 0x00000000, 0x00000000},
+        {0x00010000, 0x7FFF7FFF, 0x0000FFFE},
+        {0x00010000, 0x80008000, 0xFFFF0000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulca_s16_f(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulcax_s16.c b/tests/csky/ck803s-dsp/case/mulcax_s16.c
new file mode 100644
index 0000000..000b3ee
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulcax_s16.c
@@ -0,0 +1,64 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      12
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULCAX.S16 \n");
+
+    /*
+     * MULCAX.S16
+     * rz = rx[31:16] * ry[15:0] + rx[15:0] * ry[31:16], signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010001, 0x00010000, 0x00000001},
+        {0x00010001, 0x00010000, 0x00000001},
+        {0x00010001, 0x00010000, 0x00000001},
+        {0x00010001, 0xFFFF0000, 0xFFFFFFFF},
+        {0x00010002, 0x80007FFF, 0xFFFF7FFF},
+        {0x00017FFF, 0xFFFF8000, 0xFFFF0001},
+        {0x0001FFFF, 0xFFFF0000, 0x00000001},
+        {0x0001FFFF, 0x80007FFF, 0x0000FFFF},
+        {0x00018000, 0x80008000, 0x3FFF8000},
+        {0x00010000, 0x00000000, 0x00000000},
+        {0x00010000, 0x7FFF7FFF, 0x00007FFF},
+        {0x00010000, 0x80008000, 0xFFFF8000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulcax_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulcax_s16_f.c b/tests/csky/ck803s-dsp/case/mulcax_s16_f.c
new file mode 100644
index 0000000..c404d8d
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulcax_s16_f.c
@@ -0,0 +1,65 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      12
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULCAX.S16.F \n");
+
+    /*
+     * MULCAX.S16.F
+     * rz = (rx[31:16] * ry[15:0] + rx[15:0] * ry[31:16]) << 1,
+     * signed & fraction
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010001, 0x00010000, 0x00000002},
+        {0x00010001, 0x00010000, 0x00000002},
+        {0x00010001, 0x00010000, 0x00000002},
+        {0x00010001, 0xFFFF0000, 0xFFFFFFFE},
+        {0x00010002, 0x80007FFF, 0xFFFEFFFE},
+        {0x00017FFF, 0xFFFF8000, 0xFFFE0002},
+        {0x0001FFFF, 0xFFFF0000, 0x00000002},
+        {0x0001FFFF, 0x80007FFF, 0x0001FFFE},
+        {0x00018000, 0x80008000, 0x7FFF0000},
+        {0x00010000, 0x00000000, 0x00000000},
+        {0x00010000, 0x7FFF7FFF, 0x0000FFFE},
+        {0x00010000, 0x80008000, 0xFFFF0000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulcax_s16_f(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulcs_s16.c b/tests/csky/ck803s-dsp/case/mulcs_s16.c
new file mode 100644
index 0000000..c70a800
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulcs_s16.c
@@ -0,0 +1,64 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      12
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULCS.S16 \n");
+
+    /*
+     * MULCS.S16
+     * rz = rx[15:0] * ry[15:0] - rx[31:16] * ry[31:16], signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010001, 0x00000001, 0x00000001},
+        {0x00010001, 0x7FFF7FFF, 0x00000000},
+        {0x00010010, 0x80007FFF, 0x00087FF0},
+        {0x00010001, 0x0000FFFF, 0xFFFFFFFF},
+        {0x00010002, 0x7FFF8000, 0xFFFE8001},
+        {0x00017FFF, 0x8000FFFF, 0x00000001},
+        {0x0001FFFF, 0x0000FFFF, 0x00000001},
+        {0x0001FFFF, 0x7FFF8000, 0x00000001},
+        {0x00018000, 0x80008000, 0x40008000},
+        {0x00010000, 0x00000000, 0x00000000},
+        {0x00010000, 0x7FFF7FFF, 0xFFFF8001},
+        {0x00010000, 0x80008000, 0x00008000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulcs_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulcs_s16_f.c b/tests/csky/ck803s-dsp/case/mulcs_s16_f.c
new file mode 100644
index 0000000..2d94982
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulcs_s16_f.c
@@ -0,0 +1,65 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      12
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULCS.S16.F \n");
+
+    /*
+     * MULCS.S16.F
+     * rz = (rx[15:0] * ry[15:0] - rx[31:16] * ry[31:16]) << 1,
+     * signed & fraction
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010001, 0x00000001, 0x00000002},
+        {0x00010001, 0x7FFF7FFF, 0x00000000},
+        {0x00010010, 0x80007FFF, 0x0010FFE0},
+        {0x00010001, 0x0000FFFF, 0xFFFFFFFE},
+        {0x00010002, 0x7FFF8000, 0xFFFD0002},
+        {0x00017FFF, 0x8000FFFF, 0x00000002},
+        {0x0001FFFF, 0x0000FFFF, 0x00000002},
+        {0x0001FFFF, 0x7FFF8000, 0x00000002},
+        {0x00018000, 0x80008000, 0x80010000},
+        {0x00010000, 0x00000000, 0x00000000},
+        {0x00010000, 0x7FFF7FFF, 0xFFFF0002},
+        {0x00010000, 0x80008000, 0x00010000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulcs_s16_f(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulcsx_s16.c b/tests/csky/ck803s-dsp/case/mulcsx_s16.c
new file mode 100644
index 0000000..3b38d13
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulcsx_s16.c
@@ -0,0 +1,64 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      12
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULCSX.S16 \n");
+
+    /*
+     * MULCSX.S16
+     * rz = rx[15:0] * ry[31:16] - rx[31:16] * ry[15:0], signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010001, 0x00010000, 0x00000001},
+        {0x00010001, 0x7FFF7FFF, 0x00000000},
+        {0x00010010, 0x7FFF8000, 0x00087FF0},
+        {0x00010001, 0xFFFF0000, 0xFFFFFFFF},
+        {0x00010002, 0x80007FFF, 0xFFFE8001},
+        {0x00017FFF, 0xFFFF8000, 0x00000001},
+        {0x0001FFFF, 0xFFFF0000, 0x00000001},
+        {0x0001FFFF, 0x80007FFF, 0x00000001},
+        {0x00018000, 0x80008000, 0x40008000},
+        {0x00010000, 0x00000000, 0x00000000},
+        {0x00010000, 0x7FFF7FFF, 0xFFFF8001},
+        {0x00010000, 0x80008000, 0x00008000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulcsx_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulcsx_s16_f.c b/tests/csky/ck803s-dsp/case/mulcsx_s16_f.c
new file mode 100644
index 0000000..8d084c7
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulcsx_s16_f.c
@@ -0,0 +1,65 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      12
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULCSX.S16.F \n");
+
+    /*
+     * MULCSX.S16.F
+     * rz = (rx[15:0] * ry[31:16] - rx[31:16] * ry[15:0]) << 1,
+     * signed & fraction
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010001, 0x00010000, 0x00000002},
+        {0x00010001, 0x7FFF7FFF, 0x00000000},
+        {0x00010010, 0x7FFF8000, 0x0010FFE0},
+        {0x00010001, 0xFFFF0000, 0xFFFFFFFE},
+        {0x00010002, 0x80007FFF, 0xFFFD0002},
+        {0x00017FFF, 0xFFFF8000, 0x00000002},
+        {0x0001FFFF, 0xFFFF0000, 0x00000002},
+        {0x0001FFFF, 0x80007FFF, 0x00000002},
+        {0x00018000, 0x80008000, 0x80010000},
+        {0x00010000, 0x00000000, 0x00000000},
+        {0x00010000, 0x7FFF7FFF, 0xFFFF0002},
+        {0x00010000, 0x80008000, 0x00010000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulcsx_s16_f(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulhh_s16.c b/tests/csky/ck803s-dsp/case/mulhh_s16.c
new file mode 100644
index 0000000..e962a90
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulhh_s16.c
@@ -0,0 +1,60 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      8
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULHH.S16 \n");
+
+    /*
+     * MULHH.S16
+     * rz = rx[31:16] * ry[31:16], signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010000, 0x00010000, 0x00000001},
+        {0x00010000, 0x7FFF7FFF, 0x00007FFF},
+        {0x00010000, 0xFFFFFFFF, 0xFFFFFFFF},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000001},
+        {0x80000000, 0x80008000, 0x40000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0xFFFF7FFF, 0x00000000},
+        {0x80000000, 0x80000000, 0x40000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulhh_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulhh_s16_f.c b/tests/csky/ck803s-dsp/case/mulhh_s16_f.c
new file mode 100644
index 0000000..804eed5
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulhh_s16_f.c
@@ -0,0 +1,60 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      8
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULHH.S16_F \n");
+
+    /*
+     * MULHH.S16.F
+     * rz = rx[15:0] * ry[15:0] << 1, signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010000, 0x00010000, 0x00000002},
+        {0x00010000, 0x7FFF7FFF, 0x0000FFFE},
+        {0x00010000, 0xFFFFFFFF, 0xFFFFFFFE},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000002},
+        {0x80000000, 0x80008000, 0x80000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0xFFFF7FFF, 0x00000000},
+        {0x00008000, 0x80000000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulhh_s16_f(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulhl_s16.c b/tests/csky/ck803s-dsp/case/mulhl_s16.c
new file mode 100644
index 0000000..e99f52e
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulhl_s16.c
@@ -0,0 +1,60 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      8
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULHL.S16 \n");
+
+    /*
+     * MULHL.S16
+     * rz = rx[31:16] * ry[15:0], signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010000, 0x00000001, 0x00000001},
+        {0x00010000, 0x7FFF7FFF, 0x00007FFF},
+        {0x00010000, 0xFFFFFFFF, 0xFFFFFFFF},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000001},
+        {0x80000000, 0x80008000, 0x40000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x00000000},
+        {0x80000000, 0x00008000, 0x40000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulhl_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulhl_s16_f.c b/tests/csky/ck803s-dsp/case/mulhl_s16_f.c
new file mode 100644
index 0000000..f4b3c95
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulhl_s16_f.c
@@ -0,0 +1,60 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      8
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULHL.S16_F \n");
+
+    /*
+     * MULHL.S16.F
+     * rz = rx[15:0] * ry[15:0] << 1, signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00010000, 0x00000001, 0x00000002},
+        {0x00010000, 0x7FFF7FFF, 0x0000FFFE},
+        {0x00010000, 0xFFFFFFFF, 0xFFFFFFFE},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000002},
+        {0x80000000, 0x80008000, 0x80000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x00000000},
+        {0x00008000, 0x00008000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulhl_s16_f(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulll_s16.c b/tests/csky/ck803s-dsp/case/mulll_s16.c
new file mode 100644
index 0000000..d92dba8
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulll_s16.c
@@ -0,0 +1,60 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      8
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULLL.S16 \n");
+
+    /*
+     * MULLL.S16
+     * rz = rx[15:0] * ry[15:0], signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000001},
+        {0x00000001, 0x7FFF7FFF, 0x00007FFF},
+        {0x00000001, 0xFFFFFFFF, 0xFFFFFFFF},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000001},
+        {0x00008000, 0x80008000, 0x40000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x00000000},
+        {0x80000000, 0x00008000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulll_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/mulll_s16_f.c b/tests/csky/ck803s-dsp/case/mulll_s16_f.c
new file mode 100644
index 0000000..a44a255
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/mulll_s16_f.c
@@ -0,0 +1,60 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      8
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULLL.S16_F \n");
+
+    /*
+     * MULLL.S16.F
+     * rz = rx[15:0] * ry[15:0] << 1, signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000002},
+        {0x00000001, 0x7FFF7FFF, 0x0000FFFE},
+        {0x00000001, 0xFFFFFFFF, 0xFFFFFFFE},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000002},
+        {0x00008000, 0x80008000, 0x80000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x00000000},
+        {0x80000000, 0x00008000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_mulll_s16_f(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/muls_32_l.c b/tests/csky/ck803s-dsp/case/muls_32_l.c
new file mode 100644
index 0000000..e5b9c7f
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/muls_32_l.c
@@ -0,0 +1,68 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      16
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULS.32.L \n");
+
+    /*
+     * MULS.32.L
+     * rz = rn - rx * ry
+     */
+    struct ternary_calculation ter_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000001, 0x00000000},
+        {0x00000001, 0x00000001, 0x00000000, 0xFFFFFFFF},
+        {0x00000001, 0x80000000, 0x00000000, 0x80000000},
+        {0x00000001, 0x80000000, 0x00000001, 0x80000001},
+        {0x00000001, 0xFFFFFFFF, 0x00000001, 0x00000002},
+        {0x00000001, 0xFFFFFFFF, 0x00000000, 0x00000001},
+        {0x00000001, 0x00000001, 0x80000000, 0x7FFFFFFF},
+        {0x00000001, 0xFFFFFFFF, 0x80000000, 0x80000001},
+        {0x80000000, 0x80000000, 0x00000000, 0x00000000},
+        {0x80000000, 0xFFFFFFFF, 0x00000000, 0x80000000},
+        {0x80000000, 0xFFFFFFFF, 0x00000001, 0x80000001},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF},
+        {0x00000100, 0x7FFFFFFF, 0x80000000, 0x80000100},
+        {0x00000000, 0xFFFFFFFF, 0x00000000, 0x00000000},
+        {0xFFFFFFFF, 0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0xFFFFFFFF, 0x00000001, 0x00000001},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_muls_32_l(ter_sample[i].op1, ter_sample[i].op2,
+                            ter_sample[i].op3) == ter_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/muls_32_lf.c b/tests/csky/ck803s-dsp/case/muls_32_lf.c
new file mode 100644
index 0000000..c14a6c0
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/muls_32_lf.c
@@ -0,0 +1,68 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      16
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULS.32.LF \n");
+
+    /*
+     * MULS.32.LF
+     * rz = rn - (rx * ry){31:0} << 1, fraction
+     */
+    struct ternary_calculation ter_sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000001, 0xFFFFFFFF},
+        {0x00000001, 0x00000001, 0x00000000, 0xFFFFFFFE},
+        {0x00000001, 0x80000000, 0x00000000, 0x00000000},
+        {0x00000001, 0x80000000, 0x00000001, 0x00000001},
+        {0x00000001, 0xFFFFFFFF, 0x00000001, 0x00000003},
+        {0x00000001, 0xFFFFFFFF, 0x00000000, 0x00000002},
+        {0x00000001, 0x00000001, 0x80000000, 0x7FFFFFFE},
+        {0x00000001, 0xFFFFFFFF, 0x80000000, 0x80000002},
+        {0x80000000, 0x80000000, 0x00000000, 0x00000000},
+        {0x80000000, 0xFFFFFFFF, 0x00000000, 0x00000000},
+        {0x80000000, 0xFFFFFFFF, 0x00000001, 0x00000001},
+        {0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFE},
+        {0x00000100, 0x7FFFFFFF, 0x80000000, 0x80000200},
+        {0x00000000, 0xFFFFFFFF, 0x00000000, 0x00000000},
+        {0xFFFFFFFF, 0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0xFFFFFFFF, 0x00000001, 0x00000001},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_muls_32_lf(ter_sample[i].op1, ter_sample[i].op2,
+                            ter_sample[i].op3) == ter_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/muls_s32_h.c b/tests/csky/ck803s-dsp/case/muls_s32_h.c
new file mode 100644
index 0000000..6b648e8
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/muls_s32_h.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      15
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULS.S32.H \n");
+
+    /*
+     * MULS.S32.H
+     * rz = {{rz,32'b0} - (rx * ry)}[63:32], signed
+     */
+    struct ternary_calculation sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000000, 0xffffffff},
+        {0x00000001, 0x00000001, 0xffffffff, 0xfffffffe},
+        {0x00000001, 0x00000001, 0x80000000, 0x7fffffff},
+        {0x00000001, 0x00000001, 0x7fffffff, 0x7ffffffe},
+        {0x00000001, 0xffffffff, 0xffffffff, 0xffffffff},
+        {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+        {0x00000001, 0xffffffff, 0x7fffffff, 0x7fffffff},
+        {0x80000000, 0x80000000, 0xffffffff, 0xbfffffff},
+        {0x80000000, 0x80000000, 0x80000000, 0x40000000},
+        {0x80000000, 0x80000000, 0x7fffffff, 0x3fffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff},
+        {0x7fffffff, 0xffffffff, 0x80000000, 0x80000000},
+        {0x7fffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+        {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_muls_s32_h(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
diff --git a/tests/csky/ck803s-dsp/case/muls_s32_rh.c b/tests/csky/ck803s-dsp/case/muls_s32_rh.c
new file mode 100644
index 0000000..cd96df3
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/muls_s32_rh.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      15
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULS.S32.RH \n");
+
+    /*
+     * MULS.S32.RH
+     * rz = {{rz,32'b0} - (rx * ry) + 0x80000000}[63:32], signed
+     */
+    struct ternary_calculation sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000001, 0xffffffff, 0xffffffff},
+        {0x00000001, 0x00000001, 0x80000000, 0x80000000},
+        {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+        {0x00000001, 0xffffffff, 0xffffffff, 0xffffffff},
+        {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+        {0x00000001, 0xffffffff, 0x7fffffff, 0x7fffffff},
+        {0x80000000, 0x80000000, 0xffffffff, 0xbfffffff},
+        {0x80000000, 0x80000000, 0x80000000, 0x40000000},
+        {0x80000000, 0x80000000, 0x7fffffff, 0x3fffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff},
+        {0x7fffffff, 0xffffffff, 0x80000000, 0x80000000},
+        {0x7fffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+        {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_muls_s32_rh(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
diff --git a/tests/csky/ck803s-dsp/case/muls_u32_h.c b/tests/csky/ck803s-dsp/case/muls_u32_h.c
new file mode 100644
index 0000000..1743973
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/muls_u32_h.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      15
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULS.U32.H \n");
+
+    /*
+     * MULS.U32.H
+     * rz = {{rz,32'b0} - (rx * ry)}[63:32], unsigned
+     */
+    struct ternary_calculation sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000000, 0xffffffff},
+        {0x00000001, 0x00000001, 0xffffffff, 0xfffffffe},
+        {0x00000001, 0x00000001, 0x80000000, 0x7fffffff},
+        {0x00000001, 0x00000001, 0x7fffffff, 0x7ffffffe},
+        {0x00000001, 0xffffffff, 0xffffffff, 0xfffffffe},
+        {0x00000001, 0xffffffff, 0x80000000, 0x7fffffff},
+        {0x00000001, 0xffffffff, 0x7fffffff, 0x7ffffffe},
+        {0x80000000, 0x80000000, 0xffffffff, 0xbfffffff},
+        {0x80000000, 0x80000000, 0x80000000, 0x40000000},
+        {0x80000000, 0x80000000, 0x7fffffff, 0x3fffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffff, 0x80000000},
+        {0x7fffffff, 0xffffffff, 0x80000000, 0x00000001},
+        {0x7fffffff, 0xffffffff, 0x7fffffff, 0x00000000},
+        {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_muls_u32_h(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
diff --git a/tests/csky/ck803s-dsp/case/muls_u32_rh.c b/tests/csky/ck803s-dsp/case/muls_u32_rh.c
new file mode 100644
index 0000000..a819e0e
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/muls_u32_rh.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      15
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn MULS.U32.RH \n");
+
+    /*
+     * MULS.U32.RH
+     * rz = {{rz,32'b0} - (rx * ry) + 0x80000000}[63:32], unsigned
+     */
+    struct ternary_calculation sample[TEST_TIMES] = {
+        {0x00000001, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000001, 0xffffffff, 0xffffffff},
+        {0x00000001, 0x00000001, 0x80000000, 0x80000000},
+        {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+        {0x00000001, 0xffffffff, 0xffffffff, 0xfffffffe},
+        {0x00000001, 0xffffffff, 0x80000000, 0x7fffffff},
+        {0x00000001, 0xffffffff, 0x7fffffff, 0x7ffffffe},
+        {0x80000000, 0x80000000, 0xffffffff, 0xbfffffff},
+        {0x80000000, 0x80000000, 0x80000000, 0x40000000},
+        {0x80000000, 0x80000000, 0x7fffffff, 0x3fffffff},
+        {0x7fffffff, 0xffffffff, 0xffffffff, 0x80000000},
+        {0x7fffffff, 0xffffffff, 0x80000000, 0x00000001},
+        {0x7fffffff, 0xffffffff, 0x7fffffff, 0x00000000},
+        {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+        {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_muls_u32_rh(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
diff --git a/tests/csky/ck803s-dsp/case/pabs_s16_s.c b/tests/csky/ck803s-dsp/case/pabs_s16_s.c
new file mode 100644
index 0000000..aa5ef6f
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pabs_s16_s.c
@@ -0,0 +1,56 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      5
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PABS.S16.S \n");
+
+    /*
+     * PABS.S16.S
+     * rz[15:0] = | rx[15:0] |, rz[31:16] = | rx[31:16] |, signed
+     */
+    struct unary_calculation un_sample[TEST_TIMES] = {
+        {0X00000000, 0x00000000},
+        {0X0001FFFF, 0x00010001},
+        {0XFFFF0001, 0x00010001},
+        {0X7FFF8000, 0x7fff7fff},
+        {0X80017FFF, 0x7fff7fff},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pabs_s16_s(un_sample[i].op1)
+                     == un_sample[i].result);
+    }
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/padd_s16.c b/tests/csky/ck803s-dsp/case/padd_s16.c
new file mode 100644
index 0000000..24a72fb
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/padd_s16.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      14
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PADD.S16 \n");
+
+    /*
+     * PADD.S16
+     * rz = {(hi_x + hi_y)[15:0], (lo_x + lo_y)[15:0]}, signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x56785678, 0x12341234, 0x68ac68ac},
+        {0x12345678, 0x12345678, 0x2468acf0},
+        {0x12349876, 0x9090a0a0, 0xa2c43916},
+        {0xffffffff, 0x11111111, 0x11101110},
+        {0X00000000, 0X00000000, 0x00000000},
+        {0X00000001, 0X00010000, 0x00010001},
+        {0X00010001, 0X00010001, 0x00020002},
+        {0XFFFF0001, 0X0001FFFF, 0x00000000},
+        {0XFFFFFFFF, 0XFFFF0000, 0xfffeffff},
+        {0X0000FFFF, 0XFFFFFFFF, 0xfffffffe},
+        {0X60003000, 0X30006000, 0x90009000},
+        {0X80018001, 0X80000001, 0x00018002},
+        {0X7FFF8000, 0X7FFF8000, 0xfffe0000},
+        {0X7FFF8000, 0X80007FFF, 0xffffffff},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_padd_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/padd_s16_s.c b/tests/csky/ck803s-dsp/case/padd_s16_s.c
new file mode 100644
index 0000000..f18e704
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/padd_s16_s.c
@@ -0,0 +1,67 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      14
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PADD.S16.S \n");
+
+    /*
+     * PADD.S16.S
+     * rz[15:0] = rx[15:0] + ry[15:0],
+     * rz[31:16] = rx[31:16] + ry[31:16], signed & saturated
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x56785678, 0x12341234, 0x68ac68ac},
+        {0x12345678, 0x12345678, 0x24687fff},
+        {0x12349876, 0x9090a0a0, 0xa2c48000},
+        {0xffffffff, 0x11111111, 0x11101110},
+        {0X00000000, 0X00000000, 0x00000000},
+        {0X00000001, 0X00010000, 0x00010001},
+        {0X00010001, 0X00010001, 0x00020002},
+        {0XFFFF0001, 0X0001FFFF, 0x00000000},
+        {0XFFFFFFFF, 0XFFFF0000, 0xfffeffff},
+        {0X0000FFFF, 0XFFFFFFFF, 0xfffffffe},
+        {0X60003000, 0X30006000, 0x7fff7fff},
+        {0X80018001, 0X80000001, 0x80008002},
+        {0X7FFF8000, 0X7FFF8000, 0x7fff8000},
+        {0X7FFF8000, 0X80007FFF, 0xffffffff},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_padd_s16_s(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/paddh_s16.c b/tests/csky/ck803s-dsp/case/paddh_s16.c
new file mode 100644
index 0000000..deabd85
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/paddh_s16.c
@@ -0,0 +1,67 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      14
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PADDH.S16 \n");
+
+    /*
+     * PADDH.S16
+     * rz[15:0] = (rx[15:0] + ry[15:0])/2,
+     * rz[31:16] = (rx[31:16] + ry[31:16])/2, signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x56785678, 0xc000b000, 0x0b3c033c},
+        {0x12345678, 0x12345678, 0x1234d678},
+        {0x8080c0c0, 0x9090a0a0, 0x088830b0},
+        {0xf0007fff, 0x90000001, 0xc000c000},
+        {0X00000000, 0X00000000, 0x00000000},
+        {0X00000001, 0X00010000, 0x00000000},
+        {0X00010001, 0X00010001, 0x00010001},
+        {0XFFFF0001, 0X0001FFFF, 0x00000000},
+        {0XFFFFFFFF, 0XFFFF0000, 0xffff0000},
+        {0X0000FFFF, 0XFFFFFFFF, 0x0000ffff},
+        {0X60003000, 0X30006000, 0xc800c800},
+        {0X80018001, 0X80000001, 0x0000c001},
+        {0X7FFF8000, 0X7FFF8000, 0xffff0000},
+        {0X7FFF8000, 0X80007FFF, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_paddh_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/paddx_s32.c b/tests/csky/ck803s-dsp/case/paddx_s32.c
new file mode 100644
index 0000000..f198528
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/paddx_s32.c
@@ -0,0 +1,58 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      6
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PADDX.S32 \n");
+
+    /*
+     * PADDX.S32
+     * rz = rx + lo_ry, r(z+1) = rn + hi_ry, signed
+     */
+    struct ternary64_calculation ter64_sample[TEST_TIMES] = {
+        {0X00000000, 0X00000000, 0X00000000, 0x0000000000000000},
+        {0XFFFFFFFF, 0X00000000, 0X00000001, 0x00000001ffffffff},
+        {0X00000001, 0XFFFF0001, 0XFFFFFFFF, 0xfffffffe00000002},
+        {0XFFFFFFFF, 0XFFFF0001, 0X00000001, 0x0000000000000000},
+        {0X7FFFFFFF, 0XFFFF0001, 0X80000000, 0x7fffffff80000000},
+        {0X80000000, 0X0001FFFF, 0X7FFFFFFF, 0x800000007fffffff},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_paddx_s32(ter64_sample[i].op1, ter64_sample[i].op2,
+                           ter64_sample[i].op3) == ter64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pasri_16.c b/tests/csky/ck803s-dsp/case/pasri_16.c
new file mode 100644
index 0000000..2b7fd87
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pasri_16.c
@@ -0,0 +1,53 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      4
+int main(void)
+{
+    init_testsuite("Testing insn PASRI.16 \n");
+
+    /*
+     * PASRI.16
+     * rz = {rx[31:16] << imm4, rx[15:0] << imm4, arithmetic shift
+     */
+    struct unary_calculation sample[TEST_TIMES] = {
+        {0Xffff0000, 0xffff0000}, /* imm = 0 */
+        {0X12345678, 0x091A2B3C}, /* imm = 1 */
+        {0X0001ffff, 0x0000ffff}, /* imm = 9 */
+        {0X80007fff, 0xffff0000}, /* imm = 15 */
+    };
+
+    TEST(test_pasri_16_0(sample[0].op1) == sample[0].result);
+    TEST(test_pasri_16_1(sample[1].op1) == sample[1].result);
+    TEST(test_pasri_16_9(sample[2].op1) == sample[2].result);
+    TEST(test_pasri_16_15(sample[3].op1) == sample[3].result);
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pasri_32.c b/tests/csky/ck803s-dsp/case/pasri_32.c
new file mode 100644
index 0000000..fbe8693
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pasri_32.c
@@ -0,0 +1,53 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      4
+int main(void)
+{
+    init_testsuite("Testing insn PASRI.32 \n");
+
+    /*
+     * PASRI.32
+     * rz = rx >> imm5, r(z+1) = r(x+1) >> imm5 arithmetic shift
+     */
+    struct binary64_calculation sample[TEST_TIMES] = {
+        {0Xffffffff, 0X00000000, 0x00000000ffffffff}, /* imm = 0 */
+        {0X12345678, 0X00000001, 0x00000000091A2B3C}, /* imm = 1 */
+        {0Xffffffff, 0X7fffffff, 0x000007ffffffffff}, /* imm = 20 */
+        {0X80000000, 0X7fffffff, 0x00000000ffffffff}, /* imm = 31 */
+    };
+
+    TEST(test_pasri_32_0(sample[0].op1, sample[0].op2) == sample[0].result);
+    TEST(test_pasri_32_1(sample[1].op1, sample[1].op2) == sample[1].result);
+    TEST(test_pasri_32_20(sample[2].op1, sample[2].op2) == sample[2].result);
+    TEST(test_pasri_32_31(sample[3].op1, sample[3].op2) == sample[3].result);
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pkg.c b/tests/csky/ck803s-dsp/case/pkg.c
new file mode 100644
index 0000000..bbd4d99
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pkg.c
@@ -0,0 +1,57 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      4
+int main(void)
+{
+    init_testsuite("Testing insn PKG \n");
+
+    /*
+     * PKG
+     * rz = {(ry >> oimm4)[15:0], (rx >> imm4)[15:0], logical shift
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0Xffff0000, 0X0000ffff, 0x00000000}, /* imm = 0,  oimm = 16 */
+        {0X00007fff, 0X0001fffe, 0xffff0000}, /* imm = 15, oimm = 1  */
+        {0Xffff0000, 0X0000ffff, 0x7fff0000}, /* imm = 0,  oimm = 1  */
+        {0X00007fff, 0X0001fffe, 0x00010000}, /* imm = 15, oimm = 16 */
+    };
+
+    TEST(test_pkg_0_16(bin_sample[0].op1, bin_sample[0].op2)
+         == bin_sample[0].result);
+    TEST(test_pkg_15_1(bin_sample[1].op1, bin_sample[1].op2)
+         == bin_sample[1].result);
+    TEST(test_pkg_0_1(bin_sample[2].op1, bin_sample[2].op2)
+         == bin_sample[2].result);
+    TEST(test_pkg_15_16(bin_sample[3].op1, bin_sample[3].op2)
+         == bin_sample[3].result);
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pkghh.c b/tests/csky/ck803s-dsp/case/pkghh.c
new file mode 100644
index 0000000..48cda0b
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pkghh.c
@@ -0,0 +1,54 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      2
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PKGHH \n");
+
+    /*
+     * PKGHH
+     * rz = {ry[31:16], rx[31:16]}
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0X0000ffff, 0Xffff0000, 0xffff0000},
+        {0Xffff0000, 0X0000ffff, 0x0000ffff},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pkghh(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pkgll.c b/tests/csky/ck803s-dsp/case/pkgll.c
new file mode 100644
index 0000000..0598747
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pkgll.c
@@ -0,0 +1,54 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      2
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PKGLL \n");
+
+    /*
+     * PKGLL
+     * rz = {ry[15:0], rx[15:0]}
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0X0000ffff, 0Xffff0000, 0x0000ffff},
+        {0Xffff0000, 0X0000ffff, 0xffff0000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pkgll(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/plsli_16.c b/tests/csky/ck803s-dsp/case/plsli_16.c
new file mode 100644
index 0000000..0be7e1e
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/plsli_16.c
@@ -0,0 +1,53 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      4
+int main(void)
+{
+    init_testsuite("Testing insn PLSLI.16 \n");
+
+    /*
+     * PLSLI.16
+     * rz = {rx[31:16] << imm4, rx[15:0] << imm4
+     */
+    struct unary_calculation sample[TEST_TIMES] = {
+        {0Xffff0000, 0xffff0000}, /* imm = 0 */
+        {0X12345678, 0x2468ACF0}, /* imm = 1 */
+        {0X0001ffff, 0x0200fe00}, /* imm = 9 */
+        {0X80007fff, 0x00008000}, /* imm = 15 */
+    };
+
+    TEST(test_plsli_16_0(sample[0].op1) == sample[0].result);
+    TEST(test_plsli_16_1(sample[1].op1) == sample[1].result);
+    TEST(test_plsli_16_9(sample[2].op1) == sample[2].result);
+    TEST(test_plsli_16_15(sample[3].op1) == sample[3].result);
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/plsli_32.c b/tests/csky/ck803s-dsp/case/plsli_32.c
new file mode 100644
index 0000000..4e17cab
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/plsli_32.c
@@ -0,0 +1,53 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      4
+int main(void)
+{
+    init_testsuite("Testing insn PLSLI.32 \n");
+
+    /*
+     * PLSLI.32
+     * rz = rx << imm5, r(z+1) = r(x+1) << imm5
+     */
+    struct binary64_calculation sample[TEST_TIMES] = {
+        {0Xffffffff, 0X00000000, 0x00000000ffffffff}, /* imm = 0 */
+        {0X12345678, 0X00000001, 0x000000022468ACF0}, /* imm = 1 */
+        {0Xffffffff, 0X7fffffff, 0xfff00000fff00000}, /* imm = 20 */
+        {0X80000000, 0X7fffffff, 0x8000000000000000}, /* imm = 31 */
+    };
+
+    TEST(test_plsli_32_0(sample[0].op1, sample[0].op2) == sample[0].result);
+    TEST(test_plsli_32_1(sample[1].op1, sample[1].op2) == sample[1].result);
+    TEST(test_plsli_32_20(sample[2].op1, sample[2].op2) == sample[2].result);
+    TEST(test_plsli_32_31(sample[3].op1, sample[3].op2) == sample[3].result);
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmax_s16.c b/tests/csky/ck803s-dsp/case/pmax_s16.c
new file mode 100644
index 0000000..b3d9bb1
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmax_s16.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMAX.S16 \n");
+
+    /*
+     * PMAX.S16
+     * rz = {max(rx[31:16], ry[31:16], max(rx[15:0], ry[15:0])}, signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x80008000, 0x80007FFF, 0x80007FFF},
+        {0x80008000, 0x00000000, 0x00000000},
+        {0x80008000, 0x7FFF8000, 0x7FFF8000},
+        {0x00000000, 0x80007FFF, 0x00007FFF},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFF8000, 0x7FFF0000},
+        {0x7FFF7FFF, 0x80007FFF, 0x7FFF7FFF},
+        {0x7FFF7FFF, 0x00000000, 0x7FFF7FFF},
+        {0x7FFF7FFF, 0x7FFF8000, 0x7FFF7FFF},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmax_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmax_u16.c b/tests/csky/ck803s-dsp/case/pmax_u16.c
new file mode 100644
index 0000000..75c4c09
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmax_u16.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMAX.U16 \n");
+
+    /*
+     * PMAX.U16
+     * rz = {max(rx[31:16], ry[31:16], max(rx[15:0], ry[15:0])}, unsigned
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0xFFFFFFFF, 0xFFFF7FFF, 0xFFFFFFFF},
+        {0xFFFFFFFF, 0x00000000, 0xFFFFFFFF},
+        {0xFFFFFFFF, 0x7FFFFFFF, 0xFFFFFFFF},
+        {0x00000000, 0xFFFF7FFF, 0xFFFF7FFF},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x7FFFFFFF},
+        {0x7FFFFFFF, 0xFFFF7FFF, 0xFFFFFFFF},
+        {0x7FFFFFFF, 0x00000000, 0x7FFFFFFF},
+        {0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmax_u16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmin_s16.c b/tests/csky/ck803s-dsp/case/pmin_s16.c
new file mode 100644
index 0000000..ff7982a
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmin_s16.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMIN.S16 \n");
+
+    /*
+     * PMIN.S16
+     * rz = {MIN(rx[31:16], ry[31:16], MIN(rx[15:0], ry[15:0])}, signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0x80008000, 0x80007FFF, 0x80008000},
+        {0x80008000, 0x00000000, 0x80008000},
+        {0x80008000, 0x7FFF8000, 0x80008000},
+        {0x00000000, 0x80007FFF, 0x80000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFF8000, 0x00008000},
+        {0x7FFF7FFF, 0x80007FFF, 0x80007FFF},
+        {0x7FFF7FFF, 0x00000000, 0x00000000},
+        {0x7FFF7FFF, 0x7FFF8000, 0x7FFF8000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmin_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmin_u16.c b/tests/csky/ck803s-dsp/case/pmin_u16.c
new file mode 100644
index 0000000..ce8217f
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmin_u16.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMIN.U16 \n");
+
+    /*
+     * PMIN.U16
+     * rz = {MIN(rx[31:16], ry[31:16], MIN(rx[15:0], ry[15:0])}, unsigned
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0xFFFFFFFF, 0xFFFF7FFF, 0xFFFF7FFF},
+        {0xFFFFFFFF, 0x00000000, 0x00000000},
+        {0xFFFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF},
+        {0x00000000, 0xFFFF7FFF, 0x00000000},
+        {0x00000000, 0x00000000, 0x00000000},
+        {0x00000000, 0x7FFFFFFF, 0x00000000},
+        {0x7FFFFFFF, 0xFFFF7FFF, 0x7FFF7FFF},
+        {0x7FFFFFFF, 0x00000000, 0x00000000},
+        {0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmin_u16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmul_s16.c b/tests/csky/ck803s-dsp/case/pmul_s16.c
new file mode 100644
index 0000000..cee5eb8
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmul_s16.c
@@ -0,0 +1,63 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      11
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMUL.S16 \n");
+
+    /*
+     * PMUL.S16
+     * rz = lo_x * lo_y, rn = hi_x * hi_y, signed
+     */
+    struct binary64_calculation bin64_sample[TEST_TIMES] = {
+        {0x56785678, 0xc000b000, 0xea620000e4fa8000},
+        {0x12345678, 0x12345678, 0x014b5a901d34d840},
+        {0x8080c0c0, 0x9090a0a0, 0x3780480017907800},
+        {0xf0007fff, 0x90000001, 0x0700000000007fff},
+        {0x7fff8000, 0x80008000, 0xC000800040000000},
+        {0x76540000, 0x8000abcd, 0xC4D6000000000000},
+        {0x76540000, 0x7fff7654, 0x3B2989AC00000000},
+        {0xabcd0000, 0x80000000, 0x2A19800000000000},
+        {0xabcdffff, 0x7fffabcd, 0xD5E6D43300005433},
+        {0x7fffffff, 0x7fff7654, 0x3FFF0001ffff89ac},
+        {0xffffffff, 0xffffffff, 0x0000000100000001},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmul_s16(bin64_sample[i].op1, bin64_sample[i].op2)
+                     == bin64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmul_s16_f.c b/tests/csky/ck803s-dsp/case/pmul_s16_f.c
new file mode 100644
index 0000000..b8ea46b
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmul_s16_f.c
@@ -0,0 +1,63 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      11
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMUL.S16.F \n");
+
+    /*
+     * PMUL.S16.F
+     * rz = (lo_x * lo_y) << 1, rn = (hi_x * hi_y) << 1, signed & fraction
+     */
+    struct binary64_calculation bin64_sample[TEST_TIMES] = {
+        {0x56785678, 0xc000b000, 0xd4c40000c9f50000},
+        {0x12345678, 0x12345678, 0x0296b5203a69b080},
+        {0x8080c0c0, 0x9090a0a0, 0x6f0090002f20f000},
+        {0xf0007fff, 0x90000001, 0x0e0000000000fffe},
+        {0x7fff8000, 0x80008000, 0x8001000080000000},
+        {0x76540000, 0x8000abcd, 0x89ac000000000000},
+        {0x76540000, 0x7fff7654, 0x7653135800000000},
+        {0xabcd0000, 0x80000000, 0x5433000000000000},
+        {0xabcdffff, 0x7fffabcd, 0xabcda8660000a866},
+        {0x7fffffff, 0x7fff7654, 0x7ffe0002ffff1358},
+        {0xffffffff, 0xffffffff, 0x0000000200000002},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmul_s16_f(bin64_sample[i].op1, bin64_sample[i].op2)
+                     == bin64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmula_s16.c b/tests/csky/ck803s-dsp/case/pmula_s16.c
new file mode 100644
index 0000000..abf24bf
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmula_s16.c
@@ -0,0 +1,60 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      7
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMULA.S16 \n");
+
+    /*
+     * PMULA.S16
+     * rz = rz + rx[15:0] * ry[15:0], rn = rn + rx[31:16] * ry[31:16],
+     * signed
+     */
+    struct ternary64_calculation sample[TEST_TIMES] = {
+        {0x7fff8000, 0x80008000, 0x00000000ffffffff, 0xc00080003fffffff},
+        {0x76540000, 0x8000abcd, 0x80000000ffffffff, 0x44d60000ffffffff},
+        {0x76540000, 0x7fff7654, 0x0000000000000000, 0x3b2989ac00000000},
+        {0xabcd0000, 0x80000000, 0x0123456789abcdef, 0x2b3cc56789abcdef},
+        {0xabcdffff, 0x7fffabcd, 0x0000000100000001, 0xd5e6d43400005434},
+        {0x7fffffff, 0x7fff7654, 0x7fffffffffffffff, 0xbfff0000ffff89ab},
+        {0xffffffff, 0xffffffff, 0x7fffffff7fffffff, 0x8000000080000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmula_s16(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmula_s16_f.c b/tests/csky/ck803s-dsp/case/pmula_s16_f.c
new file mode 100644
index 0000000..058f37c
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmula_s16_f.c
@@ -0,0 +1,67 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      7
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMULA.S16.F \n");
+
+    /*
+     * PMULA.S16.F
+     * rz = rz + rx[15:0] * ry[15:0] << 1,
+     * rn = rn + rx[31:16] * ry[31:16] << 1, signed & fraction
+     */
+    struct ternary64_calculation sample[TEST_TIMES] = {
+        {0x7fff8000, 0x80008000, 0x00000000ffffffff, 0x800100007fffffff},
+        {0x76540000, 0x8000abcd, 0x80000000ffffffff, 0x09ac0000ffffffff},
+        {0x76540000, 0x7fff7654, 0x0000000000000000, 0x7653135800000000},
+        {0xabcd0000, 0x80000000, 0x0123456789abcdef, 0x5556456789abcdef},
+        {0xabcdffff, 0x7fffabcd, 0x0000000100000001, 0xabcda8670000a867},
+        {0x7fffffff, 0x7fff7654, 0x7fffffffffffffff, 0xfffe0001ffff1357},
+        {0xffffffff, 0xffffffff, 0x7fffffff7fffffff, 0x8000000180000001},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmula_s16_f(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
+
+
+
+
+
+
+
diff --git a/tests/csky/ck803s-dsp/case/pmulawh_s16.c b/tests/csky/ck803s-dsp/case/pmulawh_s16.c
new file mode 100644
index 0000000..b3afd49
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmulawh_s16.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      7
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMULAWH.S16 \n");
+
+    /*
+     * PMULAWH.S16
+     * rz = rz + rx[15:0] * ry[31:16], rn = rn + rx[31:16] * ry[31:16],
+     * signed
+     */
+    struct ternary64_calculation sample[TEST_TIMES] = {
+        {0x7fff8000, 0x80008000, 0x00000000ffffffff, 0xc00080003fffffff},
+        {0x76540000, 0x8000abcd, 0x80000000ffffffff, 0x44d60000ffffffff},
+        {0x76540000, 0x7fff7654, 0x0000000000000000, 0x3b2989ac00000000},
+        {0xabcd0000, 0x80000000, 0x0123456789abcdef, 0x2b3cc56789abcdef},
+        {0xabcdffff, 0x7fffabcd, 0x0000000100000001, 0xd5e6d434ffff8002},
+        {0x7fffffff, 0x7fff7654, 0x7fffffffffffffff, 0xbfff0000ffff8000},
+        {0xffffffff, 0xffffffff, 0x7fffffff7fffffff, 0x8000000080000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmulawh_s16(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
+
+
+
+
+
+
diff --git a/tests/csky/ck803s-dsp/case/pmulawh_s16_f.c b/tests/csky/ck803s-dsp/case/pmulawh_s16_f.c
new file mode 100644
index 0000000..ed99246
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmulawh_s16_f.c
@@ -0,0 +1,59 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      7
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMULAWH.S16.F \n");
+
+    /*
+     * PMULAWH.S16.F
+     * rz = rz + rx[15:0] * ry[31:16] << 1,
+     * rn = rn + rx[31:16] * ry[31:16] << 1, signed & fraction
+     */
+    struct ternary64_calculation sample[TEST_TIMES] = {
+        {0x7fff8000, 0x80008000, 0x00000000ffffffff, 0x800100007fffffff},
+        {0x76540000, 0x8000abcd, 0x80000000ffffffff, 0x09ac0000ffffffff},
+        {0x76540000, 0x7fff7654, 0x0000000000000000, 0x7653135800000000},
+        {0xabcd0000, 0x80000000, 0x0123456789abcdef, 0x5556456789abcdef},
+        {0xabcdffff, 0x7fffabcd, 0x0000000100000001, 0xabcda867ffff0003},
+        {0x7fffffff, 0x7fff7654, 0x7fffffffffffffff, 0xfffe0001ffff0001},
+        {0xffffffff, 0xffffffff, 0x7fffffff7fffffff, 0x8000000180000001},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmulawh_s16_f(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
diff --git a/tests/csky/ck803s-dsp/case/pmulawl_s16.c b/tests/csky/ck803s-dsp/case/pmulawl_s16.c
new file mode 100644
index 0000000..2cf6c76
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmulawl_s16.c
@@ -0,0 +1,60 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      7
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMULAWL.S16 \n");
+
+    /*
+     * PMULAWL.S16
+     * rz = rz + rx[15:0] * ry[15:0], rn = rn + rx[31:16] * ry[15:0],
+     * signed
+     */
+    struct ternary64_calculation sample[TEST_TIMES] = {
+        {0x7fff8000, 0x80008000, 0x00000000ffffffff, 0xc00080003fffffff},
+        {0x76540000, 0x8000abcd, 0x80000000ffffffff, 0x5914dd44ffffffff},
+        {0x76540000, 0x7fff7654, 0x0000000000000000, 0x36b18b9000000000},
+        {0xabcd0000, 0x80000000, 0x0123456789abcdef, 0x0123456789abcdef},
+        {0xabcdffff, 0x7fffabcd, 0x0000000100000001, 0x1bb1822a00005434},
+        {0x7fffffff, 0x7fff7654, 0x7fffffffffffffff, 0xbb2989abffff89ab},
+        {0xffffffff, 0xffffffff, 0x7fffffff7fffffff, 0x8000000080000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmulawl_s16(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmulawl_s16_f.c b/tests/csky/ck803s-dsp/case/pmulawl_s16_f.c
new file mode 100644
index 0000000..82307f1
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmulawl_s16_f.c
@@ -0,0 +1,60 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      7
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMULAWL.S16.F \n");
+
+    /*
+     * PMULAWL.S16.F
+     * rz = rz + rx[15:0] * ry[15:0] << 1,
+     * rn = rn + rx[31:16] * ry[15:0] << 1, signed & fraction
+     */
+    struct ternary64_calculation sample[TEST_TIMES] = {
+        {0x7fff8000, 0x80008000, 0x00000000ffffffff, 0x800100007fffffff},
+        {0x76540000, 0x8000abcd, 0x80000000ffffffff, 0x3229ba88ffffffff},
+        {0x76540000, 0x7fff7654, 0x0000000000000000, 0x6d63172000000000},
+        {0xabcd0000, 0x80000000, 0x0123456789abcdef, 0x0123456789abcdef},
+        {0xabcdffff, 0x7fffabcd, 0x0000000100000001, 0x376304530000a867},
+        {0x7fffffff, 0x7fff7654, 0x7fffffffffffffff, 0xf6531357ffff1357},
+        {0xffffffff, 0xffffffff, 0x7fffffff7fffffff, 0x8000000180000001},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmulawl_s16_f(sample[i].op1, sample[i].op2, sample[i].op3)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmulwh_s16.c b/tests/csky/ck803s-dsp/case/pmulwh_s16.c
new file mode 100644
index 0000000..a1e7513
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmulwh_s16.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      14
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMULWH.S16 \n");
+
+    /*
+     * PMULWH.S16
+     * rz = lo_x * hi_y, rn = hi_x * hi_y, signed
+     */
+    struct binary64_calculation sample[TEST_TIMES] = {
+        {0x7fff8000, 0x80008000, 0xc000800040000000},
+        {0x76540000, 0x8000abcd, 0xc4d6000000000000},
+        {0x76540000, 0x7fff7654, 0x3b2989ac00000000},
+        {0xabcd0000, 0x80000000, 0x2a19800000000000},
+        {0xabcdffff, 0x7fffabcd, 0xd5e6d433ffff8001},
+        {0x7fffffff, 0x7fff7654, 0x3fff0001ffff8001},
+        {0xffffffff, 0xffffffff, 0x0000000100000001},
+        {0x7fff8000, 0x80008000, 0xc000800040000000},
+        {0x76540000, 0xabcd8000, 0xd914dd4400000000},
+        {0x76540000, 0x76547fff, 0x36b18b9000000000},
+        {0xabcd0000, 0x00008000, 0x0000000000000000},
+        {0xabcdffff, 0xabcd7fff, 0x1bb1822900005433},
+        {0x7fffffff, 0x76547fff, 0x3b2989acffff89ac},
+        {0xffffffff, 0xffffffff, 0x0000000100000001},
+       };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmulwh_s16(sample[i].op1, sample[i].op2)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmulwh_s16_f.c b/tests/csky/ck803s-dsp/case/pmulwh_s16_f.c
new file mode 100644
index 0000000..b4f6230
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmulwh_s16_f.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      14
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMULWH.S16.F \n");
+
+    /*
+     * PMULWH.S16.F
+     * rz = lo_x * hi_y << 1, rn = hi_x * hi_y << 1, signed & fraction
+     */
+    struct binary64_calculation sample[TEST_TIMES] = {
+        {0x7fff8000, 0x80008000, 0x8001000080000000},
+        {0x76540000, 0x8000abcd, 0x89ac000000000000},
+        {0x76540000, 0x7fff7654, 0x7653135800000000},
+        {0xabcd0000, 0x80000000, 0x5433000000000000},
+        {0xabcdffff, 0x7fffabcd, 0xabcda866ffff0002},
+        {0x7fffffff, 0x7fff7654, 0x7ffe0002ffff0002},
+        {0xffffffff, 0xffffffff, 0x0000000200000002},
+        {0x7fff8000, 0x80008000, 0x8001000080000000},
+        {0x76540000, 0xabcd8000, 0xb229ba8800000000},
+        {0x76540000, 0x76547fff, 0x6d63172000000000},
+        {0xabcd0000, 0x00008000, 0x0000000000000000},
+        {0xabcdffff, 0xabcd7fff, 0x376304520000a866},
+        {0x7fffffff, 0x76547fff, 0x76531358ffff1358},
+        {0xffffffff, 0xffffffff, 0x0000000200000002},
+       };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmulwh_s16_f(sample[i].op1, sample[i].op2)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmulwl_s16.c b/tests/csky/ck803s-dsp/case/pmulwl_s16.c
new file mode 100644
index 0000000..3474a24
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmulwl_s16.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      14
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMULWL.S16 \n");
+
+    /*
+     * PMULWL.S16
+     * rz = lo_x * lo_y, rn = hi_x * lo_y, signed
+     */
+    struct binary64_calculation sample[TEST_TIMES] = {
+        {0x7fff8000, 0x80008000, 0xc000800040000000},
+        {0x76540000, 0x8000abcd, 0xd914dd4400000000},
+        {0x76540000, 0x7fff7654, 0x36b18b9000000000},
+        {0xabcd0000, 0x80000000, 0x0000000000000000},
+        {0xabcdffff, 0x7fffabcd, 0x1bb1822900005433},
+        {0x7fffffff, 0x7fff7654, 0x3b2989acffff89ac},
+        {0xffffffff, 0xffffffff, 0x0000000100000001},
+        {0x7fff8000, 0x80008000, 0xc000800040000000},
+        {0x76540000, 0xabcd8000, 0xc4d6000000000000},
+        {0x76540000, 0x76547fff, 0x3b2989ac00000000},
+        {0xabcd0000, 0x00008000, 0x2a19800000000000},
+        {0xabcdffff, 0xabcd7fff, 0xd5e6d433ffff8001},
+        {0x7fffffff, 0x76547fff, 0x3fff0001ffff8001},
+        {0xffffffff, 0xffffffff, 0x0000000100000001},
+       };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmulwl_s16(sample[i].op1, sample[i].op2)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pmulwl_s16_f.c b/tests/csky/ck803s-dsp/case/pmulwl_s16_f.c
new file mode 100644
index 0000000..9352d57
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pmulwl_s16_f.c
@@ -0,0 +1,66 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      14
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PMULWL.S16.F \n");
+
+    /*
+     * PMULWL.S16.F
+     * rz = lo_x * lo_y << 1, rn = hi_x * lo_y << 1, signed & fraction
+     */
+    struct binary64_calculation sample[TEST_TIMES] = {
+        {0x7fff8000, 0x80008000, 0x8001000080000000},
+        {0x76540000, 0x8000abcd, 0xb229ba8800000000},
+        {0x76540000, 0x7fff7654, 0x6d63172000000000},
+        {0xabcd0000, 0x80000000, 0x0000000000000000},
+        {0xabcdffff, 0x7fffabcd, 0x376304520000a866},
+        {0x7fffffff, 0x7fff7654, 0x76531358ffff1358},
+        {0xffffffff, 0xffffffff, 0x0000000200000002},
+        {0x7fff8000, 0x80008000, 0x8001000080000000},
+        {0x76540000, 0xabcd8000, 0x89ac000000000000},
+        {0x76540000, 0x76547fff, 0x7653135800000000},
+        {0xabcd0000, 0x00008000, 0x5433000000000000},
+        {0xabcdffff, 0xabcd7fff, 0xabcda866ffff0002},
+        {0x7fffffff, 0x76547fff, 0x7ffe0002ffff0002},
+        {0xffffffff, 0xffffffff, 0x0000000200000002},
+       };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pmulwl_s16_f(sample[i].op1, sample[i].op2)
+                     == sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/pneg_s16_s.c b/tests/csky/ck803s-dsp/case/pneg_s16_s.c
new file mode 100644
index 0000000..496f32c
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/pneg_s16_s.c
@@ -0,0 +1,56 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      5
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PNEG.S16.S \n");
+
+    /*
+     * PNEG.S16.S
+     * rz[15:0] = | rx[15:0] |, rz[31:16] = | rx[31:16] |, signed
+     */
+    struct unary_calculation un_sample[TEST_TIMES] = {
+        {0X00000000, 0x00000000},
+        {0X0001FFFF, 0xffff0001},
+        {0XFFFF0001, 0x0001ffff},
+        {0X7FFF8000, 0x80017fff},
+        {0X80017FFF, 0x7fff8001},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_pneg_s16_s(un_sample[i].op1)
+                     == un_sample[i].result);
+    }
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/psub_s16.c b/tests/csky/ck803s-dsp/case/psub_s16.c
new file mode 100644
index 0000000..11690b6
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/psub_s16.c
@@ -0,0 +1,61 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PSUB.S16 \n");
+
+    /*
+     * PSUB.S16
+     * rz = {(hi_x - hi_y)[15:0], (lo_x - lo_y)[15:0]}, signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0X00000000, 0X00000000, 0x00000000},
+        {0X00000001, 0X00010000, 0xffff0001},
+        {0X00010001, 0X00010001, 0x00000000},
+        {0XFFFF0001, 0X0001FFFF, 0xfffe0002},
+        {0XFFFFFFFF, 0XFFFF0000, 0x0000ffff},
+        {0X0000FFFF, 0XFFFFFFFF, 0x00010000},
+        {0X7FFF8000, 0X7FFF8000, 0x00000000},
+        {0X7FFF8000, 0X80007FFF, 0xffff0001},
+        {0X80007FFF, 0X7FFF8000, 0x0001ffff},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_psub_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/psub_s16_s.c b/tests/csky/ck803s-dsp/case/psub_s16_s.c
new file mode 100644
index 0000000..77c3d4d
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/psub_s16_s.c
@@ -0,0 +1,62 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PSUB.S16.S \n");
+
+    /*
+     * PSUB.S16.S
+     * rz[15:0] = rx[15:0] - ry[15:0],
+     * rz[31:16] = rx[31:16] - ry[31:16], signed & saturated
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0X00000000, 0X00000000, 0x00000000},
+        {0X00000001, 0X00010000, 0xffff0001},
+        {0X00010001, 0X00010001, 0x00000000},
+        {0XFFFF0001, 0X0001FFFF, 0xfffe0002},
+        {0XFFFFFFFF, 0XFFFF0000, 0x0000ffff},
+        {0X0000FFFF, 0XFFFFFFFF, 0x00010000},
+        {0X7FFF8000, 0X7FFF8000, 0x00000000},
+        {0X7FFF8000, 0X80007FFF, 0x7fff8000},
+        {0X80007FFF, 0X7FFF8000, 0x80007fff},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_psub_s16_s(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/psubh_s16.c b/tests/csky/ck803s-dsp/case/psubh_s16.c
new file mode 100644
index 0000000..951a956
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/psubh_s16.c
@@ -0,0 +1,62 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      9
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PSUBH.S16 \n");
+
+    /*
+     * PSUBH.S16
+     * rz[15:0] = (rx[15:0] - ry[15:0])/2,
+     * rz[31:16] = (rx[31:16] - ry[31:16])/2, signed
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0X00000000, 0X00000000, 0x00000000},
+        {0X00000001, 0X00010000, 0x00000000},
+        {0X00010001, 0X00010001, 0x00000000},
+        {0XFFFF0001, 0X0001FFFF, 0xffff0001},
+        {0XFFFFFFFF, 0XFFFF0000, 0x00000000},
+        {0X0000FFFF, 0XFFFFFFFF, 0x00000000},
+        {0X7FFF8000, 0X7FFF8000, 0x00000000},
+        {0X7FFF8000, 0X80007FFF, 0x00000000},
+        {0X80007FFF, 0X7FFF8000, 0x00000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_psubh_s16(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/psubx_s32.c b/tests/csky/ck803s-dsp/case/psubx_s32.c
new file mode 100644
index 0000000..da6cdb7
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/psubx_s32.c
@@ -0,0 +1,58 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      6
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn PSUBX.S32 \n");
+
+    /*
+     * PSUBX.S32
+     * rz = rx + lo_ry, r(z+1) = rn + hi_ry, signed
+     */
+    struct ternary64_calculation ter64_sample[TEST_TIMES] = {
+        {0X00000000, 0X00000000, 0X00000000, 0x0000000000000000},
+        {0X00000000, 0XFFFF0001, 0X00000000, 0x00000001ffffffff},
+        {0X00000001, 0XFFFF0001, 0X00000001, 0x0000000200000000},
+        {0XFFFFFFFF, 0XFFFF0001, 0XFFFFFFFF, 0x00000000fffffffe},
+        {0X80000000, 0XFFFF0001, 0X7FFFFFFF, 0x800000007fffffff},
+        {0X7FFFFFFF, 0X0001FFFF, 0X80000000, 0x7fffffff80000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_psubx_s32(ter64_sample[i].op1, ter64_sample[i].op2,
+                           ter64_sample[i].op3) == ter64_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/sel_32.c b/tests/csky/ck803s-dsp/case/sel_32.c
new file mode 100644
index 0000000..19a7878
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/sel_32.c
@@ -0,0 +1,55 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      2
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn SEL.32 \n");
+
+    /*
+     * SEL.32
+     * rz = (c == 0) ? rx : ry
+     * note: if op2 == op0, c = 0; else c = 1
+     */
+    struct ternary_calculation ter_sample[TEST_TIMES] = {
+        {0x00000000, 0xFFFFFFFF, 0x00000000, 0x00000000}, /* c = 0 */
+        {0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xffffffff}, /* c = 1 */
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_sel_32(ter_sample[i].op1, ter_sample[i].op2,
+                         ter_sample[i].op3) == ter_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/case/sub_s32_s.c b/tests/csky/ck803s-dsp/case/sub_s32_s.c
new file mode 100644
index 0000000..7a0e640
--- /dev/null
+++ b/tests/csky/ck803s-dsp/case/sub_s32_s.c
@@ -0,0 +1,64 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dsp_insn.h"
+#define TEST_TIMES      12
+int main(void)
+{
+    int i = 0;
+
+    init_testsuite("Testing insn SUB.S32.S \n");
+
+    /*
+     * SUB.S32.S
+     * rz = rx - ry, signed & saturated
+     */
+    struct binary_calculation bin_sample[TEST_TIMES] = {
+        {0X00000001, 0X00000001, 0x00000000},
+        {0XFFFFFFFF, 0X00000001, 0xfffffffe},
+        {0X00000001, 0XFFFFFFFF, 0x00000002},
+        {0XFFFFFFFF, 0XFFFFFFFF, 0x00000000},
+        {0X30000000, 0X80000001, 0x7fffffff},
+        {0X80000001, 0X30000000, 0x80000000},
+        {0X7FFFFFFF, 0X00000000, 0x7fffffff},
+        {0X7FFFFFFF, 0X7FFFFFFF, 0x00000000},
+        {0X7FFFFFFF, 0X80000000, 0x7fffffff},
+        {0X80000000, 0X00000000, 0x80000000},
+        {0X80000000, 0X80000000, 0x00000000},
+        {0X80000000, 0X7FFFFFFF, 0x80000000},
+    };
+
+    for (i = 0; i < TEST_TIMES; i++) {
+        TEST(test_sub_s32_s(bin_sample[i].op1, bin_sample[i].op2)
+                     == bin_sample[i].result);
+    }
+
+    return done_testing();
+}
+
diff --git a/tests/csky/ck803s-dsp/runcase_ck803sdsp.sh b/tests/csky/ck803s-dsp/runcase_ck803sdsp.sh
new file mode 100755
index 0000000..5dcf44c
--- /dev/null
+++ b/tests/csky/ck803s-dsp/runcase_ck803sdsp.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+num_total=0
+num_fail=0
+
+make
+cd case
+for file in *.elf
+do
+    cmd="../../../../cskyv2-softmmu/qemu-system-cskyv2 -machine smartl -kernel $file -nographic"
+    $cmd
+    if [ $? -ne 0 ]
+    then
+        num_fail=`expr $num_fail + 1`
+    fi
+    num_total=`expr $num_total + 1`
+done
+
+echo "\n------sumary------"
+echo "Total  case: $num_total"
+echo "Failed case: $num_fail"
+echo "------------------\n"
+
+cd ..
+make clean
diff --git a/tests/csky/dspv2/Makefile b/tests/csky/dspv2/Makefile
new file mode 100644
index 0000000..dbca128
--- /dev/null
+++ b/tests/csky/dspv2/Makefile
@@ -0,0 +1,29 @@
+CORE_OBJ = core 
+BOARD_DIR = ../board/smartl/ck803s
+CFLAGS = -g2 -mcpu=ck803efr1 -msoft-float
+TARGET_CROSS = csky-abiv2-elf
+
+CC = $(TARGET_CROSS)-gcc
+
+ROOTDIR = $(shell pwd)/
+srcdir = $(ROOTDIR)../
+EXPECT = expect
+RUNTEST = runtest
+RUNTESTFLAGS =
+
+all: core
+
+core:
+	@echo "  CC    $(BOARD_DIR)/crt0.o"
+	@$(CC) -c $(CFLAGS) $(BOARD_DIR)/crt0.S -o $(BOARD_DIR)/crt0.o
+	@echo "  CC    $(BOARD_DIR)/uart.o"
+	@$(CC) -c $(CFLAGS) $(BOARD_DIR)/uart.c -o $(BOARD_DIR)/uart.o
+	make -C case
+
+clean:
+	rm -f $(BOARD_DIR)/*.o
+	rm -f core
+	make -C case clean
+
+
+
diff --git a/tests/csky/dspv2/case/Makefile b/tests/csky/dspv2/case/Makefile
new file mode 100644
index 0000000..151397e
--- /dev/null
+++ b/tests/csky/dspv2/case/Makefile
@@ -0,0 +1,22 @@
+SRC = $(wildcard *.c) $(sample_array.c)
+SRS = $(wildcard *.S)
+OBJFILE = $(SRS:%.S=%.o) $(SRC:%.c=%)
+BOARD_DIR = ../../board/smartl/ck803s
+INCLUDE = -I../../include -I$(BOARD_DIR)
+CFLAGS = -g2 -O2 -mcpu=ck803efr1 -msoft-float
+all: case
+
+case: $(OBJFILE)
+
+%.o: %.S
+	@echo "  CC    case/$@"
+	@csky-abiv2-elf-gcc $(CFLAGS) -c $(INCLUDE) -o $@  $<
+
+%: %.c
+	@echo "  CC    case/$@.o"
+	@csky-abiv2-elf-gcc $(CFLAGS) -c $(INCLUDE) -O2 -o $@.o  $<
+	@echo "  CC    case/$@.elf"
+	@csky-abiv2-elf-gcc $(CFLAGS) $(BOARD_DIR)/uart.o $(BOARD_DIR)/crt0.o dspv2_insn.o -T$(BOARD_DIR)/ckcpu.ld -nostartfiles -lgcc $@.o -o $@.elf
+	@#csky-abiv2-elf-objdump -S $@.elf > $@.asm
+clean:
+	rm -rf  *.o *.a *.asm *.elf
diff --git a/tests/csky/dspv2/case/abs_s32_s.c b/tests/csky/dspv2/case/abs_s32_s.c
new file mode 100644
index 0000000..1091dd1
--- /dev/null
+++ b/tests/csky/dspv2/case/abs_s32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn abs.s32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_abs_s32_s)/sizeof(struct unary_calculation);
+         i++) {
+        TEST(test_abs_s32_s(samples_abs_s32_s[i].op1)
+                     == samples_abs_s32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/add_64.c b/tests/csky/dspv2/case/add_64.c
new file mode 100644
index 0000000..641eeef
--- /dev/null
+++ b/tests/csky/dspv2/case/add_64.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn add.64\n");
+
+    for (i = 0;
+         i < sizeof(samples_add_64)/sizeof(struct binary64_64_64_calculation);
+         i++) {
+        TEST(test_add_64(samples_add_64[i].op1, samples_add_64[i].op2)
+                     == samples_add_64[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/add_s32_s.c b/tests/csky/dspv2/case/add_s32_s.c
new file mode 100644
index 0000000..2021bb6
--- /dev/null
+++ b/tests/csky/dspv2/case/add_s32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn add.s32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_add_s32_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_add_s32_s(samples_add_s32_s[i].op1, samples_add_s32_s[i].op2)
+                     == samples_add_s32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/add_s64_s.c b/tests/csky/dspv2/case/add_s64_s.c
new file mode 100644
index 0000000..09c40d1
--- /dev/null
+++ b/tests/csky/dspv2/case/add_s64_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn add.s64.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_add_s64_s)/sizeof(struct binary64_64_64_calculation);
+         i++) {
+        TEST(test_add_s64_s(samples_add_s64_s[i].op1, samples_add_s64_s[i].op2)
+                     == samples_add_s64_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/add_u32_s.c b/tests/csky/dspv2/case/add_u32_s.c
new file mode 100644
index 0000000..37fe727
--- /dev/null
+++ b/tests/csky/dspv2/case/add_u32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn add.u32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_add_u32_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_add_u32_s(samples_add_u32_s[i].op1, samples_add_u32_s[i].op2)
+                     == samples_add_u32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/add_u64_s.c b/tests/csky/dspv2/case/add_u64_s.c
new file mode 100644
index 0000000..1458ff5
--- /dev/null
+++ b/tests/csky/dspv2/case/add_u64_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn add.u64.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_add_u64_s)/sizeof(struct binary64_64_64_calculation);
+         i++) {
+        TEST(test_add_u64_s(samples_add_u64_s[i].op1, samples_add_u64_s[i].op2)
+                     == samples_add_u64_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/addh_s32.c b/tests/csky/dspv2/case/addh_s32.c
new file mode 100644
index 0000000..587d2cc
--- /dev/null
+++ b/tests/csky/dspv2/case/addh_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn addh.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_addh_s32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_addh_s32(samples_addh_s32[i].op1, samples_addh_s32[i].op2)
+                     == samples_addh_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/addh_u32.c b/tests/csky/dspv2/case/addh_u32.c
new file mode 100644
index 0000000..b158e10
--- /dev/null
+++ b/tests/csky/dspv2/case/addh_u32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn addh.u32\n");
+
+    for (i = 0;
+         i < sizeof(samples_addh_u32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_addh_u32(samples_addh_u32[i].op1, samples_addh_u32[i].op2)
+                     == samples_addh_u32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/asr_s32_r.c b/tests/csky/dspv2/case/asr_s32_r.c
new file mode 100644
index 0000000..66389d4
--- /dev/null
+++ b/tests/csky/dspv2/case/asr_s32_r.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn asr.s32.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_asr_s32_r)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_asr_s32_r(samples_asr_s32_r[i].op1, samples_asr_s32_r[i].op2)
+                     == samples_asr_s32_r[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/asri_s32_r.c b/tests/csky/dspv2/case/asri_s32_r.c
new file mode 100644
index 0000000..eecbf19
--- /dev/null
+++ b/tests/csky/dspv2/case/asri_s32_r.c
@@ -0,0 +1,28 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn asri.s32.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_asri_s32_r)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_asri_s32_r[i].op2 == 32) {
+            TEST(test_asri_s32_r_32(samples_asri_s32_r[i].op1)
+                 == samples_asri_s32_r[i].result);
+        } else if (samples_asri_s32_r[i].op2 == 1) {
+            TEST(test_asri_s32_r_1(samples_asri_s32_r[i].op1)
+                 == samples_asri_s32_r[i].result);
+        } else if (samples_asri_s32_r[i].op2 == 2) {
+            TEST(test_asri_s32_r_2(samples_asri_s32_r[i].op1)
+                 == samples_asri_s32_r[i].result);
+        } else if (samples_asri_s32_r[i].op2 == 31) {
+            TEST(test_asri_s32_r_31(samples_asri_s32_r[i].op1)
+                 == samples_asri_s32_r[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/bloop.c b/tests/csky/dspv2/case/bloop.c
new file mode 100644
index 0000000..27522e4
--- /dev/null
+++ b/tests/csky/dspv2/case/bloop.c
@@ -0,0 +1,42 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn bloop\n");
+
+    int rx=10;
+    int ry=0;
+    int rz=10;
+    int rs=100;
+    TEST((test_bloop(rx, ry, rz, rs) == 0));
+
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/clip_s32.c b/tests/csky/dspv2/case/clip_s32.c
new file mode 100644
index 0000000..24b96d7
--- /dev/null
+++ b/tests/csky/dspv2/case/clip_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn clip.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_clip_s32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_clip_s32(samples_clip_s32[i].op1, samples_clip_s32[i].op2)
+                     == samples_clip_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/clip_u32.c b/tests/csky/dspv2/case/clip_u32.c
new file mode 100644
index 0000000..c377fbe
--- /dev/null
+++ b/tests/csky/dspv2/case/clip_u32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn clip.u32\n");
+
+    for (i = 0;
+         i < sizeof(samples_clip_u32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_clip_u32(samples_clip_u32[i].op1, samples_clip_u32[i].op2)
+                     == samples_clip_u32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/clipi_s32.c b/tests/csky/dspv2/case/clipi_s32.c
new file mode 100644
index 0000000..659626f
--- /dev/null
+++ b/tests/csky/dspv2/case/clipi_s32.c
@@ -0,0 +1,28 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn clipi.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_clipi_s32)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_clipi_s32[i].op2 == 0) {
+            TEST(test_clipi_s32_0(samples_clipi_s32[i].op1)
+                 == samples_clipi_s32[i].result);
+        } else if (samples_clipi_s32[i].op2 == 1) {
+            TEST(test_clipi_s32_1(samples_clipi_s32[i].op1)
+                 == samples_clipi_s32[i].result);
+        } else if (samples_clipi_s32[i].op2 == 2) {
+            TEST(test_clipi_s32_2(samples_clipi_s32[i].op1)
+                 == samples_clipi_s32[i].result);
+        } else if (samples_clipi_s32[i].op2 == 31) {
+            TEST(test_clipi_s32_31(samples_clipi_s32[i].op1)
+                 == samples_clipi_s32[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/clipi_u32.c b/tests/csky/dspv2/case/clipi_u32.c
new file mode 100644
index 0000000..15135b2
--- /dev/null
+++ b/tests/csky/dspv2/case/clipi_u32.c
@@ -0,0 +1,31 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn clipi.u32\n");
+
+    for (i = 0;
+         i < sizeof(samples_clipi_u32)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_clipi_u32[i].op2 == 0) {
+            TEST(test_clipi_u32_0(samples_clipi_u32[i].op1)
+                 == samples_clipi_u32[i].result);
+        } else if (samples_clipi_u32[i].op2 == 1) {
+            TEST(test_clipi_u32_1(samples_clipi_u32[i].op1)
+                 == samples_clipi_u32[i].result);
+        } else if (samples_clipi_u32[i].op2 == 2) {
+            TEST(test_clipi_u32_2(samples_clipi_u32[i].op1)
+                 == samples_clipi_u32[i].result);
+        } else if (samples_clipi_u32[i].op2 == 5) {
+            TEST(test_clipi_u32_5(samples_clipi_u32[i].op1)
+                 == samples_clipi_u32[i].result);
+        } else if (samples_clipi_u32[i].op2 == 31) {
+            TEST(test_clipi_u32_31(samples_clipi_u32[i].op1)
+                 == samples_clipi_u32[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/dext.c b/tests/csky/dspv2/case/dext.c
new file mode 100644
index 0000000..ddf43c1
--- /dev/null
+++ b/tests/csky/dspv2/case/dext.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn dext\n");
+
+    for (i = 0;
+         i < sizeof(samples_dext)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_dext(samples_dext[i].op1, samples_dext[i].op2, samples_dext[i].op3)
+                     == samples_dext[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/dexti.c b/tests/csky/dspv2/case/dexti.c
new file mode 100644
index 0000000..0c47b23
--- /dev/null
+++ b/tests/csky/dspv2/case/dexti.c
@@ -0,0 +1,28 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn dexti\n");
+
+    for (i = 0;
+         i < sizeof(samples_dexti)/sizeof(struct ternary_calculation);
+         i++) {
+        if (samples_dexti[i].op3 == 0) {
+            TEST(test_dexti_0(samples_dexti[i].op1, samples_dexti[i].op2)
+                            == samples_dexti[i].result);
+        } else if (samples_dexti[i].op3 == 2) {
+            TEST(test_dexti_2(samples_dexti[i].op1, samples_dexti[i].op2)
+                            == samples_dexti[i].result);
+        } else if (samples_dexti[i].op3 == 5) {
+            TEST(test_dexti_5(samples_dexti[i].op1, samples_dexti[i].op2)
+                            == samples_dexti[i].result);
+        } else if (samples_dexti[i].op3 == 31) {
+            TEST(test_dexti_31(samples_dexti[i].op1, samples_dexti[i].op2)
+                            == samples_dexti[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/divsl.c b/tests/csky/dspv2/case/divsl.c
new file mode 100644
index 0000000..49ed412
--- /dev/null
+++ b/tests/csky/dspv2/case/divsl.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn divsl\n");
+
+    for (i = 0;
+         i < sizeof(samples_divsl)/sizeof(struct binary64_64_calculation);
+         i++) {
+        TEST(test_divsl(samples_divsl[i].op1, samples_divsl[i].op2)
+                     == samples_divsl[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/divul.c b/tests/csky/dspv2/case/divul.c
new file mode 100644
index 0000000..da1d7ce
--- /dev/null
+++ b/tests/csky/dspv2/case/divul.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn divul\n");
+
+    for (i = 0;
+         i < sizeof(samples_divul)/sizeof(struct binary64_64_calculation);
+         i++) {
+        TEST(test_divul(samples_divul[i].op1, samples_divul[i].op2)
+                     == samples_divul[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/dspv2_insn.S b/tests/csky/dspv2/case/dspv2_insn.S
new file mode 100644
index 0000000..ea463cc
--- /dev/null
+++ b/tests/csky/dspv2/case/dspv2_insn.S
@@ -0,0 +1,1593 @@
+   .file   "dspv2_insn.S"
+#undef TEST_FUNC
+#define TEST_FUNC(name) TEST_FUNC_M name
+    .macro TEST_FUNC_M name
+    .text
+    .align  2
+    .global \name
+    .type   \name, @function
+\name:
+    .endm
+
+TEST_FUNC(test_psub_8)
+    psub.8    a0, a0, a1
+    rts
+    .size   test_psub_8, .-test_psub_8
+
+TEST_FUNC(test_psub_16)
+    psub.16    a0, a0, a1
+    rts
+    .size   test_psub_16, .-test_psub_16
+
+TEST_FUNC(test_padd_8)
+    padd.8    a0, a0, a1
+    rts
+    .size   test_padd_8, .-test_padd_8
+
+TEST_FUNC(test_padd_16)
+    padd.16    a0, a0, a1
+    rts
+    .size   test_padd_16, .-test_padd_16
+
+TEST_FUNC(test_pasx_16)
+    pasx.16    a0, a0, a1
+    rts
+    .size   test_pasx_16, .-test_pasx_16
+
+TEST_FUNC(test_psax_16)
+    psax.16    a0, a0, a1
+    rts
+    .size   test_psax_16, .-test_psax_16
+
+TEST_FUNC(test_padd_u8_s)
+    padd.u8.s    a0, a0, a1
+    rts
+    .size   test_padd_u8_s, .-test_padd_u8_s
+
+TEST_FUNC(test_padd_s8_s)
+    padd.s8.s    a0, a0, a1
+    rts
+    .size   test_padd_s8_s, .-test_padd_s8_s
+
+TEST_FUNC(test_padd_u16_s)
+    padd.u16.s    a0, a0, a1
+    rts
+    .size   test_padd_u16_s, .-test_padd_u16_s
+
+TEST_FUNC(test_padd_s16_s)
+    padd.s16.s    a0, a0, a1
+    rts
+    .size   test_padd_s16_s, .-test_padd_s16_s
+
+TEST_FUNC(test_add_u32_s)
+    add.u32.s    a0, a0, a1
+    rts
+    .size   test_add_u32_s, .-test_add_u32_s
+
+TEST_FUNC(test_add_s32_s)
+    add.s32.s    a0, a0, a1
+    rts
+    .size   test_add_s32_s, .-test_add_s32_s
+
+TEST_FUNC(test_psub_u8_s)
+    psub.u8.s    a0, a0, a1
+    rts
+    .size   test_psub_u8_s, .-test_psub_u8_s
+
+TEST_FUNC(test_psub_s8_s)
+    psub.s8.s    a0, a0, a1
+    rts
+    .size   test_psub_s8_s, .-test_psub_s8_s
+
+TEST_FUNC(test_psub_u16_s)
+    psub.u16.s    a0, a0, a1
+    rts
+    .size   test_psub_u16_s, .-test_psub_u16_s
+
+TEST_FUNC(test_psub_s16_s)
+    psub.s16.s    a0, a0, a1
+    rts
+    .size   test_psub_s16_s, .-test_psub_s16_s
+
+TEST_FUNC(test_sub_u32_s)
+    sub.u32.s    a0, a0, a1
+    rts
+    .size   test_sub_u32_s, .-test_sub_u32_s
+
+TEST_FUNC(test_sub_s32_s)
+    sub.s32.s    a0, a0, a1
+    rts
+    .size   test_sub_s32_s, .-test_sub_s32_s
+
+TEST_FUNC(test_addh_u32)
+    addh.u32    a0, a0, a1
+    rts
+    .size   test_addh_u32, .-test_addh_u32
+
+TEST_FUNC(test_addh_s32)
+    addh.s32    a0, a0, a1
+    rts
+    .size   test_addh_s32, .-test_addh_s32
+
+TEST_FUNC(test_paddh_u8)
+    paddh.u8    a0, a0, a1
+    rts
+    .size   test_paddh_u8, .-test_paddh_u8
+
+TEST_FUNC(test_paddh_s8)
+    paddh.s8    a0, a0, a1
+    rts
+    .size   test_paddh_s8, .-test_paddh_s8
+
+TEST_FUNC(test_paddh_u16)
+    paddh.u16    a0, a0, a1
+    rts
+    .size   test_paddh_u16, .-test_paddh_u16
+
+TEST_FUNC(test_paddh_s16)
+    paddh.s16    a0, a0, a1
+    rts
+    .size   test_paddh_s16, .-test_paddh_s16
+
+TEST_FUNC(test_subh_u32)
+    subh.u32    a0, a0, a1
+    rts
+    .size   test_subh_u32, .-test_subh_u32
+
+TEST_FUNC(test_subh_s32)
+    subh.s32    a0, a0, a1
+    rts
+    .size   test_subh_s32, .-test_subh_s32
+
+TEST_FUNC(test_psubh_u8)
+    psubh.u8    a0, a0, a1
+    rts
+    .size   test_psubh_u8, .-test_psubh_u8
+
+TEST_FUNC(test_psubh_s8)
+    psubh.s8    a0, a0, a1
+    rts
+    .size   test_psubh_s8, .-test_psubh_s8
+
+TEST_FUNC(test_psubh_u16)
+    psubh.u16    a0, a0, a1
+    rts
+    .size   test_psubh_u16, .-test_psubh_u16
+
+TEST_FUNC(test_psubh_s16)
+    psubh.s16    a0, a0, a1
+    rts
+    .size   test_psubh_s16, .-test_psubh_s16
+
+TEST_FUNC(test_pasx_u16_s)
+    pasx.u16.s    a0, a0, a1
+    rts
+    .size   test_pasx_u16_s, .-test_pasx_u16_s
+
+TEST_FUNC(test_pasx_s16_s)
+    pasx.s16.s    a0, a0, a1
+    rts
+    .size   test_pasx_s16_s, .-test_pasx_s16_s
+
+TEST_FUNC(test_psax_u16_s)
+    psax.u16.s    a0, a0, a1
+    rts
+    .size   test_psax_u16_s, .-test_psax_u16_s
+
+TEST_FUNC(test_psax_s16_s)
+    psax.s16.s    a0, a0, a1
+    rts
+    .size   test_psax_s16_s, .-test_psax_s16_s
+
+TEST_FUNC(test_pasxh_u16)
+    pasxh.u16    a0, a0, a1
+    rts
+    .size   test_pasxh_u16, .-test_pasxh_u16
+
+TEST_FUNC(test_pasxh_s16)
+    pasxh.s16    a0, a0, a1
+    rts
+    .size   test_pasxh_s16, .-test_pasxh_s16
+
+TEST_FUNC(test_psaxh_u16)
+    psaxh.u16    a0, a0, a1
+    rts
+    .size   test_psaxh_u16, .-test_psaxh_u16
+
+TEST_FUNC(test_psaxh_s16)
+    psaxh.s16    a0, a0, a1
+    rts
+    .size   test_psaxh_s16, .-test_psaxh_s16
+
+TEST_FUNC(test_add_64)
+    add.64    a0, a0, a2
+    rts
+    .size   test_add_64, .-test_add_64
+
+TEST_FUNC(test_add_u64_s)
+    add.u64.s    a0, a0, a2
+    rts
+    .size   test_add_u64_s, .-test_add_u64_s
+
+TEST_FUNC(test_add_s64_s)
+    mov r31, a0
+    mov a0, a1
+    add.s64.s    a0, r31, a2
+    rts
+    .size   test_add_s64_s, .-test_add_s64_s
+
+TEST_FUNC(test_sub_64)
+    sub.64    a0, a0, a2
+    rts
+    .size   test_sub_64, .-test_sub_64
+
+TEST_FUNC(test_sub_u64_s)
+    sub.u64.s    a0, a0, a2
+    rts
+    .size   test_sub_u64_s, .-test_sub_u64_s
+
+TEST_FUNC(test_sub_s64_s)
+    sub.s64.s    a0, a0, a2
+    rts
+    .size   test_sub_s64_s, .-test_sub_s64_s
+
+TEST_FUNC(test_asri_s32_r_32)
+    asri.s32.r    a0, a0, 32
+    rts
+    .size   test_asri_s32_r_32, .-test_asri_s32_r_32
+
+TEST_FUNC(test_asri_s32_r_1)
+    asri.s32.r    a0, a0, 1
+    rts
+    .size   test_asri_s32_1, .-test_asri_s32_r_1
+
+TEST_FUNC(test_asri_s32_r_2)
+    asri.s32.r    a0, a0, 2
+    rts
+    .size   test_asri_s32_2, .-test_asri_s32_r_2
+
+TEST_FUNC(test_asri_s32_r_31)
+    asri.s32.r    a0, a0, 31
+    rts
+    .size   test_asri_s32_31, .-test_asri_s32_r_31
+
+TEST_FUNC(test_asr_s32_r)
+    asr.s32.r    a0, a0, a1
+    rts
+    .size   test_asr_s32_r, .-test_asr_s32_r
+
+TEST_FUNC(test_lsri_u32_r_32)
+    lsri.u32.r    a0, a0, 32
+    rts
+    .size   test_lsri_u32_r_32, .-test_lsri_u32_r_32
+
+TEST_FUNC(test_lsri_u32_r_1)
+    lsri.u32.r    a0, a0, 1
+    rts
+    .size   test_lsri_u32_r_1, .-test_lsri_u32_r_1
+
+TEST_FUNC(test_lsri_u32_r_2)
+    lsri.u32.r    a0, a0, 2
+    rts
+    .size   test_lsri_u32_r_2, .-test_lsri_u32_r_2
+
+TEST_FUNC(test_lsri_u32_r_31)
+    lsri.u32.r    a0, a0, 31
+    rts
+    .size   test_lsri_u32_r_31, .-test_lsri_u32_r_31
+
+TEST_FUNC(test_lsr_u32_r)
+    lsr.u32.r    a0, a0, a1
+    rts
+    .size   test_lsr_u32_r, .-test_lsr_u32_r
+
+TEST_FUNC(test_lsli_u32_s_32)
+    lsli.u32.s    a0, a0, 32
+    rts
+    .size   test_lsli_u32_s_32, .-test_lsli_u32_s_32
+
+TEST_FUNC(test_lsli_u32_s_2)
+    lsli.u32.s    a0, a0, 2
+    rts
+    .size   test_lsli_u32_s_2, .-test_lsli_u32_s_2
+
+TEST_FUNC(test_lsli_u32_s_4)
+    lsli.u32.s    a0, a0, 4
+    rts
+    .size   test_lsli_u32_s_4, .-test_lsli_u32_s_4
+
+TEST_FUNC(test_lsli_u32_s_31)
+    lsli.u32.s    a0, a0, 31
+    rts
+    .size   test_lsli_u32_s_31, .-test_lsli_u32_s_31
+
+TEST_FUNC(test_lsli_s32_s_32)
+    lsli.s32.s    a0, a0, 32
+    rts
+    .size   test_lsli_s32_s_32, .-test_lsli_s32_s_32
+
+TEST_FUNC(test_lsli_s32_s_2)
+    lsli.s32.s    a0, a0, 2
+    rts
+    .size   test_lsli_s32_s_2, .-test_lsli_s32_s_2
+
+TEST_FUNC(test_lsli_s32_s_4)
+    lsli.s32.s    a0, a0, 4
+    rts
+    .size   test_lsli_s32_s_4, .-test_lsli_s32_s_4
+
+TEST_FUNC(test_lsli_s32_s_31)
+    lsli.s32.s    a0, a0, 31
+    rts
+    .size   test_lsli_s32_s_31, .-test_lsli_s32_s_31
+
+TEST_FUNC(test_lsl_u32_s)
+    lsl.u32.s    a0, a0, a1
+    rts
+    .size   test_lsl_u32_s, .-test_lsl_u32_s
+
+TEST_FUNC(test_lsl_s32_s)
+    lsl.s32.s    a0, a0, a1
+    rts
+    .size   test_lsl_s32_s, .-test_lsl_s32_s
+
+TEST_FUNC(test_pasri_s16_1)
+    pasri.s16    a0, a0, 1
+    rts
+    .size   test_pasri_s16_1, .-test_pasri_s16_1
+
+TEST_FUNC(test_pasri_s16_2)
+    pasri.s16    a0, a0, 2
+    rts
+    .size   test_pasri_s16_2, .-test_pasri_s16_2
+
+TEST_FUNC(test_pasri_s16_15)
+    pasri.s16    a0, a0, 15
+    rts
+    .size   test_pasri_s16_15, .-test_pasri_s16_15
+
+TEST_FUNC(test_pasri_s16_16)
+    pasri.s16    a0, a0, 16
+    rts
+    .size   test_pasri_s16_16, .-test_pasri_s16_16
+
+TEST_FUNC(test_pasr_s16)
+    pasr.s16    a0, a0, a1
+    rts
+    .size   test_pasr_s16, .-test_pasr_s16
+
+TEST_FUNC(test_pasri_s16_r_1)
+    pasri.s16.r    a0, a0, 1
+    rts
+    .size   test_pasri_s16_r_1, .-test_pasri_s16_r_1
+
+TEST_FUNC(test_pasri_s16_r_2)
+    pasri.s16.r    a0, a0, 2
+    rts
+    .size   test_pasri_s16_r_2, .-test_pasri_s16_r_2
+
+TEST_FUNC(test_pasri_s16_r_15)
+    pasri.s16.r    a0, a0, 15
+    rts
+    .size   test_pasri_s16_r_15, .-test_pasri_s16_r_15
+
+TEST_FUNC(test_pasr_s16_r)
+    pasr.s16.r    a0, a0, a1
+    rts
+    .size   test_pasr_s16_r, .-test_pasr_s16_r
+
+TEST_FUNC(test_plsri_u16_1)
+    plsri.u16    a0, a0, 0x1
+    rts
+    .size   test_plsri_u16_1, .-test_plsri_u16_1
+
+TEST_FUNC(test_plsri_u16_2)
+    plsri.u16    a0, a0, 0x2
+    rts
+    .size   test_plsri_u16_2, .-test_plsri_u16_2
+
+TEST_FUNC(test_plsri_u16_3)
+    plsri.u16    a0, a0, 0x3
+    rts
+    .size   test_plsri_u16_3, .-test_plsri_u16_3
+
+TEST_FUNC(test_plsri_u16_f)
+    plsri.u16    a0, a0, 0xf
+    rts
+    .size   test_plsri_u16_f, .-test_plsri_u16_f
+
+TEST_FUNC(test_plsri_u16_10)
+    plsri.u16    a0, a0, 0x10
+    rts
+    .size   test_plsri_u16_10, .-test_plsri_u16_10
+
+TEST_FUNC(test_plsr_u16)
+    plsr.u16    a0, a0, a1
+    rts
+    .size   test_plsr_u16, .-test_plsr_u16
+
+TEST_FUNC(test_plsri_u16_r_1)
+    plsri.u16.r    a0, a0, 0x1
+    rts
+    .size   test_plsri_u16_r_1, .-test_plsri_u16_r_1
+
+TEST_FUNC(test_plsri_u16_r_2)
+    plsri.u16.r    a0, a0, 0x2
+    rts
+    .size   test_plsri_u16_r_2, .-test_plsri_u16_r_2
+
+TEST_FUNC(test_plsri_u16_r_3)
+    plsri.u16.r    a0, a0, 0x3
+    rts
+    .size   test_plsri_u16_r_3, .-test_plsri_u16_r_3
+
+TEST_FUNC(test_plsri_u16_r_f)
+    plsri.u16.r    a0, a0, 0xf
+    rts
+    .size   test_plsri_u16_r_f, .-test_plsri_u16_r_f
+
+TEST_FUNC(test_plsri_u16_r_10)
+    plsri.u16.r    a0, a0, 0x10
+    rts
+    .size   test_plsri_u16_r_10, .-test_plsri_u16_r_10
+
+TEST_FUNC(test_plsr_u16_r)
+    plsr.u16.r    a0, a0, a1
+    rts
+    .size   test_plsr_u16_r, .-test_plsr_u16_r
+
+TEST_FUNC(test_plsli_u16_1)
+    plsli.u16    a0, a0, 1
+    rts
+    .size   test_plsli_u16_1, .-test_plsli_u16_1
+
+TEST_FUNC(test_plsli_u16_9)
+    plsli.u16    a0, a0, 9
+    rts
+    .size   test_plsli_u16_9, .-test_plsli_u16_9
+
+TEST_FUNC(test_plsli_u16_16)
+    plsli.u16    a0, a0, 16
+    rts
+    .size   test_plsli_u16_16, .-test_plsli_u16_16
+
+TEST_FUNC(test_plsl_u16)
+    plsl.u16    a0, a0, a1
+    rts
+    .size   test_plsl_u16, .-test_plsl_u16
+
+TEST_FUNC(test_plsli_u16_s_1)
+    plsli.u16.s    a0, a0, 1
+    rts
+    .size   test_plsli_u16_s_1, .-test_plsli_u16_s_1
+
+TEST_FUNC(test_plsli_u16_s_2)
+    plsli.u16.s    a0, a0, 2
+    rts
+    .size   test_plsli_u16_s_2, .-test_plsli_u16_s_2
+
+TEST_FUNC(test_plsli_u16_s_9)
+    plsli.u16.s    a0, a0, 9
+    rts
+    .size   test_plsli_u16_s_9, .-test_plsli_u16_s_9
+
+TEST_FUNC(test_plsli_u16_s_16)
+    plsli.u16.s    a0, a0, 16
+    rts
+    .size   test_plsli_u16_s_16, .-test_plsli_u16_s_16
+
+TEST_FUNC(test_plsl_u16_s)
+    plsl.u16.s    a0, a0, a1
+    rts
+    .size   test_plsl_u16_s, .-test_plsl_u16_s
+
+TEST_FUNC(test_plsli_s16_s_1)
+    plsli.s16.s    a0, a0, 1
+    rts
+    .size   test_plsli_s16_s_1, .-test_plsli_s16_s_1
+
+TEST_FUNC(test_plsli_s16_s_2)
+    plsli.s16.s    a0, a0, 2
+    rts
+    .size   test_plsli_s16_s_2, .-test_plsli_s16_s_2
+
+TEST_FUNC(test_plsli_s16_s_9)
+    plsli.s16.s    a0, a0, 9
+    rts
+    .size   test_plsli_s16_s_9, .-test_plsli_s16_s_9
+
+TEST_FUNC(test_plsli_s16_s_16)
+    plsli.s16.s    a0, a0, 16
+    rts
+    .size   test_plsli_s16_s_16, .-test_plsli_s16_s_16
+
+TEST_FUNC(test_plsl_s16_s)
+    plsl.s16.s    a0, a0, a1
+    rts
+    .size   test_plsl_s16_s, .-test_plsl_s16_s
+
+TEST_FUNC(test_pcmpne_8)
+    pcmpne.8    a0, a0, a1
+    rts
+    .size   test_pcmpne_8, .-test_pcmpne_8
+
+TEST_FUNC(test_pcmpne_16)
+    pcmpne.16    a0, a0, a1
+    rts
+    .size   test_pcmpne_16, .-test_pcmpne_16
+
+TEST_FUNC(test_pcmphs_u8)
+    pcmphs.u8    a0, a0, a1
+    rts
+    .size   test_pcmphs_u8, .-test_pcmphs_u8
+
+TEST_FUNC(test_pcmphs_s8)
+    pcmphs.s8    a0, a0, a1
+    rts
+    .size   test_pcmphs_s8, .-test_pcmphs_s8
+
+TEST_FUNC(test_pcmphs_u16)
+    pcmphs.u16    a0, a0, a1
+    rts
+    .size   test_pcmphs_u16, .-test_pcmphs_u16
+
+TEST_FUNC(test_pcmphs_s16)
+    pcmphs.s16    a0, a0, a1
+    rts
+    .size   test_pcmphs_s16, .-test_pcmphs_s16
+
+TEST_FUNC(test_pcmplt_u8)
+    pcmplt.u8    a0, a0, a1
+    rts
+    .size   test_pcmplt_u8, .-test_pcmplt_u8
+
+TEST_FUNC(test_pcmplt_s8)
+    pcmplt.s8    a0, a0, a1
+    rts
+    .size   test_pcmplt_s8, .-test_pcmplt_s8
+
+TEST_FUNC(test_pcmplt_u16)
+    pcmplt.u16    a0, a0, a1
+    rts
+    .size   test_pcmplt_u16, .-test_pcmplt_u16
+
+TEST_FUNC(test_pcmplt_s16)
+    pcmplt.s16    a0, a0, a1
+    rts
+    .size   test_pcmplt_s16, .-test_pcmplt_s16
+
+TEST_FUNC(test_pmax_u8)
+    pmax.u8    a0, a0, a1
+    rts
+    .size   test_pmax_u8, .-test_pmax_u8
+
+TEST_FUNC(test_pmax_s8)
+    pmax.s8    a0, a0, a1
+    rts
+    .size   test_pmax_s8, .-test_pmax_s8
+
+TEST_FUNC(test_pmax_u16)
+    pmax.u16    a0, a0, a1
+    rts
+    .size   test_pmax_u16, .-test_pmax_u16
+
+TEST_FUNC(test_pmax_s16)
+    pmax.s16    a0, a0, a1
+    rts
+    .size   test_pmax_s16, .-test_pmax_s16
+
+TEST_FUNC(test_max_u32)
+    max.u32    a0, a0, a1
+    rts
+    .size   test_max_u32, .-test_max_u32
+
+TEST_FUNC(test_max_s32)
+    max.s32    a0, a0, a1
+    rts
+    .size   test_max_s32, .-test_max_s32
+
+TEST_FUNC(test_pmin_u8)
+    pmin.u8    a0, a0, a1
+    rts
+    .size   test_pmin_u8, .-test_pmin_u8
+
+TEST_FUNC(test_pmin_s8)
+    pmin.s8    a0, a0, a1
+    rts
+    .size   test_pmin_s8, .-test_pmin_s8
+
+TEST_FUNC(test_pmin_u16)
+    pmin.u16    a0, a0, a1
+    rts
+    .size   test_pmin_u16, .-test_pmin_u16
+
+TEST_FUNC(test_pmin_s16)
+    pmin.s16    a0, a0, a1
+    rts
+    .size   test_pmin_s16, .-test_pmin_s16
+
+TEST_FUNC(test_min_u32)
+    min.u32    a0, a0, a1
+    rts
+    .size   test_min_u32, .-test_min_u32
+
+TEST_FUNC(test_min_s32)
+    min.s32    a0, a0, a1
+    rts
+    .size   test_min_s32, .-test_min_s32
+
+TEST_FUNC(test_pkgll)
+    pkgll    a0, a0, a1
+    rts
+    .size   test_pkgll, .-test_pkgll
+
+TEST_FUNC(test_pkghh)
+    pkghh    a0, a0, a1
+    rts
+    .size   test_pkghh, .-test_pkghh
+
+TEST_FUNC(test_narl)
+    narl    a0, a0, a1
+    rts
+    .size   test_narl, .-test_narl
+
+TEST_FUNC(test_narh)
+    narh    a0, a0, a1
+    rts
+    .size   test_narh, .-test_narh
+
+TEST_FUNC(test_narlx)
+    narlx    a0, a0, a1
+    rts
+    .size   test_narlx, .-test_narlx
+
+TEST_FUNC(test_narhx)
+    narhx    a0, a0, a1
+    rts
+    .size   test_narhx, .-test_narhx
+
+TEST_FUNC(test_clipi_u32_0)
+    clipi.u32    a0, a0, 0
+    rts
+    .size   test_clipi_u32_0, .-test_clipi_u32_0
+
+TEST_FUNC(test_clipi_u32_1)
+    clipi.u32    a0, a0, 1
+    rts
+    .size   test_clipi_u32_1, .-test_clipi_u32_1
+
+TEST_FUNC(test_clipi_u32_5)
+    clipi.u32    a0, a0, 5
+    rts
+    .size   test_clipi_u32_5, .-test_clipi_u32_5
+
+TEST_FUNC(test_clipi_u32_2)
+    clipi.u32    a0, a0, 2
+    rts
+    .size   test_clipi_u32_2, .-test_clipi_u32_2
+
+TEST_FUNC(test_clipi_u32_31)
+    clipi.u32    a0, a0, 31
+    rts
+    .size   test_clipi_u32_31, .-test_clipi_u32_31
+
+TEST_FUNC(test_clipi_s32_0)
+    clipi.s32    a0, a0, 0
+    rts
+    .size   test_clipi_s32_0, .-test_clipi_s32_0
+
+TEST_FUNC(test_clipi_s32_1)
+    clipi.s32    a0, a0, 1
+    rts
+    .size   test_clipi_s32_1, .-test_clipi_s32_1
+
+TEST_FUNC(test_clipi_s32_2)
+    clipi.s32    a0, a0, 2
+    rts
+    .size   test_clipi_s32_2, .-test_clipi_s32_2
+
+TEST_FUNC(test_clipi_s32_5)
+    clipi.s32    a0, a0, 5
+    rts
+    .size   test_clipi_s32_5, .-test_clipi_s32_5
+
+TEST_FUNC(test_clipi_s32_6)
+    clipi.s32    a0, a0, 6
+    rts
+    .size   test_clipi_s32_6, .-test_clipi_s32_6
+
+TEST_FUNC(test_clipi_s32_31)
+    clipi.s32    a0, a0, 31
+    rts
+    .size   test_clipi_s32_31, .-test_clipi_s32_31
+
+TEST_FUNC(test_clip_u32)
+    clip.u32    a0, a0, a1
+    rts
+    .size   test_clip_u32, .-test_clip_u32
+
+TEST_FUNC(test_clip_s32)
+    clip.s32    a0, a0, a1
+    rts
+    .size   test_clip_s32, .-test_clip_s32
+
+TEST_FUNC(test_pclipi_u16_0)
+    pclipi.u16    a0, a0, 0
+    rts
+    .size   test_pclipi_u16_0, .-test_pclipi_u16_0
+
+TEST_FUNC(test_pclipi_u16_1)
+    pclipi.u16    a0, a0, 1
+    rts
+    .size   test_pclipi_u16_1, .-test_pclipi_u16_1
+
+TEST_FUNC(test_pclipi_u16_2)
+    pclipi.u16    a0, a0, 2
+    rts
+    .size   test_pclipi_u16_2, .-test_pclipi_u16_2
+
+TEST_FUNC(test_pclipi_u16_7)
+    pclipi.u16    a0, a0, 7
+    rts
+    .size   test_pclipi_u16_7, .-test_pclipi_u16_7
+
+TEST_FUNC(test_pclipi_u16_15)
+    pclipi.u16    a0, a0, 15
+    rts
+    .size   test_pclipi_u16_15, .-test_pclipi_u16_15
+
+TEST_FUNC(test_pclip_u16)
+    pclip.u16    a0, a0, a1
+    rts
+    .size   test_pclip_u16, .-test_pclip_u16
+
+TEST_FUNC(test_pclipi_s16_0)
+    pclipi.s16    a0, a0, 0
+    rts
+    .size   test_pclipi_s16_0, .-test_pclipi_s16_0
+
+TEST_FUNC(test_pclipi_s16_1)
+    pclipi.s16    a0, a0, 1
+    rts
+    .size   test_pclipi_s16_1, .-test_pclipi_s16_1
+
+TEST_FUNC(test_pclipi_s16_2)
+    pclipi.s16    a0, a0, 2
+    rts
+    .size   test_pclipi_s16_2, .-test_pclipi_s16_2
+
+TEST_FUNC(test_pclipi_s16_7)
+    pclipi.s16    a0, a0, 7
+    rts
+    .size   test_pclipi_s16_7, .-test_pclipi_s16_7
+
+TEST_FUNC(test_pclipi_s16_15)
+    pclipi.s16    a0, a0, 15
+    rts
+    .size   test_pclipi_s16_15, .-test_pclipi_s16_15
+
+TEST_FUNC(test_pclip_s16)
+    pclip.s16    a0, a0, a1
+    rts
+    .size   test_pclip_s16, .-test_pclip_s16
+
+TEST_FUNC(test_dup_8_0)
+    dup.8    a0, a0, 0
+    rts
+    .size   test_dup_8_0, .-test_dup_8_0
+
+TEST_FUNC(test_dup_8_1)
+    dup.8    a0, a0, 1
+    rts
+    .size   test_dup_8_1, .-test_dup_8_1
+
+TEST_FUNC(test_dup_8_2)
+    dup.8    a0, a0, 2
+    rts
+    .size   test_dup_8_2, .-test_dup_8_2
+
+TEST_FUNC(test_dup_8_3)
+    dup.8    a0, a0, 3
+    rts
+    .size   test_dup_8_3, .-test_dup_8_3
+
+TEST_FUNC(test_dup_16_0)
+    dup.16    a0, a0, 0
+    rts
+    .size   test_dup_16_0, .-test_dup_16_0
+
+TEST_FUNC(test_dup_16_1)
+    dup.16    a0, a0, 1
+    rts
+    .size   test_dup_16_1, .-test_dup_16_1
+
+TEST_FUNC(test_psabsa_u8)
+    psabsa.u8    a0, a0, a1
+    rts
+    .size   test_psabsa_u8, .-test_psabsa_u8
+
+TEST_FUNC(test_mulaca_s8)
+    mulaca.s8    a0, a0, a1
+    rts
+    .size   test_mulaca_s8, .-test_mulaca_s8
+
+TEST_FUNC(test_pabs_s8_s)
+    pabs.s8.s    a0,a0
+    rts
+    .size   test_pabs_s8_s, .-test_pabs_s8_s
+
+TEST_FUNC(test_pabs_s16_s)
+    pabs.s16.s    a0,a0
+    rts
+    .size   test_pabs_s16_s, .-test_pabs_s16_s
+
+TEST_FUNC(test_abs_s32_s)
+    abs.s32.s    a0,a0
+    rts
+    .size   test_abs_s32_s, .-test_abs_s32_s
+
+TEST_FUNC(test_pneg_s8_s)
+    pneg.s8.s    a0,a0
+    rts
+    .size   test_pneg_s8_s, .-test_pneg_s8_s
+
+TEST_FUNC(test_pneg_s16_s)
+    pneg.s16.s    a0,a0
+    rts
+    .size   test_pneg_s16_s, .-test_pneg_s16_s
+
+TEST_FUNC(test_neg_s32_s)
+    neg.s32.s    a0,a0
+    rts
+    .size   test_neg_s32_s, .-test_neg_s32_s
+
+TEST_FUNC(test_pext_u8_e)
+    pext.u8.e    a0,a0
+    rts
+    .size   test_pext_u8_e, .-test_pext_u8_e
+
+TEST_FUNC(test_pext_s8_e)
+    pext.s8.e    a0,a0
+    rts
+    .size   test_pext_s8_e, .-test_pext_s8_e
+
+TEST_FUNC(test_pextx_u8_e)
+    pextx.u8.e    a0,a0
+    rts
+    .size   test_pextx_u8_e, .-test_pextx_u8_e
+
+TEST_FUNC(test_pextx_s8_e)
+    pextx.s8.e    a0,a0
+    rts
+    .size   test_pextx_s8_e, .-test_pextx_s8_e
+
+TEST_FUNC(test_sel)
+    sel    a3, a0, a1, a2
+    mov    a0, a3
+    rts
+    .size   test_sel, .-test_sel
+
+TEST_FUNC(test_dexti_0)
+    dexti    a2, a0, a1, 0
+    mov    a0, a2
+    rts
+    .size   test_dexti_0, .-test_dexti_0
+
+TEST_FUNC(test_dexti_2)
+    dexti    a2, a0, a1, 2
+    mov    a0, a2
+    rts
+    .size   test_dexti_2, .-test_dexti_2
+
+TEST_FUNC(test_dexti_5)
+    dexti    a2, a0, a1, 5
+    mov    a0, a2
+    rts
+    .size   test_dexti_5, .-test_dexti_5
+
+TEST_FUNC(test_dexti_31)
+    dexti    a2, a0, a1, 31
+    mov    a0, a2
+    rts
+    .size   test_dexti_31, .-test_dexti_31
+
+TEST_FUNC(test_dext)
+    dext    a3, a0, a1, a2
+    mov    a0, a3
+    rts
+    .size   test_dext, .-test_dext
+
+TEST_FUNC(test_psabsaa_u8)
+    psabsaa.u8    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_psabsaa_u8, .-test_psabsaa_u8
+
+TEST_FUNC(test_divul)
+    divul    a0,a0,a2
+    rts
+    .size   test_divul, .-test_divul
+
+TEST_FUNC(test_divsl)
+    divsl    a0,a0,a2
+    rts
+    .size   test_divsl, .-test_divsl
+
+TEST_FUNC(test_pkg_4_16)
+    pkg    a0, a0, 4, a1, 16
+    rts
+    .size   test_pkg_4_16, .-test_pkg_4_16
+
+TEST_FUNC(test_pkg_2_3)
+    pkg    a0, a0, 2, a1, 3
+    rts
+    .size   test_pkg_2_13, .-test_pkg_2_3
+
+TEST_FUNC(test_pkg_4_4)
+    pkg    a0, a0, 4, a1, 4
+    rts
+    .size   test_pkg_4_4, .-test_pkg_4_4
+
+TEST_FUNC(test_pkg_8_8)
+    pkg    a0, a0, 8, a1, 8
+    rts
+    .size   test_pkg_8_8, .-test_pkg_8_8
+
+TEST_FUNC(test_pkg_0_15)
+    pkg    a0, a0, 0, a1, 15
+    rts
+    .size   test_pkg_0_15, .-test_pkg_0_15
+
+TEST_FUNC(test_pkg_15_15)
+    pkg    a0, a0, 15, a1, 15
+    rts
+    .size   test_pkg_15_15, .-test_pkg_15_15
+
+TEST_FUNC(test_muls_u32)
+    muls.u32    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_muls_u32, .-test_muls_u32
+
+TEST_FUNC(test_muls_s32)
+    muls.s32    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_muls_s32, .-test_muls_s32
+
+TEST_FUNC(test_mula_u32_s)
+    mula.u32.s    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mula_u32_s, .-test_mula_u32_s
+
+TEST_FUNC(test_mula_s32_s)
+    mula.s32.s    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mula_s32_s, .-test_mula_s32_s
+
+TEST_FUNC(test_muls_u32_s)
+    muls.u32.s    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_muls_u32_s, .-test_muls_u32_s
+
+TEST_FUNC(test_muls_s32_s)
+    muls.s32.s    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_muls_s32_s, .-test_muls_s32_s
+
+TEST_FUNC(test_rmul_s32_h)
+    rmul.s32.h    a0, a0, a1
+    rts
+    .size   test_rmul_s32_h, .-test_rmul_s32_h
+
+TEST_FUNC(test_rmul_s32_rh)
+    rmul.s32.rh    a0, a0, a1
+    rts
+    .size   test_rmul_s32_rh, .-test_rmul_s32_rh
+
+TEST_FUNC(test_mula_s32_hs)
+    mula.s32.hs    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mula_s32_hs, .-test_mula_s32_hs
+
+TEST_FUNC(test_muls_s32_hs)
+    muls.s32.hs    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_muls_s32_hs, .-test_muls_s32_hs
+
+TEST_FUNC(test_mula_s32_rhs)
+    mula.s32.rhs    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mula_s32_rhs, .-test_mula_s32_rhs
+
+TEST_FUNC(test_muls_s32_rhs)
+    muls.s32.rhs    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_muls_s32_rhs, .-test_muls_s32_rhs
+
+TEST_FUNC(test_mulxl_s32)
+    mulxl.s32    a0, a0, a1
+    rts
+    .size   test_mulxl_s32, .-test_mulxl_s32
+
+TEST_FUNC(test_mulxl_s32_r)
+    mulxl.s32.r    a0, a0, a1
+    rts
+    .size   test_mulxl_s32_r, .-test_mulxl_s32_r
+
+TEST_FUNC(test_mulxh_s32)
+    mulxh.s32    a0, a0, a1
+    rts
+    .size   test_mulxh_s32, .-test_mulxh_s32
+
+TEST_FUNC(test_mulxh_s32_r)
+    mulxh.s32.r    a0, a0, a1
+    rts
+    .size   test_mulxh_s32_r, .-test_mulxh_s32_r
+
+TEST_FUNC(test_rmulxl_s32)
+    rmulxl.s32    a0, a0, a1
+    rts
+    .size   test_rmulxl_s32, .-test_rmulxl_s32
+
+TEST_FUNC(test_rmulxl_s32_r)
+    rmulxl.s32.r    a0, a0, a1
+    rts
+    .size   test_rmulxl_s32_r, .-test_rmulxl_s32_r
+
+TEST_FUNC(test_rmulxh_s32)
+    rmulxh.s32    a0, a0, a1
+    rts
+    .size   test_rmulxh_s32, .-test_rmulxh_s32
+
+TEST_FUNC(test_rmulxh_s32_r)
+    rmulxh.s32.r    a0, a0, a1
+    rts
+    .size   test_rmulxh_s32_r, .-test_rmulxh_s32_r
+
+TEST_FUNC(test_mulaxl_s32_s)
+    mulaxl.s32.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulaxl_s32_s, .-test_mulaxl_s32_s
+
+TEST_FUNC(test_mulaxl_s32_rs)
+    mulaxl.s32.rs    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulaxl_s32_rs, .-test_mulaxl_s32_rs
+
+TEST_FUNC(test_mulaxh_s32_s)
+    mulaxh.s32.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulaxh_s32_s, .-test_mulaxh_s32_s
+
+TEST_FUNC(test_mulaxh_s32_rs)
+    mulaxh.s32.rs    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulaxh_s32_rs, .-test_mulaxh_s32_rs
+
+TEST_FUNC(test_rmulll_s16)
+    rmulll.s16    a0, a0, a1
+    rts
+    .size   test_rmulll_s16, .-test_rmulll_s16
+
+TEST_FUNC(test_rmulhh_s16)
+    rmulhh.s16    a0, a0, a1
+    rts
+    .size   test_rmulhh_s16, .-test_rmulhh_s16
+
+TEST_FUNC(test_rmulhl_s16)
+    rmulhl.s16    a0, a0, a1
+    rts
+    .size   test_rmulhl_s16, .-test_rmulhl_s16
+
+TEST_FUNC(test_mulall_s16_s)
+    mulall.s16.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulall_s16_s, .-test_mulall_s16_s
+
+TEST_FUNC(test_mulahh_s16_s)
+    mulahh.s16.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulahh_s16_s, .-test_mulahh_s16_s
+
+TEST_FUNC(test_mulahl_s16_s)
+    mulahl.s16.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulahl_s16_s, .-test_mulahl_s16_s
+
+TEST_FUNC(test_mulall_s16_e)
+    mulall.s16.e    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mulall_s16_e, .-test_mulall_s16_e
+
+TEST_FUNC(test_mulahl_s16_e)
+    mulahl.s16.e    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mulahl_s16_e, .-test_mulahl_s16_e
+
+TEST_FUNC(test_mulahh_s16_e)
+    mulahh.s16.e    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mulahh_s16_e, .-test_mulahh_s16_e
+
+TEST_FUNC(test_pmul_s16)
+    pmul.s16    a0, a0, a1
+    rts
+    .size   test_pmul_s16, .-test_pmul_s16
+
+TEST_FUNC(test_pmul_u16)
+    pmul.u16    a0, a0, a1
+    rts
+    .size   test_pmul_u16, .-test_pmul_u16
+
+TEST_FUNC(test_pmulx_s16)
+    pmulx.s16    a0, a0, a1
+    rts
+    .size   test_pmulx_s16, .-test_pmulx_s16
+
+TEST_FUNC(test_pmulx_u16)
+    pmulx.u16    a0, a0, a1
+    rts
+    .size   test_pmulx_u16, .-test_pmulx_u16
+
+TEST_FUNC(test_prmul_s16)
+    prmul.s16    a0, a0, a1
+    rts
+    .size   test_prmul_s16, .-test_prmul_s16
+
+TEST_FUNC(test_prmulx_s16)
+    prmulx.s16    a0, a0, a1
+    rts
+    .size   test_prmulx_s16, .-test_prmulx_s16
+
+TEST_FUNC(test_prmul_s16_h)
+    prmul.s16.h    a0, a0, a1
+    rts
+    .size   test_prmul_s16_h, .-test_prmul_s16_h
+
+TEST_FUNC(test_prmul_s16_rh)
+    prmul.s16.rh    a0, a0, a1
+    rts
+    .size   test_prmul_s16_rh, .-test_prmul_s16_rh
+
+TEST_FUNC(test_prmulx_s16_h)
+    prmulx.s16.h    a0, a0, a1
+    rts
+    .size   test_prmulx_s16_h, .-test_prmulx_s16_h
+
+TEST_FUNC(test_prmulx_s16_rh)
+    prmulx.s16.rh    a0, a0, a1
+    rts
+    .size   test_prmulx_s16_rh, .-test_prmulx_s16_rh
+
+TEST_FUNC(test_mulca_s16_s)
+    mulca.s16.s    a0, a0, a1
+    rts
+    .size   test_mulca_s16_s, .-test_mulca_s16_s
+
+TEST_FUNC(test_mulcax_s16_s)
+    mulcax.s16.s    a0, a0, a1
+    rts
+    .size   test_mulcax_s16_s, .-test_mulcax_s16_s
+
+TEST_FUNC(test_mulcs_s16)
+    mulcs.s16    a0, a0, a1
+    rts
+    .size   test_mulcs_s16, .-test_mulcs_s16
+
+TEST_FUNC(test_mulcsr_s16)
+    mulcsr.s16    a0, a0, a1
+    rts
+    .size   test_mulcsr_s16, .-test_mulcsr_s16
+
+TEST_FUNC(test_mulcsx_s16)
+    mulcsx.s16    a0, a0, a1
+    rts
+    .size   test_mulcsx_s16, .-test_mulcsx_s16
+
+TEST_FUNC(test_mulaca_s16_s)
+    mulaca.s16.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulaca_s16_s, .-test_mulaca_s16_s
+
+TEST_FUNC(test_mulacax_s16_s)
+    mulacax.s16.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulacax_s16_s, .-test_mulacax_s16_s
+
+TEST_FUNC(test_mulacs_s16_s)
+    mulacs.s16.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulacs_s16_s, .-test_mulacs_s16_s
+
+TEST_FUNC(test_mulacsr_s16_s)
+    mulacsr.s16.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulacsr_s16_s, .-test_mulacsr_s16_s
+
+TEST_FUNC(test_mulacsx_s16_s)
+    mulacsx.s16.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulacsx_s16_s, .-test_mulacsx_s16_s
+
+TEST_FUNC(test_mulsca_s16_s)
+    mulsca.s16.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulsca_s16_s, .-test_mulsca_s16_s
+
+TEST_FUNC(test_mulscax_s16_s)
+    mulscax.s16.s    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mulscax_s16_s, .-test_mulscax_s16_s
+
+TEST_FUNC(test_mulaca_s16_e)
+    mulaca.s16.e    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mulaca_s16_e, .-test_mulaca_s16_e
+
+TEST_FUNC(test_mulacax_s16_e)
+    mulacax.s16.e    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mulacax_s16_e, .-test_mulacax_s16_e
+
+TEST_FUNC(test_mulacs_s16_e)
+    mulacs.s16.e    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mulacs_s16_e, .-test_mulacs_s16_e
+
+TEST_FUNC(test_mulacsr_s16_e)
+    mulacsr.s16.e    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mulacsr_s16_e, .-test_mulacsr_s16_e
+
+TEST_FUNC(test_mulacsx_s16_e)
+    mulacsx.s16.e    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mulacsx_s16_e, .-test_mulacsx_s16_e
+
+TEST_FUNC(test_mulsca_s16_e)
+    mulsca.s16.e    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mulsca_s16_e, .-test_mulsca_s16_e
+
+TEST_FUNC(test_mulscax_s16_e)
+    mulscax.s16.e    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mulscax_s16_e, .-test_mulscax_s16_e
+
+TEST_FUNC(test_mul_u32)
+    mul.u32    a0, a0, a1
+    rts
+    .size   test_mul_u32, .-test_mul_u32
+
+TEST_FUNC(test_mul_s32)
+    mul.s32    a0, a0, a1
+    rts
+    .size   test_mul_s32, .-test_mul_s32
+
+TEST_FUNC(test_mula_u32)
+    mula.u32    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mula_u32, .-test_mula_u32
+
+TEST_FUNC(test_mula_s32)
+    mula.s32    a2, a0, a1
+    mov    a0, a2
+    mov    a1, a3
+    rts
+    .size   test_mula_s32, .-test_mula_s32
+
+TEST_FUNC(test_mula_32_l)
+    mula.32.l    a2, a0, a1
+    mov    a0, a2
+    rts
+    .size   test_mula_32_l, .-test_mula_32_l
+
+TEST_FUNC(test_mul_s32_h)
+    mul.s32.h    a0, a0, a1
+    rts
+    .size   test_mul_s32_h, .-test_mul_s32_h
+
+TEST_FUNC(test_mul_s32_rh)
+    mul.s32.rh    a0, a0, a1
+    rts
+    .size   test_mul_s32_rh, .-test_mul_s32_rh
+
+TEST_FUNC(test_mulll_s16)
+    mulll.s16    a0, a0, a1
+    rts
+    .size   test_mulll_s16, .-test_mulll_s16
+
+TEST_FUNC(test_mulhh_s16)
+    mulhh.s16    a0, a0, a1
+    rts
+    .size   test_mulhh_s16, .-test_mulhh_s16
+
+TEST_FUNC(test_mulhl_s16)
+    mulhl.s16    a0, a0, a1
+    rts
+    .size   test_mulhl_s16, .-test_mulhl_s16
+
+    .text
+    .align 2
+LD_DATA:
+    .long  0xC0C0C0C0
+    .long  0x00010001
+
+TEST_FUNC(test_ldbi_w)
+    grs a2, LD_DATA
+    mov a3, a2
+    ldbi.w a0, (a3)
+    subi a3, a3, 4
+    cmpne a2, a3
+    bf l_ldbi_w
+    movi a0, 0
+l_ldbi_w:
+    rts
+    .size  test_ldbi_w, .-test_ldbi_w
+
+TEST_FUNC(test_ldbi_h)
+    grs a2, LD_DATA
+    mov a3, a2
+    ldbi.h a0, (a3)
+    subi a3, a3, 2
+    cmpne a2, a3
+    bf l_ldbi_h
+    movi a0, 0
+l_ldbi_h:
+    rts
+    .size  test_ldbi_h, .-test_ldbi_h
+
+TEST_FUNC(test_ldbi_hs)
+    grs a2, LD_DATA
+    mov a3, a2
+    ldbi.hs a0, (a3)
+    subi a3, a3, 2
+    cmpne a2, a3
+    bf l_ldbi_hs
+    movi a0, 0
+l_ldbi_hs:
+    rts
+    .size  test_ldbi_hs, .-test_ldbi_hs
+
+TEST_FUNC(test_ldbi_b)
+    grs a2, LD_DATA
+    mov a3, a2
+    ldbi.b a0, (a3)
+    subi a3, a3, 1
+    cmpne a2, a3
+    bf l_ldbi_b
+    movi a0, 0
+l_ldbi_b:
+    rts
+    .size  test_ldbi_b, .-test_ldbi_b
+
+TEST_FUNC(test_ldbi_bs)
+    grs a2, LD_DATA
+    mov a3, a2
+    ldbi.bs a0, (a3)
+    subi a3, a3, 1
+    cmpne a2, a3
+    bf l_ldbi_bs
+    movi a0, 0
+l_ldbi_bs:
+    rts
+    .size  test_ldbi_bs, .-test_ldbi_bs
+
+TEST_FUNC(test_pldbi_d)
+    grs a2, LD_DATA
+    mov a3, a2
+    pldbi.d a0, (a3)
+    subi a3, a3, 8
+    cmpne a2, a3
+    bf l_pldbi_d
+    movi a0, 0
+l_pldbi_d:
+    rts
+    .size  test_pdbi_d, .-test_pldbi_d
+
+TEST_FUNC(test_ldbir_w)
+    mov a2, a0
+    grs a3, LD_DATA
+    ldbir.w a0, (a3), a2
+    sub a2, a3, a2
+    grs a3, LD_DATA
+    cmpne a2, a3
+    bf l_ldbir_w
+    movi a0, 0
+l_ldbir_w:
+    rts
+    .size  test_ldbir_w, .-test_ldbir_w
+
+TEST_FUNC(test_ldbir_h)
+    mov a2, a0
+    grs a3, LD_DATA
+    ldbir.h a0, (a3), a2
+    sub a2, a3, a2
+    grs a3, LD_DATA
+    cmpne a2, a3
+    bf l_ldbir_h
+    movi a0, 0
+l_ldbir_h:
+    rts
+    .size  test_ldbir_h, .-test_ldbir_h
+
+TEST_FUNC(test_ldbir_hs)
+    mov a2, a0
+    grs a3, LD_DATA
+    ldbir.hs a0, (a3), a2
+    sub a2, a3, a2
+    grs a3, LD_DATA
+    cmpne a2, a3
+    bf l_ldbir_hs
+    movi a0, 0
+l_ldbir_hs:
+    rts
+    .size  test_ldbir_hs, .-test_ldbir_hs
+
+TEST_FUNC(test_ldbir_b)
+    mov a2, a0
+    grs a3, LD_DATA
+    ldbir.b a0, (a3), a2
+    sub a2, a3, a2
+    grs a3, LD_DATA
+    cmpne a2, a3
+    bf l_ldbir_b
+    movi a0, 0
+l_ldbir_b:
+    rts
+    .size  test_ldbir_b, .-test_ldbir_b
+
+TEST_FUNC(test_ldbir_bs)
+    mov a2, a0
+    grs a3, LD_DATA
+    ldbir.bs a0, (a3), a2
+    sub a2, a3, a2
+    grs a3, LD_DATA
+    cmpne a2, a3
+    bf l_ldbir_bs
+    movi a0, 0
+l_ldbir_bs:
+    rts
+    .size  test_ldbir_bs, .-test_ldbir_bs
+
+TEST_FUNC(test_pldbir_d)
+    mov a2, a0
+    grs a3, LD_DATA
+    pldbir.d a0, (a3), a2
+    add a2, a2, a2
+    sub a2, a3, a2
+    grs a3, LD_DATA
+    cmpne a2, a3
+    bf l_pldbir_d
+    movi a0, 0
+l_pldbir_d:
+    rts
+    .size  test_pdbi_d, .-test_pldbir_d
+
+TEST_FUNC(test_stbi_w)
+    mov a2, a0
+    stbi.w a1, (a0)
+    subi a0, a0, 4
+    cmpne a2, a0
+    bf l_stbi_w
+    movi a0, 0
+l_stbi_w:
+    rts
+    .size  test_stbi_w, .-test_stbi_w
+
+TEST_FUNC(test_stbi_h)
+    mov a2, a0
+    stbi.h a1, (a0)
+    subi a0, a0, 2
+    cmpne a2, a0
+    bf l_stbi_h
+    movi a0, 0
+l_stbi_h:
+    rts
+    .size  test_stbi_h, .-test_stbi_h
+
+TEST_FUNC(test_stbi_b)
+    mov a2, a0
+    stbi.b a1, (a0)
+    subi a0, a0, 1
+    cmpne a2, a0
+    bf l_stbi_b
+    movi a0, 0
+l_stbi_b:
+    rts
+    .size  test_stbi_b, .-test_stbi_b
+
+TEST_FUNC(test_stbir_w)
+    mov a3, a0
+    stbir.w a2, (a0), a1
+    sub a0, a0, a1
+    cmpne a3, a0
+    bf l_stbir_w
+    movi a0, 0
+l_stbir_w:
+    rts
+    .size  test_stbir_w, .-test_stbir_w
+
+TEST_FUNC(test_stbir_h)
+    mov a3, a0
+    stbir.h a2, (a0), a1
+    sub a0, a0, a1
+    cmpne a3, a0
+    bf l_stbir_h
+    movi a0, 0
+l_stbir_h:
+    rts
+    .size  test_stbir_h, .-test_stbir_h
+
+TEST_FUNC(test_stbir_b)
+    mov a3, a0
+    stbir.b a2, (a0), a1
+    sub a0, a0, a1
+    cmpne a3, a0
+    bf l_stbir_b
+    movi a0, 0
+l_stbir_b:
+    rts
+    .size  test_stbir_b, .-test_stbir_b
+TEST_FUNC(test_bloop)
+l_bloop_begin:
+    subu a3,a2
+l_bloop_end:
+    bloop a0, l_bloop_begin, l_bloop_end
+    cmpne a3, a1
+    bf l_bloop_exit
+    mov a0,a3
+l_bloop_exit:
+    rts
+    .size  test_bloop, .-test_bloop
diff --git a/tests/csky/dspv2/case/dspv2_insn.h b/tests/csky/dspv2/case/dspv2_insn.h
new file mode 100644
index 0000000..a7c7413
--- /dev/null
+++ b/tests/csky/dspv2/case/dspv2_insn.h
@@ -0,0 +1,279 @@
+#ifndef DSPV2_INSN_H
+#define DSPV2_INSN_H
+int32_t test_psub_8(int32_t a, int32_t b);
+int32_t test_psub_16(int32_t a, int32_t b);
+int32_t test_padd_8(int32_t a, int32_t b);
+int32_t test_padd_16(int32_t a, int32_t b);
+int32_t test_pasx_16(int32_t a, int32_t b);
+int32_t test_psax_16(int32_t a, int32_t b);
+int32_t test_padd_u8_s(int32_t a, int32_t b);
+int32_t test_padd_s8_s(int32_t a, int32_t b);
+int32_t test_padd_u16_s(int32_t a, int32_t b);
+int32_t test_padd_s16_s(int32_t a, int32_t b);
+int32_t test_add_u32_s(int32_t a, int32_t b);
+int32_t test_add_s32_s(int32_t a, int32_t b);
+int32_t test_psub_u8_s(int32_t a, int32_t b);
+int32_t test_psub_s8_s(int32_t a, int32_t b);
+int32_t test_psub_u16_s(int32_t a, int32_t b);
+int32_t test_psub_s16_s(int32_t a, int32_t b);
+int32_t test_sub_u32_s(int32_t a, int32_t b);
+int32_t test_sub_s32_s(int32_t a, int32_t b);
+int32_t test_addh_u32(int32_t a, int32_t b);
+int32_t test_addh_s32(int32_t a, int32_t b);
+int32_t test_paddh_u8(int32_t a, int32_t b);
+int32_t test_paddh_s8(int32_t a, int32_t b);
+int32_t test_paddh_u16(int32_t a, int32_t b);
+int32_t test_paddh_s16(int32_t a, int32_t b);
+int32_t test_subh_u32(int32_t a, int32_t b);
+int32_t test_subh_s32(int32_t a, int32_t b);
+int32_t test_psubh_u8(int32_t a, int32_t b);
+int32_t test_psubh_s8(int32_t a, int32_t b);
+int32_t test_psubh_u16(int32_t a, int32_t b);
+int32_t test_psubh_s16(int32_t a, int32_t b);
+int32_t test_pasx_u16_s(int32_t a, int32_t b);
+int32_t test_pasx_s16_s(int32_t a, int32_t b);
+int32_t test_psax_u16_s(int32_t a, int32_t b);
+int32_t test_psax_s16_s(int32_t a, int32_t b);
+int32_t test_pasxh_u16(int32_t a, int32_t b);
+int32_t test_pasxh_s16(int32_t a, int32_t b);
+int32_t test_psaxh_u16(int32_t a, int32_t b);
+int32_t test_psaxh_s16(int32_t a, int32_t b);
+int64_t test_add_64(int64_t a, int64_t b);
+int64_t test_add_u64_s(int64_t a, int64_t b);
+int64_t test_add_s64_s(int64_t a, int64_t b);
+int64_t test_sub_64(int64_t a, int64_t b);
+int64_t test_sub_u64_s(int64_t a, int64_t b);
+int64_t test_sub_s64_s(int64_t a, int64_t b);
+int32_t test_asri_s32_r_32(int32_t a);
+int32_t test_asri_s32_r_1(int32_t a);
+int32_t test_asri_s32_r_2(int32_t a);
+int32_t test_asri_s32_r_31(int32_t a);
+int32_t test_asr_s32_r(int32_t a, int32_t b);
+int32_t test_lsri_u32_r_32(int32_t a);
+int32_t test_lsri_u32_r_1(int32_t a);
+int32_t test_lsri_u32_r_2(int32_t a);
+int32_t test_lsri_u32_r_31(int32_t a);
+int32_t test_lsr_u32_r(int32_t a, int32_t b);
+int32_t test_lsli_u32_s_32(int32_t a);
+int32_t test_lsli_u32_s_2(int32_t a);
+int32_t test_lsli_u32_s_4(int32_t a);
+int32_t test_lsli_u32_s_31(int32_t a);
+int32_t test_lsli_s32_s_32(int32_t a);
+int32_t test_lsli_s32_s_2(int32_t a);
+int32_t test_lsli_s32_s_4(int32_t a);
+int32_t test_lsli_s32_s_31(int32_t a);
+int32_t test_lsl_u32_s(int32_t a, int32_t b);
+int32_t test_lsl_s32_s(int32_t a, int32_t b);
+int32_t test_pasri_s16_1(int32_t a);
+int32_t test_pasri_s16_2(int32_t a);
+int32_t test_pasri_s16_15(int32_t a);
+int32_t test_pasri_s16_16(int32_t a);
+int32_t test_pasr_s16(int32_t a, int32_t b);
+int32_t test_pasri_s16_r_1(int32_t a);
+int32_t test_pasri_s16_r_2(int32_t a);
+int32_t test_pasri_s16_r_15(int32_t a);
+int32_t test_pasr_s16_r(int32_t a, int32_t b);
+int32_t test_plsri_u16_1(int32_t a, int32_t b);
+int32_t test_plsri_u16_2(int32_t a, int32_t b);
+int32_t test_plsri_u16_3(int32_t a, int32_t b);
+int32_t test_plsri_u16_f(int32_t a, int32_t b);
+int32_t test_plsri_u16_10(int32_t a, int32_t b);
+int32_t test_plsr_u16(int32_t a, int32_t b);
+int32_t test_plsri_u16_r_1(int32_t a, int32_t b);
+int32_t test_plsri_u16_r_2(int32_t a, int32_t b);
+int32_t test_plsri_u16_r_3(int32_t a, int32_t b);
+int32_t test_plsri_u16_r_f(int32_t a, int32_t b);
+int32_t test_plsri_u16_r_10(int32_t a, int32_t b);
+int32_t test_plsr_u16_r(int32_t a, int32_t b);
+int32_t test_plsli_u16_1(int32_t a);
+int32_t test_plsli_u16_9(int32_t a);
+int32_t test_plsli_u16_16(int32_t a);
+int32_t test_plsl_u16(int32_t a, int32_t b);
+int32_t test_plsli_u16_s_1(int32_t a);
+int32_t test_plsli_u16_s_2(int32_t a);
+int32_t test_plsli_u16_s_9(int32_t a);
+int32_t test_plsli_u16_s_16(int32_t a);
+int32_t test_plsl_u16_s(int32_t a, int32_t b);
+int32_t test_plsli_s16_s_1(int32_t a);
+int32_t test_plsli_s16_s_2(int32_t a);
+int32_t test_plsli_s16_s_9(int32_t a);
+int32_t test_plsli_s16_s_16(int32_t a);
+int32_t test_plsl_s16_s(int32_t a, int32_t b);
+int32_t test_pcmpne_8(int32_t a, int32_t b);
+int32_t test_pcmpne_16(int32_t a, int32_t b);
+int32_t test_pcmphs_u8(int32_t a, int32_t b);
+int32_t test_pcmphs_s8(int32_t a, int32_t b);
+int32_t test_pcmphs_u16(int32_t a, int32_t b);
+int32_t test_pcmphs_s16(int32_t a, int32_t b);
+int32_t test_pcmplt_u8(int32_t a, int32_t b);
+int32_t test_pcmplt_s8(int32_t a, int32_t b);
+int32_t test_pcmplt_u16(int32_t a, int32_t b);
+int32_t test_pcmplt_s16(int32_t a, int32_t b);
+int32_t test_pmax_u8(int32_t a, int32_t b);
+int32_t test_pmax_s8(int32_t a, int32_t b);
+int32_t test_pmax_u16(int32_t a, int32_t b);
+int32_t test_pmax_s16(int32_t a, int32_t b);
+int32_t test_max_u32(int32_t a, int32_t b);
+int32_t test_max_s32(int32_t a, int32_t b);
+int32_t test_pmin_u8(int32_t a, int32_t b);
+int32_t test_pmin_s8(int32_t a, int32_t b);
+int32_t test_pmin_u16(int32_t a, int32_t b);
+int32_t test_pmin_s16(int32_t a, int32_t b);
+int32_t test_min_u32(int32_t a, int32_t b);
+int32_t test_min_s32(int32_t a, int32_t b);
+int32_t test_pkgll(int32_t a, int32_t b);
+int32_t test_pkghh(int32_t a, int32_t b);
+int32_t test_narl(int32_t a, int32_t b);
+int32_t test_narh(int32_t a, int32_t b);
+int32_t test_narlx(int32_t a, int32_t b);
+int32_t test_narhx(int32_t a, int32_t b);
+int32_t test_clipi_u32_0(int32_t a);
+int32_t test_clipi_u32_1(int32_t a);
+int32_t test_clipi_u32_2(int32_t a);
+int32_t test_clipi_u32_5(int32_t a);
+int32_t test_clipi_u32_31(int32_t a);
+int32_t test_clipi_s32_0(int32_t a);
+int32_t test_clipi_s32_1(int32_t a);
+int32_t test_clipi_s32_2(int32_t a);
+int32_t test_clipi_s32_5(int32_t a);
+int32_t test_clipi_s32_6(int32_t a);
+int32_t test_clipi_s32_31(int32_t a);
+int32_t test_clip_u32(int32_t a, int32_t b);
+int32_t test_clip_s32(int32_t a, int32_t b);
+int32_t test_pclipi_u16_0(int32_t a);
+int32_t test_pclipi_u16_1(int32_t a);
+int32_t test_pclipi_u16_2(int32_t a);
+int32_t test_pclipi_u16_7(int32_t a);
+int32_t test_pclipi_u16_15(int32_t a);
+int32_t test_pclip_u16(int32_t a, int32_t b);
+int32_t test_pclipi_s16_0(int32_t a);
+int32_t test_pclipi_s16_1(int32_t a);
+int32_t test_pclipi_s16_2(int32_t a);
+int32_t test_pclipi_s16_7(int32_t a);
+int32_t test_pclipi_s16_15(int32_t a);
+int32_t test_pclip_s16(int32_t a, int32_t b);
+int32_t test_dup_8_0(int32_t a);
+int32_t test_dup_8_1(int32_t a);
+int32_t test_dup_8_2(int32_t a);
+int32_t test_dup_8_3(int32_t a);
+int32_t test_dup_16_0(int32_t a);
+int32_t test_dup_16_1(int32_t a);
+int32_t test_psabsa_u8(int32_t a, int32_t b);
+int32_t test_mulaca_s8(int32_t a, int32_t b);
+int32_t test_pabs_s8_s(int32_t a);
+int32_t test_pabs_s16_s(int32_t a);
+int32_t test_abs_s32_s(int32_t a);
+int32_t test_pneg_s8_s(int32_t a);
+int32_t test_pneg_s16_s(int32_t a);
+int32_t test_neg_s32_s(int32_t a);
+int64_t test_pext_u8_e(int32_t a);
+int64_t test_pext_s8_e(int32_t a);
+int64_t test_pextx_u8_e(int32_t a);
+int64_t test_pextx_s8_e(int32_t a);
+int32_t test_sel(int32_t a, int32_t b, int32_t c);
+int32_t test_dexti_0(int32_t a, int32_t b);
+int32_t test_dexti_2(int32_t a, int32_t b);
+int32_t test_dexti_5(int32_t a, int32_t b);
+int32_t test_dexti_31(int32_t a, int32_t b);
+int32_t test_dext(int32_t a, int32_t b, int32_t c);
+int32_t test_psabsaa_u8(int32_t a, int32_t b, int32_t c);
+int64_t test_divul(uint64_t a, int32_t b);
+int64_t test_divsl(uint64_t a, int32_t b);
+int32_t test_pkg_4_16(int32_t a, int32_t b);
+int32_t test_pkg_2_3(int32_t a, int32_t b);
+int32_t test_pkg_4_4(int32_t a, int32_t b);
+int32_t test_pkg_8_8(int32_t a, int32_t b);
+int32_t test_pkg_0_15(int32_t a, int32_t b);
+int32_t test_pkg_15_15(int32_t a, int32_t b);
+int64_t test_muls_u32(int32_t a, int32_t b, int64_t c);
+int64_t test_muls_s32(int32_t a, int32_t b, int64_t c);
+int64_t test_mula_u32_s(int32_t a, int32_t b, int64_t c);
+int64_t test_mula_s32_s(int32_t a, int32_t b, int64_t c);
+int64_t test_muls_u32_s(int32_t a, int32_t b, int64_t c);
+int64_t test_muls_s32_s(int32_t a, int32_t b, int64_t c);
+int32_t test_rmul_s32_h(int32_t a, int32_t b);
+int32_t test_rmul_s32_rh(int32_t a, int32_t b);
+int32_t test_mula_s32_hs(int32_t a, int32_t b, int32_t c);
+int32_t test_muls_s32_hs(int32_t a, int32_t b, int32_t c);
+int32_t test_mula_s32_rhs(int32_t a, int32_t b, int32_t c);
+int32_t test_muls_s32_rhs(int32_t a, int32_t b, int32_t c);
+int32_t test_mulxl_s32(int32_t a, int32_t b);
+int32_t test_mulxl_s32_r(int32_t a, int32_t b);
+int32_t test_mulxh_s32(int32_t a, int32_t b);
+int32_t test_mulxh_s32_r(int32_t a, int32_t b);
+int32_t test_rmulxl_s32(int32_t a, int32_t b);
+int32_t test_rmulxl_s32_r(int32_t a, int32_t b);
+int32_t test_rmulxh_s32(int32_t a, int32_t b);
+int32_t test_rmulxh_s32_r(int32_t a, int32_t b);
+int32_t test_mulaxl_s32_s(int32_t a, int32_t b, int32_t c);
+int32_t test_mulaxl_s32_rs(int32_t a, int32_t b, int32_t c);
+int32_t test_mulaxh_s32_s(int32_t a, int32_t b, int32_t c);
+int32_t test_mulaxh_s32_rs(int32_t a, int32_t b, int32_t c);
+int32_t test_rmulll_s16(int32_t a, int32_t b);
+int32_t test_rmulhh_s16(int32_t a, int32_t b);
+int32_t test_rmulhl_s16(int32_t a, int32_t b);
+int32_t test_mulall_s16_s(int32_t a, int32_t b, int32_t c);
+int32_t test_mulahh_s16_s(int32_t a, int32_t b, int32_t c);
+int32_t test_mulahl_s16_s(int32_t a, int32_t b, int32_t c);
+int64_t test_mulall_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_mulahl_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_mulahh_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_pmul_s16(int32_t a, int32_t b);
+int64_t test_pmul_u16(int32_t a, int32_t b);
+int64_t test_pmulx_s16(int32_t a, int32_t b);
+int64_t test_pmulx_u16(int32_t a, int32_t b);
+int64_t test_prmul_s16(int32_t a, int32_t b);
+int64_t test_prmulx_s16(int32_t a, int32_t b);
+int32_t test_prmul_s16_h(int32_t a, int32_t b);
+int32_t test_prmul_s16_rh(int32_t a, int32_t b);
+int32_t test_prmulx_s16_h(int32_t a, int32_t b);
+int32_t test_prmulx_s16_rh(int32_t a, int32_t b);
+int32_t test_mulca_s16_s(int32_t a, int32_t b);
+int32_t test_mulcax_s16_s(int32_t a, int32_t b);
+int32_t test_mulcs_s16(int32_t a, int32_t b);
+int32_t test_mulcsr_s16(int32_t a, int32_t b);
+int32_t test_mulcsx_s16(int32_t a, int32_t b);
+int32_t test_mulaca_s16_s(int32_t a, int32_t b, int32_t c);
+int32_t test_mulacax_s16_s(int32_t a, int32_t b, int32_t c);
+int32_t test_mulacs_s16_s(int32_t a, int32_t b, int32_t c);
+int32_t test_mulacsr_s16_s(int32_t a, int32_t b, int32_t c);
+int32_t test_mulacsx_s16_s(int32_t a, int32_t b, int32_t c);
+int32_t test_mulsca_s16_s(int32_t a, int32_t b, int32_t c);
+int32_t test_mulscax_s16_s(int32_t a, int32_t b, int32_t c);
+int64_t test_mulaca_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_mulacax_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_mulacs_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_mulacsr_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_mulacsx_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_mulsca_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_mulscax_s16_e(int32_t a, int32_t b, int64_t c);
+int64_t test_mul_u32(int32_t a, int32_t b);
+int64_t test_mul_s32(int32_t a, int32_t b);
+int64_t test_mula_u32(int32_t a, int32_t b, int64_t c);
+int64_t test_mula_s32(int32_t a, int32_t b, int64_t c);
+int32_t test_mul_s32_h(int32_t a, int32_t b);
+int32_t test_mul_s32_rh(int32_t a, int32_t b);
+int32_t test_mulll_s16(int32_t a, int32_t b);
+int32_t test_mulhh_s16(int32_t a, int32_t b);
+int32_t test_mulhl_s16(int32_t a, int32_t b);
+int32_t test_mula_32_l(int32_t a, int32_t b, int32_t c);
+int32_t test_ldbi_w();
+int32_t test_ldbi_h();
+int32_t test_ldbi_hs();
+int32_t test_ldbi_b();
+int32_t test_ldbi_bs();
+int64_t test_pldbi_d();
+int32_t test_ldbir_w(int32_t ry);
+int32_t test_ldbir_h(int32_t ry);
+int32_t test_ldbir_hs(int32_t ry);
+int32_t test_ldbir_b(int32_t ry);
+int32_t test_ldbir_bs(int32_t ry);
+int64_t test_pldbir_d(int32_t ry);
+int32_t test_stbi_w(int *rx, int rz);
+int32_t test_stbi_h(int *rx, int rz);
+int32_t test_stbi_b(int *rx, int rz);
+int32_t test_stbir_w(int *rx, int ry, int rz);
+int32_t test_stbir_h(int *rx, int ry, int rz);
+int32_t test_stbir_b(int *rx, int ry, int rz);
+int32_t test_bloop(int rx, int ry, int rz, int rs);
+#endif
diff --git a/tests/csky/dspv2/case/dup_16.c b/tests/csky/dspv2/case/dup_16.c
new file mode 100644
index 0000000..1a81b10
--- /dev/null
+++ b/tests/csky/dspv2/case/dup_16.c
@@ -0,0 +1,22 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn dup.16\n");
+
+    for (i = 0;
+         i < sizeof(samples_dup_16)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_dup_16[i].op2 == 0) {
+            TEST(test_dup_16_0(samples_dup_16[i].op1)
+                 == samples_dup_16[i].result);
+        } else if (samples_dup_16[i].op2 == 1) {
+            TEST(test_dup_16_1(samples_dup_16[i].op1)
+                 == samples_dup_16[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/dup_8.c b/tests/csky/dspv2/case/dup_8.c
new file mode 100644
index 0000000..c31db7d
--- /dev/null
+++ b/tests/csky/dspv2/case/dup_8.c
@@ -0,0 +1,24 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn dup.8\n");
+
+    for (i = 0;
+         i < sizeof(samples_dup_8)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_dup_8[i].op2 == 0) {
+            TEST(test_dup_8_0(samples_dup_8[i].op1) == samples_dup_8[i].result);
+        } else if (samples_dup_8[i].op2 == 1) {
+            TEST(test_dup_8_1(samples_dup_8[i].op1) == samples_dup_8[i].result);
+        } else if (samples_dup_8[i].op2 == 2) {
+            TEST(test_dup_8_2(samples_dup_8[i].op1) == samples_dup_8[i].result);
+        } else if (samples_dup_8[i].op2 == 3) {
+            TEST(test_dup_8_3(samples_dup_8[i].op1) == samples_dup_8[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/ldbi_b.c b/tests/csky/dspv2/case/ldbi_b.c
new file mode 100644
index 0000000..3bcd5aa
--- /dev/null
+++ b/tests/csky/dspv2/case/ldbi_b.c
@@ -0,0 +1,39 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn LDBI.B\n");
+
+    TEST(test_ldbi_b() == 0xc0);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/ldbi_bs.c b/tests/csky/dspv2/case/ldbi_bs.c
new file mode 100644
index 0000000..7b1ae74
--- /dev/null
+++ b/tests/csky/dspv2/case/ldbi_bs.c
@@ -0,0 +1,38 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn LDBI.BS \n");
+
+    TEST(test_ldbi_bs() == 0xffffffc0);
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/ldbi_h.c b/tests/csky/dspv2/case/ldbi_h.c
new file mode 100644
index 0000000..634473b
--- /dev/null
+++ b/tests/csky/dspv2/case/ldbi_h.c
@@ -0,0 +1,39 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn LDBI.H \n");
+
+    TEST(test_ldbi_h() == 0xc0c0);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/ldbi_hs.c b/tests/csky/dspv2/case/ldbi_hs.c
new file mode 100644
index 0000000..34fcd15
--- /dev/null
+++ b/tests/csky/dspv2/case/ldbi_hs.c
@@ -0,0 +1,38 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn LDBI.HS \n");
+
+    TEST(test_ldbi_hs() == 0xffffc0c0);
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/ldbi_w.c b/tests/csky/dspv2/case/ldbi_w.c
new file mode 100644
index 0000000..59b8cc0
--- /dev/null
+++ b/tests/csky/dspv2/case/ldbi_w.c
@@ -0,0 +1,39 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn LDBI.W \n");
+
+    TEST(test_ldbi_w() == 0xc0c0c0c0);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/ldbir_b.c b/tests/csky/dspv2/case/ldbir_b.c
new file mode 100644
index 0000000..23b9875
--- /dev/null
+++ b/tests/csky/dspv2/case/ldbir_b.c
@@ -0,0 +1,39 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn LDBIR.B\n");
+
+    TEST(test_ldbir_b(1) == 0xc0);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/ldbir_bs.c b/tests/csky/dspv2/case/ldbir_bs.c
new file mode 100644
index 0000000..312359f
--- /dev/null
+++ b/tests/csky/dspv2/case/ldbir_bs.c
@@ -0,0 +1,39 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn LDBIR.BS\n");
+
+    TEST(test_ldbir_bs(1) == 0xffffffc0);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/ldbir_h.c b/tests/csky/dspv2/case/ldbir_h.c
new file mode 100644
index 0000000..b16b803
--- /dev/null
+++ b/tests/csky/dspv2/case/ldbir_h.c
@@ -0,0 +1,39 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn LDBIR.H \n");
+
+    TEST(test_ldbir_h(2) == 0xc0c0);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/ldbir_hs.c b/tests/csky/dspv2/case/ldbir_hs.c
new file mode 100644
index 0000000..b95011c
--- /dev/null
+++ b/tests/csky/dspv2/case/ldbir_hs.c
@@ -0,0 +1,39 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn LDBIR.HS \n");
+
+    TEST(test_ldbir_hs(2) == 0xffffc0c0);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/ldbir_w.c b/tests/csky/dspv2/case/ldbir_w.c
new file mode 100644
index 0000000..a888bf3
--- /dev/null
+++ b/tests/csky/dspv2/case/ldbir_w.c
@@ -0,0 +1,39 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn LDBIR.W \n");
+
+    TEST(test_ldbir_w(4) == 0xc0c0c0c0);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/lsl_s32_s.c b/tests/csky/dspv2/case/lsl_s32_s.c
new file mode 100644
index 0000000..4715cdb
--- /dev/null
+++ b/tests/csky/dspv2/case/lsl_s32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn lsl.s32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_lsl_s32_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_lsl_s32_s(samples_lsl_s32_s[i].op1, samples_lsl_s32_s[i].op2)
+                     == samples_lsl_s32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/lsl_u32_s.c b/tests/csky/dspv2/case/lsl_u32_s.c
new file mode 100644
index 0000000..a4edf76
--- /dev/null
+++ b/tests/csky/dspv2/case/lsl_u32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn lsl.u32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_lsl_u32_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_lsl_u32_s(samples_lsl_u32_s[i].op1, samples_lsl_u32_s[i].op2)
+                     == samples_lsl_u32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/lsli_s32_s.c b/tests/csky/dspv2/case/lsli_s32_s.c
new file mode 100644
index 0000000..7caca2e
--- /dev/null
+++ b/tests/csky/dspv2/case/lsli_s32_s.c
@@ -0,0 +1,28 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn lsli.s32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_lsli_s32_s)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_lsli_s32_s[i].op2 == 32) {
+            TEST(test_lsli_s32_s_32(samples_lsli_s32_s[i].op1)
+                 == samples_lsli_s32_s[i].result);
+        } else if (samples_lsli_s32_s[i].op2 == 2) {
+            TEST(test_lsli_s32_s_2(samples_lsli_s32_s[i].op1)
+                 == samples_lsli_s32_s[i].result);
+        } else if (samples_lsli_s32_s[i].op2 == 4) {
+            TEST(test_lsli_s32_s_4(samples_lsli_s32_s[i].op1)
+                 == samples_lsli_s32_s[i].result);
+        } else if (samples_lsli_s32_s[i].op2 == 31) {
+            TEST(test_lsli_s32_s_31(samples_lsli_s32_s[i].op1)
+                 == samples_lsli_s32_s[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/lsli_u32_s.c b/tests/csky/dspv2/case/lsli_u32_s.c
new file mode 100644
index 0000000..7760011
--- /dev/null
+++ b/tests/csky/dspv2/case/lsli_u32_s.c
@@ -0,0 +1,28 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn lsli.u32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_lsli_u32_s)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_lsli_u32_s[i].op2 == 32) {
+            TEST(test_lsli_u32_s_32(samples_lsli_u32_s[i].op1)
+                 == samples_lsli_u32_s[i].result);
+        } else if (samples_lsli_u32_s[i].op2 == 2) {
+            TEST(test_lsli_u32_s_2(samples_lsli_u32_s[i].op1)
+                 == samples_lsli_u32_s[i].result);
+        } else if (samples_lsli_u32_s[i].op2 == 4) {
+            TEST(test_lsli_u32_s_4(samples_lsli_u32_s[i].op1)
+                 == samples_lsli_u32_s[i].result);
+        } else if (samples_lsli_u32_s[i].op2 == 31) {
+            TEST(test_lsli_u32_s_31(samples_lsli_u32_s[i].op1)
+                 == samples_lsli_u32_s[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/lsr_u32_r.c b/tests/csky/dspv2/case/lsr_u32_r.c
new file mode 100644
index 0000000..d15df5f
--- /dev/null
+++ b/tests/csky/dspv2/case/lsr_u32_r.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn lsr.u32.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_lsr_u32_r)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_lsr_u32_r(samples_lsr_u32_r[i].op1, samples_lsr_u32_r[i].op2)
+                     == samples_lsr_u32_r[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/lsri_u32_r.c b/tests/csky/dspv2/case/lsri_u32_r.c
new file mode 100644
index 0000000..417b0c1
--- /dev/null
+++ b/tests/csky/dspv2/case/lsri_u32_r.c
@@ -0,0 +1,27 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn lsri.u32.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_lsri_u32_r)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_lsri_u32_r[i].op2 == 32) {
+            TEST(test_lsri_u32_r_32(samples_lsri_u32_r[i].op1)
+                 == samples_lsri_u32_r[i].result);
+        } else if (samples_lsri_u32_r[i].op2 == 1) {
+            TEST(test_lsri_u32_r_1(samples_lsri_u32_r[i].op1)
+                 == samples_lsri_u32_r[i].result);
+        } else if (samples_lsri_u32_r[i].op2 == 2) {
+            TEST(test_lsri_u32_r_2(samples_lsri_u32_r[i].op1)
+                 == samples_lsri_u32_r[i].result);
+        } else if (samples_lsri_u32_r[i].op2 == 31) {
+            TEST(test_lsri_u32_r_31(samples_lsri_u32_r[i].op1)
+                 == samples_lsri_u32_r[i].result);
+        }    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/max_s32.c b/tests/csky/dspv2/case/max_s32.c
new file mode 100644
index 0000000..ed337f2
--- /dev/null
+++ b/tests/csky/dspv2/case/max_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn max.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_max_s32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_max_s32(samples_max_s32[i].op1, samples_max_s32[i].op2)
+                     == samples_max_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/max_u32.c b/tests/csky/dspv2/case/max_u32.c
new file mode 100644
index 0000000..a854f58
--- /dev/null
+++ b/tests/csky/dspv2/case/max_u32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn max.u32\n");
+
+    for (i = 0;
+         i < sizeof(samples_max_u32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_max_u32(samples_max_u32[i].op1, samples_max_u32[i].op2)
+                     == samples_max_u32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/min_s32.c b/tests/csky/dspv2/case/min_s32.c
new file mode 100644
index 0000000..dedda6b
--- /dev/null
+++ b/tests/csky/dspv2/case/min_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn min.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_min_s32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_min_s32(samples_min_s32[i].op1, samples_min_s32[i].op2)
+                     == samples_min_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/min_u32.c b/tests/csky/dspv2/case/min_u32.c
new file mode 100644
index 0000000..a24fab9
--- /dev/null
+++ b/tests/csky/dspv2/case/min_u32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn min.u32\n");
+
+    for (i = 0;
+         i < sizeof(samples_min_u32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_min_u32(samples_min_u32[i].op1, samples_min_u32[i].op2)
+                     == samples_min_u32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mul_s32.c b/tests/csky/dspv2/case/mul_s32.c
new file mode 100644
index 0000000..247a804
--- /dev/null
+++ b/tests/csky/dspv2/case/mul_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mul.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_mul_s32)/sizeof(struct binary64_calculation);
+         i++) {
+        TEST(test_mul_s32(samples_mul_s32[i].op1, samples_mul_s32[i].op2)
+                     == samples_mul_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mul_s32_h.c b/tests/csky/dspv2/case/mul_s32_h.c
new file mode 100644
index 0000000..105345d
--- /dev/null
+++ b/tests/csky/dspv2/case/mul_s32_h.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mul.s32.h\n");
+
+    for (i = 0;
+         i < sizeof(samples_mul_s32_h)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mul_s32_h(samples_mul_s32_h[i].op1, samples_mul_s32_h[i].op2)
+                     == samples_mul_s32_h[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mul_s32_rh.c b/tests/csky/dspv2/case/mul_s32_rh.c
new file mode 100644
index 0000000..b45ebea
--- /dev/null
+++ b/tests/csky/dspv2/case/mul_s32_rh.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mul.s32.rh\n");
+
+    for (i = 0;
+         i < sizeof(samples_mul_s32_rh)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mul_s32_rh(samples_mul_s32_rh[i].op1, samples_mul_s32_rh[i].op2)
+                     == samples_mul_s32_rh[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mul_u32.c b/tests/csky/dspv2/case/mul_u32.c
new file mode 100644
index 0000000..bb30120
--- /dev/null
+++ b/tests/csky/dspv2/case/mul_u32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mul.u32\n");
+
+    for (i = 0;
+         i < sizeof(samples_mul_u32)/sizeof(struct binary64_calculation);
+         i++) {
+        TEST(test_mul_u32(samples_mul_u32[i].op1, samples_mul_u32[i].op2)
+                     == samples_mul_u32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mula_32_l.c b/tests/csky/dspv2/case/mula_32_l.c
new file mode 100644
index 0000000..0427397
--- /dev/null
+++ b/tests/csky/dspv2/case/mula_32_l.c
@@ -0,0 +1,18 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mula.32.l\n");
+
+    for (i = 0;
+         i < sizeof(samples_mula_32_l)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mula_32_l(samples_mula_32_l[i].op1, samples_mula_32_l[i].op2,
+                           samples_mula_32_l[i].op3)
+                     == samples_mula_32_l[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mula_s32.c b/tests/csky/dspv2/case/mula_s32.c
new file mode 100644
index 0000000..5c245d2
--- /dev/null
+++ b/tests/csky/dspv2/case/mula_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mula.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_mula_s32)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mula_s32(samples_mula_s32[i].op1, samples_mula_s32[i].op2, samples_mula_s32[i].op3)
+                     == samples_mula_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mula_s32_hs.c b/tests/csky/dspv2/case/mula_s32_hs.c
new file mode 100644
index 0000000..cf482fa
--- /dev/null
+++ b/tests/csky/dspv2/case/mula_s32_hs.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mula.s32.hs\n");
+
+    for (i = 0;
+         i < sizeof(samples_mula_s32_hs)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mula_s32_hs(samples_mula_s32_hs[i].op1, samples_mula_s32_hs[i].op2, samples_mula_s32_hs[i].op3)
+                     == samples_mula_s32_hs[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mula_s32_rhs.c b/tests/csky/dspv2/case/mula_s32_rhs.c
new file mode 100644
index 0000000..7f3b1da
--- /dev/null
+++ b/tests/csky/dspv2/case/mula_s32_rhs.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mula.s32.rhs\n");
+
+    for (i = 0;
+         i < sizeof(samples_mula_s32_rhs)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mula_s32_rhs(samples_mula_s32_rhs[i].op1, samples_mula_s32_rhs[i].op2, samples_mula_s32_rhs[i].op3)
+                     == samples_mula_s32_rhs[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mula_s32_s.c b/tests/csky/dspv2/case/mula_s32_s.c
new file mode 100644
index 0000000..6d40085
--- /dev/null
+++ b/tests/csky/dspv2/case/mula_s32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mula.s32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mula_s32_s)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mula_s32_s(samples_mula_s32_s[i].op1, samples_mula_s32_s[i].op2, samples_mula_s32_s[i].op3)
+                     == samples_mula_s32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mula_u32.c b/tests/csky/dspv2/case/mula_u32.c
new file mode 100644
index 0000000..d532162
--- /dev/null
+++ b/tests/csky/dspv2/case/mula_u32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mula.u32\n");
+
+    for (i = 0;
+         i < sizeof(samples_mula_u32)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mula_u32(samples_mula_u32[i].op1, samples_mula_u32[i].op2, samples_mula_u32[i].op3)
+                     == samples_mula_u32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mula_u32_s.c b/tests/csky/dspv2/case/mula_u32_s.c
new file mode 100644
index 0000000..a8b9e01
--- /dev/null
+++ b/tests/csky/dspv2/case/mula_u32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mula.u32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mula_u32_s)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mula_u32_s(samples_mula_u32_s[i].op1, samples_mula_u32_s[i].op2, samples_mula_u32_s[i].op3)
+                     == samples_mula_u32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulaca_s16_e.c b/tests/csky/dspv2/case/mulaca_s16_e.c
new file mode 100644
index 0000000..23511a8
--- /dev/null
+++ b/tests/csky/dspv2/case/mulaca_s16_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulaca.s16.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulaca_s16_e)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mulaca_s16_e(samples_mulaca_s16_e[i].op1, samples_mulaca_s16_e[i].op2, samples_mulaca_s16_e[i].op3)
+                     == samples_mulaca_s16_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulaca_s16_s.c b/tests/csky/dspv2/case/mulaca_s16_s.c
new file mode 100644
index 0000000..9ee0295
--- /dev/null
+++ b/tests/csky/dspv2/case/mulaca_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulaca.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulaca_s16_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulaca_s16_s(samples_mulaca_s16_s[i].op1, samples_mulaca_s16_s[i].op2, samples_mulaca_s16_s[i].op3)
+                     == samples_mulaca_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulaca_s8.c b/tests/csky/dspv2/case/mulaca_s8.c
new file mode 100644
index 0000000..1c0fdf6
--- /dev/null
+++ b/tests/csky/dspv2/case/mulaca_s8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulaca.s8\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulaca_s8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulaca_s8(samples_mulaca_s8[i].op1, samples_mulaca_s8[i].op2)
+                     == samples_mulaca_s8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulacax_s16_e.c b/tests/csky/dspv2/case/mulacax_s16_e.c
new file mode 100644
index 0000000..1fa20ca
--- /dev/null
+++ b/tests/csky/dspv2/case/mulacax_s16_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulacax.s16.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulacax_s16_e)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mulacax_s16_e(samples_mulacax_s16_e[i].op1, samples_mulacax_s16_e[i].op2, samples_mulacax_s16_e[i].op3)
+                     == samples_mulacax_s16_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulacax_s16_s.c b/tests/csky/dspv2/case/mulacax_s16_s.c
new file mode 100644
index 0000000..c656580
--- /dev/null
+++ b/tests/csky/dspv2/case/mulacax_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulacax.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulacax_s16_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulacax_s16_s(samples_mulacax_s16_s[i].op1, samples_mulacax_s16_s[i].op2, samples_mulacax_s16_s[i].op3)
+                     == samples_mulacax_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulacs_s16_e.c b/tests/csky/dspv2/case/mulacs_s16_e.c
new file mode 100644
index 0000000..236e92b
--- /dev/null
+++ b/tests/csky/dspv2/case/mulacs_s16_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulacs.s16.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulacs_s16_e)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mulacs_s16_e(samples_mulacs_s16_e[i].op1, samples_mulacs_s16_e[i].op2, samples_mulacs_s16_e[i].op3)
+                     == samples_mulacs_s16_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulacs_s16_s.c b/tests/csky/dspv2/case/mulacs_s16_s.c
new file mode 100644
index 0000000..4eeae38
--- /dev/null
+++ b/tests/csky/dspv2/case/mulacs_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulacs.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulacs_s16_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulacs_s16_s(samples_mulacs_s16_s[i].op1, samples_mulacs_s16_s[i].op2, samples_mulacs_s16_s[i].op3)
+                     == samples_mulacs_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulacsr_s16_e.c b/tests/csky/dspv2/case/mulacsr_s16_e.c
new file mode 100644
index 0000000..9041053
--- /dev/null
+++ b/tests/csky/dspv2/case/mulacsr_s16_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulacsr.s16.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulacsr_s16_e)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mulacsr_s16_e(samples_mulacsr_s16_e[i].op1, samples_mulacsr_s16_e[i].op2, samples_mulacsr_s16_e[i].op3)
+                     == samples_mulacsr_s16_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulacsr_s16_s.c b/tests/csky/dspv2/case/mulacsr_s16_s.c
new file mode 100644
index 0000000..cd49d8c
--- /dev/null
+++ b/tests/csky/dspv2/case/mulacsr_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulacsr.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulacsr_s16_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulacsr_s16_s(samples_mulacsr_s16_s[i].op1, samples_mulacsr_s16_s[i].op2, samples_mulacsr_s16_s[i].op3)
+                     == samples_mulacsr_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulacsx_s16_e.c b/tests/csky/dspv2/case/mulacsx_s16_e.c
new file mode 100644
index 0000000..da88f38
--- /dev/null
+++ b/tests/csky/dspv2/case/mulacsx_s16_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulacsx.s16.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulacsx_s16_e)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mulacsx_s16_e(samples_mulacsx_s16_e[i].op1, samples_mulacsx_s16_e[i].op2, samples_mulacsx_s16_e[i].op3)
+                     == samples_mulacsx_s16_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulacsx_s16_s.c b/tests/csky/dspv2/case/mulacsx_s16_s.c
new file mode 100644
index 0000000..92b5101
--- /dev/null
+++ b/tests/csky/dspv2/case/mulacsx_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulacsx.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulacsx_s16_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulacsx_s16_s(samples_mulacsx_s16_s[i].op1, samples_mulacsx_s16_s[i].op2, samples_mulacsx_s16_s[i].op3)
+                     == samples_mulacsx_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulahh_s16_e.c b/tests/csky/dspv2/case/mulahh_s16_e.c
new file mode 100644
index 0000000..0ea9994
--- /dev/null
+++ b/tests/csky/dspv2/case/mulahh_s16_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulahh.s16.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulahh_s16_e)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mulahh_s16_e(samples_mulahh_s16_e[i].op1, samples_mulahh_s16_e[i].op2, samples_mulahh_s16_e[i].op3)
+                     == samples_mulahh_s16_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulahh_s16_s.c b/tests/csky/dspv2/case/mulahh_s16_s.c
new file mode 100644
index 0000000..2ae8e1c
--- /dev/null
+++ b/tests/csky/dspv2/case/mulahh_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulahh.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulahh_s16_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulahh_s16_s(samples_mulahh_s16_s[i].op1, samples_mulahh_s16_s[i].op2, samples_mulahh_s16_s[i].op3)
+                     == samples_mulahh_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulahl_s16_e.c b/tests/csky/dspv2/case/mulahl_s16_e.c
new file mode 100644
index 0000000..79603ee
--- /dev/null
+++ b/tests/csky/dspv2/case/mulahl_s16_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulahl.s16.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulahl_s16_e)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mulahl_s16_e(samples_mulahl_s16_e[i].op1, samples_mulahl_s16_e[i].op2, samples_mulahl_s16_e[i].op3)
+                     == samples_mulahl_s16_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulahl_s16_s.c b/tests/csky/dspv2/case/mulahl_s16_s.c
new file mode 100644
index 0000000..f20ebd9
--- /dev/null
+++ b/tests/csky/dspv2/case/mulahl_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulahl.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulahl_s16_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulahl_s16_s(samples_mulahl_s16_s[i].op1, samples_mulahl_s16_s[i].op2, samples_mulahl_s16_s[i].op3)
+                     == samples_mulahl_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulall_s16_e.c b/tests/csky/dspv2/case/mulall_s16_e.c
new file mode 100644
index 0000000..ddfa2fc
--- /dev/null
+++ b/tests/csky/dspv2/case/mulall_s16_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulall.s16.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulall_s16_e)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mulall_s16_e(samples_mulall_s16_e[i].op1, samples_mulall_s16_e[i].op2, samples_mulall_s16_e[i].op3)
+                     == samples_mulall_s16_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulall_s16_s.c b/tests/csky/dspv2/case/mulall_s16_s.c
new file mode 100644
index 0000000..6d0696d
--- /dev/null
+++ b/tests/csky/dspv2/case/mulall_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulall.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulall_s16_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulall_s16_s(samples_mulall_s16_s[i].op1, samples_mulall_s16_s[i].op2, samples_mulall_s16_s[i].op3)
+                     == samples_mulall_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulaxh_s32_rs.c b/tests/csky/dspv2/case/mulaxh_s32_rs.c
new file mode 100644
index 0000000..75df2d7
--- /dev/null
+++ b/tests/csky/dspv2/case/mulaxh_s32_rs.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulaxh.s32.rs\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulaxh_s32_rs)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulaxh_s32_rs(samples_mulaxh_s32_rs[i].op1, samples_mulaxh_s32_rs[i].op2, samples_mulaxh_s32_rs[i].op3)
+                     == samples_mulaxh_s32_rs[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulaxh_s32_s.c b/tests/csky/dspv2/case/mulaxh_s32_s.c
new file mode 100644
index 0000000..d30e0cc
--- /dev/null
+++ b/tests/csky/dspv2/case/mulaxh_s32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulaxh.s32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulaxh_s32_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulaxh_s32_s(samples_mulaxh_s32_s[i].op1, samples_mulaxh_s32_s[i].op2, samples_mulaxh_s32_s[i].op3)
+                     == samples_mulaxh_s32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulaxl_s32_rs.c b/tests/csky/dspv2/case/mulaxl_s32_rs.c
new file mode 100644
index 0000000..5a6638a
--- /dev/null
+++ b/tests/csky/dspv2/case/mulaxl_s32_rs.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulaxl.s32.rs\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulaxl_s32_rs)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulaxl_s32_rs(samples_mulaxl_s32_rs[i].op1, samples_mulaxl_s32_rs[i].op2, samples_mulaxl_s32_rs[i].op3)
+                     == samples_mulaxl_s32_rs[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulaxl_s32_s.c b/tests/csky/dspv2/case/mulaxl_s32_s.c
new file mode 100644
index 0000000..9cf9325
--- /dev/null
+++ b/tests/csky/dspv2/case/mulaxl_s32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulaxl.s32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulaxl_s32_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulaxl_s32_s(samples_mulaxl_s32_s[i].op1, samples_mulaxl_s32_s[i].op2, samples_mulaxl_s32_s[i].op3)
+                     == samples_mulaxl_s32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulca_s16_s.c b/tests/csky/dspv2/case/mulca_s16_s.c
new file mode 100644
index 0000000..9db985e
--- /dev/null
+++ b/tests/csky/dspv2/case/mulca_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulca.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulca_s16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulca_s16_s(samples_mulca_s16_s[i].op1, samples_mulca_s16_s[i].op2)
+                     == samples_mulca_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulcax_s16_s.c b/tests/csky/dspv2/case/mulcax_s16_s.c
new file mode 100644
index 0000000..42fb667
--- /dev/null
+++ b/tests/csky/dspv2/case/mulcax_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulcax.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulcax_s16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulcax_s16_s(samples_mulcax_s16_s[i].op1, samples_mulcax_s16_s[i].op2)
+                     == samples_mulcax_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulcs_s16.c b/tests/csky/dspv2/case/mulcs_s16.c
new file mode 100644
index 0000000..be9091f
--- /dev/null
+++ b/tests/csky/dspv2/case/mulcs_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulcs.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulcs_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulcs_s16(samples_mulcs_s16[i].op1, samples_mulcs_s16[i].op2)
+                     == samples_mulcs_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulcsr_s16.c b/tests/csky/dspv2/case/mulcsr_s16.c
new file mode 100644
index 0000000..cd77940
--- /dev/null
+++ b/tests/csky/dspv2/case/mulcsr_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulcsr.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulcsr_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulcsr_s16(samples_mulcsr_s16[i].op1, samples_mulcsr_s16[i].op2)
+                     == samples_mulcsr_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulcsx_s16.c b/tests/csky/dspv2/case/mulcsx_s16.c
new file mode 100644
index 0000000..150f91c
--- /dev/null
+++ b/tests/csky/dspv2/case/mulcsx_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulcsx.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulcsx_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulcsx_s16(samples_mulcsx_s16[i].op1, samples_mulcsx_s16[i].op2)
+                     == samples_mulcsx_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulhh_s16.c b/tests/csky/dspv2/case/mulhh_s16.c
new file mode 100644
index 0000000..08c6561
--- /dev/null
+++ b/tests/csky/dspv2/case/mulhh_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulhh.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulhh_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulhh_s16(samples_mulhh_s16[i].op1, samples_mulhh_s16[i].op2)
+                     == samples_mulhh_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulhl_s16.c b/tests/csky/dspv2/case/mulhl_s16.c
new file mode 100644
index 0000000..4a5cd34
--- /dev/null
+++ b/tests/csky/dspv2/case/mulhl_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulhl.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulhl_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulhl_s16(samples_mulhl_s16[i].op1, samples_mulhl_s16[i].op2)
+                     == samples_mulhl_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulll_s16.c b/tests/csky/dspv2/case/mulll_s16.c
new file mode 100644
index 0000000..3a59f95
--- /dev/null
+++ b/tests/csky/dspv2/case/mulll_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulll.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulll_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulll_s16(samples_mulll_s16[i].op1, samples_mulll_s16[i].op2)
+                     == samples_mulll_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/muls_s32.c b/tests/csky/dspv2/case/muls_s32.c
new file mode 100644
index 0000000..cc93995
--- /dev/null
+++ b/tests/csky/dspv2/case/muls_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn muls.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_muls_s32)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_muls_s32(samples_muls_s32[i].op1, samples_muls_s32[i].op2, samples_muls_s32[i].op3)
+                     == samples_muls_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/muls_s32_hs.c b/tests/csky/dspv2/case/muls_s32_hs.c
new file mode 100644
index 0000000..de29d33
--- /dev/null
+++ b/tests/csky/dspv2/case/muls_s32_hs.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn muls.s32.hs\n");
+
+    for (i = 0;
+         i < sizeof(samples_muls_s32_hs)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_muls_s32_hs(samples_muls_s32_hs[i].op1, samples_muls_s32_hs[i].op2, samples_muls_s32_hs[i].op3)
+                     == samples_muls_s32_hs[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/muls_s32_rhs.c b/tests/csky/dspv2/case/muls_s32_rhs.c
new file mode 100644
index 0000000..9e81a7a
--- /dev/null
+++ b/tests/csky/dspv2/case/muls_s32_rhs.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn muls.s32.rhs\n");
+
+    for (i = 0;
+         i < sizeof(samples_muls_s32_rhs)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_muls_s32_rhs(samples_muls_s32_rhs[i].op1, samples_muls_s32_rhs[i].op2, samples_muls_s32_rhs[i].op3)
+                     == samples_muls_s32_rhs[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/muls_s32_s.c b/tests/csky/dspv2/case/muls_s32_s.c
new file mode 100644
index 0000000..6f7184a
--- /dev/null
+++ b/tests/csky/dspv2/case/muls_s32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn muls.s32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_muls_s32_s)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_muls_s32_s(samples_muls_s32_s[i].op1, samples_muls_s32_s[i].op2, samples_muls_s32_s[i].op3)
+                     == samples_muls_s32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/muls_u32.c b/tests/csky/dspv2/case/muls_u32.c
new file mode 100644
index 0000000..8107e60
--- /dev/null
+++ b/tests/csky/dspv2/case/muls_u32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn muls.u32\n");
+
+    for (i = 0;
+         i < sizeof(samples_muls_u32)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_muls_u32(samples_muls_u32[i].op1, samples_muls_u32[i].op2, samples_muls_u32[i].op3)
+                     == samples_muls_u32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/muls_u32_s.c b/tests/csky/dspv2/case/muls_u32_s.c
new file mode 100644
index 0000000..bcfd18a
--- /dev/null
+++ b/tests/csky/dspv2/case/muls_u32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn muls.u32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_muls_u32_s)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_muls_u32_s(samples_muls_u32_s[i].op1, samples_muls_u32_s[i].op2, samples_muls_u32_s[i].op3)
+                     == samples_muls_u32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulsca_s16_e.c b/tests/csky/dspv2/case/mulsca_s16_e.c
new file mode 100644
index 0000000..7cc1c10
--- /dev/null
+++ b/tests/csky/dspv2/case/mulsca_s16_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulsca.s16.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulsca_s16_e)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mulsca_s16_e(samples_mulsca_s16_e[i].op1, samples_mulsca_s16_e[i].op2, samples_mulsca_s16_e[i].op3)
+                     == samples_mulsca_s16_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulsca_s16_s.c b/tests/csky/dspv2/case/mulsca_s16_s.c
new file mode 100644
index 0000000..274f336
--- /dev/null
+++ b/tests/csky/dspv2/case/mulsca_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulsca.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulsca_s16_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulsca_s16_s(samples_mulsca_s16_s[i].op1, samples_mulsca_s16_s[i].op2, samples_mulsca_s16_s[i].op3)
+                     == samples_mulsca_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulscax_s16_e.c b/tests/csky/dspv2/case/mulscax_s16_e.c
new file mode 100644
index 0000000..b510fea
--- /dev/null
+++ b/tests/csky/dspv2/case/mulscax_s16_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulscax.s16.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulscax_s16_e)/sizeof(struct ternary64_calculation);
+         i++) {
+        TEST(test_mulscax_s16_e(samples_mulscax_s16_e[i].op1, samples_mulscax_s16_e[i].op2, samples_mulscax_s16_e[i].op3)
+                     == samples_mulscax_s16_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulscax_s16_s.c b/tests/csky/dspv2/case/mulscax_s16_s.c
new file mode 100644
index 0000000..75e817b
--- /dev/null
+++ b/tests/csky/dspv2/case/mulscax_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulscax.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulscax_s16_s)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_mulscax_s16_s(samples_mulscax_s16_s[i].op1, samples_mulscax_s16_s[i].op2, samples_mulscax_s16_s[i].op3)
+                     == samples_mulscax_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulxh_s32.c b/tests/csky/dspv2/case/mulxh_s32.c
new file mode 100644
index 0000000..3915ec0
--- /dev/null
+++ b/tests/csky/dspv2/case/mulxh_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulxh.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulxh_s32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulxh_s32(samples_mulxh_s32[i].op1, samples_mulxh_s32[i].op2)
+                     == samples_mulxh_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulxh_s32_r.c b/tests/csky/dspv2/case/mulxh_s32_r.c
new file mode 100644
index 0000000..447fd8b
--- /dev/null
+++ b/tests/csky/dspv2/case/mulxh_s32_r.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulxh.s32.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulxh_s32_r)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulxh_s32_r(samples_mulxh_s32_r[i].op1, samples_mulxh_s32_r[i].op2)
+                     == samples_mulxh_s32_r[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulxl_s32.c b/tests/csky/dspv2/case/mulxl_s32.c
new file mode 100644
index 0000000..70225b8
--- /dev/null
+++ b/tests/csky/dspv2/case/mulxl_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulxl.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulxl_s32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulxl_s32(samples_mulxl_s32[i].op1, samples_mulxl_s32[i].op2)
+                     == samples_mulxl_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/mulxl_s32_r.c b/tests/csky/dspv2/case/mulxl_s32_r.c
new file mode 100644
index 0000000..94ace4b
--- /dev/null
+++ b/tests/csky/dspv2/case/mulxl_s32_r.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn mulxl.s32.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_mulxl_s32_r)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_mulxl_s32_r(samples_mulxl_s32_r[i].op1, samples_mulxl_s32_r[i].op2)
+                     == samples_mulxl_s32_r[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/narh.c b/tests/csky/dspv2/case/narh.c
new file mode 100644
index 0000000..cf354fd
--- /dev/null
+++ b/tests/csky/dspv2/case/narh.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn narh\n");
+
+    for (i = 0;
+         i < sizeof(samples_narh)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_narh(samples_narh[i].op1, samples_narh[i].op2)
+                     == samples_narh[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/narhx.c b/tests/csky/dspv2/case/narhx.c
new file mode 100644
index 0000000..3d0484b
--- /dev/null
+++ b/tests/csky/dspv2/case/narhx.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn narhx\n");
+
+    for (i = 0;
+         i < sizeof(samples_narhx)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_narhx(samples_narhx[i].op1, samples_narhx[i].op2)
+                     == samples_narhx[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/narl.c b/tests/csky/dspv2/case/narl.c
new file mode 100644
index 0000000..dbca27f
--- /dev/null
+++ b/tests/csky/dspv2/case/narl.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn narl\n");
+
+    for (i = 0;
+         i < sizeof(samples_narl)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_narl(samples_narl[i].op1, samples_narl[i].op2)
+                     == samples_narl[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/narlx.c b/tests/csky/dspv2/case/narlx.c
new file mode 100644
index 0000000..95f2cbe
--- /dev/null
+++ b/tests/csky/dspv2/case/narlx.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn narlx\n");
+
+    for (i = 0;
+         i < sizeof(samples_narlx)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_narlx(samples_narlx[i].op1, samples_narlx[i].op2)
+                     == samples_narlx[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/neg_s32_s.c b/tests/csky/dspv2/case/neg_s32_s.c
new file mode 100644
index 0000000..973918c
--- /dev/null
+++ b/tests/csky/dspv2/case/neg_s32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn neg.s32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_neg_s32_s)/sizeof(struct unary_calculation);
+         i++) {
+        TEST(test_neg_s32_s(samples_neg_s32_s[i].op1)
+                     == samples_neg_s32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pabs_s16_s.c b/tests/csky/dspv2/case/pabs_s16_s.c
new file mode 100644
index 0000000..20886a0
--- /dev/null
+++ b/tests/csky/dspv2/case/pabs_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pabs.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_pabs_s16_s)/sizeof(struct unary_calculation);
+         i++) {
+        TEST(test_pabs_s16_s(samples_pabs_s16_s[i].op1)
+                     == samples_pabs_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pabs_s8_s.c b/tests/csky/dspv2/case/pabs_s8_s.c
new file mode 100644
index 0000000..a5228a4
--- /dev/null
+++ b/tests/csky/dspv2/case/pabs_s8_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pabs.s8.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_pabs_s8_s)/sizeof(struct unary_calculation);
+         i++) {
+        TEST(test_pabs_s8_s(samples_pabs_s8_s[i].op1)
+                     == samples_pabs_s8_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/padd_16.c b/tests/csky/dspv2/case/padd_16.c
new file mode 100644
index 0000000..4d927c9
--- /dev/null
+++ b/tests/csky/dspv2/case/padd_16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn padd.16\n");
+
+    for (i = 0;
+         i < sizeof(samples_padd_16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_padd_16(samples_padd_16[i].op1, samples_padd_16[i].op2)
+                     == samples_padd_16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/padd_8.c b/tests/csky/dspv2/case/padd_8.c
new file mode 100644
index 0000000..5c8327b
--- /dev/null
+++ b/tests/csky/dspv2/case/padd_8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn padd.8\n");
+
+    for (i = 0;
+         i < sizeof(samples_padd_8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_padd_8(samples_padd_8[i].op1, samples_padd_8[i].op2)
+                     == samples_padd_8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/padd_s16_s.c b/tests/csky/dspv2/case/padd_s16_s.c
new file mode 100644
index 0000000..b001a41
--- /dev/null
+++ b/tests/csky/dspv2/case/padd_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn padd.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_padd_s16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_padd_s16_s(samples_padd_s16_s[i].op1, samples_padd_s16_s[i].op2)
+                     == samples_padd_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/padd_s8_s.c b/tests/csky/dspv2/case/padd_s8_s.c
new file mode 100644
index 0000000..17f56cd
--- /dev/null
+++ b/tests/csky/dspv2/case/padd_s8_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn padd.s8.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_padd_s8_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_padd_s8_s(samples_padd_s8_s[i].op1, samples_padd_s8_s[i].op2)
+                     == samples_padd_s8_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/padd_u16_s.c b/tests/csky/dspv2/case/padd_u16_s.c
new file mode 100644
index 0000000..a25f754
--- /dev/null
+++ b/tests/csky/dspv2/case/padd_u16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn padd.u16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_padd_u16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_padd_u16_s(samples_padd_u16_s[i].op1, samples_padd_u16_s[i].op2)
+                     == samples_padd_u16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/padd_u8_s.c b/tests/csky/dspv2/case/padd_u8_s.c
new file mode 100644
index 0000000..6b3072d
--- /dev/null
+++ b/tests/csky/dspv2/case/padd_u8_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn padd.u8.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_padd_u8_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_padd_u8_s(samples_padd_u8_s[i].op1, samples_padd_u8_s[i].op2)
+                     == samples_padd_u8_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/paddh_s16.c b/tests/csky/dspv2/case/paddh_s16.c
new file mode 100644
index 0000000..905b3b0
--- /dev/null
+++ b/tests/csky/dspv2/case/paddh_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn paddh.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_paddh_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_paddh_s16(samples_paddh_s16[i].op1, samples_paddh_s16[i].op2)
+                     == samples_paddh_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/paddh_s8.c b/tests/csky/dspv2/case/paddh_s8.c
new file mode 100644
index 0000000..cbdafd9
--- /dev/null
+++ b/tests/csky/dspv2/case/paddh_s8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn paddh.s8\n");
+
+    for (i = 0;
+         i < sizeof(samples_paddh_s8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_paddh_s8(samples_paddh_s8[i].op1, samples_paddh_s8[i].op2)
+                     == samples_paddh_s8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/paddh_u16.c b/tests/csky/dspv2/case/paddh_u16.c
new file mode 100644
index 0000000..a8e49fe
--- /dev/null
+++ b/tests/csky/dspv2/case/paddh_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn paddh.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_paddh_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_paddh_u16(samples_paddh_u16[i].op1, samples_paddh_u16[i].op2)
+                     == samples_paddh_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/paddh_u8.c b/tests/csky/dspv2/case/paddh_u8.c
new file mode 100644
index 0000000..65abbc6
--- /dev/null
+++ b/tests/csky/dspv2/case/paddh_u8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn paddh.u8\n");
+
+    for (i = 0;
+         i < sizeof(samples_paddh_u8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_paddh_u8(samples_paddh_u8[i].op1, samples_paddh_u8[i].op2)
+                     == samples_paddh_u8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pasr_s16.c b/tests/csky/dspv2/case/pasr_s16.c
new file mode 100644
index 0000000..be3f920
--- /dev/null
+++ b/tests/csky/dspv2/case/pasr_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pasr.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pasr_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pasr_s16(samples_pasr_s16[i].op1, samples_pasr_s16[i].op2)
+                     == samples_pasr_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pasr_s16_r.c b/tests/csky/dspv2/case/pasr_s16_r.c
new file mode 100644
index 0000000..d7c7e06
--- /dev/null
+++ b/tests/csky/dspv2/case/pasr_s16_r.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pasr.s16.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_pasr_s16_r)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pasr_s16_r(samples_pasr_s16_r[i].op1, samples_pasr_s16_r[i].op2)
+                     == samples_pasr_s16_r[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pasri_s16.c b/tests/csky/dspv2/case/pasri_s16.c
new file mode 100644
index 0000000..cecaa03
--- /dev/null
+++ b/tests/csky/dspv2/case/pasri_s16.c
@@ -0,0 +1,28 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pasri.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pasri_s16)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_pasri_s16[i].op2 == 1) {
+            TEST(test_pasri_s16_1(samples_pasri_s16[i].op1)
+                 == samples_pasri_s16[i].result);
+        } else if (samples_pasri_s16[i].op2 == 2) {
+            TEST(test_pasri_s16_2(samples_pasri_s16[i].op1)
+                 == samples_pasri_s16[i].result);
+        } else if (samples_pasri_s16[i].op2 == 15) {
+            TEST(test_pasri_s16_15(samples_pasri_s16[i].op1)
+                 == samples_pasri_s16[i].result);
+        } else if (samples_pasri_s16[i].op2 == 16) {
+            TEST(test_pasri_s16_16(samples_pasri_s16[i].op1)
+                 == samples_pasri_s16[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pasri_s16_r.c b/tests/csky/dspv2/case/pasri_s16_r.c
new file mode 100644
index 0000000..f82925a
--- /dev/null
+++ b/tests/csky/dspv2/case/pasri_s16_r.c
@@ -0,0 +1,25 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pasri.s16.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_pasri_s16_r)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_pasri_s16_r[i].op2 == 1) {
+            TEST(test_pasri_s16_r_1(samples_pasri_s16_r[i].op1)
+                 == samples_pasri_s16_r[i].result);
+        } else if (samples_pasri_s16_r[i].op2 == 2) {
+            TEST(test_pasri_s16_r_2(samples_pasri_s16_r[i].op1)
+                 == samples_pasri_s16_r[i].result);
+        } else if (samples_pasri_s16_r[i].op2 == 15) {
+            TEST(test_pasri_s16_r_15(samples_pasri_s16_r[i].op1)
+                 == samples_pasri_s16_r[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pasx_16.c b/tests/csky/dspv2/case/pasx_16.c
new file mode 100644
index 0000000..7c44d6e
--- /dev/null
+++ b/tests/csky/dspv2/case/pasx_16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pasx.16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pasx_16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pasx_16(samples_pasx_16[i].op1, samples_pasx_16[i].op2)
+                     == samples_pasx_16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pasx_s16_s.c b/tests/csky/dspv2/case/pasx_s16_s.c
new file mode 100644
index 0000000..0006c46
--- /dev/null
+++ b/tests/csky/dspv2/case/pasx_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pasx.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_pasx_s16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pasx_s16_s(samples_pasx_s16_s[i].op1, samples_pasx_s16_s[i].op2)
+                     == samples_pasx_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pasx_u16_s.c b/tests/csky/dspv2/case/pasx_u16_s.c
new file mode 100644
index 0000000..4f6041d
--- /dev/null
+++ b/tests/csky/dspv2/case/pasx_u16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pasx.u16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_pasx_u16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pasx_u16_s(samples_pasx_u16_s[i].op1, samples_pasx_u16_s[i].op2)
+                     == samples_pasx_u16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pasxh_s16.c b/tests/csky/dspv2/case/pasxh_s16.c
new file mode 100644
index 0000000..1d05734
--- /dev/null
+++ b/tests/csky/dspv2/case/pasxh_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pasxh.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pasxh_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pasxh_s16(samples_pasxh_s16[i].op1, samples_pasxh_s16[i].op2)
+                     == samples_pasxh_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pasxh_u16.c b/tests/csky/dspv2/case/pasxh_u16.c
new file mode 100644
index 0000000..9b59eca
--- /dev/null
+++ b/tests/csky/dspv2/case/pasxh_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pasxh.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pasxh_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pasxh_u16(samples_pasxh_u16[i].op1, samples_pasxh_u16[i].op2)
+                     == samples_pasxh_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pclip_s16.c b/tests/csky/dspv2/case/pclip_s16.c
new file mode 100644
index 0000000..b395f92
--- /dev/null
+++ b/tests/csky/dspv2/case/pclip_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pclip.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pclip_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pclip_s16(samples_pclip_s16[i].op1, samples_pclip_s16[i].op2)
+                     == samples_pclip_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pclip_u16.c b/tests/csky/dspv2/case/pclip_u16.c
new file mode 100644
index 0000000..b5d4028
--- /dev/null
+++ b/tests/csky/dspv2/case/pclip_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pclip.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pclip_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pclip_u16(samples_pclip_u16[i].op1, samples_pclip_u16[i].op2)
+                     == samples_pclip_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pclipi_s16.c b/tests/csky/dspv2/case/pclipi_s16.c
new file mode 100644
index 0000000..9023972
--- /dev/null
+++ b/tests/csky/dspv2/case/pclipi_s16.c
@@ -0,0 +1,31 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pclipi.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pclipi_s16)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_pclipi_s16[i].op2 == 0) {
+            TEST(test_pclipi_s16_0(samples_pclipi_s16[i].op1)
+                 == samples_pclipi_s16[i].result);
+        } else if (samples_pclipi_s16[i].op2 == 1) {
+            TEST(test_pclipi_s16_1(samples_pclipi_s16[i].op1)
+                 == samples_pclipi_s16[i].result);
+        } else if (samples_pclipi_s16[i].op2 == 2) {
+            TEST(test_pclipi_s16_2(samples_pclipi_s16[i].op1)
+                 == samples_pclipi_s16[i].result);
+        } else if (samples_pclipi_s16[i].op2 == 7) {
+            TEST(test_pclipi_s16_7(samples_pclipi_s16[i].op1)
+                 == samples_pclipi_s16[i].result);
+        } else if (samples_pclipi_s16[i].op2 == 15) {
+            TEST(test_pclipi_s16_15(samples_pclipi_s16[i].op1)
+                 == samples_pclipi_s16[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pclipi_u16.c b/tests/csky/dspv2/case/pclipi_u16.c
new file mode 100644
index 0000000..2c80b94
--- /dev/null
+++ b/tests/csky/dspv2/case/pclipi_u16.c
@@ -0,0 +1,31 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pclipi.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pclipi_u16)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_pclipi_u16[i].op2 == 0) {
+            TEST(test_pclipi_u16_0(samples_pclipi_u16[i].op1)
+                 == samples_pclipi_u16[i].result);
+        } else if (samples_pclipi_u16[i].op2 == 1) {
+            TEST(test_pclipi_u16_1(samples_pclipi_u16[i].op1)
+                 == samples_pclipi_u16[i].result);
+        } else if (samples_pclipi_u16[i].op2 == 2) {
+            TEST(test_pclipi_u16_2(samples_pclipi_u16[i].op1)
+                 == samples_pclipi_u16[i].result);
+        } else if (samples_pclipi_u16[i].op2 == 7) {
+            TEST(test_pclipi_u16_7(samples_pclipi_u16[i].op1)
+                 == samples_pclipi_u16[i].result);
+        } else if (samples_pclipi_u16[i].op2 == 15) {
+            TEST(test_pclipi_u16_15(samples_pclipi_u16[i].op1)
+                 == samples_pclipi_u16[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pcmphs_s16.c b/tests/csky/dspv2/case/pcmphs_s16.c
new file mode 100644
index 0000000..eb47a87
--- /dev/null
+++ b/tests/csky/dspv2/case/pcmphs_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pcmphs.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pcmphs_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pcmphs_s16(samples_pcmphs_s16[i].op1, samples_pcmphs_s16[i].op2)
+                     == samples_pcmphs_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pcmphs_s8.c b/tests/csky/dspv2/case/pcmphs_s8.c
new file mode 100644
index 0000000..fdb9f8c
--- /dev/null
+++ b/tests/csky/dspv2/case/pcmphs_s8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pcmphs.s8\n");
+
+    for (i = 0;
+         i < sizeof(samples_pcmphs_s8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pcmphs_s8(samples_pcmphs_s8[i].op1, samples_pcmphs_s8[i].op2)
+                     == samples_pcmphs_s8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pcmphs_u16.c b/tests/csky/dspv2/case/pcmphs_u16.c
new file mode 100644
index 0000000..36242c2
--- /dev/null
+++ b/tests/csky/dspv2/case/pcmphs_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pcmphs.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pcmphs_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pcmphs_u16(samples_pcmphs_u16[i].op1, samples_pcmphs_u16[i].op2)
+                     == samples_pcmphs_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pcmphs_u8.c b/tests/csky/dspv2/case/pcmphs_u8.c
new file mode 100644
index 0000000..e47c32e
--- /dev/null
+++ b/tests/csky/dspv2/case/pcmphs_u8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pcmphs.u8\n");
+
+    for (i = 0;
+         i < sizeof(samples_pcmphs_u8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pcmphs_u8(samples_pcmphs_u8[i].op1, samples_pcmphs_u8[i].op2)
+                     == samples_pcmphs_u8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pcmplt_s16.c b/tests/csky/dspv2/case/pcmplt_s16.c
new file mode 100644
index 0000000..d6c04ee
--- /dev/null
+++ b/tests/csky/dspv2/case/pcmplt_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pcmplt.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pcmplt_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pcmplt_s16(samples_pcmplt_s16[i].op1, samples_pcmplt_s16[i].op2)
+                     == samples_pcmplt_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pcmplt_s8.c b/tests/csky/dspv2/case/pcmplt_s8.c
new file mode 100644
index 0000000..71f5303
--- /dev/null
+++ b/tests/csky/dspv2/case/pcmplt_s8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pcmplt.s8\n");
+
+    for (i = 0;
+         i < sizeof(samples_pcmplt_s8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pcmplt_s8(samples_pcmplt_s8[i].op1, samples_pcmplt_s8[i].op2)
+                     == samples_pcmplt_s8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pcmplt_u16.c b/tests/csky/dspv2/case/pcmplt_u16.c
new file mode 100644
index 0000000..5dfc0a2
--- /dev/null
+++ b/tests/csky/dspv2/case/pcmplt_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pcmplt.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pcmplt_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pcmplt_u16(samples_pcmplt_u16[i].op1, samples_pcmplt_u16[i].op2)
+                     == samples_pcmplt_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pcmplt_u8.c b/tests/csky/dspv2/case/pcmplt_u8.c
new file mode 100644
index 0000000..b3bca11
--- /dev/null
+++ b/tests/csky/dspv2/case/pcmplt_u8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pcmplt.u8\n");
+
+    for (i = 0;
+         i < sizeof(samples_pcmplt_u8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pcmplt_u8(samples_pcmplt_u8[i].op1, samples_pcmplt_u8[i].op2)
+                     == samples_pcmplt_u8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pcmpne_16.c b/tests/csky/dspv2/case/pcmpne_16.c
new file mode 100644
index 0000000..ca42065
--- /dev/null
+++ b/tests/csky/dspv2/case/pcmpne_16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pcmpne.16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pcmpne_16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pcmpne_16(samples_pcmpne_16[i].op1, samples_pcmpne_16[i].op2)
+                     == samples_pcmpne_16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pcmpne_8.c b/tests/csky/dspv2/case/pcmpne_8.c
new file mode 100644
index 0000000..8e34d3d
--- /dev/null
+++ b/tests/csky/dspv2/case/pcmpne_8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pcmpne.8\n");
+
+    for (i = 0;
+         i < sizeof(samples_pcmpne_8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pcmpne_8(samples_pcmpne_8[i].op1, samples_pcmpne_8[i].op2)
+                     == samples_pcmpne_8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pext_s8_e.c b/tests/csky/dspv2/case/pext_s8_e.c
new file mode 100644
index 0000000..a662d95
--- /dev/null
+++ b/tests/csky/dspv2/case/pext_s8_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pext.s8.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_pext_s8_e)/sizeof(struct unary64_calculation);
+         i++) {
+        TEST(test_pext_s8_e(samples_pext_s8_e[i].op1)
+                     == samples_pext_s8_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pext_u8_e.c b/tests/csky/dspv2/case/pext_u8_e.c
new file mode 100644
index 0000000..84b0f0c
--- /dev/null
+++ b/tests/csky/dspv2/case/pext_u8_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pext.u8.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_pext_u8_e)/sizeof(struct unary64_calculation);
+         i++) {
+        TEST(test_pext_u8_e(samples_pext_u8_e[i].op1)
+                     == samples_pext_u8_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pextx_s8_e.c b/tests/csky/dspv2/case/pextx_s8_e.c
new file mode 100644
index 0000000..550076b
--- /dev/null
+++ b/tests/csky/dspv2/case/pextx_s8_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pextx.s8.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_pextx_s8_e)/sizeof(struct unary64_calculation);
+         i++) {
+        TEST(test_pextx_s8_e(samples_pextx_s8_e[i].op1)
+                     == samples_pextx_s8_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pextx_u8_e.c b/tests/csky/dspv2/case/pextx_u8_e.c
new file mode 100644
index 0000000..40dce4e
--- /dev/null
+++ b/tests/csky/dspv2/case/pextx_u8_e.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pextx.u8.e\n");
+
+    for (i = 0;
+         i < sizeof(samples_pextx_u8_e)/sizeof(struct unary64_calculation);
+         i++) {
+        TEST(test_pextx_u8_e(samples_pextx_u8_e[i].op1)
+                     == samples_pextx_u8_e[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pkg.c b/tests/csky/dspv2/case/pkg.c
new file mode 100644
index 0000000..ee5dc93
--- /dev/null
+++ b/tests/csky/dspv2/case/pkg.c
@@ -0,0 +1,35 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    int res = 0;
+    init_testsuite("Testing insn pkg\n");
+
+    for (i = 0;
+         i < sizeof(samples_pkg)/sizeof(struct quanary_calculation);
+         i++) {
+        if ((samples_pkg[i].op2 == 4) && (samples_pkg[i].op4 == 16)) {
+            res = test_pkg_4_16(samples_pkg[i].op1, samples_pkg[i].op3);
+            TEST(res == samples_pkg[i].result);
+        } else if ((samples_pkg[i].op2 == 2) && (samples_pkg[i].op4 == 3)) {
+            res = test_pkg_2_3(samples_pkg[i].op1, samples_pkg[i].op3);
+            TEST(res == samples_pkg[i].result);
+        } else if ((samples_pkg[i].op2 == 4) && (samples_pkg[i].op4 == 4)) {
+            res = test_pkg_4_4(samples_pkg[i].op1, samples_pkg[i].op3);
+            TEST(res == samples_pkg[i].result);
+        } else if ((samples_pkg[i].op2 == 8) && (samples_pkg[i].op4 == 8)) {
+            res =test_pkg_8_8(samples_pkg[i].op1, samples_pkg[i].op3);
+            TEST(res == samples_pkg[i].result);
+        } else if ((samples_pkg[i].op2 == 0) && (samples_pkg[i].op4 == 15)) {
+            res = test_pkg_0_15(samples_pkg[i].op1, samples_pkg[i].op3);
+            TEST(res == samples_pkg[i].result);
+        } else if ((samples_pkg[i].op2 == 15) && (samples_pkg[i].op4 == 15)) {
+            res = test_pkg_15_15(samples_pkg[i].op1, samples_pkg[i].op3);
+            TEST(res == samples_pkg[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pkghh.c b/tests/csky/dspv2/case/pkghh.c
new file mode 100644
index 0000000..91c47b6
--- /dev/null
+++ b/tests/csky/dspv2/case/pkghh.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pkghh\n");
+
+    for (i = 0;
+         i < sizeof(samples_pkghh)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pkghh(samples_pkghh[i].op1, samples_pkghh[i].op2)
+                     == samples_pkghh[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pkgll.c b/tests/csky/dspv2/case/pkgll.c
new file mode 100644
index 0000000..6da598c
--- /dev/null
+++ b/tests/csky/dspv2/case/pkgll.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pkgll\n");
+
+    for (i = 0;
+         i < sizeof(samples_pkgll)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pkgll(samples_pkgll[i].op1, samples_pkgll[i].op2)
+                     == samples_pkgll[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pldbi_d.c b/tests/csky/dspv2/case/pldbi_d.c
new file mode 100644
index 0000000..b76fc87
--- /dev/null
+++ b/tests/csky/dspv2/case/pldbi_d.c
@@ -0,0 +1,39 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn PLDBI.D \n");
+
+    TEST(test_pldbi_d() == 0x00010001c0c0c0c0);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/pldbir_d.c b/tests/csky/dspv2/case/pldbir_d.c
new file mode 100644
index 0000000..7e9ce1c
--- /dev/null
+++ b/tests/csky/dspv2/case/pldbir_d.c
@@ -0,0 +1,39 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn PLDBIR.D \n");
+
+    TEST(test_pldbir_d(4) == 0x00010001c0c0c0c0);
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/plsl_s16_s.c b/tests/csky/dspv2/case/plsl_s16_s.c
new file mode 100644
index 0000000..e542d05
--- /dev/null
+++ b/tests/csky/dspv2/case/plsl_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn plsl.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_plsl_s16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_plsl_s16_s(samples_plsl_s16_s[i].op1, samples_plsl_s16_s[i].op2)
+                     == samples_plsl_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/plsl_u16.c b/tests/csky/dspv2/case/plsl_u16.c
new file mode 100644
index 0000000..60f8234
--- /dev/null
+++ b/tests/csky/dspv2/case/plsl_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn plsl.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_plsl_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_plsl_u16(samples_plsl_u16[i].op1, samples_plsl_u16[i].op2)
+                     == samples_plsl_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/plsl_u16_s.c b/tests/csky/dspv2/case/plsl_u16_s.c
new file mode 100644
index 0000000..13f32b8
--- /dev/null
+++ b/tests/csky/dspv2/case/plsl_u16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn plsl.u16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_plsl_u16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_plsl_u16_s(samples_plsl_u16_s[i].op1, samples_plsl_u16_s[i].op2)
+                     == samples_plsl_u16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/plsli_s16_s.c b/tests/csky/dspv2/case/plsli_s16_s.c
new file mode 100644
index 0000000..626a6af
--- /dev/null
+++ b/tests/csky/dspv2/case/plsli_s16_s.c
@@ -0,0 +1,28 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn plsli.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_plsli_s16_s)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_plsli_s16_s[i].op2 == 1) {
+        TEST(test_plsli_s16_s_1(samples_plsli_s16_s[i].op1)
+                     == samples_plsli_s16_s[i].result);
+        } else if (samples_plsli_s16_s[i].op2 == 2) {
+        TEST(test_plsli_s16_s_2(samples_plsli_s16_s[i].op1)
+                     == samples_plsli_s16_s[i].result);
+        } else if (samples_plsli_s16_s[i].op2 == 9) {
+        TEST(test_plsli_s16_s_9(samples_plsli_s16_s[i].op1)
+                     == samples_plsli_s16_s[i].result);
+        } else if (samples_plsli_s16_s[i].op2 == 16) {
+        TEST(test_plsli_s16_s_16(samples_plsli_s16_s[i].op1)
+                     == samples_plsli_s16_s[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/plsli_u16.c b/tests/csky/dspv2/case/plsli_u16.c
new file mode 100644
index 0000000..108395c
--- /dev/null
+++ b/tests/csky/dspv2/case/plsli_u16.c
@@ -0,0 +1,25 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn plsli.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_plsli_u16)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_plsli_u16[i].op2 == 1) {
+        TEST(test_plsli_u16_1(samples_plsli_u16[i].op1)
+                     == samples_plsli_u16[i].result);
+        } else if (samples_plsli_u16[i].op2 == 9) {
+        TEST(test_plsli_u16_9(samples_plsli_u16[i].op1)
+                     == samples_plsli_u16[i].result);
+        } else if (samples_plsli_u16[i].op2 == 16) {
+        TEST(test_plsli_u16_16(samples_plsli_u16[i].op1)
+                     == samples_plsli_u16[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/plsli_u16_s.c b/tests/csky/dspv2/case/plsli_u16_s.c
new file mode 100644
index 0000000..b6da51b
--- /dev/null
+++ b/tests/csky/dspv2/case/plsli_u16_s.c
@@ -0,0 +1,25 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn plsli.u16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_plsli_u16_s)/sizeof(struct binary_calculation);
+         i++) {
+        if (samples_plsli_u16_s[i].op2 == 1) {
+        TEST(test_plsli_u16_s_1(samples_plsli_u16_s[i].op1)
+                     == samples_plsli_u16_s[i].result);
+        } else if (samples_plsli_u16_s[i].op2 == 9) {
+        TEST(test_plsli_u16_s_9(samples_plsli_u16_s[i].op1)
+                     == samples_plsli_u16_s[i].result);
+        } else if (samples_plsli_u16_s[i].op2 == 16) {
+        TEST(test_plsli_u16_s_16(samples_plsli_u16_s[i].op1)
+                     == samples_plsli_u16_s[i].result);
+        }
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/plsr_u16.c b/tests/csky/dspv2/case/plsr_u16.c
new file mode 100644
index 0000000..3b59c02
--- /dev/null
+++ b/tests/csky/dspv2/case/plsr_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn plsr.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_plsr_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_plsr_u16(samples_plsr_u16[i].op1, samples_plsr_u16[i].op2)
+                     == samples_plsr_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/plsr_u16_r.c b/tests/csky/dspv2/case/plsr_u16_r.c
new file mode 100644
index 0000000..4c2639f
--- /dev/null
+++ b/tests/csky/dspv2/case/plsr_u16_r.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn plsr.u16.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_plsr_u16_r)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_plsr_u16_r(samples_plsr_u16_r[i].op1, samples_plsr_u16_r[i].op2)
+                     == samples_plsr_u16_r[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/plsri_u16.c b/tests/csky/dspv2/case/plsri_u16.c
new file mode 100644
index 0000000..0ad2161
--- /dev/null
+++ b/tests/csky/dspv2/case/plsri_u16.c
@@ -0,0 +1,29 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn plsri.u16\n");
+    for (i = 0;
+         i < sizeof(samples_plsri_u16)/sizeof(struct binary_calculation);
+         i++) {
+        if(samples_plsri_u16[i].op2 == 0x1)
+            TEST(test_plsri_u16_1(samples_plsri_u16[i].op1, samples_plsri_u16[i].op2)
+                     == samples_plsri_u16[i].result);
+        else if(samples_plsri_u16[i].op2 == 0x2)
+            TEST(test_plsri_u16_2(samples_plsri_u16[i].op1, samples_plsri_u16[i].op2)
+                     == samples_plsri_u16[i].result);
+        else if(samples_plsri_u16[i].op2 == 0x3)
+            TEST(test_plsri_u16_3(samples_plsri_u16[i].op1, samples_plsri_u16[i].op2)
+                     == samples_plsri_u16[i].result);
+        else if(samples_plsri_u16[i].op2 == 0xf)
+            TEST(test_plsri_u16_f(samples_plsri_u16[i].op1, samples_plsri_u16[i].op2)
+                     == samples_plsri_u16[i].result);
+        else if(samples_plsri_u16[i].op2 == 0x10)
+            TEST(test_plsri_u16_10(samples_plsri_u16[i].op1, samples_plsri_u16[i].op2)
+                     == samples_plsri_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/plsri_u16_r.c b/tests/csky/dspv2/case/plsri_u16_r.c
new file mode 100644
index 0000000..1e4e1fd
--- /dev/null
+++ b/tests/csky/dspv2/case/plsri_u16_r.c
@@ -0,0 +1,30 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn plsri.u16.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_plsri_u16_r)/sizeof(struct binary_calculation);
+         i++) {
+        if(samples_plsri_u16_r[i].op2 == 0x1)
+            TEST(test_plsri_u16_r_1(samples_plsri_u16_r[i].op1, samples_plsri_u16_r[i].op2)
+                     == samples_plsri_u16_r[i].result);
+        else if(samples_plsri_u16_r[i].op2 == 0x2)
+            TEST(test_plsri_u16_r_2(samples_plsri_u16_r[i].op1, samples_plsri_u16_r[i].op2)
+                     == samples_plsri_u16_r[i].result);
+        else if(samples_plsri_u16_r[i].op2 == 0x3)
+            TEST(test_plsri_u16_r_3(samples_plsri_u16_r[i].op1, samples_plsri_u16_r[i].op2)
+                     == samples_plsri_u16_r[i].result);
+        else if(samples_plsri_u16_r[i].op2 == 0xf)
+            TEST(test_plsri_u16_r_f(samples_plsri_u16_r[i].op1, samples_plsri_u16_r[i].op2)
+                     == samples_plsri_u16_r[i].result);
+        else if(samples_plsri_u16_r[i].op2 == 0x10)
+            TEST(test_plsri_u16_r_10(samples_plsri_u16_r[i].op1, samples_plsri_u16_r[i].op2)
+                     == samples_plsri_u16_r[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmax_s16.c b/tests/csky/dspv2/case/pmax_s16.c
new file mode 100644
index 0000000..2cae5da
--- /dev/null
+++ b/tests/csky/dspv2/case/pmax_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmax.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmax_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pmax_s16(samples_pmax_s16[i].op1, samples_pmax_s16[i].op2)
+                     == samples_pmax_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmax_s8.c b/tests/csky/dspv2/case/pmax_s8.c
new file mode 100644
index 0000000..7ce7ba0
--- /dev/null
+++ b/tests/csky/dspv2/case/pmax_s8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmax.s8\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmax_s8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pmax_s8(samples_pmax_s8[i].op1, samples_pmax_s8[i].op2)
+                     == samples_pmax_s8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmax_u16.c b/tests/csky/dspv2/case/pmax_u16.c
new file mode 100644
index 0000000..08aaf33
--- /dev/null
+++ b/tests/csky/dspv2/case/pmax_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmax.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmax_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pmax_u16(samples_pmax_u16[i].op1, samples_pmax_u16[i].op2)
+                     == samples_pmax_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmax_u8.c b/tests/csky/dspv2/case/pmax_u8.c
new file mode 100644
index 0000000..58a64f9
--- /dev/null
+++ b/tests/csky/dspv2/case/pmax_u8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn max.u8\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmax_u8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pmax_u8(samples_pmax_u8[i].op1, samples_pmax_u8[i].op2)
+                     == samples_pmax_u8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmin_s16.c b/tests/csky/dspv2/case/pmin_s16.c
new file mode 100644
index 0000000..b982d73
--- /dev/null
+++ b/tests/csky/dspv2/case/pmin_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmin.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmin_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pmin_s16(samples_pmin_s16[i].op1, samples_pmin_s16[i].op2)
+                     == samples_pmin_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmin_s8.c b/tests/csky/dspv2/case/pmin_s8.c
new file mode 100644
index 0000000..3ebe29d
--- /dev/null
+++ b/tests/csky/dspv2/case/pmin_s8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmin.s8\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmin_s8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pmin_s8(samples_pmin_s8[i].op1, samples_pmin_s8[i].op2)
+                     == samples_pmin_s8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmin_u16.c b/tests/csky/dspv2/case/pmin_u16.c
new file mode 100644
index 0000000..c51167c
--- /dev/null
+++ b/tests/csky/dspv2/case/pmin_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmin.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmin_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pmin_u16(samples_pmin_u16[i].op1, samples_pmin_u16[i].op2)
+                     == samples_pmin_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmin_u8.c b/tests/csky/dspv2/case/pmin_u8.c
new file mode 100644
index 0000000..2a2ccef
--- /dev/null
+++ b/tests/csky/dspv2/case/pmin_u8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmin.u8\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmin_u8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_pmin_u8(samples_pmin_u8[i].op1, samples_pmin_u8[i].op2)
+                     == samples_pmin_u8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmul_s16.c b/tests/csky/dspv2/case/pmul_s16.c
new file mode 100644
index 0000000..261019d
--- /dev/null
+++ b/tests/csky/dspv2/case/pmul_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmul.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmul_s16)/sizeof(struct binary64_calculation);
+         i++) {
+        TEST(test_pmul_s16(samples_pmul_s16[i].op1, samples_pmul_s16[i].op2)
+                     == samples_pmul_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmul_u16.c b/tests/csky/dspv2/case/pmul_u16.c
new file mode 100644
index 0000000..7b68db6
--- /dev/null
+++ b/tests/csky/dspv2/case/pmul_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmul.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmul_u16)/sizeof(struct binary64_calculation);
+         i++) {
+        TEST(test_pmul_u16(samples_pmul_u16[i].op1, samples_pmul_u16[i].op2)
+                     == samples_pmul_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmulx_s16.c b/tests/csky/dspv2/case/pmulx_s16.c
new file mode 100644
index 0000000..6ef1aa5
--- /dev/null
+++ b/tests/csky/dspv2/case/pmulx_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmulx.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmulx_s16)/sizeof(struct binary64_calculation);
+         i++) {
+        TEST(test_pmulx_s16(samples_pmulx_s16[i].op1, samples_pmulx_s16[i].op2)
+                     == samples_pmulx_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pmulx_u16.c b/tests/csky/dspv2/case/pmulx_u16.c
new file mode 100644
index 0000000..742b2d5
--- /dev/null
+++ b/tests/csky/dspv2/case/pmulx_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pmulx.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_pmulx_u16)/sizeof(struct binary64_calculation);
+         i++) {
+        TEST(test_pmulx_u16(samples_pmulx_u16[i].op1, samples_pmulx_u16[i].op2)
+                     == samples_pmulx_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pneg_s16_s.c b/tests/csky/dspv2/case/pneg_s16_s.c
new file mode 100644
index 0000000..5f5aa9a
--- /dev/null
+++ b/tests/csky/dspv2/case/pneg_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pneg.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_pneg_s16_s)/sizeof(struct unary_calculation);
+         i++) {
+        TEST(test_pneg_s16_s(samples_pneg_s16_s[i].op1)
+                     == samples_pneg_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/pneg_s8_s.c b/tests/csky/dspv2/case/pneg_s8_s.c
new file mode 100644
index 0000000..1103b1a
--- /dev/null
+++ b/tests/csky/dspv2/case/pneg_s8_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn pneg.s8.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_pneg_s8_s)/sizeof(struct unary_calculation);
+         i++) {
+        TEST(test_pneg_s8_s(samples_pneg_s8_s[i].op1)
+                     == samples_pneg_s8_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/prmul_s16.c b/tests/csky/dspv2/case/prmul_s16.c
new file mode 100644
index 0000000..f9ddd75
--- /dev/null
+++ b/tests/csky/dspv2/case/prmul_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn prmul.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_prmul_s16)/sizeof(struct binary64_calculation);
+         i++) {
+        TEST(test_prmul_s16(samples_prmul_s16[i].op1, samples_prmul_s16[i].op2)
+                     == samples_prmul_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/prmul_s16_h.c b/tests/csky/dspv2/case/prmul_s16_h.c
new file mode 100644
index 0000000..a01b7d2
--- /dev/null
+++ b/tests/csky/dspv2/case/prmul_s16_h.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn prmul.s16.h\n");
+
+    for (i = 0;
+         i < sizeof(samples_prmul_s16_h)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_prmul_s16_h(samples_prmul_s16_h[i].op1, samples_prmul_s16_h[i].op2)
+                     == samples_prmul_s16_h[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/prmul_s16_rh.c b/tests/csky/dspv2/case/prmul_s16_rh.c
new file mode 100644
index 0000000..83c427a
--- /dev/null
+++ b/tests/csky/dspv2/case/prmul_s16_rh.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn prmul.s16.rh\n");
+
+    for (i = 0;
+         i < sizeof(samples_prmul_s16_rh)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_prmul_s16_rh(samples_prmul_s16_rh[i].op1, samples_prmul_s16_rh[i].op2)
+                     == samples_prmul_s16_rh[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/prmulx_s16.c b/tests/csky/dspv2/case/prmulx_s16.c
new file mode 100644
index 0000000..e0c642c
--- /dev/null
+++ b/tests/csky/dspv2/case/prmulx_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn prmulx.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_prmulx_s16)/sizeof(struct binary64_calculation);
+         i++) {
+        TEST(test_prmulx_s16(samples_prmulx_s16[i].op1, samples_prmulx_s16[i].op2)
+                     == samples_prmulx_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/prmulx_s16_h.c b/tests/csky/dspv2/case/prmulx_s16_h.c
new file mode 100644
index 0000000..09b8956
--- /dev/null
+++ b/tests/csky/dspv2/case/prmulx_s16_h.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn prmulx.s16.h\n");
+
+    for (i = 0;
+         i < sizeof(samples_prmulx_s16_h)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_prmulx_s16_h(samples_prmulx_s16_h[i].op1, samples_prmulx_s16_h[i].op2)
+                     == samples_prmulx_s16_h[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/prmulx_s16_rh.c b/tests/csky/dspv2/case/prmulx_s16_rh.c
new file mode 100644
index 0000000..0093786
--- /dev/null
+++ b/tests/csky/dspv2/case/prmulx_s16_rh.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn prmulx.s16.rh\n");
+
+    for (i = 0;
+         i < sizeof(samples_prmulx_s16_rh)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_prmulx_s16_rh(samples_prmulx_s16_rh[i].op1, samples_prmulx_s16_rh[i].op2)
+                     == samples_prmulx_s16_rh[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psabsa_u8.c b/tests/csky/dspv2/case/psabsa_u8.c
new file mode 100644
index 0000000..b58cc6b
--- /dev/null
+++ b/tests/csky/dspv2/case/psabsa_u8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psabsa.u8\n");
+
+    for (i = 0;
+         i < sizeof(samples_psabsa_u8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psabsa_u8(samples_psabsa_u8[i].op1, samples_psabsa_u8[i].op2)
+                     == samples_psabsa_u8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psabsaa_u8.c b/tests/csky/dspv2/case/psabsaa_u8.c
new file mode 100644
index 0000000..360e3a7
--- /dev/null
+++ b/tests/csky/dspv2/case/psabsaa_u8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psabsaa.u8\n");
+
+    for (i = 0;
+         i < sizeof(samples_psabsaa_u8)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_psabsaa_u8(samples_psabsaa_u8[i].op1, samples_psabsaa_u8[i].op2, samples_psabsaa_u8[i].op3)
+                     == samples_psabsaa_u8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psax_16.c b/tests/csky/dspv2/case/psax_16.c
new file mode 100644
index 0000000..ef29ba4
--- /dev/null
+++ b/tests/csky/dspv2/case/psax_16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psax.16\n");
+
+    for (i = 0;
+         i < sizeof(samples_psax_16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psax_16(samples_psax_16[i].op1, samples_psax_16[i].op2)
+                     == samples_psax_16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psax_s16_s.c b/tests/csky/dspv2/case/psax_s16_s.c
new file mode 100644
index 0000000..7dc8913
--- /dev/null
+++ b/tests/csky/dspv2/case/psax_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psax.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_psax_s16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psax_s16_s(samples_psax_s16_s[i].op1, samples_psax_s16_s[i].op2)
+                     == samples_psax_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psax_u16_s.c b/tests/csky/dspv2/case/psax_u16_s.c
new file mode 100644
index 0000000..b021f3a
--- /dev/null
+++ b/tests/csky/dspv2/case/psax_u16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psax.u16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_psax_u16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psax_u16_s(samples_psax_u16_s[i].op1, samples_psax_u16_s[i].op2)
+                     == samples_psax_u16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psaxh_s16.c b/tests/csky/dspv2/case/psaxh_s16.c
new file mode 100644
index 0000000..b8c8554
--- /dev/null
+++ b/tests/csky/dspv2/case/psaxh_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psaxh.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_psaxh_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psaxh_s16(samples_psaxh_s16[i].op1, samples_psaxh_s16[i].op2)
+                     == samples_psaxh_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psaxh_u16.c b/tests/csky/dspv2/case/psaxh_u16.c
new file mode 100644
index 0000000..5ce2d09
--- /dev/null
+++ b/tests/csky/dspv2/case/psaxh_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psaxh.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_psaxh_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psaxh_u16(samples_psaxh_u16[i].op1, samples_psaxh_u16[i].op2)
+                     == samples_psaxh_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psub_16.c b/tests/csky/dspv2/case/psub_16.c
new file mode 100644
index 0000000..3600a58
--- /dev/null
+++ b/tests/csky/dspv2/case/psub_16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psub.16\n");
+
+    for (i = 0;
+         i < sizeof(samples_psub_16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psub_16(samples_psub_16[i].op1, samples_psub_16[i].op2)
+                     == samples_psub_16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psub_8.c b/tests/csky/dspv2/case/psub_8.c
new file mode 100644
index 0000000..f4836db
--- /dev/null
+++ b/tests/csky/dspv2/case/psub_8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psub.8\n");
+
+    for (i = 0;
+         i < sizeof(samples_psub_8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psub_8(samples_psub_8[i].op1, samples_psub_8[i].op2)
+                     == samples_psub_8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psub_s16_s.c b/tests/csky/dspv2/case/psub_s16_s.c
new file mode 100644
index 0000000..5830ff0
--- /dev/null
+++ b/tests/csky/dspv2/case/psub_s16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psub.s16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_psub_s16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psub_s16_s(samples_psub_s16_s[i].op1, samples_psub_s16_s[i].op2)
+                     == samples_psub_s16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psub_s8_s.c b/tests/csky/dspv2/case/psub_s8_s.c
new file mode 100644
index 0000000..69a0b4d
--- /dev/null
+++ b/tests/csky/dspv2/case/psub_s8_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psub.s8.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_psub_s8_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psub_s8_s(samples_psub_s8_s[i].op1, samples_psub_s8_s[i].op2)
+                     == samples_psub_s8_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psub_u16_s.c b/tests/csky/dspv2/case/psub_u16_s.c
new file mode 100644
index 0000000..902d0f3
--- /dev/null
+++ b/tests/csky/dspv2/case/psub_u16_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psub.u16.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_psub_u16_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psub_u16_s(samples_psub_u16_s[i].op1, samples_psub_u16_s[i].op2)
+                     == samples_psub_u16_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psub_u8_s.c b/tests/csky/dspv2/case/psub_u8_s.c
new file mode 100644
index 0000000..29cffec
--- /dev/null
+++ b/tests/csky/dspv2/case/psub_u8_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psub.u8.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_psub_u8_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psub_u8_s(samples_psub_u8_s[i].op1, samples_psub_u8_s[i].op2)
+                     == samples_psub_u8_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psubh_s16.c b/tests/csky/dspv2/case/psubh_s16.c
new file mode 100644
index 0000000..d83d8a7
--- /dev/null
+++ b/tests/csky/dspv2/case/psubh_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psubh.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_psubh_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psubh_s16(samples_psubh_s16[i].op1, samples_psubh_s16[i].op2)
+                     == samples_psubh_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psubh_s8.c b/tests/csky/dspv2/case/psubh_s8.c
new file mode 100644
index 0000000..10341a7
--- /dev/null
+++ b/tests/csky/dspv2/case/psubh_s8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psubh.s8\n");
+
+    for (i = 0;
+         i < sizeof(samples_psubh_s8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psubh_s8(samples_psubh_s8[i].op1, samples_psubh_s8[i].op2)
+                     == samples_psubh_s8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psubh_u16.c b/tests/csky/dspv2/case/psubh_u16.c
new file mode 100644
index 0000000..d6eda91
--- /dev/null
+++ b/tests/csky/dspv2/case/psubh_u16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psubh.u16\n");
+
+    for (i = 0;
+         i < sizeof(samples_psubh_u16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psubh_u16(samples_psubh_u16[i].op1, samples_psubh_u16[i].op2)
+                     == samples_psubh_u16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/psubh_u8.c b/tests/csky/dspv2/case/psubh_u8.c
new file mode 100644
index 0000000..f67223b
--- /dev/null
+++ b/tests/csky/dspv2/case/psubh_u8.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn psubh.u8\n");
+
+    for (i = 0;
+         i < sizeof(samples_psubh_u8)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_psubh_u8(samples_psubh_u8[i].op1, samples_psubh_u8[i].op2)
+                     == samples_psubh_u8[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/rmul_s32_h.c b/tests/csky/dspv2/case/rmul_s32_h.c
new file mode 100644
index 0000000..0879810
--- /dev/null
+++ b/tests/csky/dspv2/case/rmul_s32_h.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn rmul.s32.h\n");
+
+    for (i = 0;
+         i < sizeof(samples_rmul_s32_h)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_rmul_s32_h(samples_rmul_s32_h[i].op1, samples_rmul_s32_h[i].op2)
+                     == samples_rmul_s32_h[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/rmul_s32_rh.c b/tests/csky/dspv2/case/rmul_s32_rh.c
new file mode 100644
index 0000000..0758e3e
--- /dev/null
+++ b/tests/csky/dspv2/case/rmul_s32_rh.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn rmul.s32.rh\n");
+
+    for (i = 0;
+         i < sizeof(samples_rmul_s32_rh)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_rmul_s32_rh(samples_rmul_s32_rh[i].op1, samples_rmul_s32_rh[i].op2)
+                     == samples_rmul_s32_rh[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/rmulhh_s16.c b/tests/csky/dspv2/case/rmulhh_s16.c
new file mode 100644
index 0000000..b23e55f
--- /dev/null
+++ b/tests/csky/dspv2/case/rmulhh_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn rmulhh.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_rmulhh_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_rmulhh_s16(samples_rmulhh_s16[i].op1, samples_rmulhh_s16[i].op2)
+                     == samples_rmulhh_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/rmulhl_s16.c b/tests/csky/dspv2/case/rmulhl_s16.c
new file mode 100644
index 0000000..01f1210
--- /dev/null
+++ b/tests/csky/dspv2/case/rmulhl_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn rmulhl.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_rmulhl_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_rmulhl_s16(samples_rmulhl_s16[i].op1, samples_rmulhl_s16[i].op2)
+                     == samples_rmulhl_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/rmulll_s16.c b/tests/csky/dspv2/case/rmulll_s16.c
new file mode 100644
index 0000000..62f51ec
--- /dev/null
+++ b/tests/csky/dspv2/case/rmulll_s16.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn rmulll.s16\n");
+
+    for (i = 0;
+         i < sizeof(samples_rmulll_s16)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_rmulll_s16(samples_rmulll_s16[i].op1, samples_rmulll_s16[i].op2)
+                     == samples_rmulll_s16[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/rmulxh_s32.c b/tests/csky/dspv2/case/rmulxh_s32.c
new file mode 100644
index 0000000..9121faf
--- /dev/null
+++ b/tests/csky/dspv2/case/rmulxh_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn rmulxh.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_rmulxh_s32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_rmulxh_s32(samples_rmulxh_s32[i].op1, samples_rmulxh_s32[i].op2)
+                     == samples_rmulxh_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/rmulxh_s32_r.c b/tests/csky/dspv2/case/rmulxh_s32_r.c
new file mode 100644
index 0000000..d1a4781
--- /dev/null
+++ b/tests/csky/dspv2/case/rmulxh_s32_r.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn rmulxh.s32.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_rmulxh_s32_r)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_rmulxh_s32_r(samples_rmulxh_s32_r[i].op1, samples_rmulxh_s32_r[i].op2)
+                     == samples_rmulxh_s32_r[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/rmulxl_s32.c b/tests/csky/dspv2/case/rmulxl_s32.c
new file mode 100644
index 0000000..b07b07a
--- /dev/null
+++ b/tests/csky/dspv2/case/rmulxl_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn rmulxl.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_rmulxl_s32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_rmulxl_s32(samples_rmulxl_s32[i].op1, samples_rmulxl_s32[i].op2)
+                     == samples_rmulxl_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/rmulxl_s32_r.c b/tests/csky/dspv2/case/rmulxl_s32_r.c
new file mode 100644
index 0000000..98d06fd
--- /dev/null
+++ b/tests/csky/dspv2/case/rmulxl_s32_r.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn rmulxl.s32.r\n");
+
+    for (i = 0;
+         i < sizeof(samples_rmulxl_s32_r)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_rmulxl_s32_r(samples_rmulxl_s32_r[i].op1, samples_rmulxl_s32_r[i].op2)
+                     == samples_rmulxl_s32_r[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/sample_array.h b/tests/csky/dspv2/case/sample_array.h
new file mode 100644
index 0000000..b312539
--- /dev/null
+++ b/tests/csky/dspv2/case/sample_array.h
@@ -0,0 +1,3473 @@
+#include "test_device.h"
+#ifndef SAMPLE_ARRAY_H
+#define SAMPLE_ARRAY_H
+
+/* psub.8 */
+struct binary_calculation samples_psub_8[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0x00000001, 0xffffffff, 0x01010102},
+    {0xffffffff, 0x00000001, 0xfffffffe},
+    {0x00000000, 0x7fffffff, 0x81010101},
+    {0x00000000, 0x80000000, 0x80000000},
+    {0x00000000, 0xffffffff, 0x01010101},
+    {0xffffffff, 0x80000000, 0x7fffffff},
+    {0x80000000, 0xffffffff, 0x81010101},
+    {0xffffffff, 0x7fffffff, 0x80000000},
+    {0x22221111, 0x11112020, 0x1111f1f1},
+};
+
+/* psub.16 */
+struct binary_calculation samples_psub_16[] = {
+    {0x00010001, 0x00010001, 0x00000000},
+    {0x0001ffff, 0x00020001, 0xfffffffe},
+    {0xffff0001, 0x00010002, 0xfffeffff},
+    {0x00010001, 0x00020002, 0xffffffff},
+    {0x00020002, 0x00010001, 0x00010001},
+    {0x00000000, 0xffffffff, 0x00010001},
+    {0x00000000, 0x7fffffff, 0x80010001},
+    {0x00000000, 0x80000000, 0x80000000},
+    {0x80000000, 0x7fffffff, 0x00010001},
+    {0x7fffffff, 0x80000000, 0xffffffff},
+    {0x7fffffff, 0xffffffff, 0x80000000},
+    {0x88881111, 0x11112020, 0x7777f0f1},
+};
+
+/* padd.8 */
+struct binary_calculation samples_padd_8[] = {
+    {0x00000000, 0x11111111, 0x11111111},
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xff000000, 0x01000000, 0x00000000},
+    {0xffffffff, 0x01010101, 0x00000000},
+    {0x80808080, 0x80808080, 0x00000000},
+    {0x7f7f7f7f, 0x01010101, 0x80808080},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0xfefefefe},
+    {0x11888888, 0x22888888, 0x33101010},
+};
+
+/* padd.16 */
+struct binary_calculation samples_padd_16[] = {
+    {0x12345678, 0x11112222, 0x2345789A},
+    {0x9000A000, 0xA000B000, 0x30005000},
+    {0xFFFF8000, 0x00008000, 0xFFFF0000},
+    {0xffffffff, 0xffffffff, 0xfffefffe},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0x7fff7fff, 0x80008000, 0xffffffff},
+    {0x7fffffff, 0x80000000, 0xffffffff},
+    {0x88888888, 0x88888888, 0x11101110},
+};
+
+/* pasx.16 */
+struct binary_calculation samples_pasx_16[] = {
+    {0x00000001, 0x00000001, 0x00010001},
+    {0x00010000, 0x00010001, 0x0002ffff},
+    {0x7fff0000, 0x00000001, 0x80000000},
+    {0xffff0000, 0x00000001, 0x00000000},
+    {0x00008000, 0x00010000, 0x00007fff},
+    {0x00000000, 0xffffffff, 0xffff0001},
+    {0x7fffffff, 0xffffffff, 0x7ffe0000},
+    {0xffffffff, 0x80000000, 0xffff7fff},
+    {0x80000000, 0x7fffffff, 0x7fff8001},
+    {0x11111111, 0x22222222, 0x3333eeef},
+};
+
+/* psax.16 */
+struct binary_calculation samples_psax_16[] = {
+    {0x00000001, 0x00000001, 0xffff0001},
+    {0x80000000, 0x0000ffff, 0x80010000},
+    {0x00007fff, 0x00010000, 0x00008000},
+    {0x80007fff, 0x0001ffff, 0x80018000},
+    {0xffffffff, 0x7fffffff, 0x00007ffe},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x80000000, 0xffffffff, 0x8001ffff},
+    {0x7fffffff, 0x80000000, 0x7fff7fff},
+    {0x11111111, 0x22222222, 0xeeef3333},
+};
+
+/* padd.u8.s */
+struct binary_calculation samples_padd_u8_s[] = {
+    {0x01010101, 0x01010101, 0x02020202},
+    {0x01010101, 0xffffffff, 0xffffffff},
+    {0x01010101, 0xffffffff, 0xffffffff},
+    {0x01010101, 0xff010101, 0xff020202},
+    {0x01010101, 0x01ff0101, 0x02ff0202},
+    {0x01010101, 0x0101ff01, 0x0202ff02},
+    {0x01010101, 0x010101ff, 0x020202ff},
+    {0xffffffff, 0xffffffff, 0xffffffff},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0x00000001, 0xffffffff, 0xffffffff},
+    {0x11888888, 0x22888888, 0x33ffffff},
+};
+
+/* padd.s8.s */
+struct binary_calculation samples_padd_s8_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xffffffff, 0xffffffff, 0xfefefefe},
+    {0x00000001, 0xffffffff, 0xffffff00},
+    {0x00000001, 0x7f7f7f7f, 0x7f7f7f7f},
+    {0x01010101, 0x7f7f7f7f, 0x7f7f7f7f},
+    {0xffffffff, 0x80808080, 0x80808080},
+    {0xffffffff, 0x00000080, 0xffffff80},
+    {0x00000000, 0x00000001, 0x00000001},
+    {0x00000000, 0x7f7f7f7f, 0x7f7f7f7f},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0x00000000, 0x80000000, 0x80000000},
+    {0x7fffffff, 0x80000000, 0xffffffff},
+    {0x88117aaa, 0x812211bb, 0x80337f80},
+};
+
+/* padd.u16.s */
+struct binary_calculation samples_padd_u16_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0x00000001, 0x80008000, 0x80008001},
+    {0x00000001, 0xffffffff, 0xffffffff},
+    {0x00000001, 0x0000ffff, 0x0000ffff},
+    {0x00010000, 0xffff0000, 0xffff0000},
+    {0xffffffff, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0xffffffff},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0xffff0000, 0xffff0000},
+    {0x00000000, 0x0000ffff, 0x0000ffff},
+    {0x00000000, 0x00ffff00, 0x00ffff00},
+    {0x88888888, 0x00008888, 0x8888ffff},
+};
+
+/* padd.s16.s */
+struct binary_calculation samples_padd_s16_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0x00000001, 0xffffffff, 0xffff0000},
+    {0xffffffff, 0xffffffff, 0xfffefffe},
+    {0x00010001, 0xffffffff, 0x00000000},
+    {0x00010001, 0x7fffffff, 0x7fff0000},
+    {0x00000001, 0x7fffffff, 0x7fff0000},
+    {0x00000001, 0xffff7fff, 0xffff7fff},
+    {0x80000000, 0xffffffff, 0x8000ffff},
+    {0x00008000, 0x00000001, 0x00008001},
+    {0x80000000, 0x00010001, 0x80010001},
+    {0x7fffffff, 0x00000000, 0x7fffffff},
+    {0x7fff7fff, 0x00000000, 0x7fff7fff},
+    {0x7fff7fff, 0x80008000, 0xffffffff},
+    {0x00000000, 0x80000000, 0x80000000},
+    {0x00000000, 0x80008000, 0x80008000},
+    {0x7888aaaa, 0x2000bbbb, 0x7fff8000},
+};
+
+/* add.u32.s */
+struct binary_calculation samples_add_u32_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0x00000001, 0xffffffff, 0xffffffff},
+    {0x00010001, 0xffffffff, 0xffffffff},
+    {0x00010001, 0x0001ffff, 0x00030000},
+    {0x00010000, 0x00ff0000, 0x01000000},
+    {0x00000001, 0x00000000, 0x00000001},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x80008000, 0x00000000, 0x80008000},
+    {0x80008000, 0x7fff7fff, 0xffffffff},
+    {0x88888888, 0x88880000, 0xffffffff},
+};
+
+/* add.s32.s */
+struct binary_calculation samples_add_s32_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xffffffff, 0xffffffff, 0xfffffffe},
+    {0x00000001, 0xffffffff, 0x00000000},
+    {0x00000001, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0x80000000, 0x80000000},
+    {0x00000001, 0x0000007f, 0x00000080},
+    {0x00000001, 0x00007fff, 0x00008000},
+    {0xffffffff, 0xffffff80, 0xffffff7f},
+    {0xffffffff, 0xfff80000, 0xfff7ffff},
+    {0x00000001, 0x00000000, 0x00000001},
+    {0x00000000, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0x80000000, 0xffffffff},
+    {0xaaaaaaaa, 0xbbbbbbbb, 0x80000000},
+    {0x78888888, 0x28880000, 0x7fffffff},
+};
+
+/* psub.u8.s */
+struct binary_calculation samples_psub_u8_s[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0x00000002, 0x00000001, 0x00000001},
+    {0x00000000, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fffffff, 0x80000000},
+    {0x00000001, 0xffffffff, 0x00000000},
+    {0x7fffffff, 0x80000000, 0x00ffffff},
+    {0xff7fffff, 0x00800000, 0xff00ffff},
+    {0xfffff7ff, 0x00008000, 0xffff77ff},
+    {0xffffff7f, 0x00000080, 0xffffff00},
+    {0x88881111, 0x11112020, 0x77770000},
+};
+
+/* psub.s8.s */
+struct binary_calculation samples_psub_s8_s[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0xfffffffe, 0xffffffff, 0x000000ff},
+    {0xfefefefe, 0xffffffff, 0xffffffff},
+    {0x00000000, 0x7fffffff, 0x81010101},
+    {0x00000000, 0x80000000, 0x7f000000},
+    {0x7fffffff, 0x80808080, 0x7f7f7f7f},
+    {0x7f7f7f7f, 0xffffffff, 0x7f7f7f7f},
+    {0x80000000, 0x01000000, 0x80000000},
+    {0x00008000, 0x00000100, 0x00008000},
+    {0x00000080, 0x00000001, 0x00000080},
+    {0x7a7aaaaa, 0xafaf7f7f, 0x7f7f8080},
+};
+
+/* psub.u16.s */
+struct binary_calculation samples_psub_u16_s[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0x00020002, 0x00010001, 0x00010001},
+    {0x00000000, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x00000000, 0x00000001, 0x00000000},
+    {0x00000000, 0x00010001, 0x00000000},
+    {0x00010001, 0x00020002, 0x00000000},
+    {0x00010002, 0x00020001, 0x00000001},
+    {0x00020001, 0x00010002, 0x00010000},
+    {0x22221111, 0x11112222, 0x11110000},
+};
+
+/* psub.s16.s */
+struct binary_calculation samples_psub_s16_s[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0x00020002, 0x00010001, 0x00010001},
+    {0xfffefffe, 0xffffffff, 0xffffffff},
+    {0x00000000, 0x7fffffff, 0x80010001},
+    {0x00000000, 0x80000000, 0x7fff0000},
+    {0x7fffffff, 0x80000000, 0x7fffffff},
+    {0x80008000, 0x7fff7fff, 0x80008000},
+    {0x7fff7fff, 0xffffffff, 0x7fff7fff},
+    {0x7f7f7f7f, 0xffffffff, 0x7f807f80},
+    {0x80008000, 0x00010001, 0x80008000},
+    {0x80000000, 0x00010001, 0x8000ffff},
+    {0xaaaa2222, 0x7fff1111, 0x80001111},
+};
+
+/* sub.u32.s */
+struct binary_calculation samples_sub_u32_s[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0x00000001, 0x00000002, 0x00000000},
+    {0x00010001, 0x00020002, 0x00000000},
+    {0x01010101, 0x02020202, 0x00000000},
+    {0x10000000, 0x02222222, 0x0dddddde},
+    {0x00000000, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x11111111, 0x22222222, 0x00000000},
+    {0x22222222, 0x11111111, 0x11111111},
+};
+
+/* sub.s32.s */
+struct binary_calculation samples_sub_s32_s[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0x7fffffff, 0xffffffff, 0x7fffffff},
+    {0x80000000, 0x00000001, 0x80000000},
+    {0x00008000, 0x00000001, 0x00007fff},
+    {0x00007fff, 0x0000ffff, 0xffff8000},
+    {0x7fffffff, 0x00000000, 0x7fffffff},
+    {0x80000000, 0x7fffffff, 0x80000000},
+    {0x7fffffff, 0x80000000, 0x7fffffff},
+    {0xaaaaaaaa, 0x7fffffff, 0x80000000},
+    {0x7fff0000, 0xbbbb0000, 0x7fffffff},
+};
+
+/* addh.u32 */
+struct binary_calculation samples_addh_u32[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x80808082, 0x80808080, 0x80808081},
+    {0x80000000, 0x80000000, 0x80000000},
+    {0x00000000, 0xffffffff, 0x7fffffff},
+    {0xffffffff, 0xffffffff, 0xffffffff},
+    {0x7fffffff, 0x7fffffff, 0x7fffffff},
+};
+
+/* addh.s32 */
+struct binary_calculation samples_addh_s32[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x80808082, 0x80808080, 0x80808081},
+    {0x80000000, 0x80000000, 0x80000000},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0x7fffffff, 0xffffffff, 0x3fffffff},
+    {0x7fffffff, 0x7ffffff9, 0x7ffffffc},
+    {0x80000002, 0x80000000, 0x80000001},
+};
+
+/* paddh.u8 */
+struct binary_calculation samples_paddh_u8[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x02020202, 0x02020202, 0x02020202},
+    {0x80808080, 0x80808080, 0x80808080},
+    {0x80000000, 0x80000000, 0x80000000},
+    {0x00000000, 0xffffffff, 0x7f7f7f7f},
+    {0xffffffff, 0xffffffff, 0xffffffff},
+    {0x7f801000, 0x7f802001, 0x7f801800},
+};
+
+/* paddh.s8 */
+struct binary_calculation samples_paddh_s8[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0xffffffff, 0xffffffff, 0xffffffff},
+    {0x7f7f7f7f, 0x01010101, 0x40404040},
+    {0x7fffffff, 0x00000001, 0x3fffff00},
+    {0x80808080, 0xffffffff, 0xbfbfbfbf},
+    {0x00000000, 0x7fffffff, 0x3fffffff},
+    {0x00000000, 0x80000000, 0xc0000000},
+    {0x7f881000, 0x7f112001, 0x7fcc1800},
+};
+
+/* paddh.u16 */
+struct binary_calculation samples_paddh_u16[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00020002, 0x00020002, 0x00020002},
+    {0xffffffff, 0x00000001, 0x7fff8000},
+    {0xffff0000, 0x00010001, 0x80000000},
+    {0xffffffff, 0x00010001, 0x80008000},
+    {0x00000000, 0xffffffff, 0x7fff7fff},
+    {0xffffffff, 0xffffffff, 0xffffffff},
+    {0x80007fff, 0x80007fff, 0x80007fff},
+};
+
+/* paddh.s16 */
+struct binary_calculation samples_paddh_s16[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0xffffffff, 0xffffffff, 0xffffffff},
+    {0x7fff7fff, 0x00010001, 0x40004000},
+    {0x7fffffff, 0x00010001, 0x40000000},
+    {0x80008000, 0xffffffff, 0xbfffbfff},
+    {0x80008000, 0xffff0000, 0xbfffc000},
+    {0x7fff7fff, 0x00000000, 0x3fff3fff},
+    {0x7fffffff, 0x00000000, 0x3fffffff},
+    {0x80008000, 0x00000000, 0xc000c000},
+    {0x80000000, 0x00000000, 0xc0000000},
+    {0x7fff7fff, 0x80008000, 0xffffffff},
+    {0x7fffffff, 0x80000000, 0xffffffff},
+    {0x80007ff9, 0x80027fff, 0x80017ffc},
+};
+
+/* subh.u32 */
+struct binary_calculation samples_subh_u32[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0x00000001, 0x00000002, 0xffffffff},
+    {0xffffffff, 0x00000000, 0x7fffffff},
+    {0x00000000, 0xffffffff, 0x80000000},
+    {0x7fffffff, 0x80000000, 0xffffffff},
+    {0x00000000, 0x7fffffff, 0xc0000000},
+    {0x11111111, 0x22222222, 0xf7777777},
+    {0x7fffffff, 0x80000000, 0xffffffff},
+};
+
+/* subh.s32 */
+struct binary_calculation samples_subh_s32[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0x00000001, 0x00000002, 0xffffffff},
+    {0xffffffff, 0xfffffffe, 0x00000000},
+    {0x7fffffff, 0xffffffff, 0x40000000},
+    {0x80000000, 0x00000001, 0xbfffffff},
+    {0x00000000, 0x7fffffff, 0xc0000000},
+    {0x00000000, 0x80000000, 0x40000000},
+    {0x80000000, 0x00000000, 0xc0000000},
+    {0x80000000, 0x7fffffff, 0x80000000},
+    {0x00000001, 0x00000010, 0xfffffff8},
+};
+
+/* psubh.u8 */
+struct binary_calculation samples_psubh_u8[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0x00000001, 0xffffffff, 0x80808081},
+    {0x01010101, 0xffffffff, 0x81818181},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0x2222117f, 0x11112280, 0x0808f7ff},
+};
+
+/* psubh.s8 */
+struct binary_calculation samples_psubh_s8[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0x00000001, 0xffffffff, 0x00000001},
+    {0xffffffff, 0x00000001, 0xffffffff},
+    {0x7f7f7f7f, 0xffffffff, 0x40404040},
+    {0x80808080, 0x01010101, 0xbfbfbfbf},
+    {0x7fffffff, 0xffffffff, 0x40000000},
+    {0x80000000, 0x00000001, 0xc00000ff},
+    {0x00000000, 0x7fffffff, 0xc0000000},
+    {0x80000000, 0x7fffffff, 0x80000000},
+    {0x7f7f7f7f, 0x80808080, 0x7f7f7f7f},
+    {0x7fffffff, 0x80000000, 0x7fffffff},
+    {0x01011111, 0x10102222, 0xf8f8f7f7},
+};
+
+/* psubh.u16 */
+struct binary_calculation samples_psubh_u16[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0x00020002, 0x00000002, 0x00010000},
+    {0x00000001, 0x00000002, 0x0000ffff},
+    {0x00010001, 0x00020002, 0xffffffff},
+    {0x00000000, 0xffffffff, 0x80008000},
+    {0xffffffff, 0x00000000, 0x7fff7fff},
+    {0x11111111, 0x22222222, 0xf777f777},
+};
+
+/* psubh.s16 */
+struct binary_calculation samples_psubh_s16[] = {
+    {0x00000001, 0x00000001, 0x00000000},
+    {0xffffffff, 0x00000001, 0xffffffff},
+    {0x7fffffff, 0xffffffff, 0x40000000},
+    {0x7fff7fff, 0xffffffff, 0x40004000},
+    {0x80000000, 0x00000001, 0xc000ffff},
+    {0x80008000, 0x00000000, 0xc000c000},
+    {0x7fffffff, 0x00000000, 0x3fffffff},
+    {0x80000000, 0x00000000, 0xc0000000},
+    {0x7fffffff, 0x80000000, 0x7fffffff},
+    {0x80000000, 0x7fffffff, 0x80000000},
+    {0x80008000, 0x7fff7fff, 0x80008000},
+    {0x00010001, 0x00100001, 0xfff80000},
+    {0x00000000, 0x00010001, 0xffffffff},
+};
+
+/* pasx.u16.s */
+struct binary_calculation samples_pasx_u16_s[] = {
+    {0x00000001, 0x00000001, 0x00010001},
+    {0xffff0000, 0x00000001, 0xffff0000},
+    {0x00000000, 0x00010000, 0x00000000},
+    {0x00000000, 0xffffffff, 0xffff0000},
+    {0x7fffffff, 0xffffffff, 0xffff0000},
+    {0xffffffff, 0x80000000, 0xffff7fff},
+    {0x80000000, 0x7fffffff, 0xffff0000},
+    {0xff001000, 0x10011111, 0xffff0000},
+};
+
+/* pasx.s16.s */
+struct binary_calculation samples_pasx_s16_s[] = {
+    {0x00000001, 0x00000001, 0x00010001},
+    {0x00010000, 0x00010001, 0x0002ffff},
+    {0x7fff0000, 0x00000001, 0x7fff0000},
+    {0x00080000, 0x00010000, 0x0008ffff},
+    {0x00000000, 0xffffffff, 0xffff0001},
+    {0x7fffffff, 0xffffffff, 0x7ffe0000},
+    {0xffffffff, 0x80000000, 0xffff7fff},
+    {0x80000000, 0x7fffffff, 0x80008001},
+    {0x7fff8001, 0x10001111, 0x7fff8000},
+};
+
+/* psax.u16.s */
+struct binary_calculation samples_psax_u16_s[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00007fff, 0x00010001, 0x00008000},
+    {0xffffffff, 0x7fffffff, 0x0000ffff},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x80000000, 0xffffffff, 0x0000ffff},
+    {0x7fffffff, 0x80000000, 0x7fffffff},
+    {0x1000ff00, 0x10001001, 0x0000ffff},
+    {0x0000f000, 0x10000001, 0x0000ffff},
+};
+
+/* psax.s16.s */
+struct binary_calculation samples_psax_s16_s[] = {
+    {0x00000001, 0x00000001, 0xffff0001},
+    {0x80000000, 0x0000ffff, 0x80010000},
+    {0x00007fff, 0x00010000, 0x00007fff},
+    {0x80007fff, 0x0001ffff, 0x80017fff},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x80000000, 0x00000000, 0x80000000},
+    {0x7fffffff, 0x80000000, 0x7fff8000},
+    {0x80017f00, 0x10001001, 0x80007fff},
+};
+
+/* pasxh.u16 */
+struct binary_calculation samples_pasxh_u16[] = {
+    {0x00000001, 0x00010000, 0x00000000},
+    {0x00010000, 0x00010001, 0x0001ffff},
+    {0xffff0000, 0x00010000, 0x7fffffff},
+    {0xffff0000, 0x00010001, 0x8000ffff},
+    {0x00008000, 0x00008001, 0x40004000},
+    {0x00000000, 0xffffffff, 0x7fff8000},
+    {0x7fffffff, 0xffffffff, 0xbfff0000},
+    {0xffffffff, 0x00008000, 0xbfff7fff},
+    {0x80000000, 0xffff7fff, 0x7fff8000},
+    {0x88881111, 0x22228888, 0x8888f777},
+    {0x7fff0000, 0x00017fff, 0x7fffffff},
+    {0x80008000, 0x7fff8000, 0x80000000},
+    {0x7fff7fff, 0x80007fff, 0x7fffffff},
+};
+
+/* pasxh.s16 */
+struct binary_calculation samples_pasxh_s16[] = {
+    {0x00000001, 0x00010000, 0x00000000},
+    {0x00010000, 0x00010001, 0x0001ffff},
+    {0xffff0000, 0x00010000, 0xffffffff},
+    {0xffff0000, 0x00010001, 0x0000ffff},
+    {0x7fff0000, 0x00010000, 0x3fffffff},
+    {0x00008000, 0x00008001, 0xc000c000},
+    {0x80000000, 0xffff0000, 0xc0000000},
+    {0x80007fff, 0xffffffff, 0xbfff4000},
+    {0x00000000, 0xffffffff, 0xffff0000},
+    {0x7fffffff, 0xffffffff, 0x3fff0000},
+    {0xffffffff, 0x00008000, 0xbfffffff},
+    {0x80000000, 0xffff7fff, 0xffff0000},
+    {0x7fff0001, 0x00101000, 0x47fffff8},
+    {0x7fff7fff, 0x80007fff, 0x7fff7fff},
+};
+
+/* psaxh.u16 */
+struct binary_calculation samples_psaxh_u16[] = {
+    {0x00010000, 0x00000001, 0x00000000},
+    {0x00000001, 0x00010001, 0xffff0001},
+    {0x0000ffff, 0x00000001, 0xffff7fff},
+    {0x0000ffff, 0x00010001, 0xffff8000},
+    {0x80000000, 0x80010000, 0x40004000},
+    {0x00000000, 0xffffffff, 0x80007fff},
+    {0xffff7fff, 0xffffffff, 0x0000bfff},
+    {0xffffffff, 0x80000000, 0x7fffbfff},
+    {0x00008000, 0x7fffffff, 0x80007fff},
+    {0x1111ff00, 0x10002222, 0xf7778780},
+    {0x0000ff00, 0x10000001, 0xffff8780},
+};
+
+/* psaxh.s16 */
+struct binary_calculation samples_psaxh_s16[] = {
+    {0x00010000, 0x00000001, 0x00000000},
+    {0x00000001, 0x00010001, 0xffff0001},
+    {0x0000ffff, 0x00000001, 0xffffffff},
+    {0x0000ffff, 0x00010001, 0xffff0000},
+    {0x00007fff, 0x00000001, 0xffff3fff},
+    {0x80000000, 0x80010000, 0xc000c000},
+    {0x00008000, 0x0000ffff, 0x0000c000},
+    {0x7fff8000, 0xffffffff, 0x4000bfff},
+    {0x00000000, 0xffffffff, 0x0000ffff},
+    {0xffff7fff, 0xffffffff, 0x00003fff},
+    {0xffffffff, 0x80000000, 0xffffbfff},
+    {0x00008000, 0x7fffffff, 0x0000ffff},
+    {0x00017f00, 0x20000010, 0xfff84f80},
+};
+
+/* add.64 */
+struct binary64_64_64_calculation samples_add_64[] = {
+    {0x0000000100000001, 0x0000000100000001, 0x0000000200000002},
+    {0x0000000100000000, 0x0000000100000000, 0x0000000200000000},
+    {0x0000000000000001, 0x0000000000000001, 0x0000000000000002},
+    {0xffffffff00000000, 0x0000000100000000, 0x0000000000000000},
+    {0xffffffff80000000, 0x0000000180000000, 0x0000000100000000},
+    {0x0000000000000000, 0x0000000000000000, 0x0000000000000000},
+    {0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffffffffffe},
+    {0x7fffffff7fffffff, 0x0000000000000000, 0x7fffffff7fffffff},
+    {0x7fffffff80000000, 0x800000007fffffff, 0xffffffffffffffff},
+    {0x2000000000000000, 0xff00000000000000, 0x1f00000000000000},
+};
+
+/* add.u64.s */
+struct binary64_64_64_calculation samples_add_u64_s[] = {
+    {0x0000000100000001, 0x0000000100000001, 0x0000000200000002},
+    {0x0000000100000000, 0x0000000100000000, 0x0000000200000000},
+    {0x0000000000000001, 0x0000000000000001, 0x0000000000000002},
+    {0xffffffff00000000, 0x0000000100000000, 0xffffffffffffffff},
+    {0xffffffff80000000, 0x0000000180000000, 0xffffffffffffffff},
+    {0x0000000000000000, 0x0000000000000000, 0x0000000000000000},
+    {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x7fffffff7fffffff, 0x0000000000000000, 0x7fffffff7fffffff},
+    {0x7fffffff80000000, 0x800000007fffffff, 0xffffffffffffffff},
+    {0xff00000000000000, 0x2000000000000000, 0xffffffffffffffff},
+};
+
+/* add.s64.s */
+struct binary64_64_64_calculation samples_add_s64_s[] = {
+    {0x0000000100000001, 0x0000000100000001, 0x0000000200000002},
+    {0x0000000100000000, 0x0000000100000000, 0x0000000200000000},
+    {0x0000000000000001, 0x0000000000000001, 0x0000000000000002},
+    {0x7fffffff00000000, 0x0000000100000000, 0x7fffffffffffffff},
+    {0x8000000000000000, 0x8000000000000000, 0x8000000000000000},
+    {0x7fffffff80000000, 0x0000000180000000, 0x7fffffffffffffff},
+    {0xffffffff80000000, 0x0000000180000000, 0x0000000100000000},
+    {0x0000000000000000, 0x0000000000000000, 0x0000000000000000},
+    {0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffffffffffe},
+    {0x7fffffff7fffffff, 0x0000000000000000, 0x7fffffff7fffffff},
+    {0x7fffffff80000000, 0x800000007fffffff, 0xffffffffffffffff},
+    {0x7f00000000000000, 0x2000000000000000, 0x7fffffffffffffff},
+    {0x8000000000000001, 0xaa00000000000000, 0x8000000000000000},
+};
+
+/* sub.64 */
+struct binary64_64_64_calculation samples_sub_64[] = {
+    {0x0000001000000010, 0x0000000100000001, 0x0000000f0000000f},
+    {0x0000001000000000, 0x0000000100000000, 0x0000000f00000000},
+    {0x0000000000000010, 0x0000000000000001, 0x000000000000000f},
+    {0x0000000000000000, 0xffffffff00000000, 0x0000000100000000},
+    {0x0000000000000000, 0x8000000000000000, 0x8000000000000000},
+    {0x0000000000000000, 0x7fffffff80000000, 0x8000000080000000},
+    {0x0000000000000000, 0xffffffff80000000, 0x0000000080000000},
+    {0x0000000000000000, 0x0000000000000000, 0x0000000000000000},
+    {0xfffffffefffffffe, 0xffffffffffffffff, 0xfffffffeffffffff},
+    {0x7fffffff7fffffff, 0x7fffffff7fffffff, 0x0000000000000000},
+    {0xffffffffffffffff, 0x7fffffff80000000, 0x800000007fffffff},
+    {0x0000000000000001, 0x0000000000000010, 0xfffffffffffffff1},
+};
+
+/* sub.u64.s */
+struct binary64_64_64_calculation samples_sub_u64_s[] = {
+    {0x0000001000000010, 0x0000000100000001, 0x0000000f0000000f},
+    {0x0000001000000000, 0x0000000100000000, 0x0000000f00000000},
+    {0x0000000000000010, 0x0000000000000001, 0x000000000000000f},
+    {0x0000000000000000, 0xffffffff00000000, 0x0000000000000000},
+    {0x0000000000000000, 0x8000000000000000, 0x0000000000000000},
+    {0x0000000000000000, 0x7fffffff80000000, 0x0000000000000000},
+    {0x0000000000000000, 0xffffffff80000000, 0x0000000000000000},
+    {0x0000000000000000, 0x0000000000000000, 0x0000000000000000},
+    {0xfffffffefffffffe, 0xffffffffffffffff, 0x0000000000000000},
+    {0x7fffffff7fffffff, 0x7fffffff7fffffff, 0x0000000000000000},
+    {0xffffffffffffffff, 0x7fffffff80000000, 0x800000007fffffff},
+    {0x1000000000000000, 0x2000000000000000, 0x0000000000000000},
+};
+
+/* sub.s64.s */
+struct binary64_64_64_calculation samples_sub_s64_s[] = {
+    {0x0000001000000010, 0x0000000100000001, 0x0000000f0000000f},
+    {0x0000001000000000, 0x0000000100000000, 0x0000000f00000000},
+    {0x0000000000000010, 0x0000000000000001, 0x000000000000000f},
+    {0x8000000000000000, 0x7fffffff00000000, 0x8000000000000000},
+    {0x0000000000000000, 0x8000000000000000, 0x7fffffffffffffff},
+    {0x0000000000000000, 0x7fffffff80000000, 0x8000000080000000},
+    {0x0000000000000000, 0xffffffff80000000, 0x0000000080000000},
+    {0x0000000000000000, 0x0000000000000000, 0x0000000000000000},
+    {0xfffffffefffffffe, 0xffffffffffffffff, 0xfffffffeffffffff},
+    {0x7fffffff7fffffff, 0x7fffffff7fffffff, 0x0000000000000000},
+    {0xffffffffffffffff, 0x7fffffff80000000, 0x800000007fffffff},
+    {0x7000000000000001, 0x7000000000000000, 0x0000000000000001},
+};
+
+/* asri.s32.r */
+struct binary_calculation samples_asri_s32_r[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x10000000, 0x00000020, 0x00000000},
+    {0x00000000, 0x0000001f, 0x00000000},
+    {0x01111111, 0x0000001f, 0x00000000},
+    {0xffffffff, 0x0000001f, 0x00000000},
+    {0xbfffffff, 0x0000001f, 0xffffffff},
+    {0x7fffffff, 0x0000001f, 0x00000001},
+    {0x80000000, 0x0000001f, 0xffffffff},
+    {0x10101011, 0x00000001, 0x08080809},
+    {0x80101011, 0x00000001, 0xc0080809},
+    {0x10101012, 0x00000002, 0x04040405},
+    {0x10101010, 0x00000002, 0x04040404},
+    {0x80101012, 0x00000002, 0xe0040405},
+};
+
+/* asr.s32.r */
+struct binary_calculation samples_asr_s32_r[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x00000010, 0x00000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x0000001f, 0x00000000},
+    {0x01111111, 0x0000001f, 0x00000000},
+    {0xffffffff, 0x0000001f, 0x00000000},
+    {0xbfffffff, 0x0000001f, 0xffffffff},
+    {0x7fffffff, 0x0000001f, 0x00000001},
+    {0x80000000, 0x0000001f, 0xffffffff},
+    {0x10101011, 0x00000001, 0x08080809},
+    {0x80101011, 0x00000001, 0xc0080809},
+    {0x10101012, 0x00000002, 0x04040405},
+    {0x10101010, 0x00000002, 0x04040404},
+    {0x80101012, 0x00000002, 0xe0040405},
+    {0x80000000, 0x0000003f, 0x00000000},
+    {0x80000000, 0x00000020, 0x00000000},
+    {0x80000000, 0x00000000, 0x80000000},
+};
+
+/* lsri.u32.r */
+struct binary_calculation samples_lsri_u32_r[] = {
+    {0x10000000, 0x00000001, 0x08000000},
+    {0x11000000, 0x00000001, 0x08800000},
+    {0x10101011, 0x00000001, 0x08080809},
+    {0x10000001, 0x00000001, 0x08000001},
+    {0x80001000, 0x00000020, 0x00000001},
+    {0x00000000, 0x0000001f, 0x00000000},
+    {0x01111111, 0x0000001f, 0x00000000},
+    {0xffffffff, 0x0000001f, 0x00000002},
+    {0xbfffffff, 0x0000001f, 0x00000001},
+    {0x7fffffff, 0x0000001f, 0x00000001},
+    {0x80000000, 0x0000001f, 0x00000001},
+    {0x80101012, 0x00000002, 0x20040405},
+    {0x80101010, 0x00000002, 0x20040404},
+};
+
+/* lsr.u32.r */
+struct binary_calculation samples_lsr_u32_r[] = {
+    {0x10000000, 0x00000001, 0x08000000},
+    {0x11000000, 0x00000001, 0x08800000},
+    {0x11000000, 0x00000010, 0x00001100},
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x00000010, 0x00000000},
+    {0x10000001, 0x00000001, 0x08000001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x0000001f, 0x00000000},
+    {0x01111111, 0x0000001f, 0x00000000},
+    {0xffffffff, 0x0000001f, 0x00000002},
+    {0xbfffffff, 0x0000001f, 0x00000001},
+    {0x7fffffff, 0x0000001f, 0x00000001},
+    {0x80000000, 0x0000001f, 0x00000001},
+    {0x10101011, 0x00000001, 0x08080809},
+    {0x10101010, 0x00000001, 0x08080808},
+    {0xffffffff, 0x0000003f, 0x00000000},
+    {0xffffffff, 0x00000020, 0x00000001},
+    {0x00000001, 0x00000000, 0x00000001},
+};
+
+/* lsli.u32.s */
+struct binary_calculation samples_lsli_u32_s[] = {
+    {0xffffffff, 0x0000001f, 0xffffffff},
+    {0x00000000, 0x0000001f, 0x00000000},
+    {0x00000001, 0x00000020, 0xffffffff},
+    {0x10101010, 0x00000002, 0x40404040},
+    {0x40101010, 0x00000004, 0xffffffff},
+};
+
+/* lsli.s32.s */
+struct binary_calculation samples_lsli_s32_s[] = {
+    {0x00000001, 0x00000001, 0x00000010},
+    {0xfffffffe, 0x00000001, 0xfffffffc},
+    {0x7fffffff, 0x00000001, 0x7fffffff},
+    {0x80000000, 0x00000001, 0x80000000},
+    {0x007fffff, 0x00000009, 0x7fffffff},
+    {0xff800000, 0x00000009, 0x80000000},
+    {0xffffffff, 0x0000001f, 0x80000000},
+    {0x00000000, 0x0000001f, 0x00000000},
+    {0x00000001, 0x0000001f, 0x7fffffff},
+    {0x7fffffff, 0x00000020, 0x7fffffff},
+    {0x40101010, 0x00000002, 0x7fffffff},
+    {0x80101010, 0x00000002, 0x80000000},
+};
+
+/* lsl.u32.s */
+struct binary_calculation samples_lsl_u32_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xfffffffe, 0x00000001, 0xffffffff},
+    {0x7fffffff, 0x00000001, 0xfffffffe},
+    {0x80000000, 0x00000001, 0xffffffff},
+    {0x007fffff, 0x00000009, 0xfffffe00},
+    {0x00800000, 0x00000009, 0xffffffff},
+    {0xffffffff, 0x0000001f, 0xffffffff},
+    {0x00000000, 0x0000001f, 0x00000000},
+    {0x00000001, 0x0000001f, 0x80000000},
+    {0x7fffffff, 0x00000000, 0x7fffffff},
+    {0x10101010, 0x00000002, 0x40404040},
+    {0x40101010, 0x00000004, 0xffffffff},
+    {0x00000001, 0x0000003f, 0xffffffff},
+    {0xffffffff, 0x0000003f, 0xffffffff},
+    {0x00000001, 0x00000020, 0xffffffff},
+    {0xffffffff, 0x00000020, 0xffffffff},
+};
+
+/* lsl.s32.s */
+struct binary_calculation samples_lsl_s32_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xfffffffe, 0x00000001, 0xfffffffc},
+    {0x7fffffff, 0x00000001, 0x7fffffff},
+    {0x80000000, 0x00000001, 0x80000000},
+    {0x007fffff, 0x00000009, 0x7fffffff},
+    {0xff800000, 0x00000009, 0x80000000},
+    {0xffffffff, 0x0000001f, 0x80000000},
+    {0x00000000, 0x0000001f, 0x00000000},
+    {0x00000001, 0x0000001f, 0x7fffffff},
+    {0x7fffffff, 0x00000000, 0x7fffffff},
+    {0x40101010, 0x00000002, 0x7fffffff},
+    {0x80101010, 0x00000002, 0x80000000},
+    {0x00000001, 0x0000003f, 0x7fffffff},
+    {0xffffffff, 0x0000003f, 0x80000000},
+    {0x00000001, 0x00000020, 0x7fffffff},
+    {0xffffffff, 0x00000020, 0x80000000},
+};
+
+/* pasri.s16 */
+struct binary_calculation samples_pasri_s16[] = {
+    {0x10000000, 0x00000001, 0x08000000},
+    {0x00010001, 0x00000001, 0x00000000},
+    {0x00000000, 0x00000010, 0x00000000},
+    {0x80111010, 0x00000010, 0xffff0000},
+    {0x80111010, 0x00000001, 0xc0080808},
+    {0x80007fff, 0x0000000f, 0xffff0000},
+    {0x80111010, 0x00000002, 0xe0040404},
+    {0x80008000, 0x00000002, 0xe000e000},
+    {0x10001000, 0x00000002, 0x04000400},
+};
+
+/* pasr.s16 */
+struct binary_calculation samples_pasr_s16[] = {
+    {0x10000000, 0x00000001, 0x08000000},
+    {0x00010001, 0x00000001, 0x00000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x80111010, 0x00000010, 0xffff0000},
+    {0x80111010, 0x00000001, 0xc0080808},
+    {0x80007fff, 0x0000000f, 0xffff0000},
+    {0x80111010, 0x00000001, 0xc0080808},
+    {0x80008000, 0x00000001, 0xc000c000},
+    {0x10001000, 0x00000001, 0x08000800},
+    {0x80008000, 0x0000001f, 0xffffffff},
+    {0x80008000, 0x00000010, 0xffffffff},
+};
+
+/* pasri.s16.r */
+struct binary_calculation samples_pasri_s16_r[] = {
+    {0x10000000, 0x00000001, 0x08000000},
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x00000002, 0x00000000},
+    {0x80121012, 0x00000002, 0xe0050405},
+    {0x80111011, 0x00000001, 0xc0090809},
+    {0x80008000, 0x00000002, 0xe000e000},
+    {0x80028002, 0x00000002, 0xe001e001},
+    {0x10001000, 0x00000002, 0x04000400},
+    {0x10021002, 0x00000002, 0x04010401},
+};
+
+/* pasr.s16.r */
+struct binary_calculation samples_pasr_s16_r[] = {
+    {0x10000000, 0x00000001, 0x08000000},
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x00000002, 0x00000000},
+    {0x80121012, 0x00000002, 0xe0050405},
+    {0x80111011, 0x00000001, 0xc0090809},
+    {0x80008000, 0x00000001, 0xc000c000},
+    {0x80018001, 0x00000001, 0xc001c001},
+    {0x80008000, 0x00000000, 0x80008000},
+    {0x80008000, 0x0000001f, 0x00000000},
+    {0x80008000, 0x00000010, 0x00000000},
+};
+
+/* plsri.u16 */
+struct binary_calculation samples_plsri_u16[] = {
+    {0x10000000, 0x00000001, 0x08000000},
+    {0x11000000, 0x00000001, 0x08800000},
+    {0x11000000, 0x00000002, 0x04400000},
+    {0x10001000, 0x00000001, 0x08000800},
+    {0x00000001, 0x00000001, 0x00000000},
+    {0x00000001, 0x00000002, 0x00000000},
+    {0x10000001, 0x00000002, 0x04000000},
+    {0x10000001, 0x00000001, 0x08000000},
+    {0x10000001, 0x00000003, 0x02000000},
+    {0x7fff7fff, 0x00000003, 0x0fff0fff},
+    {0xffffffff, 0x0000000f, 0x00010001},
+    {0xbfffffff, 0x0000000f, 0x00010001},
+    {0x7fffffff, 0x0000000f, 0x00000001},
+    {0x80000000, 0x0000000f, 0x00010000},
+    {0xffffffff, 0x00000010, 0x00000000},
+    {0x10118010, 0x00000002, 0x04042004},
+    {0x10101010, 0x00000002, 0x04040404},
+    {0x80108010, 0x00000002, 0x20042004},
+};
+
+/* plsr.u16 */
+struct binary_calculation samples_plsr_u16[] = {
+    {0x10000000, 0x00000001, 0x08000000},
+    {0x11000000, 0x00000001, 0x08800000},
+    {0x11000000, 0x00000002, 0x04400000},
+    {0x10001000, 0x00000001, 0x08000800},
+    {0x00000001, 0x00000001, 0x00000000},
+    {0x00000001, 0x00000010, 0x00000000},
+    {0x10000001, 0x00000002, 0x04000000},
+    {0x10000001, 0x00000001, 0x08000000},
+    {0x10000001, 0x00000003, 0x02000000},
+    {0x7fff7fff, 0x00000003, 0x0fff0fff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0xffffffff, 0x0000000f, 0x00010001},
+    {0xbfffffff, 0x0000000f, 0x00010001},
+    {0x7fffffff, 0x0000000f, 0x00000001},
+    {0x80000000, 0x0000000f, 0x00010000},
+    {0xffffffff, 0x00000010, 0x00000000},
+    {0x80111010, 0x00000001, 0x40080808},
+    {0x80118011, 0x00000001, 0x40084008},
+    {0x10101010, 0x00000001, 0x08080808},
+    {0xffffffff, 0x0000001f, 0x00000000},
+};
+
+/* plsri.u16.r */
+struct binary_calculation samples_plsri_u16_r[] = {
+    {0x10000000, 0x00000001, 0x08000000},
+    {0x11000000, 0x00000001, 0x08800000},
+    {0x11000000, 0x00000002, 0x04400000},
+    {0x10001000, 0x00000001, 0x08000800},
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x00000002, 0x00000000},
+    {0x10000001, 0x00000002, 0x04000000},
+    {0x10000001, 0x00000001, 0x08000001},
+    {0x10000001, 0x00000003, 0x02000000},
+    {0x7fff7fff, 0x00000003, 0x10001000},
+    {0x00000000, 0x0000000f, 0x00000000},
+    {0x01111111, 0x0000000f, 0x00000000},
+    {0xffffffff, 0x0000000f, 0x00020002},
+    {0xbfffffff, 0x0000000f, 0x00010002},
+    {0x7fffffff, 0x0000000f, 0x00010002},
+    {0x80000000, 0x0000000f, 0x00010000},
+    {0xffffffff, 0x00000010, 0x00010001},
+    {0x80121012, 0x00000002, 0x20050405},
+    {0x80008000, 0x00000002, 0x20002000},
+    {0x80028002, 0x00000002, 0x20012001},
+};
+
+/* plsr.u16.r */
+struct binary_calculation samples_plsr_u16_r[] = {
+    {0x10000000, 0x00000001, 0x08000000},
+    {0x11000000, 0x00000001, 0x08800000},
+    {0x11000000, 0x00000002, 0x04400000},
+    {0x10001000, 0x00000001, 0x08000800},
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x00000002, 0x00000000},
+    {0x10000001, 0x00000002, 0x04000000},
+    {0x10000001, 0x00000001, 0x08000001},
+    {0x10000001, 0x00000003, 0x02000000},
+    {0x7fff7fff, 0x00000003, 0x10001000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x0000000f, 0x00000000},
+    {0x01111111, 0x0000000f, 0x00000000},
+    {0xffffffff, 0x0000000f, 0x00020002},
+    {0xbfffffff, 0x0000000f, 0x00010002},
+    {0x7fffffff, 0x0000000f, 0x00010002},
+    {0x80000000, 0x0000000f, 0x00010000},
+    {0xffffffff, 0x00000010, 0x00010001},
+    {0x80181018, 0x00000004, 0x08020102},
+    {0x80088000, 0x00000004, 0x08010800},
+    {0x80008000, 0x0000001f, 0x00000000},
+    {0x80008000, 0x00000010, 0x00010001},
+    {0x80008000, 0x0000000f, 0x00010001},
+};
+
+/* plsli.u16 */
+struct binary_calculation samples_plsli_u16[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xfffffffe, 0x00000001, 0xfffefffc},
+    {0x7fffffff, 0x00000001, 0xfffefffe},
+    {0x80000000, 0x00000001, 0x00000000},
+    {0x007fffff, 0x00000009, 0xfe00fe00},
+    {0x00800000, 0x00000009, 0x00000000},
+    {0xffffffff, 0x00000010, 0x00000000},
+    {0x80108011, 0x00000001, 0x00200022},
+    {0x80008000, 0x00000001, 0x00000000},
+};
+
+/* plsl.u16 */
+struct binary_calculation samples_plsl_u16[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xfffffffe, 0x00000001, 0xfffefffc},
+    {0x7fffffff, 0x00000001, 0xfffefffe},
+    {0x80000000, 0x00000001, 0x00000000},
+    {0x007fffff, 0x00000009, 0xfe00fe00},
+    {0x00800000, 0x00000009, 0x00000000},
+    {0xffffffff, 0x00000010, 0x00000000},
+    {0x7fffffff, 0x00000000, 0x7fffffff},
+    {0x80108011, 0x00000002, 0x00400044},
+    {0x80008000, 0x00000002, 0x00000000},
+    {0x00010001, 0x0000001f, 0x00000000},
+    {0x80008000, 0x00000000, 0x80008000},
+    {0x00010001, 0x00000010, 0x00000000},
+    {0x00010001, 0x0000000f, 0x80008000},
+};
+
+/* plsli.u16.s */
+struct binary_calculation samples_plsli_u16_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xfffffffe, 0x00000001, 0xffffffff},
+    {0x7fffffff, 0x00000001, 0xfffeffff},
+    {0x80000000, 0x00000001, 0xffff0000},
+    {0x007fffff, 0x00000009, 0xfe00ffff},
+    {0x00800000, 0x00000009, 0xffff0000},
+    {0x00000001, 0x00000010, 0x0000ffff},
+    {0x10118010, 0x00000001, 0x2022ffff},
+    {0x80008000, 0x00000001, 0xffffffff},
+};
+
+/* plsl.u16.s */
+struct binary_calculation samples_plsl_u16_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xfffffffe, 0x00000001, 0xffffffff},
+    {0x7fffffff, 0x00000001, 0xfffeffff},
+    {0x80000000, 0x00000001, 0xffff0000},
+    {0x007fffff, 0x00000009, 0xfe00ffff},
+    {0x00800000, 0x00000009, 0xffff0000},
+    {0x00000001, 0x00000010, 0x0000ffff},
+    {0x7fffffff, 0x00000000, 0x7fffffff},
+    {0x10118010, 0x00000003, 0x8088ffff},
+    {0x10001000, 0x00000003, 0x80008000},
+    {0x00010001, 0x0000001f, 0xffffffff},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x00010001, 0x00000010, 0xffffffff},
+    {0x00010001, 0x0000000f, 0x80008000},
+};
+
+/* plsli.s16.s */
+struct binary_calculation samples_plsli_s16_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xfffffffe, 0x00000001, 0xfffefffc},
+    {0x7fffffff, 0x00000001, 0x7ffffffe},
+    {0x80000000, 0x00000001, 0x80000000},
+    {0x007fffff, 0x00000009, 0x7ffffe00},
+    {0xff800000, 0x00000009, 0x80000000},
+    {0xffffffff, 0x00000010, 0x80008000},
+    {0x00000001, 0x00000010, 0x00007fff},
+    {0x40118010, 0x00000002, 0x7fff8000},
+    {0x80008000, 0x00000002, 0x80008000},
+};
+
+/* plsl.s16.s */
+struct binary_calculation samples_plsl_s16_s[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0xfffffffe, 0x00000001, 0xfffefffc},
+    {0x7fffffff, 0x00000001, 0x7ffffffe},
+    {0x80000000, 0x00000001, 0x80000000},
+    {0x007fffff, 0x00000009, 0x7ffffe00},
+    {0xff800000, 0x00000009, 0x80000000},
+    {0xffffffff, 0x00000010, 0x80008000},
+    {0x00000001, 0x00000010, 0x00007fff},
+    {0x7fffffff, 0x00000000, 0x7fffffff},
+    {0x10118010, 0x00000004, 0x7fff8000},
+    {0x80008000, 0x00000004, 0x80008000},
+    {0x20002000, 0x00000004, 0x7fff7fff},
+    {0x00010001, 0x0000000f, 0x7fff7fff},
+    {0x00010001, 0x00000010, 0x7fff7fff},
+    {0x00010001, 0x0000000e, 0x40004000},
+    {0x00010001, 0x0000001f, 0x7fff7fff},
+};
+
+/* pcmpne.8 */
+struct binary_calculation samples_pcmpne_8[] = {
+    {0x22222222, 0x11111111, 0xffffffff},
+    {0x22222222, 0x22111111, 0x00ffffff},
+    {0x22222222, 0x22221111, 0x0000ffff},
+    {0x22222222, 0x22222211, 0x000000ff},
+    {0x22222222, 0x22222222, 0x00000000},
+    {0x0110aa00, 0x0111ab00, 0x00ffff00},
+    {0x00000000, 0x01010101, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+};
+
+/* pcmpne.16 */
+struct binary_calculation samples_pcmpne_16[] = {
+    {0x22222222, 0x11111111, 0xffffffff},
+    {0x22222222, 0x22111111, 0xffffffff},
+    {0x22222222, 0x22221111, 0x0000ffff},
+    {0x22222222, 0x22222211, 0x0000ffff},
+    {0x22222222, 0x22222222, 0x00000000},
+    {0x80111010, 0x00001010, 0xffff0000},
+    {0x00010001, 0x00010001, 0x00000000},
+};
+
+/* pcmphs.u8 */
+struct binary_calculation samples_pcmphs_u8[] = {
+    {0x22222222, 0x11111111, 0xffffffff},
+    {0x22222222, 0x22111111, 0xffffffff},
+    {0x22222222, 0x33221111, 0x00ffffff},
+    {0x22222222, 0x33332211, 0x0000ffff},
+    {0x22222222, 0x33333333, 0x00000000},
+    {0x7f7f7f7f, 0x80808080, 0x00000000},
+    {0xffffffff, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x12111010, 0x11112001, 0xffff00ff},
+    {0x01010101, 0x00000000, 0xffffffff},
+    {0x01010101, 0x01010101, 0xffffffff},
+};
+
+/* pcmphs.s8 */
+struct binary_calculation samples_pcmphs_s8[] = {
+    {0x22222222, 0x11111111, 0xffffffff},
+    {0x22222222, 0x22111111, 0xffffffff},
+    {0x22222222, 0x33221111, 0x00ffffff},
+    {0x22222222, 0x33332211, 0x0000ffff},
+    {0x22222222, 0x33333333, 0x00000000},
+    {0x22222222, 0xeeeeeeee, 0xffffffff},
+    {0xeeeeeeee, 0x22222222, 0x00000000},
+    {0x7f7f7f7f, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0xfeaa1010, 0xfdaa7f01, 0xffff00ff},
+    {0x01010101, 0x00000000, 0xffffffff},
+    {0x80808080, 0x00000000, 0x00000000},
+    {0xaaaaaaaa, 0xaaaaaaaa, 0xffffffff},
+};
+
+/* pcmphs.u16 */
+struct binary_calculation samples_pcmphs_u16[] = {
+    {0x22222222, 0x11111111, 0xffffffff},
+    {0x22222222, 0x22111111, 0xffffffff},
+    {0x22222222, 0x33221111, 0x0000ffff},
+    {0x22222222, 0x33332211, 0x0000ffff},
+    {0x22222222, 0x33333333, 0x00000000},
+    {0x7f7f7f7f, 0x80808080, 0x00000000},
+    {0x7fff7fff, 0x80008000, 0x00000000},
+    {0xffffffff, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x00101000, 0x10000001, 0x0000ffff},
+    {0x80008000, 0x80008000, 0xffffffff},
+};
+
+/* pcmphs.s16 */
+struct binary_calculation samples_pcmphs_s16[] = {
+    {0x22222222, 0x11111111, 0xffffffff},
+    {0x22222222, 0x22111111, 0xffffffff},
+    {0x22222222, 0x33221111, 0x0000ffff},
+    {0x22222222, 0x33332211, 0x0000ffff},
+    {0x22222222, 0x33333333, 0x00000000},
+    {0x22222222, 0xeeeeeeee, 0xffffffff},
+    {0xeeeeeeee, 0x22222222, 0x00000000},
+    {0x7f7f7f7f, 0x80808080, 0xffffffff},
+    {0x7fff7fff, 0x80008000, 0xffffffff},
+    {0xffffffff, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0x00101000, 0x0010a001, 0xffffffff},
+    {0x80008000, 0x80008000, 0xffffffff},
+
+};
+
+/* pcmplt.u8 */
+struct binary_calculation samples_pcmplt_u8[] = {
+    {0x11111111, 0x22222222, 0xffffffff},
+    {0x22111111, 0x22222222, 0x00ffffff},
+    {0x33221111, 0x22222222, 0x0000ffff},
+    {0x33332211, 0x22222222, 0x000000ff},
+    {0x33333333, 0x22222222, 0x00000000},
+    {0x80808080, 0x7f7f7f7f, 0x00000000},
+    {0x80808080, 0xffffffff, 0xffffffff},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0x01810101, 0xf1111001, 0xff00ff00},
+};
+
+/* pcmplt.s8 */
+struct binary_calculation samples_pcmplt_s8[] = {
+    {0x11111111, 0x22222222, 0xffffffff},
+    {0x22111111, 0x22222222, 0x00ffffff},
+    {0x33221111, 0x22222222, 0x0000ffff},
+    {0x33332211, 0x22222222, 0x000000ff},
+    {0x33333333, 0x22222222, 0x00000000},
+    {0xeeeeeeee, 0x22222222, 0xffffffff},
+    {0x22222222, 0xeeeeeeee, 0x00000000},
+    {0x80808080, 0x7f7f7f7f, 0xffffffff},
+    {0x80808080, 0xffffffff, 0xffffffff},
+    {0x00000000, 0xffffffff, 0x00000000},
+    {0x01810101, 0xf1111001, 0x00ffff00},
+};
+
+/* pcmplt.u16 */
+struct binary_calculation samples_pcmplt_u16[] = {
+    {0x11111111, 0x22222222, 0xffffffff},
+    {0x22111111, 0x22222222, 0xffffffff},
+    {0x33221111, 0x22222222, 0x0000ffff},
+    {0x33332211, 0x22222222, 0x0000ffff},
+    {0x33333333, 0x22222222, 0x00000000},
+    {0x80808080, 0x7f7f7f7f, 0x00000000},
+    {0x80008000, 0x7fff7fff, 0x00000000},
+    {0x80808080, 0xffffffff, 0xffffffff},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0x00000000, 0x00010000, 0xffff0000},
+};
+
+/* pcmplt.s16 */
+struct binary_calculation samples_pcmplt_s16[] = {
+    {0x11111111, 0x22222222, 0xffffffff},
+    {0x22111111, 0x22222222, 0xffffffff},
+    {0x33221111, 0x22222222, 0x0000ffff},
+    {0x33332211, 0x22222222, 0x0000ffff},
+    {0x33333333, 0x22222222, 0x00000000},
+    {0xeeeeeeee, 0x22222222, 0xffffffff},
+    {0x22222222, 0xeeeeeeee, 0x00000000},
+    {0x80808080, 0x7f7f7f7f, 0xffffffff},
+    {0x80008000, 0x7fff7fff, 0xffffffff},
+    {0x80808080, 0xffffffff, 0xffffffff},
+    {0x00000000, 0xffffffff, 0x00000000},
+    {0x1001a000, 0x80010000, 0x0000ffff},
+};
+
+/* pmax.u8 */
+struct binary_calculation samples_pmax_u8[] = {
+    {0x22222222, 0x11111111, 0x22222222},
+    {0x22222222, 0x22111111, 0x22222222},
+    {0x22222222, 0x33221111, 0x33222222},
+    {0x22222222, 0x33332211, 0x33332222},
+    {0x22222222, 0x33333333, 0x33333333},
+    {0x22222222, 0xeeeeeeee, 0xeeeeeeee},
+    {0xeeeeeeee, 0x22222222, 0xeeeeeeee},
+    {0x7f7f7f7f, 0x80808080, 0x80808080},
+    {0xffffffff, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x80111010, 0x00aa1110, 0x80aa1110},
+};
+
+/* pmax.s8 */
+struct binary_calculation samples_pmax_s8[] = {
+    {0x22222222, 0x11111111, 0x22222222},
+    {0x22222222, 0x22111111, 0x22222222},
+    {0x22222222, 0x33221111, 0x33222222},
+    {0x22222222, 0x33332211, 0x33332222},
+    {0x22222222, 0x33333333, 0x33333333},
+    {0x22222222, 0xeeeeeeee, 0x22222222},
+    {0xeeeeeeee, 0x22222222, 0x22222222},
+    {0x7f7f7f7f, 0x80808080, 0x7f7f7f7f},
+    {0xffffffff, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0x80111022, 0x00aaaa10, 0x00111022},
+};
+
+/* pmax.u16 */
+struct binary_calculation samples_pmax_u16[] = {
+    {0x22222222, 0x11111111, 0x22222222},
+    {0x22222222, 0x22111111, 0x22222222},
+    {0x22222222, 0x33221111, 0x33222222},
+    {0x22222222, 0x33332211, 0x33332222},
+    {0x22222222, 0x33333333, 0x33333333},
+    {0x22222222, 0xeeeeeeee, 0xeeeeeeee},
+    {0xeeeeeeee, 0x22222222, 0xeeeeeeee},
+    {0x22222222, 0x33111111, 0x33112222},
+    {0x7f7f7f7f, 0x80808080, 0x80808080},
+    {0xffffffff, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0xa0011010, 0x11111010, 0xa0011010},
+};
+
+/* pmax.s16 */
+struct binary_calculation samples_pmax_s16[] = {
+    {0x22222222, 0x11111111, 0x22222222},
+    {0x22222222, 0x22111111, 0x22222222},
+    {0x22222222, 0x33221111, 0x33222222},
+    {0x22222222, 0x33332211, 0x33332222},
+    {0x22222222, 0x33333333, 0x33333333},
+    {0x22222222, 0xeeeeeeee, 0x22222222},
+    {0xeeeeeeee, 0x22222222, 0x22222222},
+    {0x22222222, 0x33111111, 0x33112222},
+    {0x7f7f7f7f, 0x80808080, 0x7f7f7f7f},
+    {0xffffffff, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0xa0011010, 0xb0011011, 0xb0011011},
+};
+
+/* max.u32 */
+struct binary_calculation samples_max_u32[] = {
+    {0x22222222, 0x11111111, 0x22222222},
+    {0x22222222, 0x22111111, 0x22222222},
+    {0x22222222, 0x33221111, 0x33221111},
+    {0x22222222, 0x33332211, 0x33332211},
+    {0x22222222, 0x33333333, 0x33333333},
+    {0x22222222, 0xeeeeeeee, 0xeeeeeeee},
+    {0xeeeeeeee, 0x22222222, 0xeeeeeeee},
+    {0x22222222, 0x33111111, 0x33111111},
+    {0x7f7f7f7f, 0x80808080, 0x80808080},
+    {0xffffffff, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x00100000, 0x10000001, 0x10000001},
+};
+
+/* max.s32 */
+struct binary_calculation samples_max_s32[] = {
+    {0x22222222, 0x11111111, 0x22222222},
+    {0x22222222, 0x22111111, 0x22222222},
+    {0x22222222, 0x33221111, 0x33221111},
+    {0x22222222, 0x33332211, 0x33332211},
+    {0x22222222, 0x33333333, 0x33333333},
+    {0x22222222, 0xeeeeeeee, 0x22222222},
+    {0xeeeeeeee, 0x22222222, 0x22222222},
+    {0x22222222, 0x33111111, 0x33111111},
+    {0x7f7f7f7f, 0x80808080, 0x7f7f7f7f},
+    {0xffffffff, 0x80808080, 0xffffffff},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0xa0001000, 0xb0000001, 0xb0000001},
+};
+
+/* pmin.u8 */
+struct binary_calculation samples_pmin_u8[] = {
+    {0x11111111, 0x22222222, 0x11111111},
+    {0x22111111, 0x22222222, 0x22111111},
+    {0x33221111, 0x22222222, 0x22221111},
+    {0x33332211, 0x22222222, 0x22222211},
+    {0x33333333, 0x22222222, 0x22222222},
+    {0xa1810101, 0xf1111001, 0xa1110101},
+    {0x80808080, 0x00000000, 0x00000000},
+    {0x80808080, 0x80808080, 0x80808080},
+};
+
+/* pmin.s8 */
+struct binary_calculation samples_pmin_s8[] = {
+    {0x11111111, 0x22222222, 0x11111111},
+    {0x22111111, 0x22222222, 0x22111111},
+    {0x33221111, 0x22222222, 0x22221111},
+    {0x33332211, 0x22222222, 0x22222211},
+    {0x33333333, 0x22222222, 0x22222222},
+    {0xeeeeeeee, 0x22222222, 0xeeeeeeee},
+    {0x22222222, 0xeeeeeeee, 0xeeeeeeee},
+    {0x80808080, 0x7f7f7f7f, 0x80808080},
+    {0x80808080, 0xffffffff, 0x80808080},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0xa1811101, 0xa0111001, 0xa0811001},
+};
+
+/* pmin.u16 */
+struct binary_calculation samples_pmin_u16[] = {
+    {0x11111111, 0x22222222, 0x11111111},
+    {0x22111111, 0x22222222, 0x22111111},
+    {0x33221111, 0x22222222, 0x22221111},
+    {0x33332211, 0x22222222, 0x22222211},
+    {0x33333333, 0x22222222, 0x22222222},
+    {0xeeeeeeee, 0x22222222, 0x22222222},
+    {0x22222222, 0xeeeeeeee, 0x22222222},
+    {0x33111111, 0x22222222, 0x22221111},
+    {0x80808080, 0x7f7f7f7f, 0x7f7f7f7f},
+    {0x80808080, 0xffffffff, 0x80808080},
+    {0x00000000, 0xffffffff, 0x00000000},
+    {0x00000000, 0x80008000, 0x00000000},
+};
+
+/* pmin.s16 */
+struct binary_calculation samples_pmin_s16[] = {
+    {0x11111111, 0x22222222, 0x11111111},
+    {0x22111111, 0x22222222, 0x22111111},
+    {0x33221111, 0x22222222, 0x22221111},
+    {0x33332211, 0x22222222, 0x22222211},
+    {0x33333333, 0x22222222, 0x22222222},
+    {0xeeeeeeee, 0x22222222, 0xeeeeeeee},
+    {0x22222222, 0xeeeeeeee, 0xeeeeeeee},
+    {0x33111111, 0x22222222, 0x22221111},
+    {0x80808080, 0x7f7f7f7f, 0x80808080},
+    {0x80808080, 0xffffffff, 0x80808080},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0xa0018000, 0x80010000, 0x80018000},
+};
+
+/* min.u32 */
+struct binary_calculation samples_min_u32[] = {
+    {0x11111111, 0x22222222, 0x11111111},
+    {0x22111111, 0x22222222, 0x22111111},
+    {0x33221111, 0x22222222, 0x22222222},
+    {0xeeeeeeee, 0x22222222, 0x22222222},
+    {0x22222222, 0xeeeeeeee, 0x22222222},
+    {0x80808080, 0x7f7f7f7f, 0x7f7f7f7f},
+    {0x80808080, 0xffffffff, 0x80808080},
+    {0x00000000, 0xffffffff, 0x00000000},
+    {0x80000001, 0x70000001, 0x70000001},
+};
+
+/* min.s32 */
+struct binary_calculation samples_min_s32[] = {
+    {0x11111111, 0x22222222, 0x11111111},
+    {0x33221111, 0x22222222, 0x22222222},
+    {0xeeeeeeee, 0x22222222, 0xeeeeeeee},
+    {0x22222222, 0xeeeeeeee, 0xeeeeeeee},
+    {0x80808080, 0x7f7f7f7f, 0x80808080},
+    {0x80808080, 0xffffffff, 0x80808080},
+    {0x00000000, 0xffffffff, 0xffffffff},
+    {0x80000001, 0x70000001, 0x80000001},
+};
+
+/* pkgll */
+struct binary_calculation samples_pkgll[] = {
+    {0x89abcdef, 0x01234567, 0x4567cdef},
+    {0x00000000, 0xffffffff, 0xffff0000},
+    {0x12345678, 0xffffffff, 0xffff5678},
+    {0xffffffff, 0x00000000, 0x0000ffff},
+    {0xa0011010, 0x11111011, 0x10111010},
+};
+
+/* pkghh */
+struct binary_calculation samples_pkghh[] = {
+    {0x89abcdef, 0x01234567, 0x012389ab},
+    {0x00000000, 0xffffffff, 0xffff0000},
+    {0x12345678, 0xffffffff, 0xffff1234},
+    {0xffffffff, 0x00000000, 0x0000ffff},
+    {0x00100000, 0x10000001, 0x10000010},
+};
+
+/* narl */
+struct binary_calculation samples_narl[] = {
+    {0x01234567, 0x89abcdef, 0xabef2367},
+    {0xffffffff, 0x00000000, 0x0000ffff},
+    {0x7fffffff, 0x80000000, 0x0000ffff},
+    {0x01010202, 0x10102020, 0x10200102},
+};
+
+/* narh */
+struct binary_calculation samples_narh[] = {
+    {0x01234567, 0x89abcdef, 0x89cd0145},
+    {0xffffffff, 0x00000000, 0x0000ffff},
+    {0x7fffffff, 0x80000000, 0x80007fff},
+    {0x01010202, 0x10102020, 0x10200102},
+};
+
+/* narlx */
+struct binary_calculation samples_narlx[] = {
+    {0x01234567, 0x89abcdef, 0xab23ef67},
+    {0xffffffff, 0x00000000, 0x00ff00ff},
+    {0x7fffffff, 0x80000000, 0x00ff00ff},
+    {0x01010202, 0x10102020, 0x10012002},
+};
+
+/* narhx */
+struct binary_calculation samples_narhx[] = {
+    {0x01234567, 0x89abcdef, 0x8901cd45},
+    {0xffffffff, 0x00000000, 0x00ff00ff},
+    {0x7fffffff, 0x80000000, 0x807f00ff},
+    {0x01011202, 0x10102020, 0x10012012},
+};
+
+/* clipi.u32 */
+struct binary_calculation samples_clipi_u32[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x00000002, 0x00000001},
+    {0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x0000001f, 0x00000001},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0xffffffff, 0x0000001f, 0x7fffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x0000001f, 0x00000005, 0x0000001f},
+    {0x000000ff, 0x00000005, 0x0000001f},
+};
+
+/* clipi.s32 */
+struct binary_calculation samples_clipi_s32[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x00000002, 0x00000001},
+    {0x00000001, 0x00000000, 0x00000000},
+    {0xffffffff, 0x00000002, 0xffffffff},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0xfffffffe, 0x00000000, 0xffffffff},
+    {0x00000001, 0x0000001f, 0x00000001},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0xffffffff, 0x0000001f, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x0000001f, 0x7fffffff},
+    {0x80000000, 0x0000001f, 0x80000000},
+    {0xffffffff, 0x0000001f, 0xffffffff},
+    {0x000000ff, 0x00000006, 0x0000003f},
+    {0xffffffe0, 0x00000005, 0xffffffe0},
+    {0xffffffc1, 0x00000005, 0xffffffe0},
+};
+
+/* clip.u32 */
+struct binary_calculation samples_clip_u32[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x00000002, 0x00000001},
+    {0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x0000001f, 0x00000001},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0xffffffff, 0x0000001f, 0x7fffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x0000003f, 0x00000006, 0x0000003f},
+    {0x0000001f, 0x00000006, 0x0000001f},
+    {0x0000004f, 0x00000006, 0x0000003f},
+};
+
+/* clip.s32 */
+struct binary_calculation samples_clip_s32[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x00000002, 0x00000001},
+    {0x00000001, 0x00000000, 0x00000000},
+    {0xffffffff, 0x00000002, 0xffffffff},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0xfffffffe, 0x00000000, 0xffffffff},
+    {0x00000001, 0x0000001f, 0x00000001},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0xffffffff, 0x0000001f, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x0000001f, 0x7fffffff},
+    {0x80000000, 0x0000001f, 0x80000000},
+    {0xffffffff, 0x0000001f, 0xffffffff},
+    {0x0000003f, 0x00000006, 0x0000003f},
+    {0x0000002f, 0x00000006, 0x0000002f},
+    {0x0000004f, 0x00000006, 0x0000003f},
+    {0xffffffc0, 0x00000006, 0xffffffc0},
+    {0xffffffb1, 0x00000006, 0xffffffc0},
+};
+
+/* pclipi.u16 */
+struct binary_calculation samples_pclipi_u16[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00010001, 0x00000002, 0x00010001},
+    {0x00000001, 0x00000000, 0x00000000},
+    {0x00010001, 0x00000000, 0x00000000},
+    {0x10001000, 0x00000002, 0x00030003},
+    {0x10000001, 0x00000002, 0x00030001},
+    {0x00010001, 0x0000000f, 0x00010001},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0xffffffff, 0x0000000f, 0x7fff7fff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x0000000f, 0x00000000},
+    {0x0011007f, 0x00000007, 0x0011007f},
+    {0x000000ff, 0x00000007, 0x0000007f},
+    {0x00ff00ff, 0x00000007, 0x007f007f},
+    {0x80008000, 0x00000007, 0x007f007f},
+};
+
+/* pclip.u16 */
+struct binary_calculation samples_pclip_u16[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00010001, 0x00000002, 0x00010001},
+    {0x00000001, 0x00000000, 0x00000000},
+    {0x00010001, 0x00000000, 0x00000000},
+    {0x10001000, 0x00000002, 0x00030003},
+    {0x10000001, 0x00000002, 0x00030001},
+    {0x00010001, 0x0000000f, 0x00010001},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0xffffffff, 0x0000000f, 0x7fff7fff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x0000000f, 0x00000000},
+    {0x001100ff, 0x00000008, 0x001100ff},
+    {0x000001ff, 0x00000008, 0x000000ff},
+    {0x01ff01ff, 0x00000008, 0x00ff00ff},
+    {0x80008000, 0x00000008, 0x00ff00ff},
+};
+
+/* pclipi.s16 */
+struct binary_calculation samples_pclipi_s16[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00010001, 0x00000001, 0x00010001},
+    {0xffff0001, 0x00000001, 0xffff0001},
+    {0xfffe0001, 0x00000001, 0xfffe0001},
+    {0xfffd0010, 0x00000001, 0xfffe0001},
+    {0xfffc0011, 0x00000001, 0xfffe0001},
+    {0x00010001, 0x0000000f, 0x00010001},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0xffffffff, 0x0000000f, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x0000000f, 0x00000000},
+    {0x7fffffff, 0x0000000f, 0x7fffffff},
+    {0x80000000, 0x0000000f, 0x80000000},
+    {0x7ffe8001, 0x0000000f, 0x7ffe8001},
+    {0x000100ff, 0x00000007, 0x0001007f},
+    {0xffffff01, 0x00000007, 0xffffff80},
+    {0xff01ff01, 0x00000007, 0xff80ff80},
+};
+
+/* pclip.s16 */
+struct binary_calculation samples_pclip_s16[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00010001, 0x00000001, 0x00010001},
+    {0xffff0001, 0x00000001, 0xffff0001},
+    {0xfffe0001, 0x00000001, 0xfffe0001},
+    {0xfffd0010, 0x00000001, 0xfffe0001},
+    {0xfffc0011, 0x00000001, 0xfffe0001},
+    {0x00010001, 0x0000000f, 0x00010001},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0xffffffff, 0x0000000f, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x0000000f, 0x00000000},
+    {0x7fffffff, 0x0000000f, 0x7fffffff},
+    {0x80000000, 0x0000000f, 0x80000000},
+    {0x7ffe8001, 0x0000000f, 0x7ffe8001},
+    {0x000100ff, 0x00000008, 0x000100ff},
+    {0x8001fe01, 0x00000008, 0xff00ff00},
+    {0xfe01fe01, 0x00000008, 0xff00ff00},
+};
+
+/* dup.8 */
+struct binary_calculation samples_dup_8[] = {
+    {0x12345678, 0x00000000, 0x78787878},
+    {0x12345678, 0x00000001, 0x56565656},
+    {0x12345678, 0x00000002, 0x34343434},
+    {0x12345678, 0x00000003, 0x12121212},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x7fffffff, 0x00000000, 0xffffffff},
+    {0x80000000, 0x00000000, 0x00000000},
+    {0x44332211, 0x00000001, 0x22222222},
+    {0x44332211, 0x00000002, 0x33333333},
+    {0x45332211, 0x00000003, 0x45454545},
+    {0x45332211, 0x00000000, 0x11111111},
+};
+
+/* dup.16 */
+struct binary_calculation samples_dup_16[] = {
+    {0x12345678, 0x00000000, 0x56785678},
+    {0x12345678, 0x00000001, 0x12341234},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0xffffffff, 0x00000000, 0xffffffff},
+    {0x7fffffff, 0x00000001, 0x7fff7fff},
+    {0x80000000, 0x00000001, 0x80008000},
+    {0x22221111, 0x00000000, 0x11111111},
+    {0x22221111, 0x00000001, 0x22222222},
+};
+
+/* psabsa.u8 */
+struct binary_calculation samples_psabsa_u8[] = {
+    {0x44556677, 0x00112233, 0x00000110},
+    {0x00112233, 0x44556677, 0x00000110},
+    {0x44444444, 0x44444444, 0x00000000},
+    {0xffffffff, 0x7f7f7f7f, 0x00000200},
+    {0xffffffff, 0x00000000, 0x000003fc},
+    {0x7f7f7f7f, 0x80808080, 0x00000004},
+    {0xff7f0080, 0x7fff807f, 0x00000181},
+    {0xff01807f, 0xff107f80, 0x00000011},
+};
+
+/* mulaca.s8 */
+struct binary_calculation samples_mulaca_s8[] = {
+    {0x01010101, 0x40404040, 0x00000100},
+    {0x40404040, 0x01010101, 0x00000100},
+    {0x02020202, 0x40404040, 0x00000200},
+    {0x01010101, 0x80808080, 0xfffffe00},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0xffffffff, 0xffffffff, 0x00000004},
+    {0x7fffffff, 0x80808080, 0xffffc200},
+    {0x80000000, 0x7fff4000, 0xffffc080},
+    {0x7fffffff, 0x4000ff00, 0x00001fc1},
+    {0x7f80ff01, 0x40ff017f, 0x000020be},
+};
+
+/* pabs.s8.s */
+struct unary_calculation samples_pabs_s8_s[] = {
+    {0x01010101, 0x01010101},
+    {0x00000001, 0x00000001},
+    {0x00010001, 0x00010001},
+    {0x80808080, 0x7f7f7f7f},
+    {0x80000000, 0x7f000000},
+    {0x80008000, 0x7f007f00},
+    {0x00000000, 0x00000000},
+    {0xffffffff, 0x01010101},
+    {0x7f7f7f7f, 0x7f7f7f7f},
+    {0x7fffffff, 0x7f010101},
+    {0x7fff7fff, 0x7f017f01},
+    {0x80807f02, 0x7f7f7f02},
+    {0x81818181, 0x7f7f7f7f},
+    {0x80808080, 0x7f7f7f7f},
+    {0x7f7f7f7f, 0x7f7f7f7f},
+};
+
+/* pabs.s16.s */
+struct unary_calculation samples_pabs_s16_s[] = {
+    {0x01010101, 0x01010101},
+    {0x00000001, 0x00000001},
+    {0x00010001, 0x00010001},
+    {0x80808080, 0x7f807f80},
+    {0x80000000, 0x7fff0000},
+    {0x80008000, 0x7fff7fff},
+    {0x00000000, 0x00000000},
+    {0xffffffff, 0x00010001},
+    {0x7f7f7f7f, 0x7f7f7f7f},
+    {0x7fffffff, 0x7fff0001},
+    {0x7fff7fff, 0x7fff7fff},
+    {0x8000001f, 0x7fff001f},
+    {0xf00100ff, 0x0fff00ff},
+    {0x80018001, 0x7fff7fff},
+};
+
+/* abs.s32.s */
+struct unary_calculation samples_abs_s32_s[] = {
+    {0x01010101, 0x01010101},
+    {0x00000001, 0x00000001},
+    {0x00010001, 0x00010001},
+    {0x80808080, 0x7f7f7f80},
+    {0x80000000, 0x7fffffff},
+    {0x80008000, 0x7fff8000},
+    {0x00000000, 0x00000000},
+    {0xffffffff, 0x00000001},
+    {0x7f7f7f7f, 0x7f7f7f7f},
+    {0x7fffffff, 0x7fffffff},
+    {0x7fff7fff, 0x7fff7fff},
+    {0x0000003f, 0x0000003f},
+    {0xf000001f, 0x0fffffe1},
+};
+
+/* pneg.s8.s */
+struct unary_calculation samples_pneg_s8_s[] = {
+    {0x01010101, 0xffffffff},
+    {0xffffffff, 0x01010101},
+    {0x00010001, 0x00ff00ff},
+    {0x00ff00ff, 0x00010001},
+    {0x00000001, 0x000000ff},
+    {0x80808080, 0x7f7f7f7f},
+    {0x80008000, 0x7f007f00},
+    {0x80000000, 0x7f000000},
+    {0x00000000, 0x00000000},
+    {0xffffffff, 0x01010101},
+    {0x7f7f7f7f, 0x81818181},
+    {0x7fff7fff, 0x81018101},
+    {0x7fffffff, 0x81010101},
+    {0x00017f80, 0x00ff817f},
+    {0x811111ff, 0x7fefef01},
+    {0x81818181, 0x7f7f7f7f},
+};
+
+/* pneg.s16.s */
+struct unary_calculation samples_pneg_s16_s[] = {
+    {0x01010101, 0xfefffeff},
+    {0xfefffeff, 0x01010101},
+    {0x00010001, 0xffffffff},
+    {0x00ff00ff, 0xff01ff01},
+    {0x00000001, 0x0000ffff},
+    {0x80808080, 0x7f807f80},
+    {0x80008000, 0x7fff7fff},
+    {0x80000000, 0x7fff0000},
+    {0x00000000, 0x00000000},
+    {0xffffffff, 0x00010001},
+    {0x7f7f7f7f, 0x80818081},
+    {0x7fff7fff, 0x80018001},
+    {0x7fffffff, 0x80010001},
+    {0x0001ffff, 0xffff0001},
+    {0x7fff8000, 0x80017fff},
+    {0x80018001, 0x7fff7fff},
+};
+
+/* neg.s32.s */
+struct unary_calculation samples_neg_s32_s[] = {
+    {0x01010101, 0xfefefeff},
+    {0xfefefeff, 0x01010101},
+    {0x00010001, 0xfffeffff},
+    {0xfffeffff, 0x00010001},
+    {0x00000001, 0xffffffff},
+    {0x80808080, 0x7f7f7f80},
+    {0x80008000, 0x7fff8000},
+    {0x80000000, 0x7fffffff},
+    {0x00000000, 0x00000000},
+    {0xffffffff, 0x00000001},
+    {0x7f7f7f7f, 0x80808081},
+    {0x7fff7fff, 0x80008001},
+    {0x7fffffff, 0x80000001},
+    {0x80000001, 0x7fffffff},
+};
+
+/* pext.u8.e */
+struct unary64_calculation samples_pext_u8_e[] = {
+    {0x12345678, 0x0012003400560078},
+    {0xffffffff, 0x00ff00ff00ff00ff},
+    {0x7fffffff, 0x007f00ff00ff00ff},
+    {0x81800100, 0x0081008000010000},
+};
+
+/* pext.s8.e */
+struct unary64_calculation samples_pext_s8_e[] = {
+    {0x12345678, 0x0012003400560078},
+    {0xffffffff, 0xffffffffffffffff},
+    {0x7fffffff, 0x007fffffffffffff},
+    {0x81818181, 0xff81ff81ff81ff81},
+    {0x81800100, 0xff81ff8000010000},
+};
+
+/* pextx.u8.e */
+struct unary64_calculation samples_pextx_u8_e[] = {
+    {0x12345678, 0x0012005600340078},
+    {0xffffffff, 0x00ff00ff00ff00ff},
+    {0x7fffffff, 0x007f00ff00ff00ff},
+    {0x81800100, 0x0081000100800000},
+};
+
+/* pextx.s8.e */
+struct unary64_calculation samples_pextx_s8_e[] = {
+    {0x12345678, 0x0012005600340078},
+    {0xffffffff, 0xffffffffffffffff},
+    {0x7fffffff, 0x007fffffffffffff},
+    {0x81800100, 0xff810001ff800000},
+};
+
+/* sel */
+struct ternary_calculation samples_sel[] = {
+    {0x00000000, 0xffffffff, 0x00000000, 0xffffffff},
+    {0x00000000, 0xffffffff, 0xffffffff, 0x00000000},
+    {0xffff0000, 0x0000ffff, 0xffff0000, 0xffffffff},
+    {0xffff0000, 0x0000ffff, 0x0000ffff, 0x00000000},
+    {0x00000000, 0xffffffff, 0xaaaaaaaa, 0x55555555},
+    {0x00000000, 0xffffffff, 0x55555555, 0xaaaaaaaa},
+};
+
+/* dexti */
+struct ternary_calculation samples_dexti[] = {
+    {0x89abcdef, 0x01234567, 0x00000000, 0x89abcdef},
+    {0x00000000, 0xffffffff, 0x00000002, 0xc0000000},
+    {0x00000000, 0xffffffff, 0x0000001f, 0xfffffffe},
+    {0xffffffff, 0x00000000, 0x0000001f, 0x00000001},
+    {0x01010101, 0x011110f1, 0x00000005, 0x88080808},
+};
+
+/* dext */
+struct ternary_calculation samples_dext[] = {
+    {0x89abcdef, 0x01234567, 0x00000008, 0x6789abcd},
+    {0x89abcdef, 0x01234567, 0x00000004, 0x789abcde},
+    {0x00000000, 0xffffffff, 0x00000002, 0xc0000000},
+    {0x00000000, 0xffffffff, 0x00000020, 0xffffffff},
+    {0xffffffff, 0x00000000, 0x0000001f, 0x00000001},
+    {0x01010101, 0x011110f1, 0x00000004, 0x10101010},
+};
+
+/* psabsaa.u8 */
+struct ternary_calculation samples_psabsaa_u8[] = {
+    {0x44556677, 0x00112233, 0x00000000, 0x00000110},
+    {0x00112233, 0x44556677, 0x00000000, 0x00000110},
+    {0x44444444, 0x44444444, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x7f7f7f7f, 0xffffffff, 0x000001ff},
+    {0xffffffff, 0x00000000, 0x00000000, 0x000003fc},
+    {0x7f7f7f7f, 0x80808080, 0x00000000, 0x00000004},
+    {0xff7f0080, 0x7fff807f, 0xffffffff, 0x00000180},
+    {0xff01807f, 0xff107f80, 0x80000000, 0x80000011},
+};
+
+/* divul */
+struct binary64_64_calculation samples_divul[] = {
+    {0x6666666655555555, 0x11111111, 0x0000000600000005},
+    {0xaaaaaaaa88888888, 0x11111111, 0x0000000a00000008},
+    {0x0000000000000001, 0x00000010, 0x0000000000000000},
+    {0xffffffffffffffff, 0x00000001, 0xffffffffffffffff},
+    {0xffffffffffffffff, 0xffffffff, 0x0000000100000001},
+    {0x0000000000000000, 0x00000001, 0x0000000000000000},
+    {0xffffffff80000001, 0xffffffff, 0x0000000100000000},
+    {0x7fffffff80000000, 0x7fffffff, 0x0000000100000001},
+    {0x7fffffff80000000, 0xffffffff, 0x0000000080000000},
+    /*{0x0000000100000000, 0x00000000, exception for div 0},*/
+};
+
+/* divsl */
+struct binary64_64_calculation samples_divsl[] = {
+    {0x6666666655555555, 0x11111111, 0x0000000600000005},
+    {0xaaaaaaaa88888888, 0x11111111, 0xfffffffafffffff9},
+    {0x0000000000000001, 0x00000010, 0x0000000000000000},
+    {0xffffffffffffffff, 0x00000001, 0xffffffffffffffff},
+    {0xffffffffffffffff, 0xffffffff, 0x0000000000000001},
+    {0x0000000000000000, 0x00000001, 0x0000000000000000},
+    {0x8000000000000000, 0xffffffff, 0x8000000000000000},
+    {0xffffffff80000001, 0xffffffff, 0x000000007fffffff},
+    {0x7fffffff80000000, 0x7fffffff, 0x0000000100000001},
+    {0x7fffffff80000000, 0xffffffff, 0x8000000080000000},
+    /*{0x0000000100000000, 0x00000000, exception for div 0},*/
+};
+
+/* pkg */
+struct quanary_calculation samples_pkg[] = {
+    {0x89abcdef, 0x00000004, 0x01234567, 0x00000010, 0x0123bcde},
+    {0x89abcdef, 0x00000004, 0x01234567, 0x00000004, 0x3456bcde},
+    {0x00000000, 0x00000008, 0xffffffff, 0x00000008, 0xffff0000},
+    {0x12345678, 0x00000000, 0xffffffff, 0x0000000f, 0xffff5678},
+    {0xffffffff, 0x0000000f, 0x00000000, 0x0000000f, 0x0000ffff},
+    {0xfffff0f0, 0x00000002, 0x11111010, 0x00000003, 0x2202fc3c},
+};
+
+
+/* muls.u32 */
+struct ternary64_calculation samples_muls_u32[] = {
+    {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000000},
+    {0x00000001, 0x00000001, 0xffffffffffffffff, 0xfffffffffffffffe},
+    {0x00000001, 0x00000001, 0x8000000000000000, 0x7fffffffffffffff},
+    {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x7ffffffffffffffe},
+    {0x00000001, 0xffffffff, 0xffffffffffffffff, 0xffffffff00000000},
+    {0x00000001, 0xffffffff, 0x8000000000000000, 0x7fffffff00000001},
+    {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x7fffffff00000000},
+    {0x80000000, 0x80000000, 0xffffffffffffffff, 0xbfffffffffffffff},
+    {0x80000000, 0x80000000, 0x8000000000000000, 0x4000000000000000},
+    {0x80000000, 0x80000000, 0x7fffffffffffffff, 0x3fffffffffffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0x800000017ffffffe},
+    {0x7fffffff, 0xffffffff, 0x8000000000000000, 0x000000017fffffff},
+    {0x7fffffff, 0xffffffff, 0x0000000000000000, 0x800000017fffffff},
+    {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x00000001, 0x000000007fffffff, 0x000000007ffffffe},
+    {0x00000001, 0xffffffff, 0x80000000ffffffff, 0x8000000000000000},
+};
+
+/* muls.s32 */
+struct ternary64_calculation samples_muls_s32[] = {
+    {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000000},
+    {0x00000001, 0x00000001, 0xffffffffffffffff, 0xfffffffffffffffe},
+    {0x00000001, 0x00000001, 0x8000000000000000, 0x7fffffffffffffff},
+    {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x7ffffffffffffffe},
+    {0x00000001, 0xffffffff, 0xffffffffffffffff, 0x0000000000000000},
+    {0x00000001, 0xffffffff, 0x8000000000000000, 0x8000000000000001},
+    {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x8000000000000000},
+    {0x80000000, 0x80000000, 0xffffffffffffffff, 0xbfffffffffffffff},
+    {0x80000000, 0x80000000, 0x8000000000000000, 0x4000000000000000},
+    {0x80000000, 0x80000000, 0x7fffffffffffffff, 0x3fffffffffffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0x000000007ffffffe},
+    {0x7fffffff, 0xffffffff, 0x8000000000000000, 0x800000007fffffff},
+    {0x7fffffff, 0xffffffff, 0x0000000000000000, 0x000000007fffffff},
+    {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x00000001, 0x000000007fffffff, 0x000000007ffffffe},
+};
+
+/* mula.u32.s */
+struct ternary64_calculation samples_mula_u32_s[] = {
+    {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000002},
+    {0x00000001, 0x00000001, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x00000001, 0x00000001, 0x8000000000000000, 0x8000000000000001},
+    {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x8000000000000000},
+    {0x00000001, 0xffffffff, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x00000001, 0xffffffff, 0x8000000000000000, 0x80000000ffffffff},
+    {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x80000000fffffffe},
+    {0x80000000, 0x80000000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x80000000, 0x80000000, 0x8000000000000000, 0xc000000000000000},
+    {0x80000000, 0x80000000, 0x7fffffffffffffff, 0xbfffffffffffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x7fffffff, 0xffffffff, 0x8000000000000000, 0xfffffffe80000001},
+    {0x7fffffff, 0xffffffff, 0x0000000000000000, 0x7ffffffe80000001},
+    {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+};
+
+/* mula.s32.s */
+struct ternary64_calculation samples_mula_s32_s[] = {
+    {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000002},
+    {0x00000001, 0x00000001, 0xffffffffffffffff, 0x0000000000000000},
+    {0x00000001, 0x00000001, 0x8000000000000000, 0x8000000000000001},
+    {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0x00000001, 0xffffffff, 0xffffffffffffffff, 0xfffffffffffffffe},
+    {0x00000001, 0xffffffff, 0x8000000000000000, 0x8000000000000000},
+    {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x7ffffffffffffffe},
+    {0x80000000, 0x80000000, 0xffffffffffffffff, 0x3fffffffffffffff},
+    {0x80000000, 0x80000000, 0x8000000000000000, 0xc000000000000000},
+    {0x80000000, 0x80000000, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0xffffffff80000000},
+    {0x7fffffff, 0xffffffff, 0x8000000000000000, 0x8000000000000000},
+    {0x7fffffff, 0xffffffff, 0x0000000000000000, 0xffffffff80000001},
+    {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+};
+
+/* muls.u32.s */
+struct ternary64_calculation samples_muls_u32_s[] = {
+    {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000000},
+    {0x00000001, 0x00000001, 0xffffffffffffffff, 0xfffffffffffffffe},
+    {0x00000001, 0x00000001, 0x8000000000000000, 0x7fffffffffffffff},
+    {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x7ffffffffffffffe},
+    {0x00000001, 0xffffffff, 0xffffffffffffffff, 0xffffffff00000000},
+    {0x00000001, 0xffffffff, 0x8000000000000000, 0x7fffffff00000001},
+    {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x7fffffff00000000},
+    {0x80000000, 0x80000000, 0xffffffffffffffff, 0xbfffffffffffffff},
+    {0x80000000, 0x80000000, 0x8000000000000000, 0x4000000000000000},
+    {0x80000000, 0x80000000, 0x7fffffffffffffff, 0x3fffffffffffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0x800000017ffffffe},
+    {0x7fffffff, 0xffffffff, 0x8000000000000000, 0x000000017fffffff},
+    {0x7fffffff, 0xffffffff, 0x0000000000000000, 0x0000000000000000},
+    {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x0000ffff, 0xffffffffffffffff, 0xffffffffffff0000},
+    {0x00000001, 0xffffffff, 0x0000000000000000, 0x0000000000000000},
+};
+
+/* muls.s32.s */
+struct ternary64_calculation samples_muls_s32_s[] = {
+    {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000000},
+    {0x00000001, 0x00000001, 0xffffffffffffffff, 0xfffffffffffffffe},
+    {0x00000001, 0x00000001, 0x8000000000000000, 0x8000000000000000},
+    {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x7ffffffffffffffe},
+    {0x00000001, 0xffffffff, 0xffffffffffffffff, 0x0000000000000000},
+    {0x00000001, 0xffffffff, 0x8000000000000000, 0x8000000000000001},
+    {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0x80000000, 0x80000000, 0xffffffffffffffff, 0xbfffffffffffffff},
+    {0x80000000, 0x80000000, 0x8000000000000000, 0x8000000000000000},
+    {0x80000000, 0x80000000, 0x7fffffffffffffff, 0x3fffffffffffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0x000000007ffffffe},
+    {0x7fffffff, 0xffffffff, 0x8000000000000000, 0x800000007fffffff},
+    {0x7fffffff, 0xffffffff, 0x0000000000000000, 0x000000007fffffff},
+    {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x0000ffff, 0xffffffffffffffff, 0xffffffffffff0000},
+};
+
+/* rmul.s32.h */
+struct binary_calculation samples_rmul_s32_h[] = {
+    {0x7fffffff, 0x7fffffff, 0x7ffffffe},
+    {0x80000000, 0x80000000, 0x7fffffff},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x80000000, 0x80000001},
+    {0x80000000, 0x7fffffff, 0x80000001},
+    {0x7fffffff, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x7fffffff, 0xffffffff},
+    {0x7fffffff, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fffffff, 0x00000000},
+    {0x80000000, 0xffffffff, 0x00000001},
+    {0xffffffff, 0x80000000, 0x00000001},
+    {0x00000000, 0x80000000, 0x00000000},
+    {0x80000000, 0x00000000, 0x00000000},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0x00000000, 0xffffffff, 0x00000000},
+    {0x80000000, 0x00000001, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x80000000, 0x80000001, 0x7fffffff},
+};
+
+/* rmul.s32.rh */
+struct binary_calculation samples_rmul_s32_rh[] = {
+    {0x7fffffff, 0x7fffffff, 0x7ffffffe},
+    {0x80000000, 0x80000000, 0x7fffffff},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x80000000, 0x80000001},
+    {0x80000000, 0x7fffffff, 0x80000001},
+    {0x7fffffff, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x7fffffff, 0xffffffff},
+    {0x7fffffff, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fffffff, 0x00000000},
+    {0x80000000, 0xffffffff, 0x00000001},
+    {0xffffffff, 0x80000000, 0x00000001},
+    {0x00000000, 0x80000000, 0x00000000},
+    {0x80000000, 0x00000000, 0x00000000},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0x7fff8000, 0x80008000, 0x80010000},
+    {0x80000000, 0x00000001, 0xffffffff},
+    {0x07ffffff, 0x0fffffff, 0x01000000},
+};
+
+/* mula.s32.hs */
+struct ternary_calculation samples_mula_s32_hs[] = {
+    {0x00000001, 0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x00000001, 0xffffffff, 0xffffffff},
+    {0x00000001, 0x00000001, 0x80000000, 0x80000000},
+    {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+    {0x00000001, 0xffffffff, 0xffffffff, 0xfffffffe},
+    {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+    {0x00000001, 0xffffffff, 0x7fffffff, 0x7ffffffe},
+    {0x80000000, 0x80000000, 0xffffffff, 0x3fffffff},
+    {0x80000000, 0x80000000, 0x80000000, 0xc0000000},
+    {0x80000000, 0x80000000, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffff, 0xfffffffe},
+    {0x7fffffff, 0xffffffff, 0x80000000, 0x80000000},
+    {0x7fffffff, 0xffffffff, 0x7fffffff, 0x7ffffffe},
+    {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x7fffffff, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0x7fffffff, 0x00000001, 0x40000000},
+    {0x07ffffff, 0x0fffffff, 0xc0000000, 0xc07fffff},
+    {0x80000000, 0x7fffffff, 0x7fffffff, 0x3fffffff},
+};
+
+/* muls.s32.hs */
+struct ternary_calculation samples_muls_s32_hs[] = {
+    {0x00000001, 0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x00000001, 0xffffffff, 0xffffffff},
+    {0x00000001, 0x00000001, 0x80000000, 0x80000000},
+    {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+    {0x00000001, 0xffffffff, 0xffffffff, 0x00000000},
+    {0x00000001, 0xffffffff, 0x80000000, 0x80000001},
+    {0x00000001, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0x80000000, 0x80000000, 0xffffffff, 0xbfffffff},
+    {0x80000000, 0x80000000, 0x80000000, 0x80000000},
+    {0x80000000, 0x80000000, 0x7fffffff, 0x3fffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffff, 0x00000000},
+    {0x7fffffff, 0xffffffff, 0x80000000, 0x80000001},
+    {0x7fffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x7fffffff, 0x80000000, 0x80000000},
+    {0x7fffffff, 0x7fffffff, 0x7fffffff, 0x40000000},
+};
+
+/* mula.s32.rhs */
+struct ternary_calculation samples_mula_s32_rhs[] = {
+    {0x00000001, 0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x00000001, 0xffffffff, 0xffffffff},
+    {0x00000001, 0x00000001, 0x80000000, 0x80000000},
+    {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+    {0x00000001, 0xffffffff, 0xffffffff, 0xffffffff},
+    {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+    {0x00000001, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0x80000000, 0x80000000, 0xffffffff, 0x3fffffff},
+    {0x80000000, 0x80000000, 0x80000000, 0xc0000000},
+    {0x80000000, 0x80000000, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff},
+    {0x7fffffff, 0xffffffff, 0x80000000, 0x80000000},
+    {0x7fffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x7fffffff, 0x7fffffff, 0x7fffffff},
+    {0x80000000, 0x00000002, 0x80000000, 0x80000000},
+};
+
+/* muls.s32.rhs */
+struct ternary_calculation samples_muls_s32_rhs[] = {
+    {0x00000001, 0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x00000001, 0xffffffff, 0xffffffff},
+    {0x00000001, 0x00000001, 0x80000000, 0x80000000},
+    {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+    {0x00000001, 0xffffffff, 0xffffffff, 0xffffffff},
+    {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+    {0x00000001, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0x80000000, 0x80000000, 0xffffffff, 0xbfffffff},
+    {0x80000000, 0x80000000, 0x80000000, 0x80000000},
+    {0x80000000, 0x80000000, 0x7fffffff, 0x3fffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff},
+    {0x7fffffff, 0xffffffff, 0x80000000, 0x80000000},
+    {0x7fffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x00000000, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x80000000, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0x00000002, 0x80000000, 0x80000000},
+};
+
+/* mulxl.s32 */
+struct binary_calculation samples_mulxl_s32[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000000},
+    {0x00000001, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x00010001, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0xffffffff},
+    {0x80000000, 0x80008000, 0x40000000},
+    {0x80000000, 0x7fff7fff, 0xc0008000},
+    {0x80000000, 0xffffffff, 0x00008000},
+    {0x7fffffff, 0x00010001, 0x00007fff},
+    {0x7fffffff, 0xffffffff, 0xffff8000},
+    {0x7fffffff, 0x7fff7fff, 0x3fff7fff},
+    {0x7fffffff, 0x80008000, 0xc0000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x7fffffff, 0xffff7fff, 0x3fff7fff},
+    {0x7fffffff, 0x7fffffff, 0xffff8000},
+    {0x7fffffff, 0x7fff8000, 0xc0000000},
+};
+
+/* mulxl.s32.r */
+struct binary_calculation samples_mulxl_s32_r[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000000},
+    {0x00000001, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x00010001, 0x00000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0x00000000},
+    {0x80000000, 0x7fff7fff, 0xc0008000},
+    {0x80000000, 0xffffffff, 0x00008000},
+    {0x7fffffff, 0x00010001, 0x00008000},
+    {0x7fffffff, 0xffffffff, 0xffff8000},
+    {0x7fffffff, 0x7fff7fff, 0x3fff8000},
+    {0x7fffffff, 0x80008000, 0xc0000001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x7fffffff, 0x0000ffff, 0xffff8000},
+    {0x7fffffff, 0x00007fff, 0x3fff8000},
+    {0x80000000, 0x0000ffff, 0x00008000},
+    {0x80008000, 0x0000ffff, 0x00008000},
+};
+
+/* mulxh.s32 */
+struct binary_calculation samples_mulxh_s32[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000000},
+    {0x00000001, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x00010001, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0xffffffff},
+    {0x80000000, 0x80008000, 0x40000000},
+    {0x80000000, 0x7fff7fff, 0xc0008000},
+    {0x80000000, 0xffffffff, 0x00008000},
+    {0x7fffffff, 0x00010001, 0x00007fff},
+    {0x7fffffff, 0xffffffff, 0xffff8000},
+    {0x7fffffff, 0x7fff7fff, 0x3fff7fff},
+    {0x7fffffff, 0x80008000, 0xc0000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x7fffffff, 0x00007fff, 0x00000000},
+    {0x7fffffff, 0x7fff0000, 0x3fff7fff},
+    {0x7fffffff, 0x80000001, 0xc0000000},
+};
+
+/* mulxh.s32.r */
+struct binary_calculation samples_mulxh_s32_r[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000000},
+    {0x00000001, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x00010001, 0x00000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0x00000000},
+    {0x80000000, 0x80008000, 0x40000000},
+    {0x80000000, 0x7fff7fff, 0xc0008000},
+    {0x80000000, 0xffffffff, 0x00008000},
+    {0x7fffffff, 0x00010001, 0x00008000},
+    {0x7fffffff, 0xffffffff, 0xffff8000},
+    {0x7fffffff, 0x7fff7fff, 0x3fff8000},
+    {0x7fffffff, 0x80008000, 0xc0000001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x7fffffff, 0x7fff0000, 0x3fff8000},
+    {0x7fffffff, 0x80007fff, 0xc0000001},
+    {0x80000000, 0x7fff8000, 0xc0008000},
+};
+
+/* rmulxl.s32 */
+struct binary_calculation samples_rmulxl_s32[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000000},
+    {0x00000001, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x00010001, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0xffffffff},
+    {0x80000000, 0x80008000, 0x7fffffff},
+    {0x80000000, 0x7fff7fff, 0x80010000},
+    {0x80000000, 0xffffffff, 0x00010000},
+    {0x7fffffff, 0x00010001, 0x0000ffff},
+    {0x7fffffff, 0xffffffff, 0xffff0000},
+    {0x7fffffff, 0x7fff7fff, 0x7ffeffff},
+    {0x7fffffff, 0x80008000, 0x80000001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x80000000, 0x7fff8000, 0x7fffffff},
+    {0x7fffffff, 0xffff7fff, 0x7ffeffff},
+    {0x7fffffff, 0x7fffffff, 0xffff0000},
+    {0x80000000, 0x7fffffff, 0x00010000},
+};
+
+/* rmulxl.s32.r */
+struct binary_calculation samples_rmulxl_s32_r[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000001},
+    {0x00000001, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x00010001, 0x00000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0xffffffff},
+    {0x80000000, 0x80008000, 0x7fffffff},
+    {0x80000000, 0x7fff7fff, 0x80010000},
+    {0x80000000, 0xffffffff, 0x00010000},
+    {0x7fffffff, 0x00010001, 0x00010000},
+    {0x7fffffff, 0xffffffff, 0xffff0000},
+    {0x7fffffff, 0x7fff7fff, 0x7ffeffff},
+    {0x7fffffff, 0x80008000, 0x80000001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x7fffffff, 0xffff7fff, 0x7ffeffff},
+    {0x7fffffff, 0x7fffffff, 0xffff0000},
+    {0x0000ffff, 0x0000ffff, 0xfffffffe},
+    {0x80000000, 0x7fff8000, 0x7fffffff},
+    {0x80000000, 0x80007fff, 0x80010000},
+};
+
+/* rmulxh.s32 */
+struct binary_calculation samples_rmulxh_s32[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000000},
+    {0x00000001, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x00010001, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0xffffffff},
+    {0x80000000, 0x80008000, 0x7fffffff},
+    {0x80000000, 0x7fff7fff, 0x80010000},
+    {0x80000000, 0xffffffff, 0x00010000},
+    {0x7fffffff, 0x00010001, 0x0000ffff},
+    {0x7fffffff, 0xffffffff, 0xffff0000},
+    {0x7fffffff, 0x7fff7fff, 0x7ffeffff},
+    {0x7fffffff, 0x80008000, 0x80000001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x80000000, 0x8000ffff, 0x7fffffff},
+    {0x7fffffff, 0x00007fff, 0x00000000},
+    {0x7fffffff, 0x7fff0000, 0x7ffeffff},
+    {0x7fffffff, 0x80000001, 0x80000001},
+};
+
+/* rmulxh.s32.r */
+struct binary_calculation samples_rmulxh_s32_r[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000001},
+    {0x00000001, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x00010001, 0x00000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0xffffffff},
+    {0x80000000, 0x80008000, 0x7fffffff},
+    {0x80000000, 0x7fff7fff, 0x80010000},
+    {0x80000000, 0xffffffff, 0x00010000},
+    {0x7fffffff, 0x00010001, 0x00010000},
+    {0x7fffffff, 0xffffffff, 0xffff0000},
+    {0x7fffffff, 0x7fff7fff, 0x7ffeffff},
+    {0x7fffffff, 0x80008000, 0x80000001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x7fffffff, 0x7fffffff, 0x7ffeffff},
+    {0x7fffffff, 0xffff7fff, 0xffff0000},
+    {0x80000000, 0x8000ffff, 0x7fffffff},
+    {0x80000001, 0x8001ffff, 0x7ffeffff},
+};
+
+/* mulaxl.s32.s */
+struct ternary_calculation samples_mulaxl_s32_s[] = {
+    {0x00000001, 0x00010001, 0x00000001, 0x00000001},
+    {0x00000001, 0x7fff7fff, 0x7fffffff, 0x7fffffff},
+    {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+    {0xffffffff, 0x00010001, 0xffffffff, 0xfffffffe},
+    {0xffffffff, 0xffffffff, 0x40000000, 0x40000000},
+    {0xffffffff, 0x7fff7fff, 0x00000000, 0xffffffff},
+    {0x80000000, 0x80008000, 0x00008000, 0x40008000},
+    {0x80000000, 0x7fff7fff, 0x7fffffff, 0x40007fff},
+    {0x80000000, 0xffffffff, 0x80000000, 0x80008000},
+    {0x7fffffff, 0x00010001, 0xffffffff, 0x00007ffe},
+    {0x7fffffff, 0xffffffff, 0x00000001, 0xffff8001},
+    {0x7fffffff, 0x7fff7fff, 0x80000000, 0xbfff7fff},
+    {0x7fffffff, 0x80008000, 0x7fffffff, 0x3fffffff},
+    {0x00000000, 0x00000000, 0x00008000, 0x00008000},
+    {0x00000000, 0x7fff7fff, 0x00000000, 0x00000000},
+    {0x7fffffff, 0xffff0001, 0x7fffffff, 0x7fffffff},
+    {0x00000001, 0x7fffffff, 0x80000000, 0x80000000},
+};
+
+/* mulaxl.s32.rs */
+struct ternary_calculation samples_mulaxl_s32_rs[] = {
+    {0x00000001, 0x00010001, 0x00000001, 0x00000001},
+    {0x00000001, 0x7fff7fff, 0x7fffffff, 0x7fffffff},
+    {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+    {0xffffffff, 0x00010001, 0xffffffff, 0x0000ffff},
+    {0xffffffff, 0xffffffff, 0x40000000, 0x3fff0000},
+    {0xffffffff, 0x7fff7fff, 0x00000000, 0x7fff0000},
+    {0x80000000, 0x80008000, 0x00008000, 0xc0008000},
+    {0x80000000, 0x7fff7fff, 0x7fffffff, 0x7fffffff},
+    {0x80000000, 0xffffffff, 0x80000000, 0x80000000},
+    {0x7fffffff, 0x00010001, 0xffffffff, 0x00007fff},
+    {0x7fffffff, 0xffffffff, 0x00000001, 0xffff8001},
+    {0x7fffffff, 0x7fff7fff, 0x80000000, 0xbfff8000},
+    {0x7fffffff, 0x80008000, 0x7fffffff, 0x40000000},
+    {0x00000000, 0x00000000, 0x00008000, 0x00008000},
+    {0x00000000, 0x7fff7fff, 0x00000000, 0x00000000},
+    {0x7fffffff, 0xffff7fff, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0xffffffff, 0x80000000, 0x80000000},
+    {0x7fffffff, 0x00000001, 0x80000000, 0x80008000},
+};
+
+/* mulaxh.s32.s */
+struct ternary_calculation samples_mulaxh_s32_s[] = {
+    {0x00000001, 0x00010001, 0x00000001, 0x00000001},
+    {0x00000001, 0x7fff7fff, 0x7fffffff, 0x7fffffff},
+    {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+    {0xffffffff, 0x00010001, 0xffffffff, 0xfffffffe},
+    {0xffffffff, 0xffffffff, 0x40000000, 0x40000000},
+    {0xffffffff, 0x7fff7fff, 0x00000000, 0xffffffff},
+    {0x80000000, 0x80008000, 0x00008000, 0x40008000},
+    {0x80000000, 0x7fff7fff, 0x7fffffff, 0x40007fff},
+    {0x80000000, 0xffffffff, 0x80000000, 0x80008000},
+    {0x7fffffff, 0x00010001, 0xffffffff, 0x00007ffe},
+    {0x7fffffff, 0xffffffff, 0x00000001, 0xffff8001},
+    {0x7fffffff, 0x7fff7fff, 0x80000000, 0xbfff7fff},
+    {0x7fffffff, 0x80008000, 0x7fffffff, 0x3fffffff},
+    {0x00000000, 0x00000000, 0x00008000, 0x00008000},
+    {0x00000000, 0x7fff7fff, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x0001ffff, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0xffff7fff, 0x80000000, 0x80000000},
+    {0x7fffffff, 0x7fffffff, 0x00000000, 0x3fff7fff},
+};
+
+/* mulaxh.s32.rs */
+struct ternary_calculation samples_mulaxh_s32_rs[] = {
+    {0x00000001, 0x00010001, 0x00000001, 0x00000001},
+    {0x00000001, 0x7fff7fff, 0x7fffffff, 0x7fffffff},
+    {0x00000001, 0xffffffff, 0x80000000, 0x80000000},
+    {0xffffffff, 0x00010001, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x40000000, 0x40000000},
+    {0xffffffff, 0x7fff7fff, 0x00000000, 0x00000000},
+    {0x80000000, 0x80008000, 0x00008000, 0x40008000},
+    {0x80000000, 0x7fff7fff, 0x7fffffff, 0x40007fff},
+    {0x80000000, 0xffffffff, 0x80000000, 0x80008000},
+    {0x7fffffff, 0x00010001, 0xffffffff, 0x00007fff},
+    {0x7fffffff, 0xffffffff, 0x00000001, 0xffff8001},
+    {0x7fffffff, 0x7fff7fff, 0x80000000, 0xbfff8000},
+    {0x7fffffff, 0x80008000, 0x7fffffff, 0x40000000},
+    {0x00000000, 0x00000000, 0x00008000, 0x00008000},
+    {0x00000000, 0x7fff7fff, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x7fff0000, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0xffff0000, 0x80000000, 0x80000000},
+    {0x7fffffff, 0x7fffffff, 0x00000000, 0x3fff8000},
+};
+
+/* rmulll.s16 */
+struct binary_calculation samples_rmulll_s16[] = {
+    {0x00000001, 0x00000001, 0x00000002},
+    {0x00000001, 0x7fff7fff, 0x0000fffe},
+    {0x00000001, 0xffffffff, 0xfffffffe},
+    {0xffffffff, 0xffffffff, 0x00000002},
+    {0x00008000, 0x80008000, 0x7fffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fffffff, 0x00000000},
+    {0x80000000, 0x00008000, 0x00000000},
+    {0x00008000, 0x00008000, 0x7fffffff},
+    {0x80007fff, 0xffff7fff, 0x7ffe0002},
+    {0x80007fff, 0x7fffffff, 0xffff0002},
+    {0x80007fff, 0x7fff8000, 0x80010000},
+};
+
+/* rmulhh.s16 */
+struct binary_calculation samples_rmulhh_s16[] = {
+    {0x00010000, 0x00010000, 0x00000002},
+    {0x00010000, 0x7fff7fff, 0x0000fffe},
+    {0x00010000, 0xffffffff, 0xfffffffe},
+    {0xffffffff, 0xffffffff, 0x00000002},
+    {0x80000000, 0x80008000, 0x7fffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0xffff7fff, 0x00000000},
+    {0x00008000, 0x80000000, 0x00000000},
+    {0x80000000, 0x8000ffff, 0x7fffffff},
+    {0x7fffffff, 0xffff7fff, 0xffff0002},
+    {0x7fffffff, 0x0000ffff, 0x00000000},
+    {0x8000ffff, 0x7fffffff, 0x80010000},
+};
+
+/* rmulhl.s16 */
+struct binary_calculation samples_rmulhl_s16[] = {
+    {0x00010000, 0x00000001, 0x00000002},
+    {0x00010000, 0x7fff7fff, 0x0000fffe},
+    {0x00010000, 0xffffffff, 0xfffffffe},
+    {0xffffffff, 0xffffffff, 0x00000002},
+    {0x80000000, 0x80008000, 0x7fffffff},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fffffff, 0x00000000},
+    {0x00008000, 0x00008000, 0x00000000},
+    {0x8000ffff, 0xffff8000, 0x7fffffff},
+    {0x7fffffff, 0x7fffffff, 0xffff0002},
+    {0x0001ffff, 0x7fffffff, 0xfffffffe},
+    {0x8000ffff, 0x80007fff, 0x80010000},
+
+};
+
+/* mulall.s16.s */
+struct ternary_calculation samples_mulall_s16_s[] = {
+    {0x00008000, 0x0001ffff, 0x7fffffff, 0x7fffffff},
+    {0x00017fff, 0x00007fff, 0x80000000, 0xbfff0001},
+    {0x00017fff, 0x00007fff, 0xffffffff, 0x3fff0000},
+    {0x00017fff, 0x00007fff, 0x7fffffff, 0x7fffffff},
+    {0xffff8000, 0x00008000, 0x80000000, 0xc0000000},
+    {0x80008000, 0x7fff8000, 0xffffffff, 0x3fffffff},
+    {0xffff8000, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0x0000ffff, 0x80000000, 0x80000001},
+    {0x8000ffff, 0x7fffffff, 0xffffffff, 0x00000000},
+    {0x8000ffff, 0x8000ffff, 0x7fffffff, 0x7fffffff},
+    {0x00007fff, 0x00008000, 0x80000000, 0x80000000},
+    {0x7fff8000, 0x7fff7fff, 0xffffffff, 0xc0007fff},
+    {0x80008000, 0x80007fff, 0x7fffffff, 0x40007fff},
+    {0x0000ffff, 0x00018000, 0x80000000, 0x80008000},
+    {0x00008000, 0x0001ffff, 0xffffffff, 0x00007fff},
+    {0x00000000, 0xffffffff, 0x00000000, 0x00000000},
+    {0x7fff0000, 0x8000ffff, 0xffffffff, 0xffffffff},
+    {0x8000ffff, 0xffff0000, 0x00000000, 0x00000000},
+    {0x0000ffff, 0xffff0000, 0xffffffff, 0xffffffff},
+    {0x7fff0000, 0x80000000, 0x00000000, 0x00000000},
+    {0x80000000, 0x80000000, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x00000001, 0x80000000, 0x80000000},
+    {0x00000001, 0x00000001, 0x7fffffff, 0x7fffffff},
+};
+
+/* mulahh.s16.s */
+struct ternary_calculation samples_mulahh_s16_s[] = {
+    {0x80000000, 0xffff0001, 0x7fffffff, 0x7fffffff},
+    {0x7fff0001, 0x7fff0000, 0x80000000, 0xbfff0001},
+    {0x7fff0001, 0x7fff0000, 0xffffffff, 0x3fff0000},
+    {0x7fff0001, 0x7fff0000, 0x7fffffff, 0x7fffffff},
+    {0x8000ffff, 0x80000000, 0x80000000, 0xc0000000},
+    {0x80008000, 0x80007fff, 0xffffffff, 0x3fffffff},
+    {0x8000ffff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0xffff0000, 0x80000000, 0x80000001},
+    {0xffff8000, 0xffff7fff, 0xffffffff, 0x00000000},
+    {0xffff8000, 0xffff8000, 0x7fffffff, 0x7fffffff},
+    {0x7fff0000, 0x80000000, 0x80000000, 0x80000000},
+    {0x80007fff, 0x7fff7fff, 0xffffffff, 0xc0007fff},
+    {0x80008000, 0x7fff8000, 0x7fffffff, 0x40007fff},
+    {0xffff0000, 0x80000001, 0x80000000, 0x80008000},
+    {0x80000000, 0xffff0001, 0xffffffff, 0x00007fff},
+    {0x00000000, 0xffffffff, 0x00000000, 0x00000000},
+    {0x00007fff, 0xffff8000, 0xffffffff, 0xffffffff},
+    {0xffff8000, 0x0000ffff, 0x00000000, 0x00000000},
+    {0xffff0000, 0x0000ffff, 0xffffffff, 0xffffffff},
+    {0x00007fff, 0x00008000, 0x00000000, 0x00000000},
+    {0x00008000, 0x00008000, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x0001ffff, 0x80000000, 0x80000000},
+    {0x0001ffff, 0xffffffff, 0x7fffffff, 0x7ffffffe},
+};
+
+/* mulahl.s16.s */
+struct ternary_calculation samples_mulahl_s16_s[] = {
+    {0x80000000, 0x0001ffff, 0x7fffffff, 0x7fffffff},
+    {0x7fff0001, 0x00007fff, 0x80000000, 0xbfff0001},
+    {0x7fff0001, 0x00007fff, 0xffffffff, 0x3fff0000},
+    {0x7fff0001, 0x00007fff, 0x7fffffff, 0x7fffffff},
+    {0x8000ffff, 0x00008000, 0x80000000, 0xc0000000},
+    {0x80008000, 0x7fff8000, 0xffffffff, 0x3fffffff},
+    {0x8000ffff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0x0000ffff, 0x80000000, 0x80000001},
+    {0xffff8000, 0x7fffffff, 0xffffffff, 0x00000000},
+    {0xffff8000, 0x8000ffff, 0x7fffffff, 0x7fffffff},
+    {0x7fff0000, 0x00008000, 0x80000000, 0x80000000},
+    {0x80007fff, 0x7fff7fff, 0xffffffff, 0xc0007fff},
+    {0x80008000, 0x80007fff, 0x7fffffff, 0x40007fff},
+    {0xffff0000, 0x00018000, 0x80000000, 0x80008000},
+    {0x80000000, 0x0001ffff, 0xffffffff, 0x00007fff},
+    {0x00000000, 0xffffffff, 0x00000000, 0x00000000},
+    {0x00007fff, 0x8000ffff, 0xffffffff, 0xffffffff},
+    {0xffff8000, 0xffff0000, 0x00000000, 0x00000000},
+    {0xffff0000, 0xffff0000, 0xffffffff, 0xffffffff},
+    {0x00007fff, 0x80000000, 0x00000000, 0x00000000},
+    {0x00008000, 0x80000000, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffff0001, 0x80000000, 0x80000000},
+    {0x0001ffff, 0xffff0001, 0x7fffffff, 0x7fffffff},
+    {0x0001ffff, 0x7fffffff, 0x7fffffff, 0x7ffffffe},
+};
+
+/* mulall.s16.e */
+struct ternary64_calculation samples_mulall_s16_e[] = {
+    {0x00017fff, 0x00007fff, 0x8000000000000000, 0x800000003fff0001},
+    {0x00017fff, 0x00007fff, 0xffffffffffffffff, 0x000000003fff0000},
+    {0x00017fff, 0x00007fff, 0x7fffffffffffffff, 0x800000003fff0000},
+    {0xffff8000, 0x00008000, 0x8000000000000000, 0x8000000040000000},
+    {0x80008000, 0x7fff8000, 0xffffffffffffffff, 0x000000003fffffff},
+    {0xffff8000, 0x80008000, 0x7fffffffffffffff, 0x800000003fffffff},
+    {0xffff7fff, 0x00008000, 0x8000000000000000, 0x7fffffffc0008000},
+    {0x80007fff, 0x7fff8000, 0xffffffffffffffff, 0xffffffffc0007fff},
+    {0x80007fff, 0x80008000, 0x7fffffffffffffff, 0x7fffffffc0007fff},
+    {0x0000ffff, 0x0000ffff, 0x8000000000000000, 0x8000000000000001},
+    {0x7fffffff, 0x7fffffff, 0xffffffffffffffff, 0x0000000000000000},
+    {0x8000ffff, 0x8000ffff, 0x7fffffffffffffff, 0x8000000000000000},
+    {0x0000ffff, 0x00018000, 0x8000000000000000, 0x8000000000008000},
+    {0x00008000, 0x0001ffff, 0xffffffffffffffff, 0x0000000000007fff},
+    {0x00008000, 0x0001ffff, 0x7fffffffffffffff, 0x8000000000007fff},
+    {0x00000000, 0xffffffff, 0x0000000000000000, 0x0000000000000000},
+    {0x7fff0000, 0x8000ffff, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x8000ffff, 0xffff0000, 0x0000000000000000, 0x0000000000000000},
+    {0x0000ffff, 0xffff0000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x7fff0000, 0x80000000, 0x0000000000000000, 0x0000000000000000},
+    {0x80000000, 0x80000000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x00007fff, 0x00007fff, 0x8000000000000000, 0x800000003fff0001},
+    {0x00007fff, 0x00007fff, 0x7fffffffffffffff, 0x800000003fff0000},
+    {0x00008000, 0x00008000, 0xffffffffffffffff, 0x000000003fffffff},
+    {0x00007fff, 0x00008000, 0xffffffffffffffff, 0xffffffffc0007fff},
+};
+
+/* mulahl.s16.e */
+struct ternary64_calculation samples_mulahl_s16_e[] = {
+    {0x7fff0001, 0x00007fff, 0x8000000000000000, 0x800000003fff0001},
+    {0x7fff0001, 0x00007fff, 0xffffffffffffffff, 0x000000003fff0000},
+    {0x7fff0001, 0x00007fff, 0x7fffffffffffffff, 0x800000003fff0000},
+    {0x8000ffff, 0x00008000, 0x8000000000000000, 0x8000000040000000},
+    {0x80008000, 0x7fff8000, 0xffffffffffffffff, 0x000000003fffffff},
+    {0x8000ffff, 0x80008000, 0x7fffffffffffffff, 0x800000003fffffff},
+    {0x7fffffff, 0x00008000, 0x8000000000000000, 0x7fffffffc0008000},
+    {0x7fff8000, 0x7fff8000, 0xffffffffffffffff, 0xffffffffc0007fff},
+    {0x7fff8000, 0x80008000, 0x7fffffffffffffff, 0x7fffffffc0007fff},
+    {0xffff0000, 0x0000ffff, 0x8000000000000000, 0x8000000000000001},
+    {0xffff7fff, 0x7fffffff, 0xffffffffffffffff, 0x0000000000000000},
+    {0xffff8000, 0x8000ffff, 0x7fffffffffffffff, 0x8000000000000000},
+    {0xffff0000, 0x00018000, 0x8000000000000000, 0x8000000000008000},
+    {0x80000000, 0x0001ffff, 0xffffffffffffffff, 0x0000000000007fff},
+    {0x80000000, 0x0001ffff, 0x7fffffffffffffff, 0x8000000000007fff},
+    {0x00000000, 0xffffffff, 0x0000000000000000, 0x0000000000000000},
+    {0x00007fff, 0x8000ffff, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0xffff8000, 0xffff0000, 0x0000000000000000, 0x0000000000000000},
+    {0xffff0000, 0xffff0000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x00007fff, 0x80000000, 0x0000000000000000, 0x0000000000000000},
+    {0x00008000, 0x80000000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x7fffffff, 0x00007fff, 0x8000000000000000, 0x800000003fff0001},
+    {0x7fffffff, 0xffff7fff, 0x7fffffffffffffff, 0x800000003fff0000},
+    {0x8000ffff, 0x7fff8000, 0xffffffffffffffff, 0x000000003fffffff},
+};
+
+/* mulahh.s16.e */
+struct ternary64_calculation samples_mulahh_s16_e[] = {
+    {0x7fff0001, 0x7fff0000, 0x8000000000000000, 0x800000003fff0001},
+    {0x7fff0001, 0x7fff0000, 0xffffffffffffffff, 0x000000003fff0000},
+    {0x7fff0001, 0x7fff0000, 0x7fffffffffffffff, 0x800000003fff0000},
+    {0x8000ffff, 0x80000000, 0x8000000000000000, 0x8000000040000000},
+    {0x80008000, 0x80007fff, 0xffffffffffffffff, 0x000000003fffffff},
+    {0x8000ffff, 0x80008000, 0x7fffffffffffffff, 0x800000003fffffff},
+    {0x7fffffff, 0x80000000, 0x8000000000000000, 0x7fffffffc0008000},
+    {0x7fff8000, 0x80007fff, 0xffffffffffffffff, 0xffffffffc0007fff},
+    {0x7fff8000, 0x80008000, 0x7fffffffffffffff, 0x7fffffffc0007fff},
+    {0xffff0000, 0xffff0000, 0x8000000000000000, 0x8000000000000001},
+    {0xffff7fff, 0xffff7fff, 0xffffffffffffffff, 0x0000000000000000},
+    {0xffff8000, 0xffff8000, 0x7fffffffffffffff, 0x8000000000000000},
+    {0xffff0000, 0x80000001, 0x8000000000000000, 0x8000000000008000},
+    {0x80000000, 0xffff0001, 0xffffffffffffffff, 0x0000000000007fff},
+    {0x80000000, 0xffff0001, 0x7fffffffffffffff, 0x8000000000007fff},
+    {0x00000000, 0xffffffff, 0x0000000000000000, 0x0000000000000000},
+    {0x00007fff, 0xffff8000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0xffff8000, 0x0000ffff, 0x0000000000000000, 0x0000000000000000},
+    {0xffff0000, 0x0000ffff, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x00007fff, 0x00008000, 0x0000000000000000, 0x0000000000000000},
+    {0x00008000, 0x00008000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x7fffffff, 0x7fff0000, 0x7fffffffffffffff, 0x800000003fff0000},
+    {0x8000ffff, 0x80007fff, 0xffffffffffffffff, 0x000000003fffffff},
+};
+
+/* pmul.s16 */
+struct binary64_calculation samples_pmul_s16[] = {
+    {0x00000001, 0x00010001, 0x0000000000000001},
+    {0x00000001, 0x7fff7fff, 0x0000000000007fff},
+    {0x00000001, 0xffffffff, 0x00000000ffffffff},
+    {0xffffffff, 0x00010001, 0xffffffffffffffff},
+    {0xffffffff, 0xffffffff, 0x0000000100000001},
+    {0xffffffff, 0x7fff7fff, 0xffff8001ffff8001},
+    {0x80000000, 0x80008000, 0x4000000000000000},
+    {0x80000000, 0x7fff7fff, 0xc000800000000000},
+    {0x80000000, 0xffffffff, 0x0000800000000000},
+    {0x7fffffff, 0x00010001, 0x00007fffffffffff},
+    {0x7fffffff, 0xffffffff, 0xffff800100000001},
+    {0x7fffffff, 0x7fff7fff, 0x3fff0001ffff8001},
+    {0x7fffffff, 0x80008000, 0xc000800000008000},
+    {0x00000000, 0x00000000, 0x0000000000000000},
+    {0x00000000, 0x7fff7fff, 0x0000000000000000},
+    {0x8000ffff, 0xffff7fff, 0x00008000ffff8001},
+    {0x7fff0000, 0x8000ffff, 0xc000800000000000},
+};
+
+/* pmul.u16 */
+struct binary64_calculation samples_pmul_u16[] = {
+    {0x00000001, 0x00010001, 0x0000000000000001},
+    {0x00000001, 0x7fff7fff, 0x0000000000007fff},
+    {0x00000001, 0xffffffff, 0x000000000000ffff},
+    {0xffffffff, 0x00010001, 0x0000ffff0000ffff},
+    {0xffffffff, 0xffffffff, 0xfffe0001fffe0001},
+    {0xffffffff, 0x7fff7fff, 0x7ffe80017ffe8001},
+    {0x80000000, 0x80008000, 0x4000000000000000},
+    {0x80000000, 0x7fff7fff, 0x3fff800000000000},
+    {0x80000000, 0xffffffff, 0x7fff800000000000},
+    {0x7fffffff, 0x00010001, 0x00007fff0000ffff},
+    {0x7fffffff, 0xffffffff, 0x7ffe8001fffe0001},
+    {0x7fffffff, 0x7fff7fff, 0x3fff00017ffe8001},
+    {0x7fffffff, 0x80008000, 0x3fff80007fff8000},
+    {0x00000000, 0x00000000, 0x0000000000000000},
+    {0x00000000, 0x7fff7fff, 0x0000000000000000},
+    {0x8000ffff, 0xffff7fff, 0x7fff80007ffe8001},
+    {0x7fff0000, 0x8000ffff, 0x3fff800000000000},
+    {0x80007fff, 0xffffffff, 0x7fff80007ffe8001},
+};
+
+/* pmulx.s16 */
+struct binary64_calculation samples_pmulx_s16[] = {
+    {0x00000001, 0x00010001, 0x0000000000000001},
+    {0x00000001, 0x7fff7fff, 0x0000000000007fff},
+    {0x00000001, 0xffffffff, 0x00000000ffffffff},
+    {0xffffffff, 0x00010001, 0xffffffffffffffff},
+    {0xffffffff, 0xffffffff, 0x0000000100000001},
+    {0xffffffff, 0x7fff7fff, 0xffff8001ffff8001},
+    {0x80000000, 0x80008000, 0x4000000000000000},
+    {0x80000000, 0x7fff7fff, 0xc000800000000000},
+    {0x80000000, 0xffffffff, 0x0000800000000000},
+    {0x7fffffff, 0x00010001, 0x00007fffffffffff},
+    {0x7fffffff, 0xffffffff, 0xffff800100000001},
+    {0x7fffffff, 0x7fff7fff, 0x3fff0001ffff8001},
+    {0x7fffffff, 0x80008000, 0xc000800000008000},
+    {0x00000000, 0x00000000, 0x0000000000000000},
+    {0x00000000, 0x7fff7fff, 0x0000000000000000},
+    {0x8000ffff, 0xffff7fff, 0xc000800000000001},
+    {0x7fff0000, 0xffff8000, 0xc000800000000000},
+    {0x80007fff, 0xffffffff, 0x00008000ffff8001},
+};
+
+/* pmulx.u16 */
+struct binary64_calculation samples_pmulx_u16[] = {
+    {0x00000001, 0x00010001, 0x0000000000000001},
+    {0x00000001, 0x7fff7fff, 0x0000000000007fff},
+    {0x00000001, 0xffffffff, 0x000000000000ffff},
+    {0xffffffff, 0x00010001, 0x0000ffff0000ffff},
+    {0xffffffff, 0xffffffff, 0xfffe0001fffe0001},
+    {0xffffffff, 0x7fff7fff, 0x7ffe80017ffe8001},
+    {0x80000000, 0x80008000, 0x4000000000000000},
+    {0x80000000, 0x7fff7fff, 0x3fff800000000000},
+    {0x80000000, 0xffffffff, 0x7fff800000000000},
+    {0x7fffffff, 0x00010001, 0x00007fff0000ffff},
+    {0x7fffffff, 0xffffffff, 0x7ffe8001fffe0001},
+    {0x7fffffff, 0x7fff7fff, 0x3fff00017ffe8001},
+    {0x7fffffff, 0x80008000, 0x3fff80007fff8000},
+    {0x00000000, 0x00000000, 0x0000000000000000},
+    {0x00000000, 0x7fff7fff, 0x0000000000000000},
+    {0x8000ffff, 0x7fffffff, 0x7fff80007ffe8001},
+    {0x7fff0000, 0xffff8000, 0x3fff800000000000},
+    {0x80007fff, 0xffffffff, 0x7fff80007ffe8001},
+};
+
+/* prmul.s16 */
+struct binary64_calculation samples_prmul_s16[] = {
+    {0x00000001, 0x00010001, 0x0000000000000002},
+    {0x00000001, 0x7fff7fff, 0x000000000000fffe},
+    {0x00000001, 0xffffffff, 0x00000000fffffffe},
+    {0xffffffff, 0x00010001, 0xfffffffefffffffe},
+    {0xffffffff, 0xffffffff, 0x0000000200000002},
+    {0xffffffff, 0x7fff7fff, 0xffff0002ffff0002},
+    {0x80000000, 0x80008000, 0x7fffffff00000000},
+    {0x80000000, 0x7fff7fff, 0x8001000000000000},
+    {0x80000000, 0xffffffff, 0x0001000000000000},
+    {0x7fffffff, 0x00010001, 0x0000fffefffffffe},
+    {0x7fffffff, 0xffffffff, 0xffff000200000002},
+    {0x7fffffff, 0x7fff7fff, 0x7ffe0002ffff0002},
+    {0x7fffffff, 0x80008000, 0x8001000000010000},
+    {0x00000000, 0x00000000, 0x0000000000000000},
+    {0x00000000, 0x7fff7fff, 0x0000000000000000},
+    {0x80008000, 0x80008000, 0x7fffffff7fffffff},
+    {0x8000ffff, 0x80007fff, 0x7fffffffffff0002},
+    {0x7fff8000, 0xffff8000, 0xffff00027fffffff},
+};
+
+/* prmulx.s16 */
+struct binary64_calculation samples_prmulx_s16[] = {
+    {0x00000001, 0x00010001, 0x0000000000000002},
+    {0x00000001, 0x7fff7fff, 0x000000000000fffe},
+    {0x00000001, 0xffffffff, 0x00000000fffffffe},
+    {0xffffffff, 0x00010001, 0xfffffffefffffffe},
+    {0xffffffff, 0xffffffff, 0x0000000200000002},
+    {0xffffffff, 0x7fff7fff, 0xffff0002ffff0002},
+    {0x80000000, 0x80008000, 0x7fffffff00000000},
+    {0x80000000, 0x7fff7fff, 0x8001000000000000},
+    {0x80000000, 0xffffffff, 0x0001000000000000},
+    {0x7fffffff, 0x00010001, 0x0000fffefffffffe},
+    {0x7fffffff, 0xffffffff, 0xffff000200000002},
+    {0x7fffffff, 0x7fff7fff, 0x7ffe0002ffff0002},
+    {0x7fffffff, 0x80008000, 0x8001000000010000},
+    {0x00000000, 0x00000000, 0x0000000000000000},
+    {0x00000000, 0x7fff7fff, 0x0000000000000000},
+    {0x80008000, 0x80008000, 0x7fffffff7fffffff},
+    {0x8000ffff, 0x7fff8000, 0x7fffffffffff0002},
+    {0x7fff8000, 0x8000ffff, 0xffff00027fffffff},
+};
+
+/* prmul.s16.h */
+struct binary_calculation samples_prmul_s16_h[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000000},
+    {0x00000001, 0xffffffff, 0x0000ffff},
+    {0xffffffff, 0x00010001, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0xffffffff},
+    {0x80000000, 0x80008000, 0x7fff0000},
+    {0x80000000, 0x7fff7fff, 0x80010000},
+    {0x80000000, 0xffffffff, 0x00010000},
+    {0x7fffffff, 0x00010001, 0x0000ffff},
+    {0x7fffffff, 0xffffffff, 0xffff0000},
+    {0x7fffffff, 0x7fff7fff, 0x7ffeffff},
+    {0x7fffffff, 0x80008000, 0x80010001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x80008000, 0x80008000, 0x7fff7fff},
+    {0x8000ffff, 0x80007fff, 0x7fffffff},
+    {0x7fff8000, 0xffff8000, 0xffff7fff},
+};
+
+/* prmul.s16.rh */
+struct binary_calculation samples_prmul_s16_rh[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000001},
+    {0x00000001, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x00010001, 0x00000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0xffffffff},
+    {0x80000000, 0x80008000, 0x7fff0000},
+    {0x80000000, 0x7fff7fff, 0x80010000},
+    {0x80000000, 0xffffffff, 0x00010000},
+    {0x7fffffff, 0x00010001, 0x00010000},
+    {0x7fffffff, 0xffffffff, 0xffff0000},
+    {0x7fffffff, 0x7fff7fff, 0x7ffeffff},
+    {0x7fffffff, 0x80008000, 0x80010001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x80008000, 0x80008000, 0x7fff7fff},
+    {0x8000ffff, 0x80007fff, 0x7fffffff},
+    {0x7fff8000, 0xffff8000, 0xffff7fff},
+    {0x3fff8000, 0xffff8000, 0x00007fff},
+};
+
+/* prmulx.s16.h */
+struct binary_calculation samples_prmulx_s16_h[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000000},
+    {0x00000001, 0xffffffff, 0x0000ffff},
+    {0xffffffff, 0x00010001, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0xffffffff},
+    {0x80000000, 0x80008000, 0x7fff0000},
+    {0x80000000, 0x7fff7fff, 0x80010000},
+    {0x80000000, 0xffffffff, 0x00010000},
+    {0x7fffffff, 0x00010001, 0x0000ffff},
+    {0x7fffffff, 0xffffffff, 0xffff0000},
+    {0x7fffffff, 0x7fff7fff, 0x7ffeffff},
+    {0x7fffffff, 0x80008000, 0x80010001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x80008000, 0x80008000, 0x7fff7fff},
+    {0x8000ffff, 0x7fff8000, 0x7fffffff},
+    {0x7fff8000, 0x8000ffff, 0xffff7fff},
+
+};
+
+/* prmulx.s16.rh */
+struct binary_calculation samples_prmulx_s16_rh[] = {
+    {0x00000001, 0x00010001, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0x00000001},
+    {0x00000001, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x00010001, 0x00000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fff7fff, 0xffffffff},
+    {0x80000000, 0x80008000, 0x7fff0000},
+    {0x80000000, 0x7fff7fff, 0x80010000},
+    {0x80000000, 0xffffffff, 0x00010000},
+    {0x7fffffff, 0x00010001, 0x00010000},
+    {0x7fffffff, 0xffffffff, 0xffff0000},
+    {0x7fffffff, 0x7fff7fff, 0x7ffeffff},
+    {0x7fffffff, 0x80008000, 0x80010001},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fff7fff, 0x00000000},
+    {0x80008000, 0x80008000, 0x7fff7fff},
+    {0x8000ffff, 0x7fff8000, 0x7fffffff},
+    {0x7fff8000, 0x8000ffff, 0xffff7fff},
+    {0x3fff8000, 0x8000ffff, 0x00007fff},
+};
+
+/* mulca.s16.s */
+struct binary_calculation samples_mulca_s16_s[] = {
+    {0x00010001, 0x00000001, 0x00000001},
+    {0x00010001, 0x00008000, 0xffff8000},
+    {0x00010001, 0x7fff7fff, 0x0000fffe},
+    {0x00010001, 0x0000ffff, 0xffffffff},
+    {0x00010002, 0x7fff8000, 0xffff7fff},
+    {0x00017fff, 0x8000ffff, 0xffff0001},
+    {0x0001ffff, 0x0000ffff, 0x00000001},
+    {0x0001ffff, 0x7fff8000, 0x0000ffff},
+    {0x00018000, 0x80008000, 0x3fff8000},
+    {0x00010000, 0x00000000, 0x00000000},
+    {0x00010000, 0x7fff7fff, 0x00007fff},
+    {0x00010000, 0x80008000, 0xffff8000},
+    {0x80008000, 0x80008000, 0x7fffffff},
+    {0x4000ffff, 0x00014000, 0x00000000},
+    {0x80007fff, 0x7fffffff, 0xc0000001},
+    {0x7fffffff, 0x8000ffff, 0xc0008001},
+};
+
+/* mulcax.s16.s */
+struct binary_calculation samples_mulcax_s16_s[] = {
+    {0x00010001, 0x00010000, 0x00000001},
+    {0x00010001, 0x80000000, 0xffff8000},
+    {0x00010001, 0x7fff7fff, 0x0000fffe},
+    {0x00010001, 0xffff0000, 0xffffffff},
+    {0x00010002, 0x80007fff, 0xffff7fff},
+    {0x00017fff, 0xffff8000, 0xffff0001},
+    {0x0001ffff, 0xffff0000, 0x00000001},
+    {0x0001ffff, 0x80007fff, 0x0000ffff},
+    {0x00018000, 0x80008000, 0x3fff8000},
+    {0x00010000, 0x00000000, 0x00000000},
+    {0x00010000, 0x7fff7fff, 0x00007fff},
+    {0x00010000, 0x80008000, 0xffff8000},
+    {0x80008000, 0x80008000, 0x7fffffff},
+    {0x4000ffff, 0x00014000, 0x0fffffff},
+    {0x4000ffff, 0x40000001, 0x00000000},
+    {0x80007fff, 0x7fffffff, 0x3fff8001},
+    {0x7fffffff, 0x8000ffff, 0x00000001},
+};
+
+/* mulcs.s16 */
+struct binary_calculation samples_mulcs_s16[] = {
+    {0x00010001, 0x00000001, 0x00000001},
+    {0x00010001, 0x7fff7fff, 0x00000000},
+    {0x00010010, 0x80007fff, 0x00087ff0},
+    {0x00010001, 0x0000ffff, 0xffffffff},
+    {0x00010002, 0x7fff8000, 0xfffe8001},
+    {0x00017fff, 0x8000ffff, 0x00000001},
+    {0x0001ffff, 0x0000ffff, 0x00000001},
+    {0x0001ffff, 0x7fff8000, 0x00000001},
+    {0x00018000, 0x80008000, 0x40008000},
+    {0x00010000, 0x00000000, 0x00000000},
+    {0x00010000, 0x7fff7fff, 0xffff8001},
+    {0x00010000, 0x80008000, 0x00008000},
+    {0x80008000, 0x80008000, 0x00000000},
+    {0x7fffffff, 0x00017fff, 0xffff0002},
+    {0x7fff0001, 0xffff7fff, 0x0000fffe},
+};
+
+/* mulcsr.s16 */
+struct binary_calculation samples_mulcsr_s16[] = {
+    {0x00010001, 0x00010000, 0x00000001},
+    {0x00010001, 0x7fff7fff, 0x00000000},
+    {0x00100001, 0x7fff8000, 0x00087ff0},
+    {0x00010001, 0xffff0000, 0xffffffff},
+    {0x00020001, 0x80007fff, 0xfffe8001},
+    {0x7fff0001, 0xffff8000, 0x00000001},
+    {0xffff0001, 0xffff0000, 0x00000001},
+    {0xffff0001, 0x80007fff, 0x00000001},
+    {0x80000001, 0x80008000, 0x40008000},
+    {0x00000001, 0x00000000, 0x00000000},
+    {0x00000001, 0x7fff7fff, 0xffff8001},
+    {0x00000001, 0x80008000, 0x00008000},
+    {0x80008000, 0x80008000, 0x00000000},
+    {0x7fffffff, 0x00017fff, 0x0000fffe},
+    {0x7fff0001, 0xffff7fff, 0xffff0002},
+};
+
+/* mulcsx.s16 */
+struct binary_calculation samples_mulcsx_s16[] = {
+    {0x00010001, 0x00010000, 0x00000001},
+    {0x00010001, 0x7fff7fff, 0x00000000},
+    {0x00010010, 0x7fff8000, 0x00087ff0},
+    {0x00010001, 0xffff0000, 0xffffffff},
+    {0x00010002, 0x80007fff, 0xfffe8001},
+    {0x00017fff, 0xffff8000, 0x00000001},
+    {0x0001ffff, 0xffff0000, 0x00000001},
+    {0x0001ffff, 0x80007fff, 0x00000001},
+    {0x00018000, 0x80008000, 0x40008000},
+    {0x00010000, 0x00000000, 0x00000000},
+    {0x00010000, 0x7fff7fff, 0xffff8001},
+    {0x00010000, 0x80008000, 0x00008000},
+    {0x80008000, 0x80008000, 0x00000000},
+    {0x7fffffff, 0x7fff0001, 0xffff0002},
+    {0x7fff0001, 0x7fffffff, 0x0000fffe},
+};
+
+/* mulaca.s16.s */
+struct ternary_calculation samples_mulaca_s16_s[] = {
+    {0x00010001, 0x00010001, 0x00000001, 0x00000003},
+    {0x80007fff, 0x80007fff, 0x80000000, 0xffff0001},
+    {0x80007fff, 0x80007fff, 0xffffffff, 0x7fff0000},
+    {0x80007fff, 0x80007fff, 0x7fffffff, 0x7fffffff},
+    {0x7fff7fff, 0x80008000, 0x80000000, 0x80000000},
+    {0x7fff7fff, 0x80008000, 0xffffffff, 0x8000ffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffff, 0x0000ffff},
+    {0xffffffff, 0xffffffff, 0x80000000, 0x80000002},
+    {0xffffffff, 0xffffffff, 0xffffffff, 0x00000001},
+    {0xffffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0x80008000, 0x80000000, 0x80010000},
+    {0xffffffff, 0x80008000, 0xffffffff, 0x0000ffff},
+    {0xffffffff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0x8000ffff, 0x8000ffff, 0x80000000, 0xc0000001},
+    {0x8000ffff, 0x8000ffff, 0xffffffff, 0x40000000},
+    {0x8000ffff, 0x8000ffff, 0x7fffffff, 0x7fffffff},
+    {0x00010000, 0xffffffff, 0x00000000, 0xffffffff},
+    {0x0001ffff, 0xffff0000, 0x00000000, 0xffffffff},
+    {0x00000001, 0xffffffff, 0x00000000, 0xffffffff},
+    {0x0000ffff, 0xffff0001, 0x00000000, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x7fff0000, 0x00017fff, 0x7fffffff, 0x7fffffff},
+    {0x7fff0001, 0x0001ffff, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0xffffffff, 0x80000000, 0x80000000},
+};
+
+/* mulacax.s16.s */
+struct ternary_calculation samples_mulacax_s16_s[] = {
+    {0x00010001, 0x00010001, 0x00000001, 0x00000003},
+    {0x80007fff, 0x7fff8000, 0x80000000, 0xffff0001},
+    {0x80007fff, 0x7fff8000, 0xffffffff, 0x7fff0000},
+    {0x80007fff, 0x7fff8000, 0x7fffffff, 0x7fffffff},
+    {0x7fff7fff, 0x80008000, 0x80000000, 0x80000000},
+    {0x7fff7fff, 0x80008000, 0xffffffff, 0x8000ffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffff, 0x0000ffff},
+    {0xffffffff, 0xffffffff, 0x80000000, 0x80000002},
+    {0xffffffff, 0xffffffff, 0xffffffff, 0x00000001},
+    {0xffffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0x80008000, 0x80000000, 0x80010000},
+    {0xffffffff, 0x80008000, 0xffffffff, 0x0000ffff},
+    {0xffffffff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0x8000ffff, 0xffff8000, 0x80000000, 0xc0000001},
+    {0x8000ffff, 0xffff8000, 0xffffffff, 0x40000000},
+    {0x8000ffff, 0xffff8000, 0x7fffffff, 0x7fffffff},
+    {0x00010000, 0xffffffff, 0x00000000, 0xffffffff},
+    {0x0001ffff, 0x0000ffff, 0x00000000, 0xffffffff},
+    {0x00000001, 0xffffffff, 0x00000000, 0xffffffff},
+    {0x0000ffff, 0x0001ffff, 0x00000000, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x7fff0001, 0xffff0001, 0x7fffffff, 0x7fffffff},
+    {0xffff0001, 0x00017fff, 0x80000000, 0x80000000},
+    {0x7fff0001, 0xffff0001, 0x7fff0000, 0x7fff7ffe},
+};
+
+/* mulacs.s16.s */
+struct ternary_calculation samples_mulacs_s16_s[] = {
+    {0x00010001, 0x00010001, 0x00000001, 0x00000001},
+    {0x80007fff, 0x80007fff, 0x80000000, 0x80000000},
+    {0x80007fff, 0x80007fff, 0xffffffff, 0xffff0000},
+    {0x80007fff, 0x80007fff, 0x7fffffff, 0x7fff0000},
+    {0x7fff7fff, 0x80008000, 0x80000000, 0x80000000},
+    {0x7fff7fff, 0x80008000, 0xffffffff, 0xffffffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0xffffffff, 0x80000000, 0x80000000},
+    {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0x80008000, 0x80000000, 0x80000000},
+    {0xffffffff, 0x80008000, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0x8000ffff, 0x8000ffff, 0x80000000, 0x80000000},
+    {0x8000ffff, 0x8000ffff, 0xffffffff, 0xc0000000},
+    {0x8000ffff, 0x8000ffff, 0x7fffffff, 0x40000000},
+    {0x00010000, 0xffffffff, 0x00000000, 0x00000001},
+    {0x0001ffff, 0xffff0000, 0x00000000, 0x00000001},
+    {0x00000001, 0xffffffff, 0x00000000, 0xffffffff},
+    {0x0000ffff, 0xffff0001, 0x00000000, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x7fff0001, 0xffff7fff, 0x7fffffff, 0x7fffffff},
+    {0xffff7fff, 0x0001ffff, 0x80000000, 0x80000000},
+    {0x7fff0000, 0xffff0000, 0x7fff0000, 0x7fff7fff},
+};
+
+/* mulacsr.s16.s */
+struct ternary_calculation samples_mulacsr_s16_s[] = {
+    {0x00010001, 0x00010001, 0x00000001, 0x00000001},
+    {0x7fff8000, 0x7fff8000, 0x80000000, 0x80000000},
+    {0x7fff8000, 0x7fff8000, 0xffffffff, 0xffff0000},
+    {0x7fff8000, 0x7fff8000, 0x7fffffff, 0x7fff0000},
+    {0x7fff7fff, 0x80008000, 0x80000000, 0x80000000},
+    {0x7fff7fff, 0x80008000, 0xffffffff, 0xffffffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0xffffffff, 0x80000000, 0x80000000},
+    {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0x80008000, 0x80000000, 0x80000000},
+    {0xffffffff, 0x80008000, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0xffff8000, 0xffff8000, 0x80000000, 0x80000000},
+    {0xffff8000, 0xffff8000, 0xffffffff, 0xc0000000},
+    {0xffff8000, 0xffff8000, 0x7fffffff, 0x40000000},
+    {0x00000001, 0xffffffff, 0x00000000, 0x00000001},
+    {0xffff0001, 0x0000ffff, 0x00000000, 0x00000001},
+    {0x00010000, 0xffffffff, 0x00000000, 0xffffffff},
+    {0xffff0000, 0x0001ffff, 0x00000000, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x7fff0001, 0x00010001, 0x7fffffff, 0x7fffffff},
+    {0x7fff0001, 0xffff0001, 0x80000000, 0x80000000},
+    {0x7fffffff, 0xffffffff, 0xffff0000, 0xfffe8000},
+};
+
+/* mulacsx.s16.s */
+struct ternary_calculation samples_mulacsx_s16_s[] = {
+    {0x00010001, 0x00010001, 0x00000001, 0x00000001},
+    {0x80007fff, 0x7fff8000, 0x80000000, 0x80000000},
+    {0x80007fff, 0x7fff8000, 0xffffffff, 0xffff0000},
+    {0x80007fff, 0x7fff8000, 0x7fffffff, 0x7fff0000},
+    {0x7fff7fff, 0x80008000, 0x80000000, 0x80000000},
+    {0x7fff7fff, 0x80008000, 0xffffffff, 0xffffffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0xffffffff, 0x80000000, 0x80000000},
+    {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0x80008000, 0x80000000, 0x80000000},
+    {0xffffffff, 0x80008000, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0x8000ffff, 0xffff8000, 0x80000000, 0x80000000},
+    {0x8000ffff, 0xffff8000, 0xffffffff, 0xc0000000},
+    {0x8000ffff, 0xffff8000, 0x7fffffff, 0x40000000},
+    {0x00010000, 0xffffffff, 0x00000000, 0x00000001},
+    {0x0001ffff, 0x0000ffff, 0x00000000, 0x00000001},
+    {0x00000001, 0xffffffff, 0x00000000, 0xffffffff},
+    {0x0000ffff, 0x0001ffff, 0x00000000, 0xffffffff},
+    {0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x00017fff, 0x00010001, 0x7fffffff, 0x7fffffff},
+    {0x0001ffff, 0x7fffffff, 0x80000000, 0x80000000},
+    {0xffff7fff, 0xffff8000, 0x4000ffff, 0x40000000},
+};
+
+/* mulsca.s16.s */
+struct ternary_calculation samples_mulsca_s16_s[] = {
+    {0x00010001, 0x00010001, 0x00000001, 0xffffffff},
+    {0x80007fff, 0x80007fff, 0x80000000, 0x80000000},
+    {0x80007fff, 0x80007fff, 0xffffffff, 0x8000fffe},
+    {0x80007fff, 0x80007fff, 0x7fffffff, 0x0000fffe},
+    {0x7fff7fff, 0x80008000, 0x80000000, 0xffff0000},
+    {0x7fff7fff, 0x80008000, 0xffffffff, 0x7ffeffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0xffffffff, 0x80000000, 0x80000000},
+    {0xffffffff, 0xffffffff, 0xffffffff, 0xfffffffd},
+    {0xffffffff, 0xffffffff, 0x7fffffff, 0x7ffffffd},
+    {0xffffffff, 0x80008000, 0x80000000, 0x80000000},
+    {0xffffffff, 0x80008000, 0xffffffff, 0xfffeffff},
+    {0xffffffff, 0x80008000, 0x7fffffff, 0x7ffeffff},
+    {0x8000ffff, 0x8000ffff, 0x80000000, 0x80000000},
+    {0x8000ffff, 0x8000ffff, 0xffffffff, 0xbffffffe},
+    {0x8000ffff, 0x8000ffff, 0x7fffffff, 0x3ffffffe},
+    {0x00010000, 0xffffffff, 0x00000000, 0x00000001},
+    {0x0001ffff, 0xffff0000, 0x00000000, 0x00000001},
+    {0x00000001, 0xffffffff, 0x00000000, 0x00000001},
+    {0x0000ffff, 0xffff0001, 0x00000000, 0x00000001},
+    {0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0xffff0001, 0x7fff0001, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0x00010001, 0x80000000, 0x80000000},
+    {0xffff7fff, 0x8000ffff, 0x7fff8000, 0x7fff7fff},
+};
+
+/* mulscax.s16.s */
+struct ternary_calculation samples_mulscax_s16_s[] = {
+    {0x00010001, 0x00010001, 0x00000001, 0xffffffff},
+    {0x80007fff, 0x7fff8000, 0x80000000, 0x80000000},
+    {0x80007fff, 0x7fff8000, 0xffffffff, 0x8000fffe},
+    {0x80007fff, 0x7fff8000, 0x7fffffff, 0x0000fffe},
+    {0x7fff7fff, 0x80008000, 0x80000000, 0xffff0000},
+    {0x7fff7fff, 0x80008000, 0xffffffff, 0x7ffeffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffff, 0x7fffffff},
+    {0xffffffff, 0xffffffff, 0x80000000, 0x80000000},
+    {0xffffffff, 0xffffffff, 0xffffffff, 0xfffffffd},
+    {0xffffffff, 0xffffffff, 0x7fffffff, 0x7ffffffd},
+    {0xffffffff, 0x80008000, 0x80000000, 0x80000000},
+    {0xffffffff, 0x80008000, 0xffffffff, 0xfffeffff},
+    {0xffffffff, 0x80008000, 0x7fffffff, 0x7ffeffff},
+    {0x8000ffff, 0xffff8000, 0x80000000, 0x80000000},
+    {0x8000ffff, 0xffff8000, 0xffffffff, 0xbffffffe},
+    {0x8000ffff, 0xffff8000, 0x7fffffff, 0x3ffffffe},
+    {0x00010000, 0xffffffff, 0x00000000, 0x00000001},
+    {0x0001ffff, 0x0000ffff, 0x00000000, 0x00000001},
+    {0x00000001, 0xffffffff, 0x00000000, 0x00000001},
+    {0x0000ffff, 0x0001ffff, 0x00000000, 0x00000001},
+    {0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x7fff0001, 0x0001ffff, 0x7fffffff, 0x7fffffff},
+    {0x7fffffff, 0x00017fff, 0x80000000, 0x80000000},
+    {0xffff7fff, 0xffff8000, 0x7fff8000, 0x7fff7fff},
+};
+
+/* mulaca.s16.e */
+struct ternary64_calculation samples_mulaca_s16_e[] = {
+    {0x00010001, 0x00010001, 0x0000000000000001, 0x0000000000000003},
+    {0x80007fff, 0x80007fff, 0x8000000000000000, 0x800000007fff0001},
+    {0x80007fff, 0x80007fff, 0xffffffffffffffff, 0x000000007fff0000},
+    {0x80007fff, 0x80007fff, 0x7fffffffffffffff, 0x800000007fff0000},
+    {0x7fff7fff, 0x80008000, 0x8000000000000000, 0x7fffffff80010000},
+    {0x7fff7fff, 0x80008000, 0xffffffffffffffff, 0xffffffff8000ffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffffffffffff, 0x7fffffff8000ffff},
+    {0xffffffff, 0xffffffff, 0x8000000000000000, 0x8000000000000002},
+    {0xffffffff, 0xffffffff, 0xffffffffffffffff, 0x0000000000000001},
+    {0xffffffff, 0xffffffff, 0x7fffffffffffffff, 0x8000000000000001},
+    {0xffffffff, 0x80008000, 0x8000000000000000, 0x8000000000010000},
+    {0xffffffff, 0x80008000, 0xffffffffffffffff, 0x000000000000ffff},
+    {0xffffffff, 0x80008000, 0x7fffffffffffffff, 0x800000000000ffff},
+    {0x8000ffff, 0x8000ffff, 0x8000000000000000, 0x8000000040000001},
+    {0x8000ffff, 0x8000ffff, 0xffffffffffffffff, 0x0000000040000000},
+    {0x8000ffff, 0x8000ffff, 0x7fffffffffffffff, 0x8000000040000000},
+    {0x00010000, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0x0001ffff, 0xffff0000, 0x0000000000000000, 0xffffffffffffffff},
+    {0x00000001, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0x0000ffff, 0xffff0001, 0x0000000000000000, 0xffffffffffffffff},
+    {0x00000000, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x7fff4000, 0x80000000, 0x800000007fff4000, 0x800000003fffc000},
+    {0x4000ff00, 0x7fffffff, 0x7fffffff4000ff00, 0x7fffffff6000c000},
+};
+
+/* mulacax.s16.e */
+struct ternary64_calculation samples_mulacax_s16_e[] = {
+    {0x00010001, 0x00010001, 0x0000000000000001, 0x0000000000000003},
+    {0x80007fff, 0x7fff8000, 0x8000000000000000, 0x800000007fff0001},
+    {0x80007fff, 0x7fff8000, 0xffffffffffffffff, 0x000000007fff0000},
+    {0x80007fff, 0x7fff8000, 0x7fffffffffffffff, 0x800000007fff0000},
+    {0x7fff7fff, 0x80008000, 0x8000000000000000, 0x7fffffff80010000},
+    {0x7fff7fff, 0x80008000, 0xffffffffffffffff, 0xffffffff8000ffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffffffffffff, 0x7fffffff8000ffff},
+    {0xffffffff, 0xffffffff, 0x8000000000000000, 0x8000000000000002},
+    {0xffffffff, 0xffffffff, 0xffffffffffffffff, 0x0000000000000001},
+    {0xffffffff, 0xffffffff, 0x7fffffffffffffff, 0x8000000000000001},
+    {0xffffffff, 0x80008000, 0x8000000000000000, 0x8000000000010000},
+    {0xffffffff, 0x80008000, 0xffffffffffffffff, 0x000000000000ffff},
+    {0xffffffff, 0x80008000, 0x7fffffffffffffff, 0x800000000000ffff},
+    {0x8000ffff, 0xffff8000, 0x8000000000000000, 0x8000000040000001},
+    {0x8000ffff, 0xffff8000, 0xffffffffffffffff, 0x0000000040000000},
+    {0x8000ffff, 0xffff8000, 0x7fffffffffffffff, 0x8000000040000000},
+    {0x00010000, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0x0001ffff, 0x0000ffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0x00000001, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0x0000ffff, 0x0001ffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0x00000000, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x7fff4000, 0x80000000, 0x800000007fff4000, 0x800000005fff4000},
+    {0x4000ff00, 0x7fffffff, 0x7fffffff4000ff00, 0x7fffffff3f80c000},
+    {0x7fffffff, 0x00010001, 0x7fffffffffffffff, 0x8000000000007ffd},
+    {0x7fff0001, 0x0001ffff, 0x8000000000000000, 0x7fffffffffff8002},
+};
+
+/* mulacs.s16.e */
+struct ternary64_calculation samples_mulacs_s16_e[] = {
+    {0x00010001, 0x00010001, 0x0000000000000001, 0x0000000000000001},
+    {0x80007fff, 0x80007fff, 0x8000000000000000, 0x7fffffffffff0001},
+    {0x80007fff, 0x80007fff, 0xffffffffffffffff, 0xffffffffffff0000},
+    {0x80007fff, 0x80007fff, 0x7fffffffffffffff, 0x7fffffffffff0000},
+    {0x7fff7fff, 0x80008000, 0x8000000000000000, 0x8000000000000000},
+    {0x7fff7fff, 0x80008000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0xffffffff, 0xffffffff, 0x8000000000000000, 0x8000000000000000},
+    {0xffffffff, 0xffffffff, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0xffffffff, 0xffffffff, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0xffffffff, 0x80008000, 0x8000000000000000, 0x8000000000000000},
+    {0xffffffff, 0x80008000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0xffffffff, 0x80008000, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0x8000ffff, 0x8000ffff, 0x8000000000000000, 0x7fffffffc0000001},
+    {0x8000ffff, 0x8000ffff, 0xffffffffffffffff, 0xffffffffc0000000},
+    {0x8000ffff, 0x8000ffff, 0x7fffffffffffffff, 0x7fffffffc0000000},
+    {0x00010000, 0xffffffff, 0x0000000000000000, 0x0000000000000001},
+    {0x0001ffff, 0xffff0000, 0x0000000000000000, 0x0000000000000001},
+    {0x00000001, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0x0000ffff, 0xffff0001, 0x0000000000000000, 0xffffffffffffffff},
+    {0x00000000, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x7fff4000, 0x80000000, 0x800000007fff4000, 0x80000000bffec000},
+    {0x4000ff00, 0x7fffffff, 0x7fffffff4000ff00, 0x7fffffff20014000},
+    {0xffff7fff, 0xffff7fff, 0x7fffffffffffffff, 0x800000003ffeffff},
+};
+
+/* mulacsr.s16.e */
+struct ternary64_calculation samples_mulacsr_s16_e[] = {
+    {0x00010001, 0x00010001, 0x0000000000000001, 0x0000000000000001},
+    {0x7fff8000, 0x7fff8000, 0x8000000000000000, 0x7fffffffffff0001},
+    {0x7fff8000, 0x7fff8000, 0xffffffffffffffff, 0xffffffffffff0000},
+    {0x7fff8000, 0x7fff8000, 0x7fffffffffffffff, 0x7fffffffffff0000},
+    {0x7fff7fff, 0x80008000, 0x8000000000000000, 0x8000000000000000},
+    {0x7fff7fff, 0x80008000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0xffffffff, 0xffffffff, 0x8000000000000000, 0x8000000000000000},
+    {0xffffffff, 0xffffffff, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0xffffffff, 0xffffffff, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0xffffffff, 0x80008000, 0x8000000000000000, 0x8000000000000000},
+    {0xffffffff, 0x80008000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0xffffffff, 0x80008000, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0xffff8000, 0xffff8000, 0x8000000000000000, 0x7fffffffc0000001},
+    {0xffff8000, 0xffff8000, 0xffffffffffffffff, 0xffffffffc0000000},
+    {0xffff8000, 0xffff8000, 0x7fffffffffffffff, 0x7fffffffc0000000},
+    {0x00000001, 0xffffffff, 0x0000000000000000, 0x0000000000000001},
+    {0xffff0001, 0x0000ffff, 0x0000000000000000, 0x0000000000000001},
+    {0x00010000, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0xffff0000, 0x0001ffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0x00000000, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x7fff4000, 0x80000000, 0x800000007fff4000, 0x800000003fffc000},
+    {0x4000ff00, 0x7fffffff, 0x7fffffff4000ff00, 0x7fffffff6000be00},
+    {0x7fffffff, 0x0001ffff, 0x7fffffffffffffff, 0x8000000000007ffd},
+};
+
+/* mulacsx.s16.e */
+struct ternary64_calculation samples_mulacsx_s16_e[] = {
+    {0x00010001, 0x00010001, 0x0000000000000001, 0x0000000000000001},
+    {0x80007fff, 0x7fff8000, 0x8000000000000000, 0x7fffffffffff0001},
+    {0x80007fff, 0x7fff8000, 0xffffffffffffffff, 0xffffffffffff0000},
+    {0x80007fff, 0x7fff8000, 0x7fffffffffffffff, 0x7fffffffffff0000},
+    {0x7fff7fff, 0x80008000, 0x8000000000000000, 0x8000000000000000},
+    {0x7fff7fff, 0x80008000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0xffffffff, 0xffffffff, 0x8000000000000000, 0x8000000000000000},
+    {0xffffffff, 0xffffffff, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0xffffffff, 0xffffffff, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0xffffffff, 0x80008000, 0x8000000000000000, 0x8000000000000000},
+    {0xffffffff, 0x80008000, 0xffffffffffffffff, 0xffffffffffffffff},
+    {0xffffffff, 0x80008000, 0x7fffffffffffffff, 0x7fffffffffffffff},
+    {0x8000ffff, 0xffff8000, 0x8000000000000000, 0x7fffffffc0000001},
+    {0x8000ffff, 0xffff8000, 0xffffffffffffffff, 0xffffffffc0000000},
+    {0x8000ffff, 0xffff8000, 0x7fffffffffffffff, 0x7fffffffc0000000},
+    {0x00010000, 0xffffffff, 0x0000000000000000, 0x0000000000000001},
+    {0x0001ffff, 0x0000ffff, 0x0000000000000000, 0x0000000000000001},
+    {0x00000001, 0xffffffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0x0000ffff, 0x0001ffff, 0x0000000000000000, 0xffffffffffffffff},
+    {0x00000000, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x7fff4000, 0x80000000, 0x800000007fff4000, 0x800000005fff4000},
+    {0x4000ff00, 0x7fffffff, 0x7fffffff4000ff00, 0x7fffffff3f814000},
+    {0x00017fff, 0x00010001, 0x7fffffffffffffff, 0x8000000000007ffd},
+};
+
+/* mulsca.s16.e */
+struct ternary64_calculation samples_mulsca_s16_e[] = {
+    {0x00010001, 0x00010001, 0x0000000000000001, 0xffffffffffffffff},
+    {0x80007fff, 0x80007fff, 0x8000000000000000, 0x7fffffff8000ffff},
+    {0x80007fff, 0x80007fff, 0xffffffffffffffff, 0xffffffff8000fffe},
+    {0x80007fff, 0x80007fff, 0x7fffffffffffffff, 0x7fffffff8000fffe},
+    {0x7fff7fff, 0x80008000, 0x8000000000000000, 0x800000007fff0000},
+    {0x7fff7fff, 0x80008000, 0xffffffffffffffff, 0x000000007ffeffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffffffffffff, 0x800000007ffeffff},
+    {0xffffffff, 0xffffffff, 0x8000000000000000, 0x7ffffffffffffffe},
+    {0xffffffff, 0xffffffff, 0xffffffffffffffff, 0xfffffffffffffffd},
+    {0xffffffff, 0xffffffff, 0x7fffffffffffffff, 0x7ffffffffffffffd},
+    {0xffffffff, 0x80008000, 0x8000000000000000, 0x7fffffffffff0000},
+    {0xffffffff, 0x80008000, 0xffffffffffffffff, 0xfffffffffffeffff},
+    {0xffffffff, 0x80008000, 0x7fffffffffffffff, 0x7ffffffffffeffff},
+    {0x8000ffff, 0x8000ffff, 0x8000000000000000, 0x7fffffffbfffffff},
+    {0x8000ffff, 0x8000ffff, 0xffffffffffffffff, 0xffffffffbffffffe},
+    {0x8000ffff, 0x8000ffff, 0x7fffffffffffffff, 0x7fffffffbffffffe},
+    {0x00010000, 0xffffffff, 0x0000000000000000, 0x0000000000000001},
+    {0x0001ffff, 0xffff0000, 0x0000000000000000, 0x0000000000000001},
+    {0x00000001, 0xffffffff, 0x0000000000000000, 0x0000000000000001},
+    {0x0000ffff, 0xffff0001, 0x0000000000000000, 0x0000000000000001},
+    {0x00000000, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x7fff4000, 0x80000000, 0x800000007fff4000, 0x80000000bffec000},
+    {0x4000ff00, 0x7fffffff, 0x7fffffff4000ff00, 0x7fffffff20013e00},
+};
+
+/* mulscax.s16.e */
+struct ternary64_calculation samples_mulscax_s16_e[] = {
+    {0x00010001, 0x00010001, 0x0000000000000001, 0xffffffffffffffff},
+    {0x80007fff, 0x7fff8000, 0x8000000000000000, 0x7fffffff8000ffff},
+    {0x80007fff, 0x7fff8000, 0xffffffffffffffff, 0xffffffff8000fffe},
+    {0x80007fff, 0x7fff8000, 0x7fffffffffffffff, 0x7fffffff8000fffe},
+    {0x7fff7fff, 0x80008000, 0x8000000000000000, 0x800000007fff0000},
+    {0x7fff7fff, 0x80008000, 0xffffffffffffffff, 0x000000007ffeffff},
+    {0x7fff7fff, 0x80008000, 0x7fffffffffffffff, 0x800000007ffeffff},
+    {0xffffffff, 0xffffffff, 0x8000000000000000, 0x7ffffffffffffffe},
+    {0xffffffff, 0xffffffff, 0xffffffffffffffff, 0xfffffffffffffffd},
+    {0xffffffff, 0xffffffff, 0x7fffffffffffffff, 0x7ffffffffffffffd},
+    {0xffffffff, 0x80008000, 0x8000000000000000, 0x7fffffffffff0000},
+    {0xffffffff, 0x80008000, 0xffffffffffffffff, 0xfffffffffffeffff},
+    {0xffffffff, 0x80008000, 0x7fffffffffffffff, 0x7ffffffffffeffff},
+    {0x8000ffff, 0xffff8000, 0x8000000000000000, 0x7fffffffbfffffff},
+    {0x8000ffff, 0xffff8000, 0xffffffffffffffff, 0xffffffffbffffffe},
+    {0x8000ffff, 0xffff8000, 0x7fffffffffffffff, 0x7fffffffbffffffe},
+    {0x00010000, 0xffffffff, 0x0000000000000000, 0x0000000000000001},
+    {0x0001ffff, 0x0000ffff, 0x0000000000000000, 0x0000000000000001},
+    {0x00000001, 0xffffffff, 0x0000000000000000, 0x0000000000000001},
+    {0x0000ffff, 0x0001ffff, 0x0000000000000000, 0x0000000000000001},
+    {0x00000000, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+    {0x7fff4000, 0x80000000, 0x800000007fff4000, 0x800000009fff4000},
+    {0x4000ff00, 0x7fffffff, 0x7fffffff4000ff00, 0x7fffffff40813e00},
+    {0x7fffffff, 0x00010001, 0x8000000000000000, 0x7fffffffffff8002},
+};
+
+/* mul.u32 */
+struct binary64_calculation samples_mul_u32[] = {
+    {0x7fffffff, 0x7fffffff, 0x3fffffff00000001},
+    {0x80000000, 0x80000000, 0x4000000000000000},
+    {0xffffffff, 0xffffffff, 0xfffffffe00000001},
+    {0x00000000, 0x00000000, 0x0000000000000000},
+    {0x7fffffff, 0x80000000, 0x3fffffff80000000},
+    {0x80000000, 0x7fffffff, 0x3fffffff80000000},
+    {0x7fffffff, 0xffffffff, 0x7ffffffe80000001},
+    {0xffffffff, 0x7fffffff, 0x7ffffffe80000001},
+    {0x7fffffff, 0x00000000, 0x0000000000000000},
+    {0x00000000, 0x7fffffff, 0x0000000000000000},
+    {0x80000000, 0xffffffff, 0x7fffffff80000000},
+    {0xffffffff, 0x80000000, 0x7fffffff80000000},
+    {0x00000000, 0x80000000, 0x0000000000000000},
+    {0x80000000, 0x00000000, 0x0000000000000000},
+    {0xffffffff, 0x00000000, 0x0000000000000000},
+    {0x00000000, 0xffffffff, 0x0000000000000000},
+};
+
+/* mul.s32 */
+struct binary64_calculation samples_mul_s32[] = {
+    {0x7fffffff, 0x7fffffff, 0x3fffffff00000001},
+    {0x80000000, 0x80000000, 0x4000000000000000},
+    {0xffffffff, 0xffffffff, 0x0000000000000001},
+    {0x00000000, 0x00000000, 0x0000000000000000},
+    {0x7fffffff, 0x80000000, 0xc000000080000000},
+    {0x80000000, 0x7fffffff, 0xc000000080000000},
+    {0x7fffffff, 0xffffffff, 0xffffffff80000001},
+    {0xffffffff, 0x7fffffff, 0xffffffff80000001},
+    {0x7fffffff, 0x00000000, 0x0000000000000000},
+    {0x00000000, 0x7fffffff, 0x0000000000000000},
+    {0x80000000, 0xffffffff, 0x0000000080000000},
+    {0xffffffff, 0x80000000, 0x0000000080000000},
+    {0x00000000, 0x80000000, 0x0000000000000000},
+    {0x80000000, 0x00000000, 0x0000000000000000},
+    {0xffffffff, 0x00000000, 0x0000000000000000},
+    {0x00000000, 0xffffffff, 0x0000000000000000},
+    {0x7fffffff, 0x7fffffff, 0x3fffffff00000001},
+};
+
+/* mula.u32 */
+struct ternary64_calculation samples_mula_u32[] = {
+    {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000002},
+    {0x00000001, 0x00000001, 0xffffffffffffffff, 0x0000000000000000},
+    {0x00000001, 0x00000001, 0x8000000000000000, 0x8000000000000001},
+    {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x8000000000000000},
+    {0x00000001, 0xffffffff, 0xffffffffffffffff, 0x00000000fffffffe},
+    {0x00000001, 0xffffffff, 0x8000000000000000, 0x80000000ffffffff},
+    {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x80000000fffffffe},
+    {0x80000000, 0x80000000, 0xffffffffffffffff, 0x3fffffffffffffff},
+    {0x80000000, 0x80000000, 0x8000000000000000, 0xc000000000000000},
+    {0x80000000, 0x80000000, 0x7fffffffffffffff, 0xbfffffffffffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0x7ffffffe80000000},
+    {0x7fffffff, 0xffffffff, 0x8000000000000000, 0xfffffffe80000001},
+    {0x7fffffff, 0xffffffff, 0x7fffffffffffffff, 0xfffffffe80000000},
+    {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+};
+
+/* mula.s32 */
+struct ternary64_calculation samples_mula_s32[] = {
+    {0x00000001, 0x00000001, 0x0000000000000001, 0x0000000000000002},
+    {0x00000001, 0x00000001, 0xffffffffffffffff, 0x0000000000000000},
+    {0x00000001, 0x00000001, 0x8000000000000000, 0x8000000000000001},
+    {0x00000001, 0x00000001, 0x7fffffffffffffff, 0x8000000000000000},
+    {0x00000001, 0xffffffff, 0xffffffffffffffff, 0xfffffffffffffffe},
+    {0x00000001, 0xffffffff, 0x8000000000000000, 0x7fffffffffffffff},
+    {0x00000001, 0xffffffff, 0x7fffffffffffffff, 0x7ffffffffffffffe},
+    {0x80000000, 0x80000000, 0xffffffffffffffff, 0x3fffffffffffffff},
+    {0x80000000, 0x80000000, 0x8000000000000000, 0xc000000000000000},
+    {0x80000000, 0x80000000, 0x7fffffffffffffff, 0xbfffffffffffffff},
+    {0x7fffffff, 0xffffffff, 0xffffffffffffffff, 0xffffffff80000000},
+    {0x7fffffff, 0xffffffff, 0x8000000000000000, 0x7fffffff80000001},
+    {0x7fffffff, 0xffffffff, 0x7fffffffffffffff, 0x7fffffff80000000},
+    {0x00000000, 0x00000001, 0x0000000000000000, 0x0000000000000000},
+    {0x00000001, 0x00000000, 0x0000000000000000, 0x0000000000000000},
+};
+
+/* mula.32.l */
+struct ternary_calculation samples_mula_32_l[] = {
+    {0x00000001, 0x00000001, 0x00000000, 0x00000001},
+    {0x00000002, 0x40000000, 0x00000000, 0x80000000},
+    {0x00000001, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF},
+    {0x00000001, 0x00000001, 0x00000001, 0x00000002},
+    {0x00000002, 0x20000000, 0x40000000, 0x80000000},
+    {0x00000002, 0x80000000, 0x00000000, 0x00000000},
+    {0x00000002, 0x80000001, 0x00000000, 0x00000002},
+    {0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000001},
+    {0x80000000, 0x80000000, 0x00000000, 0x00000000},
+    {0x80000000, 0x80000000, 0x80000000, 0x80000000},
+    {0x00000100, 0x10000001, 0xFFFFFFFF, 0x000000FF},
+    {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000},
+    {0x00000000, 0x00000001, 0x00000000, 0x00000000},
+    {0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0xFFFFFFFF, 0x00000000, 0x00000000},
+    {0x00000000, 0x00000001, 0x00000001, 0x00000001},
+    {0x00000000, 0x00000000, 0x00000001, 0x00000001},
+    {0x00000000, 0xFFFFFFFF, 0x00000001, 0x00000001},
+};
+
+/* mul.s32.h */
+struct binary_calculation samples_mul_s32_h[] = {
+    {0x7fffffff, 0x7fffffff, 0x3fffffff},
+    {0x80000000, 0x80000000, 0x40000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x80000000, 0xc0000000},
+    {0x80000000, 0x7fffffff, 0xc0000000},
+    {0x7fffffff, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0x7fffffff, 0xffffffff},
+    {0x7fffffff, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fffffff, 0x00000000},
+    {0x80000000, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x80000000, 0x00000000},
+    {0x00000000, 0x80000000, 0x00000000},
+    {0x80000000, 0x00000000, 0x00000000},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0x00000000, 0xffffffff, 0x00000000},
+};
+
+/* mul.s32.rh */
+struct binary_calculation samples_mul_s32_rh[] = {
+    {0x7fffffff, 0x7fffffff, 0x3fffffff},
+    {0x80000000, 0x80000000, 0x40000000},
+    {0xffffffff, 0xffffffff, 0x00000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x7fffffff, 0x80000000, 0xc0000001},
+    {0x80000000, 0x7fffffff, 0xc0000001},
+    {0x7fffffff, 0xffffffff, 0x00000000},
+    {0xffffffff, 0x7fffffff, 0x00000000},
+    {0x7fffffff, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fffffff, 0x00000000},
+    {0x80000000, 0xffffffff, 0x00000001},
+    {0xffffffff, 0x80000000, 0x00000001},
+    {0x00000000, 0x80000000, 0x00000000},
+    {0x80000000, 0x00000000, 0x00000000},
+    {0xffffffff, 0x00000000, 0x00000000},
+    {0x00000000, 0xffffffff, 0x00000000},
+    {0x00000001, 0x7fffffff, 0x00000000},
+    {0x00000002, 0x7fffffff, 0x00000001},
+};
+
+/* mulll.s16 */
+struct binary_calculation samples_mulll_s16[] = {
+    {0x00000001, 0x00000001, 0x00000001},
+    {0x00000001, 0x7fff7fff, 0x00007fff},
+    {0x00000001, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x00000001},
+    {0x00008000, 0x80008000, 0x40000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fffffff, 0x00000000},
+    {0x80000000, 0x00008000, 0x00000000},
+    {0xffff7fff, 0xffff7fff, 0x3fff0001},
+    {0xffff7fff, 0x7fffffff, 0xffff8001},
+    {0xffff8000, 0xffff8000, 0x40000000},
+    {0xffff8000, 0x8000ffff, 0x00008000},
+};
+
+/* mulhh.s16 */
+struct binary_calculation samples_mulhh_s16[] = {
+    {0x00010000, 0x00010000, 0x00000001},
+    {0x00010000, 0x7fff7fff, 0x00007fff},
+    {0x00010000, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x00000001},
+    {0x80000000, 0x80008000, 0x40000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0xffff7fff, 0x00000000},
+    {0x80000000, 0x80000000, 0x40000000},
+    {0x7fffffff, 0x7fffffff, 0x3fff0001},
+    {0x8000ffff, 0x8000ffff, 0x40000000},
+    {0xffff8000, 0x8000ffff, 0x00008000},
+    {0x7fffffff, 0x80007fff, 0xc0008000},
+    {0x0001ffff, 0xffff7fff, 0xffffffff},
+};
+
+/* mulhl.s16 */
+struct binary_calculation samples_mulhl_s16[] = {
+    {0x00010000, 0x00000001, 0x00000001},
+    {0x00010000, 0x7fff7fff, 0x00007fff},
+    {0x00010000, 0xffffffff, 0xffffffff},
+    {0xffffffff, 0xffffffff, 0x00000001},
+    {0x80000000, 0x80008000, 0x40000000},
+    {0x00000000, 0x00000000, 0x00000000},
+    {0x00000000, 0x7fffffff, 0x00000000},
+    {0x80000000, 0x00008000, 0x40000000},
+    {0x7fffffff, 0x7fffffff, 0xffff8001},
+    {0x0001ffff, 0x7fffffff, 0xffffffff},
+    {0x7fffffff, 0xffff7fff, 0x3fff0001},
+    {0x8000ffff, 0x7fff8000, 0x40000000},
+};
+
+#endif
diff --git a/tests/csky/dspv2/case/sel.c b/tests/csky/dspv2/case/sel.c
new file mode 100644
index 0000000..004997c
--- /dev/null
+++ b/tests/csky/dspv2/case/sel.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn sel\n");
+
+    for (i = 0;
+         i < sizeof(samples_sel)/sizeof(struct ternary_calculation);
+         i++) {
+        TEST(test_sel(samples_sel[i].op1, samples_sel[i].op2, samples_sel[i].op3)
+                     == samples_sel[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/stbi_b.c b/tests/csky/dspv2/case/stbi_b.c
new file mode 100644
index 0000000..949ebe5
--- /dev/null
+++ b/tests/csky/dspv2/case/stbi_b.c
@@ -0,0 +1,41 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn stbi.b\n");
+
+    int *rx = (int *)0x60000100;
+    int rz = 0xc0c0c0c0;
+    TEST((test_stbi_b(rx, rz) != 0) && (*rx == 0xc0));
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/stbi_h.c b/tests/csky/dspv2/case/stbi_h.c
new file mode 100644
index 0000000..3d3a3d3
--- /dev/null
+++ b/tests/csky/dspv2/case/stbi_h.c
@@ -0,0 +1,41 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn stbi.h \n");
+
+    int *rx = (int *)0x60000100;
+    int rz = 0xc0c0c0c0;
+    TEST((test_stbi_h(rx, rz) != 0) && (*rx == 0xc0c0));
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/stbi_w.c b/tests/csky/dspv2/case/stbi_w.c
new file mode 100644
index 0000000..ee7c56a
--- /dev/null
+++ b/tests/csky/dspv2/case/stbi_w.c
@@ -0,0 +1,41 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn stbi.w\n");
+
+    int *rx = (int *)0x60000100;
+    int rz = 0xc0c0c0c0;
+    TEST((test_stbi_w(rx, rz) != 0) && (*rx == 0xc0c0c0c0));
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/stbir_b.c b/tests/csky/dspv2/case/stbir_b.c
new file mode 100644
index 0000000..cf9dc8e
--- /dev/null
+++ b/tests/csky/dspv2/case/stbir_b.c
@@ -0,0 +1,42 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn stbir.b\n");
+
+    int *rx = (int *)0x60000100;
+    int rz = 0xc0c0c0c0;
+    int ry = 1;
+    TEST((test_stbir_b(rx, ry, rz) != 0) && (*rx == 0xc0));
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/stbir_h.c b/tests/csky/dspv2/case/stbir_h.c
new file mode 100644
index 0000000..cb49128
--- /dev/null
+++ b/tests/csky/dspv2/case/stbir_h.c
@@ -0,0 +1,42 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn stbir.h\n");
+
+    int *rx = (int *)0x60000100;
+    int rz = 0xc0c0c0c0;
+    int ry = 2;
+    TEST((test_stbir_h(rx, ry, rz) != 0) && (*rx == 0xc0c0));
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/stbir_w.c b/tests/csky/dspv2/case/stbir_w.c
new file mode 100644
index 0000000..a125db9
--- /dev/null
+++ b/tests/csky/dspv2/case/stbir_w.c
@@ -0,0 +1,42 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+int main(void)
+{
+    init_testsuite("Testing insn stbir.w\n");
+
+    int *rx = (int *)0x60000100;
+    int rz = 0xc0c0c0c0;
+    int ry = 4;
+    TEST((test_stbir_w(rx, ry, rz) != 0) && (*rx == 0xc0c0c0c0));
+
+    return done_testing();
+}
+
diff --git a/tests/csky/dspv2/case/sub_64.c b/tests/csky/dspv2/case/sub_64.c
new file mode 100644
index 0000000..16a50a6
--- /dev/null
+++ b/tests/csky/dspv2/case/sub_64.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn sub.64\n");
+
+    for (i = 0;
+         i < sizeof(samples_sub_64)/sizeof(struct binary64_64_64_calculation);
+         i++) {
+        TEST(test_sub_64(samples_sub_64[i].op1, samples_sub_64[i].op2)
+                     == samples_sub_64[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/sub_s32_s.c b/tests/csky/dspv2/case/sub_s32_s.c
new file mode 100644
index 0000000..c203826
--- /dev/null
+++ b/tests/csky/dspv2/case/sub_s32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn sub.s32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_sub_s32_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_sub_s32_s(samples_sub_s32_s[i].op1, samples_sub_s32_s[i].op2)
+                     == samples_sub_s32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/sub_s64_s.c b/tests/csky/dspv2/case/sub_s64_s.c
new file mode 100644
index 0000000..6229723
--- /dev/null
+++ b/tests/csky/dspv2/case/sub_s64_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn sub.s64.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_sub_s64_s)/sizeof(struct binary64_64_64_calculation);
+         i++) {
+        TEST(test_sub_s64_s(samples_sub_s64_s[i].op1, samples_sub_s64_s[i].op2)
+                     == samples_sub_s64_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/sub_u32_s.c b/tests/csky/dspv2/case/sub_u32_s.c
new file mode 100644
index 0000000..b77547a
--- /dev/null
+++ b/tests/csky/dspv2/case/sub_u32_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn sub.u32.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_sub_u32_s)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_sub_u32_s(samples_sub_u32_s[i].op1, samples_sub_u32_s[i].op2)
+                     == samples_sub_u32_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/sub_u64_s.c b/tests/csky/dspv2/case/sub_u64_s.c
new file mode 100644
index 0000000..1ee167f
--- /dev/null
+++ b/tests/csky/dspv2/case/sub_u64_s.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn sub.u64.s\n");
+
+    for (i = 0;
+         i < sizeof(samples_sub_u64_s)/sizeof(struct binary64_64_64_calculation);
+         i++) {
+        TEST(test_sub_u64_s(samples_sub_u64_s[i].op1, samples_sub_u64_s[i].op2)
+                     == samples_sub_u64_s[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/subh_s32.c b/tests/csky/dspv2/case/subh_s32.c
new file mode 100644
index 0000000..e1433bd
--- /dev/null
+++ b/tests/csky/dspv2/case/subh_s32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn subh.s32\n");
+
+    for (i = 0;
+         i < sizeof(samples_subh_s32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_subh_s32(samples_subh_s32[i].op1, samples_subh_s32[i].op2)
+                     == samples_subh_s32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/case/subh_u32.c b/tests/csky/dspv2/case/subh_u32.c
new file mode 100644
index 0000000..ca785b3
--- /dev/null
+++ b/tests/csky/dspv2/case/subh_u32.c
@@ -0,0 +1,17 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "dspv2_insn.h"
+#include "sample_array.h"
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing insn subh.u32\n");
+
+    for (i = 0;
+         i < sizeof(samples_subh_u32)/sizeof(struct binary_calculation);
+         i++) {
+        TEST(test_subh_u32(samples_subh_u32[i].op1, samples_subh_u32[i].op2)
+                     == samples_subh_u32[i].result);
+    }
+    return done_testing();
+}
diff --git a/tests/csky/dspv2/runcase_dspv2.sh b/tests/csky/dspv2/runcase_dspv2.sh
new file mode 100755
index 0000000..e73a1cc
--- /dev/null
+++ b/tests/csky/dspv2/runcase_dspv2.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+num_total=0
+num_fail=0
+
+make
+cd case
+for file in *.elf
+do
+    cmd="qemu-system-cskyv2 -machine smartl -kernel $file -nographic"
+    $cmd
+    if [ $? -ne 0 ]
+    then
+        num_fail=`expr $num_fail + 1`
+    fi
+    num_total=`expr $num_total + 1`
+done
+
+echo "\n------sumary------"
+echo "Total  case: $num_total"
+echo "Failed case: $num_fail"
+echo "------------------\n"
+
+cd ..
+make clean
diff --git a/tests/csky/fpu/Makefile b/tests/csky/fpu/Makefile
new file mode 100644
index 0000000..40dc4c8
--- /dev/null
+++ b/tests/csky/fpu/Makefile
@@ -0,0 +1,29 @@
+CORE_OBJ = core 
+BOARD_DIR = ../board/smartl/ck803s
+CFLAGS = -g2 -mcpu=ck803efr1 
+TARGET_CROSS = csky-abiv2-elf
+
+CC = $(TARGET_CROSS)-gcc
+
+ROOTDIR = $(shell pwd)/
+srcdir = $(ROOTDIR)../
+EXPECT = expect
+RUNTEST = runtest
+RUNTESTFLAGS =
+
+all: core
+
+core:
+	@echo "  CC    $(BOARD_DIR)/crt0.o"
+	@$(CC) -c $(CFLAGS) $(BOARD_DIR)/crt0.S -o $(BOARD_DIR)/crt0.o
+	@echo "  CC    $(BOARD_DIR)/uart.o"
+	@$(CC) -c $(CFLAGS) $(BOARD_DIR)/uart.c -o $(BOARD_DIR)/uart.o
+	make -C case
+
+clean:
+	rm -f $(BOARD_DIR)/*.o
+	rm -f core
+	make -C case clean
+
+
+
diff --git a/tests/csky/fpu/case/Makefile b/tests/csky/fpu/case/Makefile
new file mode 100644
index 0000000..453601a
--- /dev/null
+++ b/tests/csky/fpu/case/Makefile
@@ -0,0 +1,22 @@
+SRC = $(wildcard *.c) $(sample_array.c)
+SRS = $(wildcard *.S)
+OBJFILE = $(SRS:%.S=%.o) $(SRC:%.c=%)
+BOARD_DIR = ../../board/smartl/ck803s
+INCLUDE = -I../../include -I$(BOARD_DIR)
+CFLAGS = -g2 -O2 -mcpu=ck803efr1 -msoft-float
+all: case
+
+case: $(OBJFILE)
+
+%.o: %.S
+	@echo "  CC    case/$@"
+	@csky-abiv2-elf-gcc $(CFLAGS) -c $(INCLUDE) -o $@  $<
+
+%: %.c
+	@echo "  CC    case/$@.o"
+	@csky-abiv2-elf-gcc $(CFLAGS) -c $(INCLUDE) -O2 -o $@.o  $<
+	@echo "  CC    case/$@.elf"
+	@csky-abiv2-elf-gcc $(CFLAGS) $(BOARD_DIR)/uart.o $(BOARD_DIR)/crt0.o fpu_insn.o -T$(BOARD_DIR)/ckcpu.ld -nostartfiles -lgcc $@.o -o $@.elf
+	@#csky-abiv2-elf-objdump -S $@.elf > $@.asm
+clean:
+	rm -rf  *.o *.a *.asm *.elf
diff --git a/tests/csky/fpu/case/fpu_insn.S b/tests/csky/fpu/case/fpu_insn.S
new file mode 100644
index 0000000..8d1496d
--- /dev/null
+++ b/tests/csky/fpu/case/fpu_insn.S
@@ -0,0 +1,95 @@
+   .file   "fpu_insn.S"
+#undef TEST_FUNC
+#define TEST_FUNC(name) TEST_FUNC_M name
+    .macro TEST_FUNC_M name
+    .text
+    .align  2
+    .global \name
+    .type   \name, @function
+\name:
+    .endm
+
+TEST_FUNC(test_ide)
+    lrw     r0, 0x20008000
+    lrw     r1, 0x0000ffff
+    stw     r1, (r0, 0)
+    flds    vr1, (r0, 0)
+    movi    r0, 0
+    mtcr    r0, cr<2, 2>
+    fstosi.rz   vr1, vr1
+    mfcr    r0, cr<2, 2>
+    rts
+    .size   test_ide, .-test_ide
+
+TEST_FUNC(test_ioe)
+    lrw     r0, 0x20008000
+    lrw     r1, 0xff800000
+    lrw     r2, 0x7f800000
+    stw     r1, (r0, 0)
+    stw     r2, (r0, 4)
+    flds    vr1, (r0, 0)
+    flds    vr2, (r0, 4)
+    movi    r0, 0
+    mtcr    r0, cr<2, 2>
+    fadds   vr1, vr1, vr2
+    mfcr    r0, cr<2, 2>
+    rts
+    .size   test_ioe, .-test_ioe
+
+TEST_FUNC(test_dze)
+    lrw     r0, 0x20008000
+    lrw     r1, 0x00000000
+    stw     r1, (r0, 0)
+    flds    vr1, (r0, 0)
+    fmovis  vr2, -1.5
+    movi    r0, 0
+    mtcr    r0, cr<2, 2>
+    fdivs   vr1, vr2, vr1
+    mfcr    r0, cr<2, 2>
+    rts
+    .size   test_dze, .-test_dze
+
+TEST_FUNC(test_ofe)
+    lrw     r0, 0x20008000
+    lrw     r1, 0x7f7fffff
+    stw     r1, (r0, 0)
+    flds    vr1, (r0, 0)
+    fmovis  vr2, 2
+    movi    r0, 0
+    mtcr    r0, cr<2, 2>
+    fmuls   vr1, vr2, vr1
+    mfcr    r0, cr<2, 2>
+    rts
+    .size   test_ofe, .-test_ofe
+
+TEST_FUNC(test_ufe)
+    lrw     r0, 0x20008000
+    lrw     r1, 0x00800001
+    stw     r1, (r0, 0)
+    flds    vr1, (r0, 0)
+    fmovis  vr2, 2
+    movi    r0, 0
+    mtcr    r0, cr<2, 2>
+    fdivs   vr1, vr1, vr2
+    mfcr    r0, cr<2, 2>
+    rts
+    .size   test_ufe, .-test_ufe
+
+TEST_FUNC(test_ixe)
+    lrw     r0, 0x20008000
+    lrw     r1, 0x7f7fffff
+    stw     r1, (r0, 0)
+    flds    vr1, (r0, 0)
+    fmovis  vr2, 1.5
+    movi    r0, 0
+    mtcr    r0, cr<2, 2>
+    fadds   vr1, vr2, vr1
+    mfcr    r0, cr<2, 2>
+    rts
+    .size   test_ixe, .-test_ixe
+
+
+
+
+
+
diff --git a/tests/csky/fpu/case/fpu_insn.h b/tests/csky/fpu/case/fpu_insn.h
new file mode 100644
index 0000000..e1f8dc7
--- /dev/null
+++ b/tests/csky/fpu/case/fpu_insn.h
@@ -0,0 +1,9 @@
+#ifndef FPU_INSN_H
+#define FPU_INSN_H
+int32_t test_ide();
+int32_t test_ioe();
+int32_t test_dze();
+int32_t test_ofe();
+int32_t test_ufe();
+int32_t test_ixe();
+#endif
diff --git a/tests/csky/fpu/case/test_exception.c b/tests/csky/fpu/case/test_exception.c
new file mode 100644
index 0000000..80d9982
--- /dev/null
+++ b/tests/csky/fpu/case/test_exception.c
@@ -0,0 +1,76 @@
+#include "testsuite.h"
+#include "test_device.h"
+#include "fpu_insn.h"
+
+void init_fesr()
+{
+    __asm("movi  r0, 0");
+    __asm("mtcr r0, cr<2, 2>");
+}
+
+void enable_float_exception()
+{
+    __asm("mfcr  r0, cr<1, 2>");
+    __asm("ori   r0, r0, 0x3f");
+    __asm("mtcr  r0, cr<1, 2>");
+}
+
+
+int main(void)
+{
+    int i = 0;
+    init_testsuite("Testing fpu insn exception.\n");
+    printf("[A]. Float Exception Disable Mode:\n");
+    init_fesr();
+    printf("  1. test Input Denormalized Exception.\n");
+    TEST(test_ide() == 0xa0a0);
+
+    init_fesr();
+    printf("  2. test Invalid Operation Exception.\n");
+    TEST(test_ioe() == 0x8181);
+
+    init_fesr();
+    printf("  3. test Divide by Zero Exception.\n");
+    TEST(test_dze() == 0x8282);
+
+    init_fesr();
+    printf("  4. test Overflow Exception.\n");
+    TEST(test_ofe() == 0x9494);
+
+    init_fesr();
+    printf("  5. test Underflow Exception.\n");
+    TEST(test_ufe() == 0x9898);
+
+    init_fesr();
+    printf("  6. test InExact Exception.\n");
+    TEST(test_ixe() == 0x9090);
+
+    /*-----------------------------------------------*/
+
+    printf("[B]. Float Exception Ensable Mode:\n");
+    enable_float_exception();
+    printf("  1. test Input Denormalized Exception.\n");
+    TEST(test_ide() == 0xa0);
+
+    init_fesr();
+    printf("  2. test Invalid Operation Exception.\n");
+    TEST(test_ioe() == 0x81);
+
+    init_fesr();
+    printf("  3. test Divide by Zero Exception.\n");
+    TEST(test_dze() == 0x82);
+
+    init_fesr();
+    printf("  4. test Overflow Exception.\n");
+    TEST(test_ofe() == 0x94);
+
+    init_fesr();
+    printf("  5. test Underflow Exception.\n");
+    TEST(test_ufe() == 0x98);
+
+    init_fesr();
+    printf("  6. test InExact Exception.\n");
+    TEST(test_ixe() == 0x90);
+
+    return done_testing();
+}
diff --git a/tests/csky/fpu/runcase_fpu.sh b/tests/csky/fpu/runcase_fpu.sh
new file mode 100755
index 0000000..73988a8
--- /dev/null
+++ b/tests/csky/fpu/runcase_fpu.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+num_total=0
+num_fail=0
+
+make
+cd case
+for file in *.elf
+do
+    cmd="qemu-system-cskyv2 -machine smartl -cpu ck803efr1 -kernel $file -nographic"
+    $cmd
+    if [ $? -ne 0 ]
+    then
+        num_fail=`expr $num_fail + 1`
+    fi
+    num_total=`expr $num_total + 1`
+done
+
+echo "\n------sumary------"
+echo "Total  case: $num_total"
+echo "Failed case: $num_fail"
+echo "------------------\n"
+
+cd ..
+make clean
diff --git a/tests/csky/include/test_device.h b/tests/csky/include/test_device.h
new file mode 100644
index 0000000..d0b2308
--- /dev/null
+++ b/tests/csky/include/test_device.h
@@ -0,0 +1,90 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#ifndef TEST_DEVICE_H
+#define TEST_DEVICE_H
+
+#include "smartl_ck803s.h"
+#define CSKY_MATH_CK803S
+
+
+struct unary_calculation {
+    uint32_t op1;
+    uint32_t result;
+};
+
+struct unary64_calculation {
+    uint32_t op1;
+    uint64_t result;
+};
+
+struct binary_calculation {
+    uint32_t op1;
+    uint32_t op2;
+    uint32_t result;
+};
+
+struct binary64_calculation {
+    uint32_t op1;
+    uint32_t op2;
+    uint64_t result;
+};
+
+struct binary64_64_calculation {
+   uint64_t op1;
+   uint32_t op2;
+   uint64_t result;
+};
+
+struct ternary_calculation {
+    uint32_t op1;
+    uint32_t op2;
+    uint32_t op3;
+    uint32_t result;
+};
+
+struct ternary64_calculation {
+    uint32_t op1;
+    uint32_t op2;
+    uint64_t op3;
+    uint64_t result;
+};
+
+struct quanary_calculation {
+   uint32_t op1;
+   uint32_t op2;
+   uint32_t op3;
+   uint32_t op4;
+   uint32_t result;
+};
+
+struct binary64_64_64_calculation {
+    uint64_t op1;
+    uint64_t op2;
+    uint64_t result;
+};
+#endif  /* TEST_DEVICE_H */
diff --git a/tests/csky/include/testsuite.h b/tests/csky/include/testsuite.h
new file mode 100644
index 0000000..11c8c38
--- /dev/null
+++ b/tests/csky/include/testsuite.h
@@ -0,0 +1,185 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+
+/* vi: set sw=4 ts=4: */
+/*
+ * Some simple macros for use in test applications.
+ * Copyright (C) 2000-2006 by Erik Andersen <andersen@uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#ifndef TESTSUITE_H
+#define TESTSUITE_H
+
+#ifdef __NO_TESTCODE__
+extern int test_number;
+#endif
+#include <stdio.h>
+extern void init_testsuite(const char* testname);
+extern int  done_testing(void) ;//__attribute__((noreturn));
+extern void success_msg(int result, const char* command);
+extern void error_msg(int result, int line, const char* file, const char* command);
+
+#ifndef __NO_TESTCODE__
+
+int test_number = 0;
+static int failures = 0;
+
+void error_msg(int result, int line, const char* file, const char* command)
+{
+	failures++;
+
+	printf("\nFAILED TEST %lu: \n\t%s\n", (unsigned long)test_number, command);
+	printf("AT LINE: %d, FILE: %s\n\n", line, file);
+}
+
+void success_msg(int result, const char* command)
+{
+#if 0
+	printf("passed test: %s == 0\n", command);
+#endif
+}
+
+int  done_testing(void)
+{
+    if (0 < failures) {
+		printf("Failed %d tests\n", failures);
+		//exit(EXIT_FAILURE);
+	} else {
+		printf("All functions tested sucessfully\n");
+		///exit(EXIT_SUCCESS);
+	}
+	return failures;
+}
+
+void init_testsuite(const char* testname)
+{
+	printf("%s", testname);
+	test_number = 0;
+	failures = 0;
+#if !defined(__UCLIBC__) || defined(__UCLIBC_DYNAMIC_ATEXIT__)
+//	atexit(done_testing);
+#endif
+}
+
+#endif /* __NO_TESTCODE__ */
+
+
+#define TEST_STRING_OUTPUT(command, expected_result) \
+	do { \
+		int result = strcmp(command, expected_result); \
+		test_number++; \
+		if (result == 0.000000) { \
+			success_msg(result, "command"); \
+		} else { \
+			error_msg(result, __LINE__, __FILE__, command); \
+		}; \
+	} while (0)
+
+#define TEST_NUMERIC(command, expected_result) \
+	do { \
+		int result = (command); \
+		test_number++; \
+		if (result == expected_result) { \
+			success_msg(result, # command); \
+		} else { \
+			error_msg(result, __LINE__, __FILE__, # command); \
+		}; \
+	} while (0)
+
+
+#define TEST(command) \
+	do { \
+		int __result = (command); \
+		test_number++; \
+		if (__result == 1) { \
+			success_msg(__result, # command); \
+		} else { \
+			error_msg(__result, __LINE__, __FILE__,  # command); \
+		}; \
+	} while (0)
+
+#define TEST_NULL(command) \
+    do { \
+        int result = (command); \
+        test_number++; \
+        if (result == NULL) { \
+            success_msg(result, # command); \
+        } else { \
+            error_msg(result, __LINE__, __FILE__,  # command); \
+        }; \
+    } while (0)
+
+#define TEST_NUMERIC_LONG(command, expected_result) \
+    do { \
+        long result = (command); \
+        test_number++; \
+        if (result == expected_result) { \
+            success_msg(result, # command); \
+        } else { \
+            error_msg(result, __LINE__, __FILE__, # command); \
+        }; \
+    } while (0)
+
+#define TEST_NUMERIC_LONGLONG(command, expected_result) \
+    do { \
+       long long result = (command); \
+        test_number++; \
+        if (result == expected_result) { \
+            success_msg(result, # command); \
+        } else { \
+            error_msg(result, __LINE__, __FILE__, # command); \
+        }; \
+    } while (0)
+
+#define TEST_NUMERIC_FLOAT(command, expected_result) \
+    do { \
+       float result = (command); \
+        test_number++; \
+        if (result == expected_result) { \
+            success_msg(result, # command); \
+        } else { \
+            error_msg(result, __LINE__, __FILE__, # command); \
+        }; \
+    } while (0)
+
+#define TEST_NUMERIC_DOUBLE(command, expected_result) \
+    do { \
+        double result = (command); \
+        test_number++; \
+        if (result == expected_result) { \
+            success_msg(result, # command); \
+        } else { \
+            error_msg(result, __LINE__, __FILE__, # command); \
+        }; \
+    } while (0)
+
+#define STR_CMD(cmd) cmd
+
+#endif	/* TESTSUITE_H */
diff --git a/tests/csky/nvic/Makefile b/tests/csky/nvic/Makefile
new file mode 100644
index 0000000..9cb976d
--- /dev/null
+++ b/tests/csky/nvic/Makefile
@@ -0,0 +1,30 @@
+CORE_OBJ = csi.core.elf
+BOARD_DIR = ../board/smartl/ck803s
+CFLAGS = -g2 -mcpu=ck803r1 -msoft-float
+TARGET_CROSS = csky-abiv2-elf
+
+CC = $(TARGET_CROSS)-gcc
+
+ROOTDIR = $(shell pwd)/
+srcdir = $(ROOTDIR)../
+EXPECT = expect
+RUNTEST = runtest
+RUNTESTFLAGS =
+
+all: core
+
+core:
+	@echo "  CC    $(BOARD_DIR)/crt0.o"
+	@$(CC) -c $(CFLAGS) $(BOARD_DIR)/crt0.S -o $(BOARD_DIR)/crt0.o
+	@echo "  CC    $(BOARD_DIR)/uart.o"
+	@$(CC) -c $(CFLAGS) $(BOARD_DIR)/uart.c -o $(BOARD_DIR)/uart.o
+	make -C case
+
+clean:
+	rm -f $(BOARD_DIR)/*.o
+	rm -f site.exp
+	rm -rf testresult
+	make -C case clean
+
+
+
diff --git a/tests/csky/nvic/case/Makefile b/tests/csky/nvic/case/Makefile
new file mode 100644
index 0000000..6ea56ea
--- /dev/null
+++ b/tests/csky/nvic/case/Makefile
@@ -0,0 +1,22 @@
+SRC = $(wildcard *.c)
+SRS = $(wildcard *.S)
+OBJFILE = $(SRS:%.S=%.o) $(SRC:%.c=%)
+BOARD_DIR = ../../board/smartl/ck803s
+INCLUDE = -I../../include -I$(BOARD_DIR)
+CFLAGS = -g2 -O2 -mcpu=ck803r1 -msoft-float
+all: case
+
+case: $(OBJFILE)
+
+%.o: %.S
+	@echo "  CC    case/$@"
+	@csky-abiv2-elf-gcc $(CFLAGS) -c $(INCLUDE) -o $@  $<
+
+%: %.c
+	@echo "  CC    case/$@.o"
+	@csky-abiv2-elf-gcc $(CFLAGS) -c $(INCLUDE) -O2 -o $@.o  $<
+	@echo "  CC    case/$@.elf"
+	@csky-abiv2-elf-gcc $(CFLAGS) $(BOARD_DIR)/uart.o $(BOARD_DIR)/crt0.o nvic_insn.o -T$(BOARD_DIR)/ckcpu.ld -nostartfiles -lgcc $@.o -o $@.elf
+	@#csky-abiv2-elf-objdump -S $@.elf > $@.asm
+clean:
+	rm -rf  *.o *.a *.asm *.elf
diff --git a/tests/csky/nvic/case/ipop.c b/tests/csky/nvic/case/ipop.c
new file mode 100644
index 0000000..38774d7
--- /dev/null
+++ b/tests/csky/nvic/case/ipop.c
@@ -0,0 +1,44 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "nvic_insn.h"
+#define TEST_TIMES      1
+int main(void)
+{
+    init_testsuite("Testing insn ipop \n");
+
+    /*
+     * ipop
+     * {r0~r3, r12, r13} = MEM[sp]~MEM[sp + 20], sp = sp + 24
+     * if test_ipop return 0, succeed, otherwise, fail.
+     */
+    TEST(test_ipop() == 0);
+    return done_testing();
+}
+
diff --git a/tests/csky/nvic/case/ipush.c b/tests/csky/nvic/case/ipush.c
new file mode 100644
index 0000000..4b93397
--- /dev/null
+++ b/tests/csky/nvic/case/ipush.c
@@ -0,0 +1,44 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "nvic_insn.h"
+#define TEST_TIMES      1
+int main(void)
+{
+    init_testsuite("Testing insn ipush \n");
+
+    /*
+     * ipush
+     * MEM[sp-4]~MEM[sp - 24] = {r13, r12, r3~r0}, sp=sp - 24
+     * if test_ipush return 0, succeed, otherwise, fail.
+     */
+    TEST(test_ipush() == 0);
+    return done_testing();
+}
+
diff --git a/tests/csky/nvic/case/nie.c b/tests/csky/nvic/case/nie.c
new file mode 100644
index 0000000..82050ee
--- /dev/null
+++ b/tests/csky/nvic/case/nie.c
@@ -0,0 +1,44 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "nvic_insn.h"
+#define TEST_TIMES      1
+int main(void)
+{
+    init_testsuite("Testing insn nie \n");
+
+    /*
+     * nie
+     * MEM[sp-4] = epc; MEM[sp-8] = epsr; sp = sp - 8; psr({ee,ie}) = 1
+     * if test_nie return 0, succeed, otherwise, fail.
+     */
+    TEST(test_nie() == 0);
+    return done_testing();
+}
+
diff --git a/tests/csky/nvic/case/nir.c b/tests/csky/nvic/case/nir.c
new file mode 100644
index 0000000..bf281bc
--- /dev/null
+++ b/tests/csky/nvic/case/nir.c
@@ -0,0 +1,44 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+#include "nvic_insn.h"
+#define TEST_TIMES      1
+int main(void)
+{
+    init_testsuite("Testing insn nir \n");
+
+    /*
+     * nir
+     * epsr = MEM[sp]; epc = MEM[sp+4]; sp = sp + 8; psr = epsr; pc =epc
+     * if test_nir return 0, succeed, otherwise, fail.
+     */
+    TEST(test_nir() == 0);
+    return done_testing();
+}
+
diff --git a/tests/csky/nvic/case/nvic.c b/tests/csky/nvic/case/nvic.c
new file mode 100644
index 0000000..8fbce97
--- /dev/null
+++ b/tests/csky/nvic/case/nvic.c
@@ -0,0 +1,64 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+
+int main(void)
+{
+	int i = 0;
+	uint8_t *p;
+
+	init_testsuite("Testing NVIC api\n");
+
+	TEST(&(NVIC->ISER) == (uint32_t *)0xE000E100);
+	TEST(&(NVIC->IWER) == (uint32_t *)0xE000E140);
+	TEST(&(NVIC->ICER) == (uint32_t *)0xE000E180);
+	TEST(&(NVIC->ICPR) == (uint32_t *)0xE000E280);
+	TEST(&(NVIC->IABR) == (uint32_t *)0xE000E300);
+	TEST(&(NVIC->IPR) == (uint32_t *)0xE000E400);
+	TEST(&(NVIC->ISR) == (uint32_t *)0xE000EC00);
+	TEST(&(NVIC->IPTR) == (uint32_t *)0xE000EC04);
+
+	unsigned char free_mem[0x1000];
+
+#undef NVIC
+#define NVIC	((NVIC_Type *) free_mem)
+
+	p = (uint8_t *)free_mem;
+
+	NVIC->IWER[0] = 0x12345678;
+	TEST(*(uint32_t *)(p + 0x40) == 0x12345678);
+
+	NVIC->IABR[0] = 0x22345678;
+	TEST(*(uint32_t *)(p + 0x200) == 0x22345678);
+
+	NVIC->IPTR = 0x32345678;
+	TEST(*(uint32_t *)(p + 0xB04) == 0x32345678);
+
+	return done_testing();
+}
diff --git a/tests/csky/nvic/case/nvic_insn.S b/tests/csky/nvic/case/nvic_insn.S
new file mode 100644
index 0000000..6ec6311
--- /dev/null
+++ b/tests/csky/nvic/case/nvic_insn.S
@@ -0,0 +1,156 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+   .file   "nvic_insn.S"
+
+#undef  TEST_FUNC
+#define TEST_FUNC(name) TEST_FUNC_M name
+    .macro TEST_FUNC_M name
+    .text
+    .align  2
+    .global \name
+    .type   \name, @function
+\name:
+    .endm
+
+TEST_FUNC(test_ipop)
+    push    r4-r11, r15
+    lrw     r4, 0x00000000
+    lrw     r5, 0x00000001
+    lrw     r6, 0x12345678
+    lrw     r7, 0x7fffffff
+    lrw     r8, 0x80000000
+    lrw     r9, 0xffffffff
+    push    r4-r9
+    ipop
+    cmpne   r0, r4
+    bt      ipop_false
+    cmpne   r1, r5
+    bt      ipop_false
+    cmpne   r2, r6
+    bt      ipop_false
+    cmpne   r3, r7
+    bt      ipop_false
+    cmpne   r12, r8
+    bt      ipop_false
+    cmpne   r13, r9
+    bt      ipop_false
+    movi    a0, 0
+    br      ipop_end
+ipop_false:
+    movi    a0, 1
+ipop_end:
+    pop r4-r11, r15
+    rts
+    .size   test_ipop, .-test_ipop
+
+TEST_FUNC(test_ipush)
+    push    r4-r8
+    lrw     r0, 0x00000000
+    lrw     r1, 0x00000001
+    lrw     r2, 0x12345678
+    lrw     r3, 0x7fffffff
+    lrw     r12, 0x80000000
+    lrw     r13, 0xffffffff
+    ipush
+    mov     r8, sp
+    ld.w    r4, (r8, 0)
+    cmpne   r0, r4
+    bt      ipush_false
+    ld.w    r4, (r8, 4)
+    cmpne   r1, r4
+    bt      ipush_false
+    ld.w    r4, (r8, 8)
+    cmpne   r2, r4
+    bt      ipush_false
+    ld.w    r4, (r8, 12)
+    cmpne   r3, r4
+    bt      ipush_false
+    ld.w    r4, (r8, 16)
+    cmpne   r12, r4
+    bt      ipush_false
+    ld.w    r4, (r8, 20)
+    cmpne   r13, r4
+    bt      ipush_false
+    movi    a0, 0
+    br      ipush_end
+ipush_false:
+    movi    a0, 1
+ipush_end:
+    addi sp, sp, 24
+    pop     r4-r8
+    rts
+    .size   test_ipush, .-test_ipush
+
+TEST_FUNC(test_nie)
+    push r4-r11, r15
+    psrclr  ee, ie
+    mfcr    r4, cr<2,0>   //epsr
+    mfcr    r5, cr<4,0>   //epc
+    nie
+    mov     r8, sp
+    ld.w    r6, (r8, 0)
+    cmpne   r4, r6
+    bt      nie_fail
+    ld.w    r6, (r8, 4)
+    cmpne   r5, r6
+    bt      nie_fail
+    mfcr    r4, cr<0,0>   //psr
+    andi    r4, r4, 0x140 //psr{ee, ie} = 1
+    cmpnei  r4, 0x140
+    bt      nie_fail
+    movi    a0, 0
+    br      nie_end
+nie_fail:
+    movi    a0, 1
+nie_end:
+    addi sp, sp, 8
+    pop r4-r11, r15
+    rts
+    .size   test_nie, .-test_nie
+
+TEST_FUNC(test_sub_nir)
+    mfcr    r4, cr<0,0>   //psr
+    push    r4, r15
+    mov     a0, r4
+    nir
+    .size   test_sub_nir, .-test_sub_nir
+
+TEST_FUNC(test_nir)
+    push r4, r15
+    bsr test_sub_nir
+    mfcr    r4, cr<0,0>   //psr
+    cmpne   a0, r4
+    bt      nir_fail
+    movi    a0, 0
+    br      nir_end
+nir_fail:
+    movi    a1, 1
+nir_end:
+    pop r4, r15
+    .size   test_nir, .-test_nir
+
diff --git a/tests/csky/nvic/case/nvic_insn.h b/tests/csky/nvic/case/nvic_insn.h
new file mode 100644
index 0000000..b5ef7e6
--- /dev/null
+++ b/tests/csky/nvic/case/nvic_insn.h
@@ -0,0 +1,36 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#ifndef NVIC_INSN_H
+#define NVIC_INSN_H
+
+int32_t test_ipop(void);
+int32_t test_ipush(void);
+int32_t test_nie(void);
+int32_t test_nir(void);
+
+#endif /* NVIC_INSN_H */
diff --git a/tests/csky/nvic/case/nvic_test.c b/tests/csky/nvic/case/nvic_test.c
new file mode 100644
index 0000000..4adc789
--- /dev/null
+++ b/tests/csky/nvic/case/nvic_test.c
@@ -0,0 +1,235 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+
+#define USER1_INT_PRIO   3
+#define USER2_INT_PRIO   2 
+#define USER3_INT_PRIO   1 
+#define NVIC_THRESHOLD   0  
+#define USER1_IRQ        3
+#define USER2_IRQ        4 
+#define USER3_IRQ        5     
+static volatile int tick_count;
+
+int coretimer_irq_handler(void)
+{
+    int temp;
+    tick_count++;
+	if ((tick_count == 9876) || (tick_count == 98)) 
+	{
+		printf("tick = %d\n", tick_count);
+	printf("----------------------------------------\n");
+	}
+
+}
+
+void user1_int_irq_handler(void)
+{ 
+	int NVIC_Pend=0;
+ 	int NVIC_Active = 0;
+	int NVIC_wakeup1 = 0;
+	printf("--------start user1 irq handler!\n");
+	
+	NVIC_Active=NVIC_GetActive(USER1_IRQ);
+        TEST(NVIC_Active);
+        if(NVIC_Active)
+ 		printf("User1  NVIC_Active successed!\n");
+        NVIC_wakeup1=NVIC_GetWakeupIRQ(USER1_IRQ);
+        TEST(NVIC_wakeup1);
+        if(NVIC_wakeup1)
+        printf("User1 NVIC_SetWakeupIRQ successed!\n");
+
+   	NVIC_ClearPendingIRQ(USER1_IRQ );
+ 	NVIC_DisableIRQ(USER1_IRQ );
+
+        __disable_irq();
+	NVIC_SetPendingIRQ(USER2_IRQ );
+
+	NVIC_Pend= NVIC_GetPendingIRQ(USER2_IRQ);
+        __enable_irq();
+        TEST(NVIC_Pend);
+        if(NVIC_Pend)
+            printf("User2 NVIC_SetPending successed!\n");
+       
+        printf("--------User1 irq handle successed!\n");
+} 
+
+void user2_int_irq_handler(void)
+{ 
+	int NVIC_Pend=0;
+ 	int NVIC_Active = 0;
+	int NVIC_wakeup2 = 0;
+	printf("--------start user2 irq handler!\n");
+	
+	NVIC_Active=NVIC_GetActive(USER2_IRQ);
+        TEST(NVIC_Active);
+        if(NVIC_Active)
+ 		printf("User2  NVIC_Active successed!\n");
+        NVIC_wakeup2=NVIC_GetWakeupIRQ(USER2_IRQ);
+        TEST(NVIC_wakeup2);
+        if(NVIC_wakeup2)
+        printf("User2 NVIC_SetWakeupIRQ successed!\n");
+#if __CK80X < 3
+        NVIC_SetThreshold(USER2_IRQ,NVIC_THRESHOLD);
+#endif
+   	NVIC_ClearPendingIRQ(USER2_IRQ );
+ 	NVIC_DisableIRQ(USER2_IRQ );
+
+        __disable_irq();
+	NVIC_SetPendingIRQ(USER3_IRQ );
+
+	NVIC_Pend= NVIC_GetPendingIRQ(USER3_IRQ);
+        __enable_irq();
+        TEST(NVIC_Pend);
+        if(NVIC_Pend)
+            printf("User3 NVIC_SetPending successed!\n");
+       
+        printf("--------User2 irq handle successed!\n");
+} 
+void user3_int_irq_handler(void)
+{ 
+	int NVIC_Pend=0;
+	int NVIC_Active = 0;
+	int NVIC_wakeup3 = 0;
+	printf("--------Start user3 irq handler!\n");
+	
+	NVIC_Active=NVIC_GetActive(USER3_IRQ);
+        TEST(NVIC_Active);
+        if(NVIC_Active)
+ 		printf("User3  NVIC_Active successed!\n");
+ 	NVIC_wakeup3=NVIC_GetWakeupIRQ(USER3_IRQ);
+        TEST(NVIC_wakeup3);
+        if(NVIC_wakeup3)
+        printf("User3 NVIC_SetWakeupIRQ successed!\n");
+      
+	NVIC_ClearPendingIRQ(USER3_IRQ);
+	NVIC_DisableIRQ(USER3_IRQ);
+        printf("--------User3 irq handle successed!\n");
+} 
+
+
+void user1_int(IRQn_Type IRQn, uint32_t priority)
+{
+	int NVIC_Priority = 0;
+        int NVIC_Active = 0;
+        init_testsuite("Testing User1 int  function!\n");
+	NVIC_SetPriority(IRQn, priority);
+        NVIC_SetWakeupIRQ(IRQn);
+	NVIC_EnableIRQ(IRQn);
+        NVIC_Priority=NVIC_GetPriority(IRQn);
+        TEST(NVIC_Priority==USER1_INT_PRIO);
+        if(NVIC_Priority==USER1_INT_PRIO)
+            printf("User1 NVIC_SetPriority IRQ successed!\n");
+        printf("----------------------------------------\n");
+}
+
+void user2_int(IRQn_Type IRQn, uint32_t priority)
+{
+	int NVIC_Priority = 0;
+	int NVIC_Active = 0;
+        init_testsuite("Testing User2 int  function!\n");
+	NVIC_SetPriority(IRQn, priority);
+        NVIC_SetWakeupIRQ(IRQn);
+        NVIC_EnableIRQ(IRQn);
+        NVIC_Priority=NVIC_GetPriority(IRQn);
+        TEST(NVIC_Priority==USER2_INT_PRIO);
+        if(NVIC_Priority==USER2_INT_PRIO)
+            printf("User2 NVIC_SetPriority IRQ successed!\n");
+        printf("----------------------------------------\n");
+}
+
+void user3_int(IRQn_Type IRQn, uint32_t priority)
+{
+	int NVIC_Priority = 0;
+	int NVIC_Active = 0;
+        init_testsuite("Testing User3 int  function!\n");
+	NVIC_SetPriority(IRQn, priority);
+        NVIC_SetWakeupIRQ(IRQn);
+        NVIC_EnableIRQ(IRQn);
+        NVIC_Priority=NVIC_GetPriority(IRQn);
+        TEST(NVIC_Priority==USER3_INT_PRIO);
+        if(NVIC_Priority==USER3_INT_PRIO)
+            printf("User3 NVIC_SetPriority IRQ successed!\n");
+        printf("----------------------------------------\n");
+}
+int main(void)
+{
+	int i = 0;
+        int NVIC_Priority; 
+	int NVIC_Pend=0;
+        int NVIC_wakeup = 1;
+
+	init_testsuite("-*************Testing functions NVIC function********************\n");
+	SysTick_Config(10000);
+	NVIC_EnableIRQ (CORET_IRQn);
+        __enable_irq();
+
+	while (1) 
+	{
+		if (tick_count >10000) 
+                {
+			
+			NVIC_SetPendingIRQ(USER1_IRQ);
+			NVIC_Pend= NVIC_GetPendingIRQ(USER1_IRQ);
+                        TEST(NVIC_Pend);
+ 			if(NVIC_Pend)
+        		printf("User1 NVIC_SetPending successed!\n");
+			break;
+		}
+	}
+        NVIC_Priority=NVIC_GetPriority(CORET_IRQn);
+        printf("CORET_INT Prioriyt =%d \n",NVIC_Priority);
+        NVIC_DisableIRQ(CORET_IRQn);
+        user3_int(USER3_IRQ,USER3_INT_PRIO);
+	user2_int(USER2_IRQ,USER2_INT_PRIO);
+	user1_int(USER1_IRQ,USER1_INT_PRIO);
+	
+        NVIC_ClearWakeupIRQ(USER1_IRQ);
+        NVIC_wakeup=NVIC_GetWakeupIRQ(USER1_IRQ);
+ 	TEST(!NVIC_wakeup);
+        if(!NVIC_wakeup)
+        printf("User1 NVIC_ClearWakeupIRQ successed!\n");
+        NVIC_wakeup=1;
+
+        NVIC_ClearWakeupIRQ(USER2_IRQ);
+ 	NVIC_wakeup=NVIC_GetWakeupIRQ(USER2_IRQ);
+	TEST(!NVIC_wakeup);
+        if(!NVIC_wakeup)
+        printf("User2 NVIC_ClearWakeupIRQ successed!\n");
+ 	NVIC_wakeup=1;
+
+        NVIC_ClearWakeupIRQ(USER3_IRQ);
+ 	NVIC_wakeup=NVIC_GetWakeupIRQ(USER3_IRQ);
+
+	TEST(!NVIC_wakeup);
+        if(!NVIC_wakeup)
+        printf("User3 NVIC_ClearWakeupIRQ successed!\n");
+
+	return done_testing();
+}
diff --git a/tests/csky/nvic/case/nvic_test2.c b/tests/csky/nvic/case/nvic_test2.c
new file mode 100644
index 0000000..c3c6666
--- /dev/null
+++ b/tests/csky/nvic/case/nvic_test2.c
@@ -0,0 +1,192 @@
+/* ---------------------------------------------------------------------------
+ * Copyright (C) 2016 CSKY Limited. All rights reserved.
+ *
+ * Redistribution and use of this software in source and binary forms,
+ * with or without modification, are permitted provided that the following
+ * conditions are met:
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *   * Neither the name of CSKY Ltd. nor the names of CSKY's contributors may
+ *     be used to endorse or promote products derived from this software without
+ *     specific prior written permission of CSKY Ltd.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * -------------------------------------------------------------------------- */
+#include "testsuite.h"
+#include "test_device.h"
+
+#define USER1_INT_PRIO   3
+#define USER2_INT_PRIO   2
+#define USER3_INT_PRIO   1
+#define USER4_INT_PRIO   0
+#define NVIC_THRESHOLD   0
+#define USER1_IRQ        3
+#define USER2_IRQ        4
+#define USER3_IRQ        5
+#define USER4_IRQ        6
+
+void user1_int_irq_handler(void)
+{
+	int NVIC_Pend=0;
+	int NVIC_Active = 0;
+	printf("--------start user1 irq handler!\n");
+
+	NVIC_Active=NVIC_GetActive(USER1_IRQ);
+        TEST(NVIC_Active);
+        if(NVIC_Active)
+		printf("User1  NVIC_Active successed!\n");
+        __disable_irq();
+	NVIC_SetPendingIRQ(USER2_IRQ );
+	NVIC_Pend= NVIC_GetPendingIRQ(USER2_IRQ);
+        __enable_irq();
+        TEST(NVIC_Pend);
+        if(NVIC_Pend)
+            printf("User2 NVIC_SetPending successed!\n");
+
+        printf("--------User1 irq handle successed!\n");
+}
+
+void user2_int_irq_handler(void)
+{
+	int NVIC_Pend=0;
+	int NVIC_Active = 0;
+	printf("--------start user2 irq handler!\n");
+
+	NVIC_Active=NVIC_GetActive(USER2_IRQ);
+        TEST(NVIC_Active);
+        if(NVIC_Active)
+		printf("User2  NVIC_Active successed!\n");
+        __disable_irq();
+	NVIC_SetPendingIRQ(USER3_IRQ );
+	NVIC_Pend= NVIC_GetPendingIRQ(USER3_IRQ);
+        __enable_irq();
+        TEST(NVIC_Pend);
+        if(NVIC_Pend)
+            printf("User3 NVIC_SetPending successed!\n");
+        printf("--------User2 irq handle successed!\n");
+}
+
+void user3_int_irq_handler(void)
+{
+	int NVIC_Pend=0;
+	int NVIC_Active = 0;
+	printf("--------start user3 irq handler!\n");
+
+	NVIC_Active=NVIC_GetActive(USER3_IRQ);
+        TEST(NVIC_Active);
+        if(NVIC_Active)
+		printf("User3  NVIC_Active successed!\n");
+        __disable_irq();
+        NVIC_SetThreshold(USER1_IRQ,NVIC_THRESHOLD);
+	NVIC_SetPendingIRQ(USER4_IRQ );
+	NVIC_Pend= NVIC_GetPendingIRQ(USER4_IRQ);
+        __enable_irq();
+        TEST(NVIC_Pend);
+        if(NVIC_Pend)
+            printf("User4 NVIC_SetPending successed!\n");
+        printf("--------User3 irq handle successed!\n");
+}
+
+void user4_int_irq_handler(void)
+{
+	int NVIC_Active = 0;
+	printf("--------start user4 irq handler!\n");
+
+	NVIC_Active=NVIC_GetActive(USER4_IRQ);
+        TEST(NVIC_Active);
+        if(NVIC_Active)
+		printf("User4  NVIC_Active successed!\n");
+        printf("--------User4 irq handle successed!\n");
+}
+
+void user1_int(IRQn_Type IRQn, uint32_t priority)
+{
+	int NVIC_Priority = 0;
+        int NVIC_Active = 0;
+        init_testsuite("Testing User1 int  function!\n");
+	NVIC_SetPriority(IRQn, priority);
+	NVIC_EnableIRQ(IRQn);
+        NVIC_Priority=NVIC_GetPriority(IRQn);
+        TEST(NVIC_Priority==USER1_INT_PRIO);
+        if(NVIC_Priority==USER1_INT_PRIO)
+            printf("User1 NVIC_SetPriority IRQ successed!\n");
+        printf("----------------------------------------\n");
+}
+
+void user2_int(IRQn_Type IRQn, uint32_t priority)
+{
+	int NVIC_Priority = 0;
+	int NVIC_Active = 0;
+        init_testsuite("Testing User2 int  function!\n");
+	NVIC_SetPriority(IRQn, priority);
+        NVIC_EnableIRQ(IRQn);
+        NVIC_Priority=NVIC_GetPriority(IRQn);
+        TEST(NVIC_Priority==USER2_INT_PRIO);
+        if(NVIC_Priority==USER2_INT_PRIO)
+            printf("User2 NVIC_SetPriority IRQ successed!\n");
+        printf("----------------------------------------\n");
+}
+
+void user3_int(IRQn_Type IRQn, uint32_t priority)
+{
+	int NVIC_Priority = 0;
+	int NVIC_Active = 0;
+        init_testsuite("Testing User3 int  function!\n");
+	NVIC_SetPriority(IRQn, priority);
+        NVIC_EnableIRQ(IRQn);
+        NVIC_Priority=NVIC_GetPriority(IRQn);
+        TEST(NVIC_Priority==USER3_INT_PRIO);
+        if(NVIC_Priority==USER3_INT_PRIO)
+            printf("User3 NVIC_SetPriority IRQ successed!\n");
+        printf("----------------------------------------\n");
+}
+
+void user4_int(IRQn_Type IRQn, uint32_t priority)
+{
+	int NVIC_Priority = 0;
+	int NVIC_Active = 0;
+        init_testsuite("Testing User4 int  function!\n");
+	NVIC_SetPriority(IRQn, priority);
+        NVIC_EnableIRQ(IRQn);
+        NVIC_Priority=NVIC_GetPriority(IRQn);
+        TEST(NVIC_Priority==USER4_INT_PRIO);
+        if(NVIC_Priority==USER4_INT_PRIO)
+            printf("User4 NVIC_SetPriority IRQ successed!\n");
+        printf("----------------------------------------\n");
+}
+
+int main(void)
+{
+	int i = 0;
+        int NVIC_Priority;
+	int NVIC_Pend=0;
+
+	init_testsuite("-**********Testing functions NVIC threshold function***********\n");
+
+	NVIC_SetPendingIRQ(USER1_IRQ);
+	NVIC_Pend= NVIC_GetPendingIRQ(USER1_IRQ);
+        TEST(NVIC_Pend);
+	if(NVIC_Pend)
+            printf("User1 NVIC_SetPending successed!\n");
+        __enable_irq();
+
+        user4_int(USER4_IRQ,USER4_INT_PRIO);
+        user3_int(USER3_IRQ,USER3_INT_PRIO);
+	user2_int(USER2_IRQ,USER2_INT_PRIO);
+	user1_int(USER1_IRQ,USER1_INT_PRIO);
+
+	return done_testing();
+}
diff --git a/tests/csky/nvic/runcase_nvic.sh b/tests/csky/nvic/runcase_nvic.sh
new file mode 100755
index 0000000..e73a1cc
--- /dev/null
+++ b/tests/csky/nvic/runcase_nvic.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+num_total=0
+num_fail=0
+
+make
+cd case
+for file in *.elf
+do
+    cmd="qemu-system-cskyv2 -machine smartl -kernel $file -nographic"
+    $cmd
+    if [ $? -ne 0 ]
+    then
+        num_fail=`expr $num_fail + 1`
+    fi
+    num_total=`expr $num_total + 1`
+done
+
+echo "\n------sumary------"
+echo "Total  case: $num_total"
+echo "Failed case: $num_fail"
+echo "------------------\n"
+
+cd ..
+make clean
diff --git a/tests/csky/script/Makefile b/tests/csky/script/Makefile
new file mode 100644
index 0000000..b2043b8
--- /dev/null
+++ b/tests/csky/script/Makefile
@@ -0,0 +1,17 @@
+CORE_OBJ = a.out 
+CFLAGS = -g2 
+
+CC = gcc
+
+all: core
+
+core:
+	gcc -c $(CFLAGS) op_dspv2.c -o op_dspv2.o
+	gcc -c $(CFLAGS) op_tcg.c -o op_tcg.o
+	gcc -c $(CFLAGS) main.c -o main.o
+	gcc main.o op_dspv2.o op_tcg.o -o a.out
+	rm -f *.o
+
+clean:
+	rm -f *.o
+
diff --git a/tests/csky/script/insn.dat b/tests/csky/script/insn.dat
new file mode 100644
index 0000000..1fe52e2
--- /dev/null
+++ b/tests/csky/script/insn.dat
@@ -0,0 +1,1272 @@
+//test case
+#muls.u32
+0x00000001 0x00000001 0x0000000000000001 
+0x00000001 0x00000001 0xffffffffffffffff 
+0x00000001 0x00000001 0x8000000000000000 
+0x00000001 0x00000001 0x7fffffffffffffff 
+0x00000001 0xffffffff 0xffffffffffffffff 
+0x00000001 0xffffffff 0x8000000000000000 
+0x00000001 0xffffffff 0x7fffffffffffffff 
+0x80000000 0x80000000 0xffffffffffffffff 
+0x80000000 0x80000000 0x8000000000000000 
+0x80000000 0x80000000 0x7fffffffffffffff 
+0x7fffffff 0xffffffff 0xffffffffffffffff 
+0x7fffffff 0xffffffff 0x8000000000000000 
+0x7fffffff 0xffffffff 0x0000000000000000
+0x00000000 0x00000001 0x0000000000000000 
+0x00000001 0x00000000 0x0000000000000000 
+#muls.s32
+0x00000001 0x00000001 0x0000000000000001 
+0x00000001 0x00000001 0xffffffffffffffff 
+0x00000001 0x00000001 0x8000000000000000 
+0x00000001 0x00000001 0x7fffffffffffffff 
+0x00000001 0xffffffff 0xffffffffffffffff 
+0x00000001 0xffffffff 0x8000000000000000 
+0x00000001 0xffffffff 0x7fffffffffffffff 
+0x80000000 0x80000000 0xffffffffffffffff 
+0x80000000 0x80000000 0x8000000000000000 
+0x80000000 0x80000000 0x7fffffffffffffff 
+0x7fffffff 0xffffffff 0xffffffffffffffff 
+0x7fffffff 0xffffffff 0x8000000000000000 
+0x7fffffff 0xffffffff 0x0000000000000000
+0x00000000 0x00000001 0x0000000000000000 
+0x00000001 0x00000000 0x0000000000000000 
+#mula.u32.s
+0x00000001 0x00000001 0x0000000000000001 
+0x00000001 0x00000001 0xffffffffffffffff 
+0x00000001 0x00000001 0x8000000000000000 
+0x00000001 0x00000001 0x7fffffffffffffff 
+0x00000001 0xffffffff 0xffffffffffffffff 
+0x00000001 0xffffffff 0x8000000000000000 
+0x00000001 0xffffffff 0x7fffffffffffffff 
+0x80000000 0x80000000 0xffffffffffffffff 
+0x80000000 0x80000000 0x8000000000000000 
+0x80000000 0x80000000 0x7fffffffffffffff 
+0x7fffffff 0xffffffff 0xffffffffffffffff 
+0x7fffffff 0xffffffff 0x8000000000000000 
+0x7fffffff 0xffffffff 0x0000000000000000
+0x00000000 0x00000001 0x0000000000000000 
+0x00000001 0x00000000 0x0000000000000000 
+#mula.s32.s
+0x00000001 0x00000001 0x0000000000000001 
+0x00000001 0x00000001 0xffffffffffffffff 
+0x00000001 0x00000001 0x8000000000000000 
+0x00000001 0x00000001 0x7fffffffffffffff 
+0x00000001 0xffffffff 0xffffffffffffffff 
+0x00000001 0xffffffff 0x8000000000000000 
+0x00000001 0xffffffff 0x7fffffffffffffff 
+0x80000000 0x80000000 0xffffffffffffffff 
+0x80000000 0x80000000 0x8000000000000000 
+0x80000000 0x80000000 0x7fffffffffffffff 
+0x7fffffff 0xffffffff 0xffffffffffffffff 
+0x7fffffff 0xffffffff 0x8000000000000000 
+0x7fffffff 0xffffffff 0x0000000000000000
+0x00000000 0x00000001 0x0000000000000000 
+0x00000001 0x00000000 0x0000000000000000 
+#muls.u32.s
+0x00000001 0x00000001 0x0000000000000001 
+0x00000001 0x00000001 0xffffffffffffffff 
+0x00000001 0x00000001 0x8000000000000000 
+0x00000001 0x00000001 0x7fffffffffffffff 
+0x00000001 0xffffffff 0xffffffffffffffff 
+0x00000001 0xffffffff 0x8000000000000000 
+0x00000001 0xffffffff 0x7fffffffffffffff 
+0x80000000 0x80000000 0xffffffffffffffff 
+0x80000000 0x80000000 0x8000000000000000 
+0x80000000 0x80000000 0x7fffffffffffffff 
+0x7fffffff 0xffffffff 0xffffffffffffffff 
+0x7fffffff 0xffffffff 0x8000000000000000 
+0x7fffffff 0xffffffff 0x0000000000000000
+0x00000000 0x00000001 0x0000000000000000 
+0x00000001 0x00000000 0x0000000000000000 
+#muls.s32.s
+0x00000001 0x00000001 0x0000000000000001 
+0x00000001 0x00000001 0xffffffffffffffff 
+0x00000001 0x00000001 0x8000000000000000 
+0x00000001 0x00000001 0x7fffffffffffffff 
+0x00000001 0xffffffff 0xffffffffffffffff 
+0x00000001 0xffffffff 0x8000000000000000 
+0x00000001 0xffffffff 0x7fffffffffffffff 
+0x80000000 0x80000000 0xffffffffffffffff 
+0x80000000 0x80000000 0x8000000000000000 
+0x80000000 0x80000000 0x7fffffffffffffff 
+0x7fffffff 0xffffffff 0xffffffffffffffff 
+0x7fffffff 0xffffffff 0x8000000000000000 
+0x7fffffff 0xffffffff 0x0000000000000000
+0x00000000 0x00000001 0x0000000000000000 
+0x00000001 0x00000000 0x0000000000000000 
+#rmul.s32.h
+0x7fffffff 0x7fffffff 
+0x80000000 0x80000000 
+0xffffffff 0xffffffff 
+0x00000000 0x00000000 
+0x7fffffff 0x80000000 
+0x80000000 0x7fffffff 
+0x7fffffff 0xffffffff 
+0xffffffff 0x7fffffff 
+0x7fffffff 0x00000000 
+0x00000000 0x7fffffff 
+0x80000000 0xffffffff 
+0xffffffff 0x80000000 
+0x00000000 0x80000000 
+0x80000000 0x00000000 
+0xffffffff 0x00000000 
+0x00000000 0xffffffff 
+#rmul.s32.rh
+0x7fffffff 0x7fffffff 
+0x80000000 0x80000000 
+0xffffffff 0xffffffff 
+0x00000000 0x00000000 
+0x7fffffff 0x80000000 
+0x80000000 0x7fffffff 
+0x7fffffff 0xffffffff 
+0xffffffff 0x7fffffff 
+0x7fffffff 0x00000000 
+0x00000000 0x7fffffff 
+0x80000000 0xffffffff 
+0xffffffff 0x80000000 
+0x00000000 0x80000000 
+0x80000000 0x00000000 
+0xffffffff 0x00000000 
+0x7fff8000 0x80008000
+
+#mula.s32.hs
+0x00000001 0x00000001 0x00000000
+0x00000001 0x00000001 0xffffffff
+0x00000001 0x00000001 0x80000000
+0x00000001 0x00000001 0x7fffffff
+0x00000001 0xffffffff 0xffffffff
+0x00000001 0xffffffff 0x80000000
+0x00000001 0xffffffff 0x7fffffff
+0x80000000 0x80000000 0xffffffff
+0x80000000 0x80000000 0x80000000
+0x80000000 0x80000000 0x7fffffff
+0x7fffffff 0xffffffff 0xffffffff
+0x7fffffff 0xffffffff 0x80000000
+0x7fffffff 0xffffffff 0x7fffffff
+0x00000000 0x00000001 0x00000000
+0x00000001 0x00000000 0x00000000
+
+#muls.s32.hs
+0x00000001 0x00000001 0x00000000
+0x00000001 0x00000001 0xffffffff
+0x00000001 0x00000001 0x80000000
+0x00000001 0x00000001 0x7fffffff
+0x00000001 0xffffffff 0xffffffff
+0x00000001 0xffffffff 0x80000000
+0x00000001 0xffffffff 0x7fffffff
+0x80000000 0x80000000 0xffffffff
+0x80000000 0x80000000 0x80000000
+0x80000000 0x80000000 0x7fffffff
+0x7fffffff 0xffffffff 0xffffffff
+0x7fffffff 0xffffffff 0x80000000
+0x7fffffff 0xffffffff 0x7fffffff
+0x00000000 0x00000001 0x00000000
+0x00000001 0x00000000 0x00000000
+
+#mula.s32.rhs
+0x00000001 0x00000001 0x00000000
+0x00000001 0x00000001 0xffffffff
+0x00000001 0x00000001 0x80000000
+0x00000001 0x00000001 0x7fffffff
+0x00000001 0xffffffff 0xffffffff
+0x00000001 0xffffffff 0x80000000
+0x00000001 0xffffffff 0x7fffffff
+0x80000000 0x80000000 0xffffffff
+0x80000000 0x80000000 0x80000000
+0x80000000 0x80000000 0x7fffffff
+0x7fffffff 0xffffffff 0xffffffff
+0x7fffffff 0xffffffff 0x80000000
+0x7fffffff 0xffffffff 0x7fffffff
+0x00000000 0x00000001 0x00000000
+0x00000001 0x00000000 0x00000000
+
+#muls.s32.rhs
+0x00000001 0x00000001 0x00000000
+0x00000001 0x00000001 0xffffffff
+0x00000001 0x00000001 0x80000000
+0x00000001 0x00000001 0x7fffffff
+0x00000001 0xffffffff 0xffffffff
+0x00000001 0xffffffff 0x80000000
+0x00000001 0xffffffff 0x7fffffff
+0x80000000 0x80000000 0xffffffff
+0x80000000 0x80000000 0x80000000
+0x80000000 0x80000000 0x7fffffff
+0x7fffffff 0xffffffff 0xffffffff
+0x7fffffff 0xffffffff 0x80000000
+0x7fffffff 0xffffffff 0x7fffffff
+0x00000000 0x00000001 0x00000000
+0x00000001 0x00000000 0x00000000
+
+#mulxl.s32
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#mulxl.s32.r
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#mulxh.s32
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#mulxh.s32.r
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#rmulxl.s32
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#rmulxl.s32.r
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#rmulxh.s32
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#rmulxh.s32.r
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#mulaxl.s32.s
+0x00000001 0x00010001 0x00000001
+0x00000001 0x7fff7fff 0x7fffffff
+0x00000001 0xffffffff 0x80000000
+0xffffffff 0x00010001 0xffffffff
+0xffffffff 0xffffffff 0x40000000
+0xffffffff 0x7fff7fff 0x00000000
+0x80000000 0x80008000 0x00008000
+0x80000000 0x7fff7fff 0x7fffffff
+0x80000000 0xffffffff 0x80000000
+0x7fffffff 0x00010001 0xffffffff
+0x7fffffff 0xffffffff 0x00000001
+0x7fffffff 0x7fff7fff 0x80000000
+0x7fffffff 0x80008000 0x7fffffff
+0x00000000 0x00000000 0x00008000
+0x00000000 0x7fff7fff 0x00000000
+
+#mulaxl.s32.rs
+0x00000001 0x00010001 0x00000001
+0x00000001 0x7fff7fff 0x7fffffff
+0x00000001 0xffffffff 0x80000000
+0xffffffff 0x00010001 0xffffffff
+0xffffffff 0xffffffff 0x40000000
+0xffffffff 0x7fff7fff 0x00000000
+0x80000000 0x80008000 0x00008000
+0x80000000 0x7fff7fff 0x7fffffff
+0x80000000 0xffffffff 0x80000000
+0x7fffffff 0x00010001 0xffffffff
+0x7fffffff 0xffffffff 0x00000001
+0x7fffffff 0x7fff7fff 0x80000000
+0x7fffffff 0x80008000 0x7fffffff
+0x00000000 0x00000000 0x00008000
+0x00000000 0x7fff7fff 0x00000000
+
+#mulaxh.s32.s
+0x00000001 0x00010001 0x00000001
+0x00000001 0x7fff7fff 0x7fffffff
+0x00000001 0xffffffff 0x80000000
+0xffffffff 0x00010001 0xffffffff
+0xffffffff 0xffffffff 0x40000000
+0xffffffff 0x7fff7fff 0x00000000
+0x80000000 0x80008000 0x00008000
+0x80000000 0x7fff7fff 0x7fffffff
+0x80000000 0xffffffff 0x80000000
+0x7fffffff 0x00010001 0xffffffff
+0x7fffffff 0xffffffff 0x00000001
+0x7fffffff 0x7fff7fff 0x80000000
+0x7fffffff 0x80008000 0x7fffffff
+0x00000000 0x00000000 0x00008000
+0x00000000 0x7fff7fff 0x00000000
+
+#mulaxh.s32.rs
+0x00000001 0x00010001 0x00000001
+0x00000001 0x7fff7fff 0x7fffffff
+0x00000001 0xffffffff 0x80000000
+0xffffffff 0x00010001 0xffffffff
+0xffffffff 0xffffffff 0x40000000
+0xffffffff 0x7fff7fff 0x00000000
+0x80000000 0x80008000 0x00008000
+0x80000000 0x7fff7fff 0x7fffffff
+0x80000000 0xffffffff 0x80000000
+0x7fffffff 0x00010001 0xffffffff
+0x7fffffff 0xffffffff 0x00000001
+0x7fffffff 0x7fff7fff 0x80000000
+0x7fffffff 0x80008000 0x7fffffff
+0x00000000 0x00000000 0x00008000
+0x00000000 0x7fff7fff 0x00000000
+
+#rmulll.s16
+0x00000001 0x00000001
+0x00000001 0x7FFF7FFF
+0x00000001 0xFFFFFFFF
+0xFFFFFFFF 0xFFFFFFFF
+0x00008000 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7FFFFFFF
+0x80000000 0x00008000
+
+#rmulhh.s16
+0x00010000 0x00010000
+0x00010000 0x7FFF7FFF
+0x00010000 0xFFFFFFFF
+0xFFFFFFFF 0xFFFFFFFF
+0x80000000 0x80008000
+0x00000000 0x00000000
+0x00000000 0xFFFF7FFF
+0x00008000 0x80000000
+
+#rmulhl.s16
+0x00010000 0x00000001
+0x00010000 0x7FFF7FFF
+0x00010000 0xFFFFFFFF
+0xFFFFFFFF 0xFFFFFFFF
+0x80000000 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7FFFFFFF
+0x00008000 0x00008000
+
+#mulall.s16.s
+0x00008000 0x0001ffff 0x7fffffff
+0x00017fff 0x00007fff 0x80000000
+0x00017fff 0x00007fff 0xffffffff
+0x00017fff 0x00007fff 0x7fffffff
+0xFFFF8000 0x00008000 0x80000000
+0x80008000 0x7FFF8000 0xffffffff
+0xFFFF8000 0x80008000 0x7fffffff
+0xFFFFffff 0x0000ffff 0x80000000
+0x8000ffff 0x7FFFffff 0xffffffff
+0x8000ffff 0x8000ffff 0x7fffffff
+0x00007fff 0x00008000 0x80000000
+0x7FFF8000 0x7FFF7fff 0xffffffff
+0x80008000 0x80007fff 0x7fffffff
+0x0000ffff 0x00018000 0x80000000
+0x00008000 0x0001ffff 0xffffffff
+0x00000000 0xFFFFffff 0x00000000
+0x7FFF0000 0x8000ffff 0xffffffff
+0x8000ffff 0xFFFF0000 0x00000000
+0x0000ffff 0xFFFF0000 0xffffffff
+0x7FFF0000 0x80000000 0x00000000
+0x80000000 0x80000000 0xffffffff
+
+#mulahh.s16.s
+0x80000000 0xffff0001 0x7fffffff
+0x7fff0001 0x7fff0000 0x80000000
+0x7fff0001 0x7fff0000 0xffffffff
+0x7fff0001 0x7fff0000 0x7fffffff
+0x8000FFFF 0x80000000 0x80000000
+0x80008000 0x80007FFF 0xffffffff
+0x8000FFFF 0x80008000 0x7fffffff
+0xffffFFFF 0xffff0000 0x80000000
+0xffff8000 0xffff7FFF 0xffffffff
+0xffff8000 0xffff8000 0x7fffffff
+0x7fff0000 0x80000000 0x80000000
+0x80007FFF 0x7fff7FFF 0xffffffff
+0x80008000 0x7fff8000 0x7fffffff
+0xffff0000 0x80000001 0x80000000
+0x80000000 0xffff0001 0xffffffff
+0x00000000 0xffffFFFF 0x00000000
+0x00007FFF 0xffff8000 0xffffffff
+0xffff8000 0x0000FFFF 0x00000000
+0xffff0000 0x0000FFFF 0xffffffff
+0x00007FFF 0x00008000 0x00000000
+0x00008000 0x00008000 0xffffffff
+
+#mulahl.s16.s
+0x80000000 0x0001ffff 0x7fffffff
+0x7fff0001 0x00007fff 0x80000000
+0x7fff0001 0x00007fff 0xffffffff
+0x7fff0001 0x00007fff 0x7fffffff
+0x8000FFFF 0x00008000 0x80000000
+0x80008000 0x7FFF8000 0xffffffff
+0x8000FFFF 0x80008000 0x7fffffff
+0xffffFFFF 0x0000ffff 0x80000000
+0xffff8000 0x7FFFffff 0xffffffff
+0xffff8000 0x8000ffff 0x7fffffff
+0x7fff0000 0x00008000 0x80000000
+0x80007FFF 0x7FFF7fff 0xffffffff
+0x80008000 0x80007fff 0x7fffffff
+0xffff0000 0x00018000 0x80000000
+0x80000000 0x0001ffff 0xffffffff
+0x00000000 0xFFFFffff 0x00000000
+0x00007FFF 0x8000ffff 0xffffffff
+0xffff8000 0xFFFF0000 0x00000000
+0xffff0000 0xFFFF0000 0xffffffff
+0x00007FFF 0x80000000 0x00000000
+0x00008000 0x80000000 0xffffffff
+
+#mulall.s16.e
+0x00017fff 0x00007fff 0x8000000000000000
+0x00017fff 0x00007fff 0xffffffffffffffff
+0x00017fff 0x00007fff 0x7fffffffffffffff
+0xFFFF8000 0x00008000 0x8000000000000000
+0x80008000 0x7FFF8000 0xffffffffffffffff
+0xFFFF8000 0x80008000 0x7fffffffffffffff
+0xFFFF7fff 0x00008000 0x8000000000000000
+0x80007fff 0x7FFF8000 0xffffffffffffffff
+0x80007fff 0x80008000 0x7fffffffffffffff
+0x0000ffff 0x0000ffff 0x8000000000000000
+0x7FFFffff 0x7FFFffff 0xffffffffffffffff
+0x8000ffff 0x8000ffff 0x7fffffffffffffff
+0x0000ffff 0x00018000 0x8000000000000000
+0x00008000 0x0001ffff 0xffffffffffffffff
+0x00008000 0x0001ffff 0x7fffffffffffffff
+0x00000000 0xFFFFffff 0x0000000000000000
+0x7FFF0000 0x8000ffff 0xffffffffffffffff
+0x8000ffff 0xFFFF0000 0x0000000000000000
+0x0000ffff 0xFFFF0000 0xffffffffffffffff
+0x7FFF0000 0x80000000 0x0000000000000000
+0x80000000 0x80000000 0xffffffffffffffff
+
+#mulahl.s16.e
+0x7fff0001 0x00007fff 0x8000000000000000
+0x7fff0001 0x00007fff 0xffffffffffffffff
+0x7fff0001 0x00007fff 0x7fffffffffffffff
+0x8000FFFF 0x00008000 0x8000000000000000
+0x80008000 0x7FFF8000 0xffffffffffffffff
+0x8000FFFF 0x80008000 0x7fffffffffffffff
+0x7fffFFFF 0x00008000 0x8000000000000000
+0x7fff8000 0x7FFF8000 0xffffffffffffffff
+0x7fff8000 0x80008000 0x7fffffffffffffff
+0xffff0000 0x0000ffff 0x8000000000000000
+0xffff7FFF 0x7FFFffff 0xffffffffffffffff
+0xffff8000 0x8000ffff 0x7fffffffffffffff
+0xffff0000 0x00018000 0x8000000000000000
+0x80000000 0x0001ffff 0xffffffffffffffff
+0x80000000 0x0001ffff 0x7fffffffffffffff
+0x00000000 0xFFFFffff 0x0000000000000000
+0x00007FFF 0x8000ffff 0xffffffffffffffff
+0xffff8000 0xFFFF0000 0x0000000000000000
+0xffff0000 0xFFFF0000 0xffffffffffffffff
+0x00007FFF 0x80000000 0x0000000000000000
+0x00008000 0x80000000 0xffffffffffffffff
+
+#mulahh.s16.e
+0x7fff0001 0x7fff0000 0x8000000000000000
+0x7fff0001 0x7fff0000 0xffffffffffffffff
+0x7fff0001 0x7fff0000 0x7fffffffffffffff
+0x8000FFFF 0x80000000 0x8000000000000000
+0x80008000 0x80007FFF 0xffffffffffffffff
+0x8000FFFF 0x80008000 0x7fffffffffffffff
+0x7fffFFFF 0x80000000 0x8000000000000000
+0x7fff8000 0x80007FFF 0xffffffffffffffff
+0x7fff8000 0x80008000 0x7fffffffffffffff
+0xffff0000 0xffff0000 0x8000000000000000
+0xffff7FFF 0xffff7FFF 0xffffffffffffffff
+0xffff8000 0xffff8000 0x7fffffffffffffff
+0xffff0000 0x80000001 0x8000000000000000
+0x80000000 0xffff0001 0xffffffffffffffff
+0x80000000 0xffff0001 0x7fffffffffffffff
+0x00000000 0xffffFFFF 0x0000000000000000
+0x00007FFF 0xffff8000 0xffffffffffffffff
+0xffff8000 0x0000FFFF 0x0000000000000000
+0xffff0000 0x0000FFFF 0xffffffffffffffff
+0x00007FFF 0x00008000 0x0000000000000000
+0x00008000 0x00008000 0xffffffffffffffff
+
+#pmul.s16
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#pmul.u16
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#pmulx.s16
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#pmulx.u16
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#prmul.s16
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#prmulx.s16
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#prmul.s16.h
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#prmul.s16.rh
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#prmulx.s16.h
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#prmulx.s16.rh
+0x00000001 0x00010001
+0x00000001 0x7fff7fff
+0x00000001 0xffffffff
+0xffffffff 0x00010001
+0xffffffff 0xffffffff
+0xffffffff 0x7fff7fff
+0x80000000 0x80008000
+0x80000000 0x7fff7fff
+0x80000000 0xffffffff
+0x7fffffff 0x00010001
+0x7fffffff 0xffffffff
+0x7fffffff 0x7fff7fff
+0x7fffffff 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7fff7fff
+
+#mulca.s16.s
+0x00010001 0x00000001
+0x00010001 0x00008000
+0x00010001 0x7fff7fff
+0x00010001 0x0000FFFF
+0x00010002 0x7FFF8000
+0x00017FFF 0x8000FFFF
+0x0001FFFF 0x0000FFFF
+0x0001FFFF 0x7FFF8000
+0x00018000 0x80008000
+0x00010000 0x00000000
+0x00010000 0x7FFF7FFF
+0x00010000 0x80008000
+0x80008000 0x80008000
+
+#mulcax.s16.s
+0x00010001 0x00010000
+0x00010001 0x80000000
+0x00010001 0x7fff7fff
+0x00010001 0xFFFF0000
+0x00010002 0x80007FFF
+0x00017FFF 0xFFFF8000
+0x0001FFFF 0xFFFF0000
+0x0001FFFF 0x80007FFF
+0x00018000 0x80008000
+0x00010000 0x00000000
+0x00010000 0x7FFF7FFF
+0x00010000 0x80008000
+0x80008000 0x80008000
+
+#mulcs.s16
+0x00010001 0x00000001
+0x00010001 0x7FFF7FFF
+0x00010010 0x80007FFF
+0x00010001 0x0000FFFF
+0x00010002 0x7FFF8000
+0x00017FFF 0x8000FFFF
+0x0001FFFF 0x0000FFFF
+0x0001FFFF 0x7FFF8000
+0x00018000 0x80008000
+0x00010000 0x00000000
+0x00010000 0x7FFF7FFF
+0x00010000 0x80008000
+
+#mulcsr.s16
+0x00010001 0x00010000
+0x00010001 0x7FFF7FFF
+0x00100001 0x7FFF8000
+0x00010001 0xFFFF0000
+0x00020001 0x80007FFF
+0x7FFF0001 0xFFFF8000
+0xFFFF0001 0xFFFF0000
+0xFFFF0001 0x80007FFF
+0x80000001 0x80008000
+0x00000001 0x00000000
+0x00000001 0x7FFF7FFF
+0x00000001 0x80008000
+
+#mulcsx.s16
+0x00010001 0x00010000
+0x00010001 0x7FFF7FFF
+0x00010010 0x7FFF8000
+0x00010001 0xFFFF0000
+0x00010002 0x80007FFF
+0x00017FFF 0xFFFF8000
+0x0001FFFF 0xFFFF0000
+0x0001FFFF 0x80007FFF
+0x00018000 0x80008000
+0x00010000 0x00000000
+0x00010000 0x7FFF7FFF
+0x00010000 0x80008000
+
+#mulaca.s16.s
+0x00010001 0x00010001 0x00000001
+0x80007fff 0x80007fff 0x80000000
+0x80007fff 0x80007fff 0xffffffff
+0x80007fff 0x80007fff 0x7fffffff
+0x7fff7fff 0x80008000 0x80000000
+0x7fff7fff 0x80008000 0xffffffff
+0x7fff7fff 0x80008000 0x7fffffff
+0xffffffff 0xffffffff 0x80000000
+0xffffffff 0xffffffff 0xffffffff
+0xffffffff 0xffffffff 0x7fffffff
+0xffffffff 0x80008000 0x80000000
+0xffffffff 0x80008000 0xffffffff
+0xffffffff 0x80008000 0x7fffffff
+0x8000ffff 0x8000ffff 0x80000000
+0x8000ffff 0x8000ffff 0xffffffff
+0x8000ffff 0x8000ffff 0x7fffffff
+0x00010000 0xffffffff 0x00000000
+0x0001ffff 0xffff0000 0x00000000
+0x00000001 0xffffffff 0x00000000
+0x0000ffff 0xffff0001 0x00000000
+0x00000000 0x00000000 0x00000000
+
+#mulacax.s16.s
+0x00010001 0x00010001 0x00000001
+0x80007fff 0x7fff8000 0x80000000
+0x80007fff 0x7fff8000 0xffffffff
+0x80007fff 0x7fff8000 0x7fffffff
+0x7fff7fff 0x80008000 0x80000000
+0x7fff7fff 0x80008000 0xffffffff
+0x7fff7fff 0x80008000 0x7fffffff
+0xffffffff 0xffffffff 0x80000000
+0xffffffff 0xffffffff 0xffffffff
+0xffffffff 0xffffffff 0x7fffffff
+0xffffffff 0x80008000 0x80000000
+0xffffffff 0x80008000 0xffffffff
+0xffffffff 0x80008000 0x7fffffff
+0x8000ffff 0xffff8000 0x80000000
+0x8000ffff 0xffff8000 0xffffffff
+0x8000ffff 0xffff8000 0x7fffffff
+0x00010000 0xffffffff 0x00000000
+0x0001ffff 0x0000ffff 0x00000000
+0x00000001 0xffffffff 0x00000000
+0x0000ffff 0x0001ffff 0x00000000
+0x00000000 0x00000000 0x00000000
+
+#mulacs.s16.s
+0x00010001 0x00010001 0x00000001
+0x80007fff 0x80007fff 0x80000000
+0x80007fff 0x80007fff 0xffffffff
+0x80007fff 0x80007fff 0x7fffffff
+0x7fff7fff 0x80008000 0x80000000
+0x7fff7fff 0x80008000 0xffffffff
+0x7fff7fff 0x80008000 0x7fffffff
+0xffffffff 0xffffffff 0x80000000
+0xffffffff 0xffffffff 0xffffffff
+0xffffffff 0xffffffff 0x7fffffff
+0xffffffff 0x80008000 0x80000000
+0xffffffff 0x80008000 0xffffffff
+0xffffffff 0x80008000 0x7fffffff
+0x8000ffff 0x8000ffff 0x80000000
+0x8000ffff 0x8000ffff 0xffffffff
+0x8000ffff 0x8000ffff 0x7fffffff
+0x00010000 0xffffffff 0x00000000
+0x0001ffff 0xffff0000 0x00000000
+0x00000001 0xffffffff 0x00000000
+0x0000ffff 0xffff0001 0x00000000
+0x00000000 0x00000000 0x00000000
+
+#mulacsr.s16.s
+0x00010001 0x00010001 0x00000001
+0x7fff8000 0x7fff8000 0x80000000
+0x7fff8000 0x7fff8000 0xffffffff
+0x7fff8000 0x7fff8000 0x7fffffff
+0x7fff7fff 0x80008000 0x80000000
+0x7fff7fff 0x80008000 0xffffffff
+0x7fff7fff 0x80008000 0x7fffffff
+0xffffffff 0xffffffff 0x80000000
+0xffffffff 0xffffffff 0xffffffff
+0xffffffff 0xffffffff 0x7fffffff
+0xffffffff 0x80008000 0x80000000
+0xffffffff 0x80008000 0xffffffff
+0xffffffff 0x80008000 0x7fffffff
+0xffff8000 0xffff8000 0x80000000
+0xffff8000 0xffff8000 0xffffffff
+0xffff8000 0xffff8000 0x7fffffff
+0x00000001 0xffffffff 0x00000000
+0xffff0001 0x0000ffff 0x00000000
+0x00010000 0xffffffff 0x00000000
+0xffff0000 0x0001ffff 0x00000000
+0x00000000 0x00000000 0x00000000
+
+#mulacsx.s16.s
+0x00010001 0x00010001 0x00000001
+0x80007fff 0x7fff8000 0x80000000
+0x80007fff 0x7fff8000 0xffffffff
+0x80007fff 0x7fff8000 0x7fffffff
+0x7fff7fff 0x80008000 0x80000000
+0x7fff7fff 0x80008000 0xffffffff
+0x7fff7fff 0x80008000 0x7fffffff
+0xffffffff 0xffffffff 0x80000000
+0xffffffff 0xffffffff 0xffffffff
+0xffffffff 0xffffffff 0x7fffffff
+0xffffffff 0x80008000 0x80000000
+0xffffffff 0x80008000 0xffffffff
+0xffffffff 0x80008000 0x7fffffff
+0x8000ffff 0xffff8000 0x80000000
+0x8000ffff 0xffff8000 0xffffffff
+0x8000ffff 0xffff8000 0x7fffffff
+0x00010000 0xffffffff 0x00000000
+0x0001ffff 0x0000ffff 0x00000000
+0x00000001 0xffffffff 0x00000000
+0x0000ffff 0x0001ffff 0x00000000
+0x00000000 0x00000000 0x00000000
+
+#mulsca.s16.s
+0x00010001 0x00010001 0x00000001
+0x80007fff 0x80007fff 0x80000000
+0x80007fff 0x80007fff 0xffffffff
+0x80007fff 0x80007fff 0x7fffffff
+0x7fff7fff 0x80008000 0x80000000
+0x7fff7fff 0x80008000 0xffffffff
+0x7fff7fff 0x80008000 0x7fffffff
+0xffffffff 0xffffffff 0x80000000
+0xffffffff 0xffffffff 0xffffffff
+0xffffffff 0xffffffff 0x7fffffff
+0xffffffff 0x80008000 0x80000000
+0xffffffff 0x80008000 0xffffffff
+0xffffffff 0x80008000 0x7fffffff
+0x8000ffff 0x8000ffff 0x80000000
+0x8000ffff 0x8000ffff 0xffffffff
+0x8000ffff 0x8000ffff 0x7fffffff
+0x00010000 0xffffffff 0x00000000
+0x0001ffff 0xffff0000 0x00000000
+0x00000001 0xffffffff 0x00000000
+0x0000ffff 0xffff0001 0x00000000
+0x00000000 0x00000000 0x00000000
+
+#mulscax.s16.s
+0x00010001 0x00010001 0x00000001
+0x80007fff 0x7fff8000 0x80000000
+0x80007fff 0x7fff8000 0xffffffff
+0x80007fff 0x7fff8000 0x7fffffff
+0x7fff7fff 0x80008000 0x80000000
+0x7fff7fff 0x80008000 0xffffffff
+0x7fff7fff 0x80008000 0x7fffffff
+0xffffffff 0xffffffff 0x80000000
+0xffffffff 0xffffffff 0xffffffff
+0xffffffff 0xffffffff 0x7fffffff
+0xffffffff 0x80008000 0x80000000
+0xffffffff 0x80008000 0xffffffff
+0xffffffff 0x80008000 0x7fffffff
+0x8000ffff 0xffff8000 0x80000000
+0x8000ffff 0xffff8000 0xffffffff
+0x8000ffff 0xffff8000 0x7fffffff
+0x00010000 0xffffffff 0x00000000
+0x0001ffff 0x0000ffff 0x00000000
+0x00000001 0xffffffff 0x00000000
+0x0000ffff 0x0001ffff 0x00000000
+0x00000000 0x00000000 0x00000000
+
+#mulaca.s16.e
+0x00010001 0x00010001 0x0000000000000001
+0x80007fff 0x80007fff 0x8000000000000000
+0x80007fff 0x80007fff 0xffffffffffffffff
+0x80007fff 0x80007fff 0x7fffffffffffffff
+0x7fff7fff 0x80008000 0x8000000000000000
+0x7fff7fff 0x80008000 0xffffffffffffffff
+0x7fff7fff 0x80008000 0x7fffffffffffffff
+0xffffffff 0xffffffff 0x8000000000000000
+0xffffffff 0xffffffff 0xffffffffffffffff
+0xffffffff 0xffffffff 0x7fffffffffffffff
+0xffffffff 0x80008000 0x8000000000000000
+0xffffffff 0x80008000 0xffffffffffffffff
+0xffffffff 0x80008000 0x7fffffffffffffff
+0x8000ffff 0x8000ffff 0x8000000000000000
+0x8000ffff 0x8000ffff 0xffffffffffffffff
+0x8000ffff 0x8000ffff 0x7fffffffffffffff
+0x00010000 0xffffffff 0x0000000000000000
+0x0001ffff 0xffff0000 0x0000000000000000
+0x00000001 0xffffffff 0x0000000000000000
+0x0000ffff 0xffff0001 0x0000000000000000
+0x00000000 0x00000000 0x0000000000000000
+
+#mulacax.s16.e
+0x00010001 0x00010001 0x0000000000000001
+0x80007fff 0x7fff8000 0x8000000000000000
+0x80007fff 0x7fff8000 0xffffffffffffffff
+0x80007fff 0x7fff8000 0x7fffffffffffffff
+0x7fff7fff 0x80008000 0x8000000000000000
+0x7fff7fff 0x80008000 0xffffffffffffffff
+0x7fff7fff 0x80008000 0x7fffffffffffffff
+0xffffffff 0xffffffff 0x8000000000000000
+0xffffffff 0xffffffff 0xffffffffffffffff
+0xffffffff 0xffffffff 0x7fffffffffffffff
+0xffffffff 0x80008000 0x8000000000000000
+0xffffffff 0x80008000 0xffffffffffffffff
+0xffffffff 0x80008000 0x7fffffffffffffff
+0x8000ffff 0xffff8000 0x8000000000000000
+0x8000ffff 0xffff8000 0xffffffffffffffff
+0x8000ffff 0xffff8000 0x7fffffffffffffff
+0x00010000 0xffffffff 0x0000000000000000
+0x0001ffff 0x0000ffff 0x0000000000000000
+0x00000001 0xffffffff 0x0000000000000000
+0x0000ffff 0x0001ffff 0x0000000000000000
+0x00000000 0x00000000 0x0000000000000000
+
+#mulacs.s16.e
+0x00010001 0x00010001 0x0000000000000001
+0x80007fff 0x80007fff 0x8000000000000000
+0x80007fff 0x80007fff 0xffffffffffffffff
+0x80007fff 0x80007fff 0x7fffffffffffffff
+0x7fff7fff 0x80008000 0x8000000000000000
+0x7fff7fff 0x80008000 0xffffffffffffffff
+0x7fff7fff 0x80008000 0x7fffffffffffffff
+0xffffffff 0xffffffff 0x8000000000000000
+0xffffffff 0xffffffff 0xffffffffffffffff
+0xffffffff 0xffffffff 0x7fffffffffffffff
+0xffffffff 0x80008000 0x8000000000000000
+0xffffffff 0x80008000 0xffffffffffffffff
+0xffffffff 0x80008000 0x7fffffffffffffff
+0x8000ffff 0x8000ffff 0x8000000000000000
+0x8000ffff 0x8000ffff 0xffffffffffffffff
+0x8000ffff 0x8000ffff 0x7fffffffffffffff
+0x00010000 0xffffffff 0x0000000000000000
+0x0001ffff 0xffff0000 0x0000000000000000
+0x00000001 0xffffffff 0x0000000000000000
+0x0000ffff 0xffff0001 0x0000000000000000
+0x00000000 0x00000000 0x0000000000000000
+
+#mulacsr.s16.e
+0x00010001 0x00010001 0x0000000000000001
+0x7fff8000 0x7fff8000 0x8000000000000000
+0x7fff8000 0x7fff8000 0xffffffffffffffff
+0x7fff8000 0x7fff8000 0x7fffffffffffffff
+0x7fff7fff 0x80008000 0x8000000000000000
+0x7fff7fff 0x80008000 0xffffffffffffffff
+0x7fff7fff 0x80008000 0x7fffffffffffffff
+0xffffffff 0xffffffff 0x8000000000000000
+0xffffffff 0xffffffff 0xffffffffffffffff
+0xffffffff 0xffffffff 0x7fffffffffffffff
+0xffffffff 0x80008000 0x8000000000000000
+0xffffffff 0x80008000 0xffffffffffffffff
+0xffffffff 0x80008000 0x7fffffffffffffff
+0xffff8000 0xffff8000 0x8000000000000000
+0xffff8000 0xffff8000 0xffffffffffffffff
+0xffff8000 0xffff8000 0x7fffffffffffffff
+0x00000001 0xffffffff 0x0000000000000000
+0xffff0001 0x0000ffff 0x0000000000000000
+0x00010000 0xffffffff 0x0000000000000000
+0xffff0000 0x0001ffff 0x0000000000000000
+0x00000000 0x00000000 0x0000000000000000
+
+#mulacsx.s16.e
+0x00010001 0x00010001 0x0000000000000001
+0x80007fff 0x7fff8000 0x8000000000000000
+0x80007fff 0x7fff8000 0xffffffffffffffff
+0x80007fff 0x7fff8000 0x7fffffffffffffff
+0x7fff7fff 0x80008000 0x8000000000000000
+0x7fff7fff 0x80008000 0xffffffffffffffff
+0x7fff7fff 0x80008000 0x7fffffffffffffff
+0xffffffff 0xffffffff 0x8000000000000000
+0xffffffff 0xffffffff 0xffffffffffffffff
+0xffffffff 0xffffffff 0x7fffffffffffffff
+0xffffffff 0x80008000 0x8000000000000000
+0xffffffff 0x80008000 0xffffffffffffffff
+0xffffffff 0x80008000 0x7fffffffffffffff
+0x8000ffff 0xffff8000 0x8000000000000000
+0x8000ffff 0xffff8000 0xffffffffffffffff
+0x8000ffff 0xffff8000 0x7fffffffffffffff
+0x00010000 0xffffffff 0x0000000000000000
+0x0001ffff 0x0000ffff 0x0000000000000000
+0x00000001 0xffffffff 0x0000000000000000
+0x0000ffff 0x0001ffff 0x0000000000000000
+0x00000000 0x00000000 0x0000000000000000
+
+#mulsca.s16.e
+0x00010001 0x00010001 0x0000000000000001
+0x80007fff 0x80007fff 0x8000000000000000
+0x80007fff 0x80007fff 0xffffffffffffffff
+0x80007fff 0x80007fff 0x7fffffffffffffff
+0x7fff7fff 0x80008000 0x8000000000000000
+0x7fff7fff 0x80008000 0xffffffffffffffff
+0x7fff7fff 0x80008000 0x7fffffffffffffff
+0xffffffff 0xffffffff 0x8000000000000000
+0xffffffff 0xffffffff 0xffffffffffffffff
+0xffffffff 0xffffffff 0x7fffffffffffffff
+0xffffffff 0x80008000 0x8000000000000000
+0xffffffff 0x80008000 0xffffffffffffffff
+0xffffffff 0x80008000 0x7fffffffffffffff
+0x8000ffff 0x8000ffff 0x8000000000000000
+0x8000ffff 0x8000ffff 0xffffffffffffffff
+0x8000ffff 0x8000ffff 0x7fffffffffffffff
+0x00010000 0xffffffff 0x0000000000000000
+0x0001ffff 0xffff0000 0x0000000000000000
+0x00000001 0xffffffff 0x0000000000000000
+0x0000ffff 0xffff0001 0x0000000000000000
+0x00000000 0x00000000 0x0000000000000000
+
+//#mulscax.s16.e
+//0x00010001 0x00010001 0x0000000000000001
+//0x80007fff 0x7fff8000 0x8000000000000000
+//0x80007fff 0x7fff8000 0xffffffffffffffff
+//0x80007fff 0x7fff8000 0x7fffffffffffffff
+//0x7fff7fff 0x80008000 0x8000000000000000
+//0x7fff7fff 0x80008000 0xffffffffffffffff
+//0x7fff7fff 0x80008000 0x7fffffffffffffff
+//0xffffffff 0xffffffff 0x8000000000000000
+//0xffffffff 0xffffffff 0xffffffffffffffff
+//0xffffffff 0xffffffff 0x7fffffffffffffff
+//0xffffffff 0x80008000 0x8000000000000000
+//0xffffffff 0x80008000 0xffffffffffffffff
+//0xffffffff 0x80008000 0x7fffffffffffffff
+//0x8000ffff 0xffff8000 0x8000000000000000
+//0x8000ffff 0xffff8000 0xffffffffffffffff
+//0x8000ffff 0xffff8000 0x7fffffffffffffff
+//0x00010000 0xffffffff 0x0000000000000000
+//0x0001ffff 0x0000ffff 0x0000000000000000
+//0x00000001 0xffffffff 0x0000000000000000
+//0x0000ffff 0x0001ffff 0x0000000000000000
+//0x00000000 0x00000000 0x0000000000000000
+
+#mul.u32
+0x7fffffff 0x7fffffff
+0x80000000 0x80000000
+0xffffffff 0xffffffff
+0x00000000 0x00000000
+0x7fffffff 0x80000000
+0x80000000 0x7fffffff
+0x7fffffff 0xffffffff
+0xffffffff 0x7fffffff
+0x7fffffff 0x00000000
+0x00000000 0x7fffffff
+0x80000000 0xffffffff
+0xffffffff 0x80000000
+0x00000000 0x80000000
+0x80000000 0x00000000
+0xffffffff 0x00000000
+0x00000000 0xffffffff
+
+#mul.s32
+0x7fffffff 0x7fffffff
+0x80000000 0x80000000
+0xffffffff 0xffffffff
+0x00000000 0x00000000
+0x7fffffff 0x80000000
+0x80000000 0x7fffffff
+0x7fffffff 0xffffffff
+0xffffffff 0x7fffffff
+0x7fffffff 0x00000000
+0x00000000 0x7fffffff
+0x80000000 0xffffffff
+0xffffffff 0x80000000
+0x00000000 0x80000000
+0x80000000 0x00000000
+0xffffffff 0x00000000
+0x00000000 0xffffffff
+
+#mula.u32
+0x00000001 0x00000001 0x0000000000000001
+0x00000001 0x00000001 0xffffffffffffffff
+0x00000001 0x00000001 0x8000000000000000
+0x00000001 0x00000001 0x7fffffffffffffff
+0x00000001 0xffffffff 0xffffffffffffffff
+0x00000001 0xffffffff 0x8000000000000000
+0x00000001 0xffffffff 0x7fffffffffffffff
+0x80000000 0x80000000 0xffffffffffffffff
+0x80000000 0x80000000 0x8000000000000000
+0x80000000 0x80000000 0x7fffffffffffffff
+0x7fffffff 0xffffffff 0xffffffffffffffff
+0x7fffffff 0xffffffff 0x8000000000000000
+0x7fffffff 0xffffffff 0x7fffffffffffffff
+0x00000000 0x00000001 0x0000000000000000
+0x00000001 0x00000000 0x0000000000000000
+
+#mula.s32
+0x00000001 0x00000001 0x0000000000000001
+0x00000001 0x00000001 0xffffffffffffffff
+0x00000001 0x00000001 0x8000000000000000
+0x00000001 0x00000001 0x7fffffffffffffff
+0x00000001 0xffffffff 0xffffffffffffffff
+0x00000001 0xffffffff 0x8000000000000000
+0x00000001 0xffffffff 0x7fffffffffffffff
+0x80000000 0x80000000 0xffffffffffffffff
+0x80000000 0x80000000 0x8000000000000000
+0x80000000 0x80000000 0x7fffffffffffffff
+0x7fffffff 0xffffffff 0xffffffffffffffff
+0x7fffffff 0xffffffff 0x8000000000000000
+0x7fffffff 0xffffffff 0x7fffffffffffffff
+0x00000000 0x00000001 0x0000000000000000
+0x00000001 0x00000000 0x0000000000000000
+
+#mul.s32.h
+0x7fffffff 0x7fffffff
+0x80000000 0x80000000
+0xffffffff 0xffffffff
+0x00000000 0x00000000
+0x7fffffff 0x80000000
+0x80000000 0x7fffffff
+0x7fffffff 0xffffffff
+0xffffffff 0x7fffffff
+0x7fffffff 0x00000000
+0x00000000 0x7fffffff
+0x80000000 0xffffffff
+0xffffffff 0x80000000
+0x00000000 0x80000000
+0x80000000 0x00000000
+0xffffffff 0x00000000
+0x00000000 0xffffffff
+
+#mul.s32.rh
+0x7fffffff 0x7fffffff
+0x80000000 0x80000000
+0xffffffff 0xffffffff
+0x00000000 0x00000000
+0x7fffffff 0x80000000
+0x80000000 0x7fffffff
+0x7fffffff 0xffffffff
+0xffffffff 0x7fffffff
+0x7fffffff 0x00000000
+0x00000000 0x7fffffff
+0x80000000 0xffffffff
+0xffffffff 0x80000000
+0x00000000 0x80000000
+0x80000000 0x00000000
+0xffffffff 0x00000000
+0x00000000 0xffffffff
+
+#mulll.s16
+0x00000001 0x00000001
+0x00000001 0x7FFF7FFF
+0x00000001 0xFFFFFFFF
+0xFFFFFFFF 0xFFFFFFFF
+0x00008000 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7FFFFFFF
+0x80000000 0x00008000
+
+#mulhh.s16
+0x00010000 0x00010000
+0x00010000 0x7FFF7FFF
+0x00010000 0xFFFFFFFF
+0xFFFFFFFF 0xFFFFFFFF
+0x80000000 0x80008000
+0x00000000 0x00000000
+0x00000000 0xFFFF7FFF
+0x80000000 0x80000000
+
+#mulhl.s16
+0x00010000 0x00000001
+0x00010000 0x7FFF7FFF
+0x00010000 0xFFFFFFFF
+0xFFFFFFFF 0xFFFFFFFF
+0x80000000 0x80008000
+0x00000000 0x00000000
+0x00000000 0x7FFFFFFF
+0x80000000 0x00008000
+
diff --git a/tests/csky/script/inst_dspv2.h b/tests/csky/script/inst_dspv2.h
new file mode 100644
index 0000000..c21914a
--- /dev/null
+++ b/tests/csky/script/inst_dspv2.h
@@ -0,0 +1,201 @@
+/*
+ *  CSKY helper routines
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _INST_DSPV2_H
+#define _INST_DSPV2_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#define TRUE    1
+#define FALSE   0
+#define SIGNBIT64  0x8000000000000000
+#define DSPV2_HELPER(name) dspv2_helper_##name 
+typedef unsigned long long uint64_t;
+typedef unsigned int uint32_t;
+typedef unsigned short uint16_t;
+typedef unsigned char uint8_t;
+
+
+uint32_t DSPV2_HELPER(add_s32_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(add_u32_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(padd_s8_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(padd_u8_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(padd_s16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(padd_u16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(sub_s32_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(sub_u32_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psub_s8_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psub_u8_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psub_s16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psub_u16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(paddh_s8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(paddh_u8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(paddh_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(paddh_u16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psubh_s8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psubh_u8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psubh_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psubh_u16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pasx_s16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pasx_u16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psax_s16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psax_u16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pasxh_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pasxh_u16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psaxh_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psaxh_u16)(uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(add_s64_s)(uint64_t x, uint64_t y);
+uint64_t DSPV2_HELPER(add_u64_s)(uint64_t x, uint64_t y);
+uint64_t DSPV2_HELPER(sub_s64_s)(uint64_t x, uint64_t y);
+uint64_t DSPV2_HELPER(sub_u64_s)(uint64_t x, uint64_t y);
+uint32_t DSPV2_HELPER(lsli_32_s)(uint32_t x, uint32_t imm);
+uint32_t DSPV2_HELPER(lsl_32_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(plsli_u16_s)(uint32_t x, uint32_t imm);
+uint32_t DSPV2_HELPER(plsl_u16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pcmpne_8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pcmpne_16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pcmphs_u8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pcmphs_s8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pcmphs_u16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pcmphs_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pcmplt_u8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pcmplt_s8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pcmplt_u16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pcmplt_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pmax_s8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pmax_u8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pmin_s8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pmin_u8)(uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(pext_u8_e)(uint32_t x);
+uint64_t DSPV2_HELPER(pext_s8_e)(uint32_t x);
+uint64_t DSPV2_HELPER(pextx_u8_e)(uint32_t x);
+uint64_t DSPV2_HELPER(pextx_s8_e)(uint32_t x);
+uint32_t DSPV2_HELPER(narl)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(narh)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(narlx)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(narhx)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(clipi_u32)(uint32_t x, uint32_t imm);
+uint32_t DSPV2_HELPER(clipi_s32)(uint32_t x, uint32_t imm);
+uint32_t DSPV2_HELPER(clip_u32)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(clip_s32)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pclipi_u16)(uint32_t x, uint32_t imm);
+uint32_t DSPV2_HELPER(pclipi_s16)(uint32_t x, uint32_t imm);
+uint32_t DSPV2_HELPER(pclip_u16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pclip_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(pabs_s8_s)(uint32_t x);
+uint32_t DSPV2_HELPER(pabs_s16_s)(uint32_t x);
+uint32_t DSPV2_HELPER(abs_s32_s)(uint32_t x);
+uint32_t DSPV2_HELPER(pneg_s8_s)(uint32_t x);
+uint32_t DSPV2_HELPER(pneg_s16_s)(uint32_t x);
+uint32_t DSPV2_HELPER(neg_s32_s)(uint32_t x);
+uint32_t DSPV2_HELPER(rmul_s32_h)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(rmul_s32_rh)(uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mula_s32_s)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mula_u32_s)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(muls_s32_s)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(muls_u32_s)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mula_32_l)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mula_s32_hs)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(muls_s32_hs)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mula_s32_rhs)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(muls_s32_rhs)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(rmulxl_s32)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(rmulxl_s32_r)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(rmulxh_s32)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(rmulxh_s32_r)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulaxl_s32_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulaxl_s32_rs)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulaxh_s32_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulaxh_s32_rs)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(rmulll_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(rmulhh_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(rmulhl_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulall_s16)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulall_s16_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulahh_s16_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulahl_s16_s)(uint32_t z, uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mulall_s16_e)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mulahh_s16_e)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mulahl_s16_e)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(prmul_s16)(uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(prmulx_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(prmul_s16_h)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(prmul_s16_rh)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(prmulx_s16_h)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(prmulx_s16_rh)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulca_s16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulcax_s16_s)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulaca_s16_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulacax_s16_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulacs_s16_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulacsr_s16_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulacsx_s16_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulsca_s16_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulscax_s16_s)(uint32_t z, uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psabsa_u8)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(psabsaa_u8)(uint32_t z, uint32_t x, uint32_t y);
+
+/* tcg instructions */
+uint64_t DSPV2_HELPER(muls_u32)(uint32_t z, uint32_t z1,
+                                uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(muls_s32)(uint32_t z, uint32_t z1,
+                                uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulxl_s32)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulxl_s32_r)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulxh_s32)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulxh_s32_r)(uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(pmul_s16)(uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(pmul_u16)(uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(pmulx_s16)(uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(pmulx_u16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulcs_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulcsr_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulcsx_s16)(uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mulaca_s16_e)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mulacax_s16_e)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mulacs_s16_e)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mulacsr_s16_e)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mulacsx_s16_e)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mulsca_s16_e)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mulscax_s16_e)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y);
+uint64_t DSPV2_HELPER(mul_u32)(uint32_t x, u_int32_t y);
+uint64_t DSPV2_HELPER(mul_s32)(uint32_t x, u_int32_t y);
+uint64_t DSPV2_HELPER(mula_u32)(uint32_t z, u_int32_t z1,
+                                uint32_t x, u_int32_t y);
+uint64_t DSPV2_HELPER(mula_s32)(uint32_t z, u_int32_t z1,
+                                uint32_t x, u_int32_t y);
+uint32_t DSPV2_HELPER(mul_s32_h)(uint32_t x, u_int32_t y);
+uint32_t DSPV2_HELPER(mul_s32_rh)(uint32_t x, u_int32_t y);
+uint32_t DSPV2_HELPER(mulll_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulhh_s16)(uint32_t x, uint32_t y);
+uint32_t DSPV2_HELPER(mulhl_s16)(uint32_t x, uint32_t y);
+#endif
diff --git a/tests/csky/script/main.c b/tests/csky/script/main.c
new file mode 100644
index 0000000..6fa1f55
--- /dev/null
+++ b/tests/csky/script/main.c
@@ -0,0 +1,607 @@
+/*
+ *  CSKY DSPv2 test case data generate.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <string.h>
+#include "inst_dspv2.h"
+
+FILE *fp;
+FILE *fp_sample_h;
+FILE *fp_dspv2_insn_s;
+FILE *fp_dspv2_insn_h;
+FILE *fp_case_c;
+#define ISSPACE(c) (c == ' ' || c == '\t')
+
+enum op_type {
+    I_NO,
+    I64,
+    I32,
+};
+/* num = 1, op1 = rx                                    */
+/* num = 2, op1 = rx, op2 = ry                          */
+/* num = 3, op1 = rx, op2 = ry, op3 = rz,rz+1           */
+
+struct _func_map {
+    char *name;
+    void *func;
+    int ret_type;
+    enum op_type op_num;
+    enum op_type op1_type;
+    enum op_type op2_type;
+    enum op_type op3_type;
+    enum op_type op4_type;
+};
+
+struct _func_map funcs[] = {
+    {"padd.u8.s", &DSPV2_HELPER(padd_u8_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"padd.s8.s", &DSPV2_HELPER(padd_s8_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"padd.u16.s", &DSPV2_HELPER(padd_u16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"padd.s16.s", &DSPV2_HELPER(padd_s16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"add.u32.s", &DSPV2_HELPER(add_u32_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"add.s32.s", &DSPV2_HELPER(add_s32_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"psub.u8.s", &DSPV2_HELPER(psub_u8_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"psub.s8.s", &DSPV2_HELPER(psub_s8_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"psub.u16.s", &DSPV2_HELPER(psub_u16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"psub.s16.s", &DSPV2_HELPER(psub_s16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"sub.u32.s", &DSPV2_HELPER(sub_u32_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"sub.s32.s", &DSPV2_HELPER(sub_s32_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"paddh.u8", &DSPV2_HELPER(paddh_u8), I32, 2, I32, I32, I_NO, I_NO},
+    {"paddh.s8", &DSPV2_HELPER(paddh_s8), I32, 2, I32, I32, I_NO, I_NO},
+    {"paddh.u16", &DSPV2_HELPER(paddh_u16), I32, 2, I32, I32, I_NO, I_NO},
+    {"paddh.s16", &DSPV2_HELPER(paddh_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"psubh.u8", &DSPV2_HELPER(psubh_u8), I32, 2, I32, I32, I_NO, I_NO},
+    {"psubh.s8", &DSPV2_HELPER(psubh_s8), I32, 2, I32, I32, I_NO, I_NO},
+    {"psubh.u16", &DSPV2_HELPER(psubh_u16), I32, 2, I32, I32, I_NO, I_NO},
+    {"psubh.s16", &DSPV2_HELPER(psubh_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"add.u64.s", &DSPV2_HELPER(add_u64_s), I64, 2, I64, I64, I_NO, I_NO},
+    {"add.s64.s", &DSPV2_HELPER(add_s64_s), I64, 2, I64, I64, I_NO, I_NO},
+    {"sub.u64.s", &DSPV2_HELPER(sub_u64_s), I64, 2, I64, I64, I_NO, I_NO},
+    {"sub.s64.s", &DSPV2_HELPER(sub_s64_s), I64, 2, I64, I64, I_NO, I_NO},
+    {"pasx.u16.s", &DSPV2_HELPER(pasx_u16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"pasx.s16.s", &DSPV2_HELPER(pasx_s16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"psax.u16.s", &DSPV2_HELPER(psax_u16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"psax.s16.s", &DSPV2_HELPER(psax_s16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"pasxh.u16", &DSPV2_HELPER(pasxh_u16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pasxh.s16", &DSPV2_HELPER(pasxh_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"psaxh.u16", &DSPV2_HELPER(psaxh_u16), I32, 2, I32, I32, I_NO, I_NO},
+    {"psaxh.s16", &DSPV2_HELPER(psaxh_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pcmpne.8", &DSPV2_HELPER(pcmpne_8), I32, 2, I32, I32, I_NO, I_NO},
+    {"pcmpne.16", &DSPV2_HELPER(pcmpne_16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pcmphs.u8", &DSPV2_HELPER(pcmphs_u8), I32, 2, I32, I32, I_NO, I_NO},
+    {"pcmphs.s8", &DSPV2_HELPER(pcmphs_s8), I32, 2, I32, I32, I_NO, I_NO},
+    {"pcmphs.u16", &DSPV2_HELPER(pcmphs_u16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pcmphs.s16", &DSPV2_HELPER(pcmphs_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pcmplt.u8", &DSPV2_HELPER(pcmplt_u8), I32, 2, I32, I32, I_NO, I_NO},
+    {"pcmplt.s8", &DSPV2_HELPER(pcmplt_s8), I32, 2, I32, I32, I_NO, I_NO},
+    {"pcmplt.u16", &DSPV2_HELPER(pcmplt_u16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pcmplt.s16", &DSPV2_HELPER(pcmplt_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pmax.u8", &DSPV2_HELPER(pmax_u8), I32, 2, I32, I32, I_NO, I_NO},
+    {"pmax.s8", &DSPV2_HELPER(pmax_s8), I32, 2, I32, I32, I_NO, I_NO},
+    {"pmin.u8", &DSPV2_HELPER(pmin_u8), I32, 2, I32, I32, I_NO, I_NO},
+    {"pmin.s8", &DSPV2_HELPER(pmin_s8), I32, 2, I32, I32, I_NO, I_NO},
+    {"psabsa.u8", &DSPV2_HELPER(psabsa_u8), I32, 2, I32, I32, I_NO, I_NO},
+    {"psabsaa.u8", &DSPV2_HELPER(psabsaa_u8), I32, 3, I32, I32, I32, I_NO},
+    {"lsli.32.s", &DSPV2_HELPER(lsli_32_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"lsl.32.s", &DSPV2_HELPER(lsl_32_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"plsli.u16.s", &DSPV2_HELPER(plsli_u16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"plsl.u16.s", &DSPV2_HELPER(plsl_u16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"pext.u8.e", &DSPV2_HELPER(pext_u8_e), I64, 1, I32, I_NO, I_NO, I_NO},
+    {"pext.s8.e", &DSPV2_HELPER(pext_s8_e), I64, 1, I32, I_NO, I_NO, I_NO},
+    {"pextx.u8.e", &DSPV2_HELPER(pextx_u8_e), I64, 1, I32, I_NO, I_NO, I_NO},
+    {"pextx.s8.e", &DSPV2_HELPER(pextx_s8_e), I64, 1, I32, I_NO, I_NO, I_NO},
+    {"narl", &DSPV2_HELPER(narl), I32, 2, I32, I32, I_NO, I_NO},
+    {"narh", &DSPV2_HELPER(narh), I32, 2, I32, I32, I_NO, I_NO},
+    {"narlx", &DSPV2_HELPER(narlx), I32, 2, I32, I32, I_NO, I_NO},
+    {"narhx", &DSPV2_HELPER(narhx), I32, 2, I32, I32, I_NO, I_NO},
+    {"clipi.u32", &DSPV2_HELPER(clipi_u32), I32, 2, I32, I32, I_NO, I_NO},
+    {"clipi.s32", &DSPV2_HELPER(clipi_s32), I32, 2, I32, I32, I_NO, I_NO},
+    {"clip.u32", &DSPV2_HELPER(clip_u32), I32, 2, I32, I32, I_NO, I_NO},
+    {"clip.s32", &DSPV2_HELPER(clip_s32), I32, 2, I32, I32, I_NO, I_NO},
+    {"pclipi.u16", &DSPV2_HELPER(pclipi_u16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pclipi.s16", &DSPV2_HELPER(pclipi_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pclip.u16", &DSPV2_HELPER(pclip_u16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pclip.s16", &DSPV2_HELPER(pclip_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"pabs.s8.s", &DSPV2_HELPER(pabs_s8_s), I32, 1, I32, I_NO, I_NO},
+    {"pabs.s16.s", &DSPV2_HELPER(pabs_s16_s), I32, 1, I32, I_NO, I_NO, I_NO},
+    {"abs.s32.s", &DSPV2_HELPER(abs_s32_s), I32, 1, I32, I_NO, I_NO, I_NO},
+    {"pneg.s8.s", &DSPV2_HELPER(pneg_s8_s), I32, 1, I32, I_NO, I_NO, I_NO},
+    {"pneg.s16.s", &DSPV2_HELPER(pneg_s16_s), I32, 1, I32, I_NO, I_NO, I_NO},
+    {"neg.s32.s", &DSPV2_HELPER(neg_s32_s), I32, 1, I32, I_NO, I_NO, I_NO},
+    {"mula.u32.s", &DSPV2_HELPER(mula_u32_s), I64, 3, I32, I32, I64, I_NO},
+    {"mula.s32.s", &DSPV2_HELPER(mula_s32_s), I64, 3, I32, I32, I64, I_NO},
+    {"muls.u32.s", &DSPV2_HELPER(muls_u32_s), I64, 3, I32, I32, I64, I_NO},
+    {"muls.s32.s", &DSPV2_HELPER(muls_s32_s), I64, 3, I32, I32, I64, I_NO},
+    {"mula.32.l", &DSPV2_HELPER(mula_32_l), I32, 3, I32, I32, I32, I_NO},
+    {"rmul.s32.h", &DSPV2_HELPER(rmul_s32_h), I32, 2, I32, I32, I_NO, I_NO},
+    {"rmul.s32.rh", &DSPV2_HELPER(rmul_s32_rh), I32, 2, I32, I32, I_NO, I_NO},
+    {"mula.s32.hs", &DSPV2_HELPER(mula_s32_hs), I32, 3, I32, I32, I32, I_NO},
+    {"muls.s32.hs", &DSPV2_HELPER(muls_s32_hs), I32, 3, I32, I32, I32, I_NO},
+    {"mula.s32.rhs", &DSPV2_HELPER(mula_s32_rhs), I32, 3, I32, I32, I32, I_NO},
+    {"muls.s32.rhs", &DSPV2_HELPER(muls_s32_rhs), I32, 3, I32, I32, I32, I_NO},
+    {"rmulll.s16", &DSPV2_HELPER(rmulll_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"rmulhh.s16", &DSPV2_HELPER(rmulhh_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"rmulhl.s16", &DSPV2_HELPER(rmulhl_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulall.s16", &DSPV2_HELPER(mulall_s16), I32, 3, I32, I32, I32, I_NO},
+    {"mulall.s16.s", &DSPV2_HELPER(mulall_s16_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulahh.s16.s", &DSPV2_HELPER(mulahh_s16_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulahl.s16.s", &DSPV2_HELPER(mulahl_s16_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulall.s16.e", &DSPV2_HELPER(mulall_s16_e), I64, 3, I32, I32, I64, I_NO},
+    {"mulahh.s16.e", &DSPV2_HELPER(mulahh_s16_e), I64, 3, I32, I32, I64, I_NO},
+    {"mulahl.s16.e", &DSPV2_HELPER(mulahl_s16_e), I64, 3, I32, I32, I64, I_NO},
+    {"prmul.s16", &DSPV2_HELPER(prmul_s16), I64, 2, I32, I32, I_NO, I_NO},
+    {"prmulx.s16", &DSPV2_HELPER(prmulx_s16), I64, 2, I32, I32, I_NO, I_NO},
+    {"prmul.s16.h", &DSPV2_HELPER(prmul_s16_h), I32, 2, I32, I32, I_NO, I_NO},
+    {"prmul.s16.rh", &DSPV2_HELPER(prmul_s16_rh), I32, 2, I32, I32, I_NO, I_NO},
+    {"prmulx.s16.h", &DSPV2_HELPER(prmulx_s16_h), I32, 2, I32, I32, I_NO, I_NO},
+    {"prmulx.s16.rh", &DSPV2_HELPER(prmulx_s16_rh), I32, 2, I32, I32, I_NO, I_NO},
+    {"rmulxl.s32", &DSPV2_HELPER(rmulxl_s32), I32, 2, I32, I32, I_NO, I_NO},
+    {"rmulxl.s32.r", &DSPV2_HELPER(rmulxl_s32_r), I32, 2, I32, I32, I_NO, I_NO},
+    {"rmulxh.s32", &DSPV2_HELPER(rmulxh_s32), I32, 2, I32, I32, I_NO, I_NO},
+    {"rmulxh.s32.r", &DSPV2_HELPER(rmulxh_s32_r), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulaxl.s32.s", &DSPV2_HELPER(mulaxl_s32_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulaxl.s32.rs", &DSPV2_HELPER(mulaxl_s32_rs), I32, 3, I32, I32, I32, I_NO},
+    {"mulaxh.s32.s", &DSPV2_HELPER(mulaxh_s32_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulaxh.s32.rs", &DSPV2_HELPER(mulaxh_s32_rs), I32, 3, I32, I32, I32, I_NO},
+    {"mulca.s16.s", &DSPV2_HELPER(mulca_s16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulcax.s16.s", &DSPV2_HELPER(mulcax_s16_s), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulaca.s16.s", &DSPV2_HELPER(mulaca_s16_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulacax.s16.s", &DSPV2_HELPER(mulacax_s16_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulacs.s16.s", &DSPV2_HELPER(mulacs_s16_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulacsr.s16.s", &DSPV2_HELPER(mulacsr_s16_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulacsx.s16.s", &DSPV2_HELPER(mulacsx_s16_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulsca.s16.s", &DSPV2_HELPER(mulsca_s16_s), I32, 3, I32, I32, I32, I_NO},
+    {"mulscax.s16.s", &DSPV2_HELPER(mulscax_s16_s), I32, 3, I32, I32, I32, I_NO},
+    /* TCG instructions */
+    {"muls.u32", &DSPV2_HELPER(muls_u32), I64, 3, I32, I32, I64, I_NO},
+    {"muls.s32", &DSPV2_HELPER(muls_s32), I64, 3, I32, I32, I64, I_NO},
+    {"mulxl.s32", &DSPV2_HELPER(mulxl_s32), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulxl.s32.r", &DSPV2_HELPER(mulxl_s32_r), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulxh.s32", &DSPV2_HELPER(mulxl_s32), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulxh.s32.r", &DSPV2_HELPER(mulxl_s32_r), I32, 2, I32, I32, I_NO, I_NO},
+    {"pmul.s16", &DSPV2_HELPER(pmul_s16), I64, 2, I32, I32, I_NO, I_NO},
+    {"pmul.u16", &DSPV2_HELPER(pmul_u16), I64, 2, I32, I32, I_NO, I_NO},
+    {"pmulx.s16", &DSPV2_HELPER(pmulx_s16), I64, 2, I32, I32, I_NO, I_NO},
+    {"pmulx.u16", &DSPV2_HELPER(pmulx_u16), I64, 2, I32, I32, I_NO, I_NO},
+    {"mulcs.s16", &DSPV2_HELPER(mulcs_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulcsr.s16", &DSPV2_HELPER(mulcsr_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulcsx.s16", &DSPV2_HELPER(mulcsx_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulaca.s16.e", &DSPV2_HELPER(mulaca_s16_e), I64, 3, I32, I32, I64, I_NO},
+    {"mulacax.s16.e", &DSPV2_HELPER(mulacax_s16_e), I64, 3, I32, I32, I64, I_NO},
+    {"mulacs.s16.e", &DSPV2_HELPER(mulacs_s16_e), I64, 3, I32, I32, I64, I_NO},
+    {"mulacsr.s16.e", &DSPV2_HELPER(mulacsr_s16_e), I64, 3, I32, I32, I64, I_NO},
+    {"mulacsx.s16.e", &DSPV2_HELPER(mulacsx_s16_e), I64, 3, I32, I32, I64, I_NO},
+    {"mulsca.s16.e", &DSPV2_HELPER(mulsca_s16_e), I64, 3, I32, I32, I64, I_NO},
+    {"mulscax.s16.e", &DSPV2_HELPER(mulscax_s16_e), I64, 3, I32, I32, I64, I_NO},
+    {"mul.u32", &DSPV2_HELPER(mul_u32), I64, 2, I32, I32, I_NO, I_NO},
+    {"mul.s32", &DSPV2_HELPER(mul_s32), I64, 2, I32, I32, I_NO, I_NO},
+    {"mula.u32", &DSPV2_HELPER(mula_u32), I64, 3, I32, I32, I64, I_NO},
+    {"mula.s32", &DSPV2_HELPER(mula_s32), I64, 3, I32, I32, I64, I_NO},
+    {"mul.s32.h", &DSPV2_HELPER(mul_s32_h), I32, 2, I32, I32, I_NO, I_NO},
+    {"mul.s32.rh", &DSPV2_HELPER(mul_s32_rh), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulll.s16", &DSPV2_HELPER(mulll_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulhh.s16", &DSPV2_HELPER(mulhh_s16), I32, 2, I32, I32, I_NO, I_NO},
+    {"mulhl.s16", &DSPV2_HELPER(mulhl_s16), I32, 2, I32, I32, I_NO, I_NO},
+};
+
+enum line_type {
+    INSN,
+    SAMPLE,
+    NOTE,
+    UNKOWN,
+    EMPTY_LINE,
+    IS_EOF,
+};
+
+struct CASE_DATA {
+    char name[20];
+    uint64_t case_op[4];
+};
+
+struct line {
+    char str[100];
+    char underline_name[20];
+    enum line_type type;
+    int is_find;
+    int new_insn;
+    int print_end;
+    struct CASE_DATA test_data;
+    struct _func_map *funcs_addr;
+} line;
+
+int get_a_line()
+{
+    int i = 0;
+    if (fgets(line.str, 100, fp) == NULL)
+    {
+        line.type = IS_EOF;
+        return;
+    }
+    char *c = line.str;
+    while (ISSPACE(*c)) {
+        c++;
+    }
+
+    if (*c == '#') {
+        char *name_c = &line.test_data.name[0];
+        line.type = INSN;
+        line.is_find = FALSE;
+        c++;
+        while (!ISSPACE(*c) && *c != '\0' && *c != '\n' && i < 19) {
+            *(name_c++) = *(c++);
+            i++;
+        }
+        *name_c = '\0';
+    } else if (*c == '/') {
+        if (*c == '/') {
+            line.type = NOTE;
+        }
+        else {
+            line.type = UNKOWN;
+        }
+    } else if (*c == '\n') {
+        line.type = EMPTY_LINE;
+    } else {
+        line.type = SAMPLE;
+        char num[20];
+        int j = 0;
+        while (*c != '\0' && *c != '\n') {
+            i = 0;
+            while (!ISSPACE(*c) && *c != '\0' && *c != '\n' && i < 19) {
+                num[i++] = *(c++);
+            }
+            num[i] = '\0';
+            line.test_data.case_op[j++] = strtoull (num, NULL, 0);
+            while (ISSPACE(*c)) {
+                c++;
+            }
+        }
+    }
+    return 0;
+}
+void exchange_name(void)
+{
+    /* replace the '.' with '_' in insn name. */
+    char *name_dst = line.underline_name;
+    char *name_src = line.test_data.name;
+    while (*name_src != '\0') {
+        if (*name_src == '.') {
+            *name_dst = '_';
+        } else {
+            *name_dst = *name_src;
+        }
+        name_src++;
+        name_dst++;
+    }
+    *name_dst = '\0';
+}
+
+int find_insn()
+{
+    int i;
+    for (i = 0; i < sizeof(funcs)/sizeof(struct _func_map); i++) {
+        if (strcmp(line.test_data.name, funcs[i].name) == 0) {
+            line.is_find = TRUE;
+            line.new_insn = TRUE;
+            line.funcs_addr = &funcs[i];
+            break;
+        }
+    }
+    if (line.is_find == TRUE) {
+        exchange_name();
+        if (line.print_end == TRUE){
+            line.print_end = FALSE;
+            fprintf(fp_sample_h, "};\n\n");
+        }
+        fprintf(fp_sample_h, "/* %s */\n", line.test_data.name);
+    } else {
+        printf("\nError: can not find %s\n", line.test_data.name);
+    }
+}
+
+/* print casae xxxx.c head */
+void print_case_head()
+{
+    fprintf(fp_case_c, "#include \"testsuite.h\"\n");
+    fprintf(fp_case_c, "#include \"test_device.h\"\n");
+    fprintf(fp_case_c, "#include \"dspv2_insn.h\"\n");
+    fprintf(fp_case_c, "#include \"sample_array.h\"\n");
+    fprintf(fp_case_c, "int main(void)\n");
+    fprintf(fp_case_c, "{\n");
+    fprintf(fp_case_c, "    int i = 0;\n");
+    fprintf(fp_case_c, "    init_testsuite(\"Testing insn %s\\n\");\n\n",
+            line.test_data.name);
+}
+
+int calc_case()
+{
+    uint32_t (*func_www)(uint32_t, uint32_t);
+    uint32_t (*func_wwww)(uint32_t, uint32_t, uint32_t);
+    uint64_t (*func_dww)(uint32_t, uint32_t);
+    uint64_t (*func_dwwd)(uint32_t, uint32_t, int32_t, int32_t);
+    uint32_t ret_w;
+    uint64_t ret_d;
+    char file_name[35] = "./case/";
+    if (line.funcs_addr->op_num == 2
+            && line.funcs_addr->ret_type == I32
+            && line.funcs_addr->op1_type == I32
+            && line.funcs_addr->op2_type == I32) {
+        func_www = line.funcs_addr->func;
+        ret_w = (*func_www)((uint32_t)(line.test_data.case_op[0]),
+                (uint32_t)(line.test_data.case_op[1]));
+
+        if (line.new_insn == TRUE) {
+            fprintf(fp_sample_h, "struct binary_calculation samples_%s[] = {\n",
+                    line.underline_name);
+            fprintf(fp_dspv2_insn_s, "\nTEST_FUNC(test_%s)\n",
+                    line.underline_name);
+            fprintf(fp_dspv2_insn_s, "    %s    a0, a0, a1\n",
+                    line.test_data.name);
+            fprintf(fp_dspv2_insn_s, "    rts\n");
+            fprintf(fp_dspv2_insn_s, "    .size   test_%s, .-test_%s\n",
+                    line.underline_name, line.underline_name);
+            fprintf(fp_dspv2_insn_h, "int32_t test_%s(int32_t a, int32_t b);\n",
+                    line.underline_name);
+            /* case file: xxxx.c */
+            strcat(file_name, line.underline_name);
+            strcat(file_name, ".c");
+            fp_case_c = fopen(file_name, "w");
+            print_case_head();
+            fprintf(fp_case_c, "    for (i = 0;\n");
+            fprintf(fp_case_c,
+                    "         i < sizeof(samples_%s)/sizeof(struct binary_calculation);\n",
+                    line.underline_name);
+            fprintf(fp_case_c, "         i++) {\n");
+            fprintf(fp_case_c,
+                    "        TEST(test_%s(samples_%s[i].op1, samples_%s[i].op2)\n",
+                    line.underline_name, line.underline_name,
+                    line.underline_name);
+            fprintf(fp_case_c, "                     == samples_%s[i].result);\n",
+                    line.underline_name);
+            fprintf(fp_case_c, "    }\n");
+            fprintf(fp_case_c, "    return done_testing();\n");
+            fprintf(fp_case_c, "}\n");
+            fclose(fp_case_c);
+            line.new_insn = FALSE;
+            line.print_end = TRUE;
+        }
+        fprintf(fp_sample_h, "    {0x%08x, 0x%08x, 0x%08x},\n",
+                (uint32_t)line.test_data.case_op[0],
+                (uint32_t)line.test_data.case_op[1], ret_w);
+    } else if (line.funcs_addr->op_num == 2
+            && line.funcs_addr->ret_type == I64
+            && line.funcs_addr->op1_type == I32
+            && line.funcs_addr->op2_type == I32) {
+        func_dww = line.funcs_addr->func;
+        ret_d = (*func_dww)((uint32_t)(line.test_data.case_op[0]),
+                (uint32_t)(line.test_data.case_op[1]));
+
+        if (line.new_insn == TRUE) {
+            fprintf(fp_sample_h, "struct binary64_calculation samples_%s[] = {\n",
+                    line.underline_name);
+            fprintf(fp_dspv2_insn_s, "\nTEST_FUNC(test_%s)\n",
+                    line.underline_name);
+            fprintf(fp_dspv2_insn_s, "    %s    a0, a0, a1\n",
+                    line.test_data.name);
+            fprintf(fp_dspv2_insn_s, "    rts\n");
+            fprintf(fp_dspv2_insn_s, "    .size   test_%s, .-test_%s\n",
+                    line.underline_name, line.underline_name);
+            fprintf(fp_dspv2_insn_h, "int64_t test_%s(int32_t a, int32_t b);\n",
+                    line.underline_name);
+            /* case file: xxxx.c */
+            strcat(file_name, line.underline_name);
+            strcat(file_name, ".c");
+            fp_case_c = fopen(file_name, "w");
+            print_case_head();
+            fprintf(fp_case_c, "    for (i = 0;\n");
+            fprintf(fp_case_c,
+                    "         i < sizeof(samples_%s)/sizeof(struct binary64_calculation);\n",
+                    line.underline_name);
+            fprintf(fp_case_c, "         i++) {\n");
+            fprintf(fp_case_c,
+                    "        TEST(test_%s(samples_%s[i].op1, samples_%s[i].op2)\n",
+                    line.underline_name, line.underline_name,
+                    line.underline_name);
+            fprintf(fp_case_c, "                     == samples_%s[i].result);\n",
+                    line.underline_name);
+            fprintf(fp_case_c, "    }\n");
+            fprintf(fp_case_c, "    return done_testing();\n");
+            fprintf(fp_case_c, "}\n");
+            fclose(fp_case_c);
+            line.new_insn = FALSE;
+            line.print_end = TRUE;
+        }
+        fprintf(fp_sample_h, "    {0x%08x, 0x%08x, 0x%016llx},\n",
+                (uint32_t)line.test_data.case_op[0],
+                (uint32_t)line.test_data.case_op[1], ret_d);
+    } else  if (line.funcs_addr->op_num == 3
+            && line.funcs_addr->ret_type == I32
+            && line.funcs_addr->op1_type == I32
+            && line.funcs_addr->op2_type == I32
+            && line.funcs_addr->op3_type == I32) {
+        func_wwww = line.funcs_addr->func;
+        ret_w = (*func_wwww)((uint32_t)(line.test_data.case_op[2]),
+                (uint32_t)(line.test_data.case_op[0]),
+                (uint32_t)(line.test_data.case_op[1]));
+
+        if (line.new_insn == TRUE) {
+            fprintf(fp_sample_h,
+                    "struct ternary_calculation samples_%s[] = {\n",
+                    line.underline_name);
+            fprintf(fp_dspv2_insn_s, "\nTEST_FUNC(test_%s)\n",
+                    line.underline_name);
+            fprintf(fp_dspv2_insn_s, "    %s    a2, a0, a1\n",
+                    line.test_data.name);
+            fprintf(fp_dspv2_insn_s, "    mov    a0, a2\n");
+            fprintf(fp_dspv2_insn_s, "    rts\n");
+            fprintf(fp_dspv2_insn_s, "    .size   test_%s, .-test_%s\n",
+                    line.underline_name, line.underline_name);
+            fprintf(fp_dspv2_insn_h,
+                    "int32_t test_%s(int32_t a, int32_t b, int32_t c);\n",
+                    line.underline_name);
+            /* case file: xxxx.c */
+            strcat(file_name, line.underline_name);
+            strcat(file_name, ".c");
+            fp_case_c = fopen(file_name, "w");
+            print_case_head();
+            fprintf(fp_case_c, "    for (i = 0;\n");
+            fprintf(fp_case_c,
+                    "         i < sizeof(samples_%s)/sizeof(struct ternary_calculation);\n",
+                    line.underline_name);
+            fprintf(fp_case_c, "         i++) {\n");
+            fprintf(fp_case_c,
+                    "        TEST(test_%s(samples_%s[i].op1, samples_%s[i].op2, samples_%s[i].op3)\n",
+                    line.underline_name, line.underline_name,
+                    line.underline_name, line.underline_name);
+            fprintf(fp_case_c, "                     == samples_%s[i].result);\n",
+                    line.underline_name);
+            fprintf(fp_case_c, "    }\n");
+            fprintf(fp_case_c, "    return done_testing();\n");
+            fprintf(fp_case_c, "}\n");
+            fclose(fp_case_c);
+            line.new_insn = FALSE;
+            line.print_end = TRUE;
+        }
+        fprintf(fp_sample_h, "    {0x%08x, 0x%08x, 0x%08x, 0x%08x},\n",
+                (uint32_t)line.test_data.case_op[0],
+                (uint32_t)line.test_data.case_op[1],
+                (uint32_t)line.test_data.case_op[2], ret_w);
+    } else if (line.funcs_addr->op_num == 3
+            && line.funcs_addr->ret_type == I64
+            && line.funcs_addr->op1_type == I32
+            && line.funcs_addr->op2_type == I32
+            && line.funcs_addr->op3_type == I64) {
+        func_dwwd = line.funcs_addr->func;
+        ret_d = (*func_dwwd)((uint32_t)(line.test_data.case_op[2] & 0xffffffff),
+                (uint32_t)(line.test_data.case_op[2] >> 32),
+                (uint32_t)(line.test_data.case_op[0]),
+                (uint32_t)(line.test_data.case_op[1]));
+
+        if (line.new_insn == TRUE) {
+            fprintf(fp_sample_h, "struct ternary64_calculation samples_%s[] = {\n",
+                    line.underline_name);
+            fprintf(fp_dspv2_insn_s, "\nTEST_FUNC(test_%s)\n",
+                    line.underline_name);
+            fprintf(fp_dspv2_insn_s, "    %s    a2, a0, a1\n",
+                    line.test_data.name);
+            fprintf(fp_dspv2_insn_s, "    mov    a0, a2\n");
+            fprintf(fp_dspv2_insn_s, "    mov    a1, a3\n");
+            fprintf(fp_dspv2_insn_s, "    rts\n");
+            fprintf(fp_dspv2_insn_s, "    .size   test_%s, .-test_%s\n",
+                    line.underline_name, line.underline_name);
+            fprintf(fp_dspv2_insn_h,
+                    "int64_t test_%s(int32_t a, int32_t b, int64_t c);\n",
+                    line.underline_name);
+            /* case file: xxxx.c */
+            strcat(file_name, line.underline_name);
+            strcat(file_name, ".c");
+            fp_case_c = fopen(file_name, "w");
+            print_case_head();
+            fprintf(fp_case_c, "    for (i = 0;\n");
+            fprintf(fp_case_c,
+                    "         i < sizeof(samples_%s)/sizeof(struct ternary64_calculation);\n",
+                    line.underline_name);
+            fprintf(fp_case_c, "         i++) {\n");
+            fprintf(fp_case_c,
+                    "        TEST(test_%s(samples_%s[i].op1, samples_%s[i].op2, samples_%s[i].op3)\n",
+                    line.underline_name, line.underline_name,
+                    line.underline_name, line.underline_name);
+            fprintf(fp_case_c, "                     == samples_%s[i].result);\n",
+                    line.underline_name);
+            fprintf(fp_case_c, "    }\n");
+            fprintf(fp_case_c, "    return done_testing();\n");
+            fprintf(fp_case_c, "}\n");
+            fclose(fp_case_c);
+            line.new_insn = FALSE;
+            line.print_end = TRUE;
+        }
+        fprintf(fp_sample_h, "    {0x%08x, 0x%08x, 0x%016llx, 0x%016llx},\n",
+                (uint32_t)line.test_data.case_op[0],
+                (uint32_t)line.test_data.case_op[1],
+                line.test_data.case_op[2], ret_d);
+
+    }
+}
+
+/* print head for files. */
+void print_head(void)
+{
+    /* sample_array.h */
+    fprintf(fp_sample_h, "#include \"test_device.h\"\n");
+    fprintf(fp_sample_h, "#ifndef SAMPLE_ARRAY_H\n");
+    fprintf(fp_sample_h, "#define SAMPLE_ARRAY_H\n");
+
+    /* dspv2_insn.S*/
+    fprintf(fp_dspv2_insn_s, "   .file   \"dspv2_insn.S\"\n");
+    fprintf(fp_dspv2_insn_s, "#undef TEST_FUNC\n");
+    fprintf(fp_dspv2_insn_s, "#define TEST_FUNC(name) TEST_FUNC_M name\n");
+    fprintf(fp_dspv2_insn_s, "    .macro TEST_FUNC_M name\n");
+    fprintf(fp_dspv2_insn_s, "    .text\n");
+    fprintf(fp_dspv2_insn_s, "    .align  2\n");
+    fprintf(fp_dspv2_insn_s, "    .global \\name\n");
+    fprintf(fp_dspv2_insn_s, "    .type   \\name, @function\n");
+    fprintf(fp_dspv2_insn_s, "\\name:\n");
+    fprintf(fp_dspv2_insn_s, "    .endm\n");
+
+    /* dspv2_insn.h */
+    fprintf(fp_dspv2_insn_h, "#ifndef DSPV2_INSN_H\n");
+    fprintf(fp_dspv2_insn_h, "#define DSPV2_INSN_H\n");
+}
+
+void print_tail(void)
+{
+    /* sample_array.h  */
+    if (line.print_end == TRUE){
+        line.print_end = FALSE;
+        fprintf(fp_sample_h, "};\n\n");
+    }
+    fprintf(fp_sample_h, "#endif\n");
+
+    /* dspv2_insn.h */
+    fprintf(fp_dspv2_insn_h, "#endif\n");
+}
+
+uint32_t main(void)
+{
+    uint32_t i;
+    printf("- - - Start generate test data...\n");
+
+    fp = fopen("insn.dat", "r");
+    fp_sample_h = fopen("./case/sample_array.h", "w");
+    fp_dspv2_insn_s = fopen("./case/dspv2_insn.S", "w");
+    fp_dspv2_insn_h = fopen("./case/dspv2_insn.h", "w");
+    if(fp == NULL) {
+        printf("- - - test.dat not exist.\n");
+        return;
+    }
+    print_head();
+    line.is_find = FALSE;
+    line.new_insn = FALSE;
+    line.print_end = FALSE;
+
+    while (1) {
+        get_a_line();
+        if (line.type == NOTE || line.type == EMPTY_LINE) {
+            continue;
+        } else if (line.type == INSN) {
+            find_insn();
+            continue;
+        } else if (line.type == SAMPLE) {
+            calc_case();
+        } else if (line.type == IS_EOF){
+            break;
+        } else {
+            printf("Error: can not know this: %s", line.str);
+        }
+    }
+    print_tail();
+    fclose(fp);
+    fclose(fp_sample_h);
+    fclose(fp_dspv2_insn_s);
+    fclose(fp_dspv2_insn_h);
+    printf("- - - generate successly.\n");
+    return 0;
+}
+
+
diff --git a/tests/csky/script/op_dspv2.c b/tests/csky/script/op_dspv2.c
new file mode 100644
index 0000000..9bde96b
--- /dev/null
+++ b/tests/csky/script/op_dspv2.c
@@ -0,0 +1,1561 @@
+/*
+ *  CSKY helper routines
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "inst_dspv2.h"
+static inline uint32_t helper_sig_sat_add(uint32_t x, uint32_t y, uint32_t len)
+{
+    /* rz = rx + ry, signed & saturated add for len bits operands, len <= 32 */
+    uint32_t res = x + y;
+    uint32_t signbit = 1 << (len - 1);
+    uint32_t mask = 0xffffffff >> (32 - len);
+    if (((res ^ x) & signbit) && !((x ^ y) & signbit)) {
+        res = ~(((int32_t)(x << (32 - len)) >> 31) ^ signbit);
+    }
+    return res & mask;
+}
+
+static inline uint32_t helper_unsig_sat_add(uint32_t x,
+                                            uint32_t y, uint32_t len)
+{
+    /* rz = rx + ry, unsigned & saturated add for len bits operands. */
+    uint32_t mask = 0xffffffff >> (32 - len);
+    uint32_t res = (x + y) & mask;
+    if (res < x || res < y) {
+        res = mask;
+    }
+    return res;
+}
+
+static inline uint32_t helper_sig_sat_sub(uint32_t x, uint32_t y, uint32_t len)
+{
+    /* rz = rx - ry, signed & saturated sub for len bits operands, len <= 32 */
+    uint32_t res = x - y;
+    uint32_t signbit = 1 << (len - 1);
+    uint32_t mask = 0xffffffff >> (32 - len);
+    if (((res ^ x) & signbit) && ((x ^ y) & signbit)) {
+        res = ~(((int32_t)(x << (32 - len)) >> 31) ^ signbit);
+    }
+    return res & mask;
+}
+
+static inline uint32_t helper_unsig_sat_sub(uint32_t x,
+                                            uint32_t y, uint32_t len)
+{
+    /* rz = rx + ry, unsigned & saturated add for len bits operands. */
+    uint32_t mask = 0xffffffff >> (32 - len);
+    uint32_t res = (x - y) & mask;
+    if (res > x) {
+        res = 0;
+    }
+    return res;
+}
+
+static inline uint32_t helper_sat_lsl(uint32_t x, uint32_t n, uint32_t len)
+{
+    /*  unsigned & saturated add for len bits operands, len <= 32 */
+    uint32_t res = x << n;
+    uint32_t mask1 = (0xffffffff >> n) << n;
+    uint32_t mask2 = (0xffffffff << (32 - len)) >> (32 - len);
+    if ((x & mask1 & mask2) != 0) {
+        res = mask2;
+    }
+    return res & mask2;
+}
+
+uint32_t DSPV2_HELPER(add_s32_s)(uint32_t x, uint32_t y)
+{
+    /* rz = rx + ry, signed & saturated */
+    return helper_sig_sat_add(x, y, 32);
+}
+
+uint32_t DSPV2_HELPER(add_u32_s)(uint32_t x, uint32_t y)
+{
+    /* rz = rx + ry, signed & saturated */
+    return helper_unsig_sat_add(x, y, 32);
+}
+
+uint32_t DSPV2_HELPER(padd_s8_s)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = rx[7:0] + ry[7:0]*/
+    /* rz[15:8] = rx[15:8] + ry[15:8]*/
+    /* rz[23:16] = rx[23:16] + ry[23:16]*/
+    /* rz[31:24] = rx[31:24] + ry[31:24], signed & saturated. */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = helper_sig_sat_add(x & 0xff, y & 0xff, 8);
+    byte1 = helper_sig_sat_add((x & 0xff00) >> 8, (y & 0xff00) >> 8, 8);
+    byte2 = helper_sig_sat_add((x & 0xff0000) >> 16, (y & 0xff0000) >> 16, 8);
+    byte3 = helper_sig_sat_add((x & 0xff000000) >> 24,
+                               (y & 0xff000000) >> 24, 8);
+    return (byte3 << 24) | (byte2 << 16) |(byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(padd_u8_s)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = rx[7:0] + ry[7:0]*/
+    /* rz[15:8] = rx[15:8] + ry[15:8]*/
+    /* rz[23:16] = rx[23:16] + ry[23:16]*/
+    /* rz[31:24] = rx[31:24] + ry[31:24], unsigned & saturated. */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = helper_unsig_sat_add(x & 0xff, y & 0xff, 8);
+    byte1 = helper_unsig_sat_add((x & 0xff00) >> 8, (y & 0xff00) >> 8, 8);
+    byte2 = helper_unsig_sat_add((x & 0xff0000) >> 16, (y & 0xff0000) >> 16, 8);
+    byte3 = helper_unsig_sat_add((x & 0xff000000) >> 24,
+                                 (y & 0xff000000) >> 24, 8);
+    return (byte3 << 24) | (byte2 << 16) |(byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(padd_s16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = rx[15:0] + ry[15:0],
+     * rz[31:16] = rx[31:16] + ry[31:16], signed & saturated */
+    uint32_t lo, hi;
+    lo  = helper_sig_sat_add(x & 0xffff, y & 0xffff, 16);
+    hi  = helper_sig_sat_add((x & 0xffff0000) >> 16,
+                             (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(padd_u16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = rx[15:0] + ry[15:0],
+     * rz[31:16] = rx[31:16] + ry[31:16], unsigned & saturated */
+    uint32_t lo, hi;
+    lo  = helper_unsig_sat_add(x & 0xffff, y & 0xffff, 16);
+    hi  = helper_unsig_sat_add((x & 0xffff0000) >> 16,
+                               (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(sub_s32_s)(uint32_t x, uint32_t y)
+{
+    /* rz = rx - ry, signed & saturated */
+    return helper_sig_sat_sub(x, y, 32);
+}
+
+uint32_t DSPV2_HELPER(sub_u32_s)(uint32_t x, uint32_t y)
+{
+    /* rz = rx - ry, unsigned & saturated */
+    return helper_unsig_sat_sub(x, y, 32);
+}
+
+uint32_t DSPV2_HELPER(psub_s8_s)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = rx[7:0] - ry[7:0]*/
+    /* rz[15:8] = rx[15:8] - ry[15:8]*/
+    /* rz[23:16] = rx[23:16] - ry[23:16]*/
+    /* rz[31:24] = rx[31:24] - ry[31:24], signed & saturated. */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = helper_sig_sat_sub(x & 0xff, y & 0xff, 8);
+    byte1 = helper_sig_sat_sub((x & 0xff00) >> 8, (y & 0xff00) >> 8, 8);
+    byte2 = helper_sig_sat_sub((x & 0xff0000) >> 8, (y & 0xff0000) >> 8, 8);
+    byte3 = helper_sig_sat_sub((x & 0xff000000) >> 8,
+                               (y & 0xff000000) >> 8, 8);
+    return (byte3 << 24) | (byte2 << 16) |(byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(psub_u8_s)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = rx[7:0] - ry[7:0]*/
+    /* rz[15:8] = rx[15:8] - ry[15:8]*/
+    /* rz[23:16] = rx[23:16] - ry[23:16]*/
+    /* rz[31:24] = rx[31:24] - ry[31:24], unsigned & saturated. */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = helper_unsig_sat_sub(x & 0xff, y & 0xff, 8);
+    byte1 = helper_unsig_sat_sub((x & 0xff00) >> 8, (y & 0xff00) >> 8, 8);
+    byte2 = helper_unsig_sat_sub((x & 0xff0000) >> 8, (y & 0xff0000) >> 8, 8);
+    byte3 = helper_unsig_sat_sub((x & 0xff000000) >> 8,
+                                 (y & 0xff000000) >> 8, 8);
+    return (byte3 << 24) | (byte2 << 16) |(byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(psub_s16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = rx[15:0] - ry[15:0],
+     * rz[31:16] = rx[31:16] - ry[31:16], signed & saturated */
+    uint32_t lo, hi;
+    lo  = helper_sig_sat_sub(x & 0xffff, y & 0xffff, 16);
+    hi  = helper_sig_sat_sub((x & 0xffff0000) >> 16,
+                             (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(psub_u16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = rx[15:0] - ry[15:0],
+     * rz[31:16] = rx[31:16] - ry[31:16], unsigned & saturated */
+    uint32_t lo, hi;
+    lo  = helper_unsig_sat_sub(x & 0xffff, y & 0xffff, 16);
+    hi  = helper_unsig_sat_sub((x & 0xffff0000) >> 16,
+                               (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(paddh_s8)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = (rx[7:0] + ry[7:0])/2,
+     * rz[15:8] = (rx[15:8] + ry[15:8])/2,
+     * rz[23:16] = (rx[23:16] + ry[23:16])/2,
+     * rz[31:24] = (rx[31:24] + ry[31:24])/2, signed */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = (int8_t)(x + y) / 2;
+    byte1 = (int8_t)((x >> 8) + (y >> 8)) / 2;
+    byte2 = (int8_t)((x >> 16) + (y >> 16)) / 2;
+    byte3 = (int8_t)((x >> 24) + (y >> 24)) / 2;
+    return (byte3 << 24) | (byte2 << 16) |(byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(paddh_u8)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = (rx[7:0] + ry[7:0])/2,
+     * rz[15:8] = (rx[15:8] + ry[15:8])/2,
+     * rz[23:16] = (rx[23:16] + ry[23:16])/2,
+     * rz[31:24] = (rx[31:24] + ry[31:24])/2, unsigned */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = (uint8_t)(x + y) / 2;
+    byte1 = (uint8_t)((x >> 8) + (y >> 8)) / 2;
+    byte2 = (uint8_t)((x >> 16) + (y >> 16)) / 2;
+    byte3 = (uint8_t)((x >> 24) + (y >> 24)) / 2;
+    return (byte3 << 24) | (byte2 << 16) |(byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(paddh_s16)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = (rx[15:0] + ry[15:0])/2,
+     * rz[31:16] = (rx[31:16] + ry[31:16])/2, signed */
+    uint32_t lo, hi;
+    lo = (int16_t)(x + y) / 2;
+    hi = (int16_t)((x >> 16) + (y >> 16)) / 2;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(paddh_u16)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = (rx[15:0] + ry[15:0])/2,
+     * rz[31:16] = (rx[31:16] + ry[31:16])/2, unsigned */
+    uint32_t lo, hi;
+    lo = (uint16_t)(x + y) / 2;
+    hi = (uint16_t)((x >> 16) + (y >> 16)) / 2;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(psubh_s8)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = (rx[7:0] - ry[7:0])/2,
+     * rz[15:8] = (rx[15:8] - ry[15:8])/2,
+     * rz[23:16] = (rx[23:16] - ry[23:16])/2,
+     * rz[31:24] = (rx[31:24] - ry[31:24])/2, signed */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = (int8_t)(x - y) / 2;
+    byte1 = (int8_t)((x >> 8) - (y >> 8)) / 2;
+    byte2 = (int8_t)((x >> 16) - (y >> 16)) / 2;
+    byte3 = (int8_t)((x >> 24) - (y >> 24)) / 2;
+    return (byte3 << 24) | (byte2 << 16) |(byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(psubh_u8)(uint32_t x, uint32_t y)
+{
+    /* rz[7:0] = (rx[7:0] - ry[7:0])/2,
+     * rz[15:8] = (rx[15:8] - ry[15:8])/2,
+     * rz[23:16] = (rx[23:16] - ry[23:16])/2,
+     * rz[31:24] = (rx[31:24] - ry[31:24])/2, unsigned */
+    uint32_t byte0, byte1, byte2, byte3;
+    byte0 = (uint8_t)(x - y) / 2;
+    byte1 = (uint8_t)((x >> 8) - (y >> 8)) / 2;
+    byte2 = (uint8_t)((x >> 16) - (y >> 16)) / 2;
+    byte3 = (uint8_t)((x >> 24) - (y >> 24)) / 2;
+    return (byte3 << 24) | (byte2 << 16) |(byte1 << 8) | byte0;
+}
+
+uint32_t DSPV2_HELPER(psubh_s16)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = (rx[15:0] - ry[15:0])/2,
+     * rz[31:16] = (rx[31:16] - ry[31:16])/2, signed */
+    uint32_t lo, hi;
+    lo = (int16_t)(x - y) / 2;
+    hi = (int16_t)((x >> 16) - (y >> 16)) / 2;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(psubh_u16)(uint32_t x, uint32_t y)
+{
+    /* rz[15:0] = (rx[15:0] - ry[15:0])/2,
+     * rz[31:16] = (rx[31:16] - ry[31:16])/2, unsigned */
+    uint32_t lo, hi;
+    lo = (uint16_t)(x - y) / 2;
+    hi = (uint16_t)((x >> 16) - (y >> 16)) / 2;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(pasx_s16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = rx[31:16] + ry[15:0],
+     * rz[15:0] = rx[15:0] - ry[31:16], signed & saturated */
+    uint32_t lo, hi;
+    hi  = helper_sig_sat_add((x & 0xffff0000) >> 16, y & 0xffff, 16);
+    lo  = helper_sig_sat_sub(x & 0xffff, (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(pasx_u16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = rx[31:16] + ry[15:0],
+     * rz[15:0] = rx[15:0] - ry[31:16], unsigned & saturated */
+    uint32_t lo, hi;
+    hi  = helper_unsig_sat_add((x & 0xffff0000) >> 16, y & 0xffff, 16);
+    lo  = helper_unsig_sat_sub(x & 0xffff, (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(psax_s16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = rx[31:16] - ry[15:0],
+     * rz[15:0] = rx[15:0] + ry[31:16], signed & saturated */
+    uint32_t lo, hi;
+    hi  = helper_sig_sat_sub((x & 0xffff0000) >> 16, y & 0xffff, 16);
+    lo  = helper_sig_sat_add(x & 0xffff, (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(psax_u16_s)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = rx[31:16] - ry[15:0],
+     * rz[15:0] = rx[15:0] + ry[31:16], unsigned & saturated */
+    uint32_t lo, hi;
+    hi  = helper_unsig_sat_sub((x & 0xffff0000) >> 16, y & 0xffff, 16);
+    lo  = helper_unsig_sat_add(x & 0xffff, (y & 0xffff0000) >> 16, 16);
+    return (hi << 16) | lo;
+}
+
+uint32_t DSPV2_HELPER(pasxh_s16)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = (rx[31:16] + ry[31:16])/2,
+     * rz[15:0] = (rx[15:0] - ry[15:0])/2, signed */
+    uint32_t lo, hi;
+    hi = (int16_t)((x >> 16) + y) / 2;
+    lo = (int16_t)(x - (y >> 16)) / 2;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(pasxh_u16)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = (rx[31:16] + ry[31:16])/2,
+     * rz[15:0] = (rx[15:0] - ry[15:0])/2, unsigned */
+    uint32_t lo, hi;
+    hi = (uint16_t)((x >> 16) + y) / 2;
+    lo = (uint16_t)(x - (y >> 16)) / 2;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(psaxh_s16)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = (rx[31:16] - ry[31:16])/2,
+     * rz[15:0] = (rx[15:0] + ry[15:0])/2, signed */
+    uint32_t lo, hi;
+    hi = (int16_t)((x >> 16) - y) / 2;
+    lo = (int16_t)(x + (y >> 16)) / 2;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint32_t DSPV2_HELPER(psaxh_u16)(uint32_t x, uint32_t y)
+{
+    /* rz[31:16] = (rx[31:16] - ry[31:16])/2,
+     * rz[15:0] = (rx[15:0] + ry[15:0])/2, unsigned */
+    uint32_t lo, hi;
+    hi = (uint16_t)((x >> 16) - y) / 2;
+    lo = (uint16_t)(x + (y >> 16)) / 2;
+    return (hi << 16) | (lo & 0xffff);
+}
+
+uint64_t DSPV2_HELPER(add_s64_s)(uint64_t x, uint64_t y)
+{
+    /* rz = rx + ry, signed & saturated */
+    uint64_t res = x + y;
+    if (((res ^ x) & SIGNBIT64) && !((x ^ y) & SIGNBIT64)) {
+        res = ~(((int64_t)x >> 63) ^ SIGNBIT64);
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(add_u64_s)(uint64_t x, uint64_t y)
+{
+    /* rz = rx + ry, unsigned & saturated */
+    uint64_t res = x + y;
+    if (res < x || res < y) {
+        res = 0xffffffffffffffff;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(sub_s64_s)(uint64_t x, uint64_t y)
+{
+    /* rz = rx - ry, signed & saturated */
+    uint64_t res = x - y;
+    if (((res ^ x) & SIGNBIT64) && ((x ^ y) & SIGNBIT64)) {
+        res = ~(((int64_t)x >> 63) ^ SIGNBIT64);
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(sub_u64_s)(uint64_t x, uint64_t y)
+{
+    /* rz = rx + ry, unsigned & saturated */
+    uint64_t res = x - y;
+    if (res > x) {
+        res = 0;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(lsli_32_s)(uint32_t x, uint32_t imm)
+{
+    /* Rz[31:0] <- Satur(Rx[31:0] << imm[4:0]) */
+    return helper_sat_lsl(x, imm, 32);
+}
+
+uint32_t DSPV2_HELPER(lsl_32_s)(uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] <- Satur(Rx[31:0] << ry[5:0]) */
+    return helper_sat_lsl(x, y, 32);
+}
+
+uint32_t DSPV2_HELPER(plsli_u16_s)(uint32_t x, uint32_t imm)
+{
+    /* Rz[31:16] <- Saturate(Rx[31:16] << oimm[3:0]),
+     * Rz[15:0] <- Saturate(Rx[15:0] << oimm[3:0]) */
+    uint32_t hi, lo;
+    hi = helper_sat_lsl((x & 0xffff0000) >> 16, imm, 16);
+    lo = helper_sat_lsl(x & 0xffff, imm, 16);
+    return hi << 16 | lo;
+}
+
+uint32_t DSPV2_HELPER(plsl_u16_s)(uint32_t x, uint32_t y)
+{
+    /* Rz[31:16] <- Saturate(Rx[31:16] << ry[3:0]),
+     * Rz[15:0] <- Saturate(Rx[15:0] << ry[3:0]) */
+    uint32_t hi, lo;
+    hi = helper_sat_lsl((x & 0xffff0000) >> 16, y, 16);
+    lo = helper_sat_lsl(x & 0xffff, y, 16);
+    return hi << 16 | lo;
+}
+
+uint32_t DSPV2_HELPER(pcmpne_8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        res |= ((x & mask) != (y & mask)) ? mask : 0;
+        mask = mask << 8;
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmpne_16)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xffff;
+    uint32_t res = 0;
+    res |= ((x & mask) != (y & mask)) ? mask : 0;
+    mask = mask << 16;
+    res |= ((x & mask) != (y & mask)) ? mask : 0;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmphs_u8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        res |= ((x & mask) >= (y & mask)) ? mask : 0;
+        mask = mask << 8;
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmphs_s8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        int8_t byte_x, byte_y;
+        byte_x = (x >> (i * 8)) & mask;
+        byte_y = (x >> (i * 8)) & mask;
+        res |= (byte_x >= byte_y) ? (mask << (i * 8)) : 0;
+        i++;
+    }
+    return res;
+}
+
+
+uint32_t DSPV2_HELPER(pcmphs_u16)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xffff;
+    uint32_t res = 0;
+    res |= ((x & mask) >= (y & mask)) ? mask : 0;
+    mask = mask << 16;
+    res |= ((x & mask) >= (y & mask)) ? mask : 0;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmphs_s16)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xffff;
+    uint32_t res = 0;
+    res |= ((int16_t)(x & mask) >= (int16_t)(y & mask)) ? mask : 0;
+    mask = mask << 16;
+    res |= ((int32_t)(x & mask) >= (int32_t)(y & mask)) ? mask : 0;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmplt_u8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        res |= ((x & mask) < (y & mask)) ? mask : 0;
+        mask = mask << 8;
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmplt_s8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        int8_t byte_x, byte_y;
+        byte_x = (x >> (i * 8)) & mask;
+        byte_y = (x >> (i * 8)) & mask;
+        res |= (byte_x < byte_y) ? (mask << (i * 8)) : 0;
+        i++;
+    }
+    return res;
+}
+
+
+uint32_t DSPV2_HELPER(pcmplt_u16)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xffff;
+    uint32_t res = 0;
+    res |= ((x & mask) < (y & mask)) ? mask : 0;
+    mask = mask << 16;
+    res |= ((x & mask) < (y & mask)) ? mask : 0;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pcmplt_s16)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xffff;
+    uint32_t res = 0;
+    res |= ((int16_t)(x & mask) < (int16_t)(y & mask)) ? mask : 0;
+    mask = mask << 16;
+    res |= ((int32_t)(x & mask) < (int32_t)(y & mask)) ? mask : 0;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pmax_s8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        int8_t byte_x, byte_y;
+        byte_x = (x >> (i * 8)) & mask;
+        byte_y = (x >> (i * 8)) & mask;
+        res |= (byte_x > byte_y) ? (byte_x << (i * 8)) : (byte_y << (i * 8));
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pmax_u8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        res |= ((x & mask) > (y & mask)) ? (x & mask) : (y & mask);
+        mask = mask << 8;
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pmin_s8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        int8_t byte_x, byte_y;
+        byte_x = (x >> (i * 8)) & mask;
+        byte_y = (x >> (i * 8)) & mask;
+        res |= (byte_x < byte_y) ? (byte_x << (i * 8)) : (byte_y << (i * 8));
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pmin_u8)(uint32_t x, uint32_t y)
+{
+    uint32_t mask = 0xff;
+    uint32_t i = 0;
+    uint32_t res = 0;
+    while (i < 4) {
+        res |= ((x & mask) > (y & mask)) ? (x & mask) : (y & mask);
+        mask = mask << 8;
+        i++;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pext_u8_e)(uint32_t x)
+{
+    uint8_t byte_x;
+    uint32_t i = 0;
+    uint64_t res = 0;
+    while (i < 4) {
+        byte_x = (x >> (i * 8)) & 0xff;
+        res |= ((uint64_t)byte_x) << (i * 16);
+        i++;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pext_s8_e)(uint32_t x)
+{
+    uint8_t byte_x;
+    uint32_t i = 0;
+    uint64_t res = 0;
+    while (i < 4) {
+        byte_x = (x >> (i * 8)) & 0xff;
+        res |= (((int64_t)byte_x) & 0xffff) << (i * 16);
+        i++;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pextx_u8_e)(uint32_t x)
+{
+    uint64_t res = 0;
+    res |= x & 0xff;
+    res |= x & 0xff0000;
+    res |= (x & 0xff00) << 24;
+    res |= (x & 0xff000000) << 24;
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pextx_s8_e)(uint32_t x)
+{
+    int8_t byte_x;
+    uint64_t res = 0;
+    byte_x = (x & 0xff);
+    res |= ((int64_t)byte_x & 0xffff);
+    byte_x = (x >> 8) & 0xff;
+    res |= ((int64_t)byte_x & 0xffff) << 32;
+    byte_x = (x >> 16) & 0xff;
+    res |= ((int64_t)byte_x & 0xffff) << 16;
+    byte_x = (x >> 24) & 0xff;
+    res |= ((int64_t)byte_x & 0xffff) << 48;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(narl)(uint32_t x, uint32_t y)
+{
+    uint32_t mask_0 = 0xff;
+    uint32_t mask_2 = 0xff0000;
+
+    uint32_t res = 0;
+    res |= x & mask_0;
+    res |= (x & mask_2) >> 8;
+    res |= (y & mask_0) << 16;
+    res |= (y & mask_2) << 8;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(narh)(uint32_t x, uint32_t y)
+{
+    uint32_t mask_1 = 0xff00;
+    uint32_t mask_3 = 0xff000000;
+
+    uint32_t res = 0;
+    res |= (x & mask_1) >> 8;
+    res |= (x & mask_3) >> 16;
+    res |= (y & mask_1) << 8;
+    res |= y & mask_3;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(narlx)(uint32_t x, uint32_t y)
+{
+    uint32_t mask_02 = 0xff00ff;
+
+    uint32_t res = 0;
+    res |= x & mask_02;
+    res |= (y & mask_02) << 8;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(narhx)(uint32_t x, uint32_t y)
+{
+    uint32_t mask_13 = 0xff00ff00;
+
+    uint32_t res = 0;
+    res |= (x & mask_13) >> 8;
+    res |= y & mask_13;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(clipi_u32)(uint32_t x, uint32_t imm)
+{
+    uint32_t max = (1 << imm) -1;
+    uint32_t res = 0;
+    if (x > max) {
+        res = max;
+    } else {
+        res = x;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(clipi_s32)(uint32_t x, uint32_t imm)
+{
+    int32_t max = (1 << imm) - 1;
+    int32_t min = -(1 << imm);
+    uint32_t res = 0;
+    if (x > max) {
+        res = max;
+    } else if (x < min) {
+        res = min;
+    }else {
+        res = x;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(clip_u32)(uint32_t x, uint32_t y)
+{
+    uint32_t max = (1 << (y & 0x1f)) -1;
+    uint32_t res = 0;
+    if (x > max) {
+        res = max;
+    } else {
+        res = x;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(clip_s32)(uint32_t x, uint32_t y)
+{
+    int32_t max = (1 << (y & 0x1f)) - 1;
+    int32_t min = -(1 << (y & 0x1f));
+    uint32_t res = 0;
+    if (x > max) {
+        res = max;
+    } else if (x < min) {
+        res = min;
+    }else {
+        res = x;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pclipi_u16)(uint32_t x, uint32_t imm)
+{
+    uint16_t max = (1 << imm) - 1;
+    uint32_t res = 0;
+    int16_t hword = x & 0xffff;
+    if (hword > max) {
+        hword = max;
+    }
+    res |= hword & 0xffff;
+    hword = x >> 16;
+    if (hword > max) {
+        hword = max;
+    }
+    res |= hword << 16;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pclipi_s16)(uint32_t x, uint32_t imm)
+{
+    int16_t max = (1 << imm) - 1;
+    int16_t min = -(1 << (imm & 0xf));
+    uint32_t res = 0;
+    int16_t hword = x & 0xffff;
+    if (hword > max) {
+        hword = max;
+    } else if (hword < min) {
+        hword = min;
+    }
+    res |= hword & 0xffff;
+    hword = x >> 16;
+    if (hword > max) {
+        hword = max;
+    } else if (hword < min) {
+        hword = min;
+    }
+    res |= hword << 16;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pclip_u16)(uint32_t x, uint32_t y)
+{
+    uint16_t max = (1 << (y & 0xf)) - 1;
+    uint32_t res = 0;
+    int16_t hword = x & 0xffff;
+    if (hword > max) {
+        hword = max;
+    }
+    res |= hword & 0xffff;
+    hword = x >> 16;
+    if (hword > max) {
+        hword = max;
+    }
+    res |= hword << 16;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pclip_s16)(uint32_t x, uint32_t y)
+{
+    int16_t max = (1 << (y & 0xf)) - 1;
+    int16_t min = -(1 << (y & 0xf));
+    uint32_t res = 0;
+    int16_t hword = x & 0xffff;
+    if (hword > max) {
+        hword = max;
+    } else if (hword < min) {
+        hword = min;
+    }
+    res |= hword & 0xffff;
+    hword = x >> 16;
+    if (hword > max) {
+        hword = max;
+    } else if (hword < min) {
+        hword = min;
+    }
+    res |= hword << 16;
+    return res;
+}
+
+
+uint32_t DSPV2_HELPER(pabs_s8_s)(uint32_t x)
+{
+    /* Rz[31:24] = Saturate(abs(Rx[31:24]))
+     * Rz[23:16] = Saturate(abs(Rx[23:16]))
+     * Rz[15:8] = Saturate(abs(Rx[15:8]))
+     * Rz[7:0] = Saturate(abs(Rx[7:0])) */
+    int8_t byte_x;
+    uint32_t i = 0;
+    uint64_t res = 0;
+    while (i < 4) {
+        byte_x = (x >> (i * 8)) & 0xff;
+        if (byte_x == (int8_t)0x80) {
+            byte_x = 0x7f;
+        } else if (byte_x < 0) {
+            byte_x = -byte_x;
+        }
+        res |= byte_x << (i * 8);
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pabs_s16_s)(uint32_t x)
+{
+    /* rz[15:0] = | rx[15:0] |, rz[31:16] = | rx[31:16] |, signed */
+    int16_t lo, hi;
+    lo = (int16_t)x;
+    hi = (int16_t)(x >> 16);
+    lo = lo > 0 ? lo : -lo;
+    hi = hi > 0 ? hi : -hi;
+    if (lo == (int16_t)0x8000) {
+        lo = 0x7fff;
+    }
+    if (hi == (int16_t)0x8000) {
+        hi = 0x7fff;
+    }
+    return (lo & 0xffff) | (hi << 16);
+}
+
+uint32_t DSPV2_HELPER(abs_s32_s)(uint32_t x)
+{
+    /* rz[31:0] = Saturate(abs(Rx[31:0])), signed */
+    uint32_t res;
+    if ((int32_t)x >= 0) {
+        res = x;
+    } else if (x == 0x80000000) {
+        res = 0x7fffffff;
+    } else {
+        res = -x;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pneg_s8_s)(uint32_t x)
+{
+    /* Rz[31:24] = Saturate(neg(Rx[31:24]))
+     * Rz[23:16] = Saturate(neg(Rx[23:16]))
+     * Rz[15:8] = Saturate(neg(Rx[15:8]))
+     * Rz[7:0] = Saturate(neg(Rx[7:0])) */
+    int8_t byte_x;
+    uint32_t i = 0;
+    uint64_t res = 0;
+    while (i < 4) {
+        byte_x = -((x >> (i * 8)) & 0xff);
+        if (byte_x == (int8_t)0x80) {
+            byte_x = 0x7f;
+        }
+        res |= byte_x << (i * 8);
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(pneg_s16_s)(uint32_t x)
+{
+    /* rz[15:0] = !rx[15:0], rz[31:16] = !rx[31:16] */
+    int16_t lo, hi;
+    lo = x & 0xffff;
+    hi = x >> 16;
+    lo = -lo;
+    hi = -hi;
+    if (lo == (int16_t)0x8000) {
+        lo = 0x7fff;
+    }
+    if (hi == (int16_t)0x8000) {
+        hi = 0x7fff;
+    }
+    return (lo & 0xffff) | (hi << 16);
+}
+
+uint32_t DSPV2_HELPER(neg_s32_s)(uint32_t x)
+{
+    /* Rz[31:0] = Saturate(neg(Rx[31:0])) */
+    int32_t res = -((int32_t)x);
+    if (res == (int32_t)0x80000000) {
+        res = 0x7fffffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(rmul_s32_h)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[31:0] == 32’h8000 0000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[31:0]}[62:31] */
+    int64_t res;
+    if ((x == 0x80000000) && (y == 0x80000000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)(int32_t)y;
+        return res >> 31;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmul_s32_rh)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[31:0] == 32’h8000 0000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[31:0]}[62:31] */
+    int64_t res;
+    if ((x == 0x80000000) && (y == 0x80000000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)(int32_t)y + 0x40000000;
+        return res >> 31;
+    }
+}
+
+uint64_t DSPV2_HELPER(mula_s32_s)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( {Rz[31:0],Rz+1[31:0]}
+     * + {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int64_t res, xy;
+    int64_t z_long = ((uint64_t)z1 << 32) + z;
+    xy = (int64_t)(int32_t)x * (int64_t)(int32_t)y;
+    res = xy + z_long;
+    if (((res ^ z_long) & SIGNBIT64) && !((xy ^ z_long) & SIGNBIT64)) {
+        res = ~(((int64_t)z_long >> 63) ^ SIGNBIT64);
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(mula_u32_s)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( {Rz[31:0],Rz+1[31:0]}
+     * + {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    uint64_t res, xy;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    xy = (uint64_t)x * (uint64_t)y;
+    res = xy + z_long;
+    if (res < xy || res < z_long) {
+        res = 0xffffffffffffffff;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(muls_s32_s)(uint32_t z, uint32_t z1,
+                                  uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( {Rz[31:0],Rz+1[31:0]}
+     * - {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int64_t res, xy;
+    int64_t z_long = ((uint64_t)z1 << 32) + z;
+    xy = (int64_t)(int32_t)x * (int64_t)(int32_t)y;
+    res = z_long - xy;
+    if (((res ^ z_long) & SIGNBIT64) && ((xy ^ z_long) & SIGNBIT64)) {
+        res = ~(((int64_t)z_long >> 63) ^ SIGNBIT64);
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(muls_u32_s)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( {Rz[31:0],Rz+1[31:0]}
+     * - {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    uint64_t res, xy;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    xy = (uint64_t)x * (uint64_t)y;
+    res = z_long - xy;
+    if (res > z_long) {
+        res = 0;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mula_32_l)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] =  Rz[31:0] + {Rx[31:0] X Ry[31:0]}[31:0] ) */
+    return z + x * y;
+}
+
+uint32_t DSPV2_HELPER(mula_s32_hs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)(int32_t)y) >> 32;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(muls_s32_hs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)(int32_t)y) >> 32;
+    return helper_sig_sat_sub(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mula_s32_rhs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[31:0]
+     * + 32’h80000000}[63:32] ) */
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)(int32_t)y
+                  + 0x80000000) >> 32;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(muls_s32_rhs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[31:0]
+     * + 32’h80000000}[63:32] ) */
+    int64_t xy = (int64_t)(int32_t)x * (int64_t)(int32_t)y - 0x80000000;
+    int64_t z_long = (uint64_t)z << 32;
+    int64_t res = z_long - xy;
+    if (((res ^ z_long) & SIGNBIT64) && ((xy ^ z_long) & SIGNBIT64)) {
+        res = ~(((int64_t)z_long >> 63) ^ SIGNBIT64);
+    }
+    return res >> 32;
+}
+
+uint32_t DSPV2_HELPER(rmulxl_s32)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[15:0] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[15:0]}[46:15] */
+    int64_t res;
+    int16_t tmp_y = y & 0xffff;
+    if ((x == 0x80000000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)tmp_y;
+        return res >> 15;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmulxl_s32_r)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[15:0] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[15:0]}[46:15] */
+    int64_t res;
+    int16_t tmp_y = y & 0xffff;
+    if ((x == 0x80000000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)tmp_y + 0x4000;
+        return res >> 15;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmulxh_s32)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[31:16] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[31:16]}[46:15] */
+    int64_t res;
+    int16_t tmp_y = y >> 16;
+    if ((x == 0x80000000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)tmp_y;
+        return res >> 15;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmulxh_s32_r)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:0] == 32’h8000 0000 && Ry[31:16] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:0] X Ry[31:16]}[46:15] */
+    int64_t res;
+    int16_t tmp_y = y >> 16;
+    if ((x == 0x80000000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        res = (int64_t)(int32_t)x * (int64_t)tmp_y + 0x4000;
+        return res >> 15;
+    }
+}
+
+uint32_t DSPV2_HELPER(mulaxl_s32_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[15:0]}[63:32] ) */
+    int16_t tmp_y = y & 0xffff;
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)tmp_y) >> 16;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mulaxl_s32_rs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_y = y & 0xffff;
+    int32_t xy = ((int64_t)x * (int64_t)tmp_y + 0xf000) >> 16;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mulaxh_s32_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate( Rz[31:0] + {Rx[31:0] X Ry[31:16]}[63:32] ) */
+    int16_t tmp_y = y >> 16;
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)tmp_y) >> 16;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mulaxh_s32_rs)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_y = y >> 16;
+    int32_t xy = ((int64_t)(int32_t)x * (int64_t)tmp_y + 0xf000) >> 16;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(rmulll_s16)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[15:0] == 32’h8000 && Ry[15:0] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[15:0] X Ry[15:0]} << 1 */
+    int16_t tmp_x = x & 0xffff;
+    int16_t tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        return ((int32_t)tmp_x * (int32_t)tmp_y) << 1;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmulhh_s16)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:16] == 32’h8000 && Ry[31:16] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:16] X Ry[31:16]} << 1 */
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        return ((int32_t)tmp_x * (int32_t)tmp_y) << 1;
+    }
+}
+
+uint32_t DSPV2_HELPER(rmulhl_s16)(uint32_t x, uint32_t y)
+{
+    /* if(Rx[31:16] == 32’h8000 && Ry[15:0] == 32’h8000)
+     *   Rz[31:0] = 32’h7FFF FFFF
+     * else
+     *   Rz[31:0] = {Rx[31:16] X Ry[15:0]} << 1 */
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        return 0x7fffffff;
+    } else {
+        return ((int32_t)tmp_x * (int32_t)tmp_y) << 1;
+    }
+}
+
+uint32_t DSPV2_HELPER(mulall_s16)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Rz[31:0] + Rx[15:0] X Ry[15:0]) */
+    int16_t tmp_x = x & 0xffff;
+    int16_t tmp_y = y & 0xffff;
+    return z + (int32_t)tmp_x * (int32_t)tmp_y;
+}
+
+uint32_t DSPV2_HELPER(mulall_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate(Rz[31:0] + Rx[15:0] X Ry[15:0]) */
+    int16_t tmp_x = x & 0xffff;
+    int16_t tmp_y = y & 0xffff;
+    int32_t xy = (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mulahh_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate(Rz[31:0] + Rx[31:16] X Ry[31:16]) */
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    int32_t xy = (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint32_t DSPV2_HELPER(mulahl_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = Saturate(Rz[31:0] + Rx[31:16] X Ry[15:0]) */
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    int32_t xy = (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, xy, 32);
+}
+
+uint64_t DSPV2_HELPER(mulall_s16_e)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    /* {Rz+1[31:0],Rz[31:0]} = {Rz+1[31:0],Rz[31:0]} + Rx[15:0] X Ry[15:0] */
+    int64_t res = ((uint64_t)z1 << 32) + z;
+    int16_t tmp_x = x & 0xffff;
+    int16_t tmp_y = y & 0xffff;
+    int64_t xy = (int64_t)tmp_x * (int64_t)tmp_y;
+    return res + xy;
+}
+
+uint64_t DSPV2_HELPER(mulahh_s16_e)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    /* {Rz+1[31:0],Rz[31:0]} = {Rz+1[31:0],Rz[31:0]} + Rx[31:16] X Ry[31:16] */
+    int64_t res = ((uint64_t)z1 << 32) + z;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    int64_t xy = (int64_t)tmp_x * (int64_t)tmp_y;
+    return res + xy;
+}
+
+uint64_t DSPV2_HELPER(mulahl_s16_e)(uint32_t z, uint32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    /* {Rz+1[31:0],Rz[31:0]} = {Rz+1[31:0],Rz[31:0]} + Rx[31:16] X Ry[15:0] */
+    int64_t res = ((uint64_t)z1 << 32) + z;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    int64_t xy = (int64_t)tmp_x * (int64_t)tmp_y;
+    return res + xy;
+}
+
+uint64_t DSPV2_HELPER(prmul_s16)(uint32_t x, uint32_t y)
+{
+    uint64_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= (uint64_t)0x7fffffff << 32;
+    } else {
+        res |= (uint64_t)((int32_t)tmp_x * (int32_t)tmp_y) << 33;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fffffff;
+    } else {
+        res |= (((int64_t)tmp_x * (int64_t)tmp_y) << 1) & 0xffffffff;
+    }
+    return res;
+}
+
+uint64_t DSPV2_HELPER(prmulx_s16)(uint32_t x, uint32_t y)
+{
+    uint64_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= (uint64_t)0x7fffffff << 32;
+    } else {
+        res |= (uint64_t)((int32_t)tmp_x * (int32_t)tmp_y) << 33;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fffffff;
+    } else {
+        res |= (((int64_t)tmp_x * (int64_t)tmp_y) << 1) & 0xffffffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(prmul_s16_h)(uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff0000;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y) << 1) & 0xffff0000;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y) >>15) & 0xffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(prmul_s16_rh)(uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff0000;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y + 0x4000) << 1) & 0xffff0000;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y + 0x4000) >>15) & 0xffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(prmulx_s16_h)(uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff0000;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y) << 1) & 0xffff0000;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y) >>15) & 0xffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(prmulx_s16_rh)(uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff0000;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y + 0x4000) << 1) & 0xffff0000;
+    }
+    tmp_x = x & 0xffff;
+    tmp_y = y >> 16;
+    if ((tmp_x == (int16_t)0x8000) && (tmp_y == (int16_t)0x8000)) {
+        res |= 0x7fff;
+    } else {
+        res |= (((int32_t)tmp_x * (int32_t)tmp_y + 0x4000) >>15) & 0xffff;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mulca_s16_s)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    if ((x == 0x80008000) && (y == 0x80008000)) {
+        res = 0x7fffffff;
+    } else {
+        tmp_x = x & 0xffff;
+        tmp_y = y & 0xffff;
+        res = ((int32_t)x >> 16) * ((int32_t)y >> 16)
+            + (int32_t)tmp_x * (int32_t)tmp_y;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mulcax_s16_s)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    if ((x == 0x80008000) && (y == 0x80008000)) {
+        res = 0x7fffffff;
+    } else {
+        tmp_x = x & 0xffff;
+        tmp_y = y & 0xffff;
+        res = ((int32_t)x >> 16) * (int32_t)tmp_y
+            + (int32_t)tmp_x * ((int32_t)y >> 16);
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mulaca_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * ((int32_t)y >> 16)
+        + (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulacax_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * (int32_t)tmp_y
+        + (int32_t)tmp_x * ((int32_t)y >> 16);
+    return helper_sig_sat_add(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulacs_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = (int32_t)tmp_x * (int32_t)tmp_y
+        - ((int32_t)x >> 16) * ((int32_t)y >> 16);
+    return helper_sig_sat_add(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulacsr_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * ((int32_t)y >> 16)
+        - (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulacsx_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = (int32_t)tmp_x * ((int32_t)y >> 16)
+        - ((int32_t)x >> 16) * (int32_t)tmp_y;
+    return helper_sig_sat_add(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulsca_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * ((int32_t)y >> 16)
+        + (int32_t)tmp_x * (int32_t)tmp_y;
+    return helper_sig_sat_sub(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(mulscax_s16_s)(uint32_t z, uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * (int32_t)tmp_y
+        + (int32_t)tmp_x * ((int32_t)y >> 16);
+    return helper_sig_sat_sub(z, res, 32);
+}
+
+uint32_t DSPV2_HELPER(psabsa_u8)(uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    uint32_t i = 0;
+    uint8_t tmp_sub;
+    while (i < 4) {
+        tmp_sub = ((x >> (i * 8)) - (y >> (i * 8))) & 0xff;
+        res += (tmp_sub > 0) ? tmp_sub : -tmp_sub;
+        i++;
+    }
+    return res;
+}
+
+uint32_t DSPV2_HELPER(psabsaa_u8)(uint32_t z, uint32_t x, uint32_t y)
+{
+    uint32_t res = 0;
+    uint32_t i = 0;
+    uint8_t tmp_sub;
+    while (i < 4) {
+        tmp_sub = ((x >> (i * 8)) - (y >> (i * 8))) & 0xff;
+        res += (tmp_sub > 0) ? tmp_sub : -tmp_sub;
+        i++;
+    }
+    return res + z;
+}
+
diff --git a/tests/csky/script/op_tcg.c b/tests/csky/script/op_tcg.c
new file mode 100644
index 0000000..b492269
--- /dev/null
+++ b/tests/csky/script/op_tcg.c
@@ -0,0 +1,291 @@
+#include "inst_dspv2.h"
+
+uint64_t DSPV2_HELPER(muls_u32)(uint32_t z, uint32_t z1,
+                                uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = {Rz[31:0],Rz+1[31:0]}
+     * - {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    uint64_t res, xy;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    xy = (uint64_t)x * (uint64_t)y;
+    res = z_long - xy;
+    return res;
+}
+uint64_t DSPV2_HELPER(muls_s32)(uint32_t z, uint32_t z1,
+                                uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = {Rz[31:0],Rz+1[31:0]}
+     * - {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    uint64_t res, xy;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    xy = (int64_t)(int32_t)x * (int64_t)(int32_t)y;
+    res = z_long - xy;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mulxl_s32)(uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = {Rz[31:0],Rz+1[31:0]}
+     * - {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int16_t tmp_y = y & 0xffff;
+    uint64_t res = ((int64_t)(int32_t)x * (int64_t)tmp_y) >> 16;
+    return res;
+}
+uint32_t DSPV2_HELPER(mulxl_s32_r)(uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = {Rz[31:0],Rz+1[31:0]}
+     * - {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int16_t tmp_y = y & 0xffff;
+    uint64_t res = ((int64_t)(int32_t)x * (int64_t)tmp_y + 0x8000) >> 16;
+    return res;
+}
+uint32_t DSPV2_HELPER(mulxh_s32)(uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = {Rz[31:0],Rz+1[31:0]}
+     * - {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int16_t tmp_y = y >> 16;
+    uint64_t res = ((int64_t)(int32_t)x * (int64_t)tmp_y) >> 16;
+    return res;
+}
+uint32_t DSPV2_HELPER(mulxh_s32_r)(uint32_t x, uint32_t y)
+{
+    /* Rz[31:0] = {Rz[31:0],Rz+1[31:0]}
+     * - {Rx[31:0] X Ry[31:0]}[63:32] ) */
+    int16_t tmp_y = y >> 16;
+    uint64_t res = ((int64_t)(int32_t)x * (int64_t)tmp_y + 0x8000) >> 16;
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pmul_s16)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x = x & 0xffff;
+    int16_t tmp_y = y & 0xffff;
+    uint64_t res = (uint64_t)((int32_t)tmp_x * (int32_t)tmp_y) & 0xffffffff;
+    tmp_x = x >> 16;
+    tmp_y = y >> 16;
+    res |= (int64_t)((int32_t)tmp_x * (int32_t)tmp_y) << 32;
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pmul_u16)(uint32_t x, uint32_t y)
+{
+    uint16_t tmp_x = x & 0xffff;
+    uint16_t tmp_y = y & 0xffff;
+    uint64_t res = (uint64_t)((uint32_t)tmp_x * (uint32_t)tmp_y) & 0xffffffff;
+    tmp_x = x >> 16;
+    tmp_y = y >> 16;
+    res |= (uint64_t)((uint32_t)tmp_x * (uint32_t)tmp_y) << 32;
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pmulx_s16)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x = x & 0xffff;
+    int16_t tmp_y = y >> 16;
+    uint64_t res = (uint64_t)((int32_t)tmp_x * (int32_t)tmp_y) & 0xffffffff;
+    tmp_x = x >> 16;
+    tmp_y = y & 0xffff;
+    res |= (int64_t)((int32_t)tmp_x * (int32_t)tmp_y) << 32;
+    return res;
+}
+
+uint64_t DSPV2_HELPER(pmulx_u16)(uint32_t x, uint32_t y)
+{
+    uint16_t tmp_x = x & 0xffff;
+    uint16_t tmp_y = y >> 16;
+    uint64_t res = (uint64_t)((uint32_t)tmp_x * (uint32_t)tmp_y) & 0xffffffff;
+    tmp_x = x >> 16;
+    tmp_y = y & 0xffff;
+    res |= (uint64_t)((uint32_t)tmp_x * (uint32_t)tmp_y) << 32;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mulcs_s16)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = (int32_t)tmp_x * (int32_t)tmp_y
+        - ((int32_t)x >> 16) * ((int32_t)y >> 16);
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mulcsr_s16)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int32_t)x >> 16) * ((int32_t)y >> 16)
+        - (int32_t)tmp_x * (int32_t)tmp_y;
+    return res;
+}
+
+uint32_t DSPV2_HELPER(mulcsx_s16)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    int32_t res;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = (int32_t)tmp_x * ((int32_t)y >> 16)
+        - ((int32_t)x >> 16) * ((int32_t)tmp_y);
+    return res;
+}
+
+uint64_t DSPV2_HELPER(mulaca_s16_e)(uint32_t z, u_int32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    uint64_t res;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int64_t)(int32_t)x >> 16) * ((int64_t)(int32_t)y >> 16)
+        + (int64_t)(int32_t)tmp_x * (int64_t)(int32_t)tmp_y;
+    return res + z_long;
+}
+
+uint64_t DSPV2_HELPER(mulacax_s16_e)(uint32_t z, u_int32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    uint64_t res;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int64_t)(int32_t)x >> 16) * (int64_t)(int32_t)tmp_y
+        + (int64_t)(int32_t)tmp_x * ((int64_t)(int32_t)y >> 16);
+    return res + z_long;
+}
+
+uint64_t DSPV2_HELPER(mulacs_s16_e)(uint32_t z, u_int32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    uint64_t res;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = (int64_t)(int32_t)tmp_x * (int64_t)(int32_t)tmp_y
+        - ((int64_t)(int32_t)x >> 16) * ((int64_t)(int32_t)y >> 16);
+    return res + z_long;
+}
+
+uint64_t DSPV2_HELPER(mulacsr_s16_e)(uint32_t z, u_int32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    uint64_t res;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int64_t)(int32_t)x >> 16) * ((int64_t)(int32_t)y >> 16)
+        - (int64_t)(int32_t)tmp_x * (int64_t)(int32_t)tmp_y;
+    return res + z_long;
+}
+
+uint64_t DSPV2_HELPER(mulacsx_s16_e)(uint32_t z, u_int32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    uint64_t res;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = (int64_t)(int32_t)tmp_x * ((int64_t)(int32_t)y >> 16)
+        -((int64_t)(int32_t)x >> 16) * (int64_t)(int32_t)tmp_y;
+    return res + z_long;
+}
+
+uint64_t DSPV2_HELPER(mulsca_s16_e)(uint32_t z, u_int32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    uint64_t res;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int64_t)(int32_t)x >> 16) * ((int64_t)(int32_t)y >> 16)
+        + (int64_t)(int32_t)tmp_x * (int64_t)(int32_t)tmp_y;
+    return z_long - res;
+}
+
+uint64_t DSPV2_HELPER(mulscax_s16_e)(uint32_t z, u_int32_t z1,
+                                    uint32_t x, uint32_t y)
+{
+    int16_t tmp_x;
+    int16_t tmp_y;
+    uint64_t res;
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    tmp_x = x & 0xffff;
+    tmp_y = y & 0xffff;
+    res = ((int64_t)(int32_t)x >> 16) * (int64_t)(int32_t)tmp_y
+        + (int64_t)(int32_t)tmp_x * ((int64_t)(int32_t)y >> 16);
+    return z_long - res;
+}
+
+uint64_t DSPV2_HELPER(mul_u32)(uint32_t x, u_int32_t y)
+{
+    return (uint64_t)x * (u_int64_t)y;
+}
+
+uint64_t DSPV2_HELPER(mul_s32)(uint32_t x, u_int32_t y)
+{
+    return (uint64_t)(int32_t)x * (u_int64_t)(int32_t)y;
+}
+
+uint64_t DSPV2_HELPER(mula_u32)(uint32_t z, u_int32_t z1,
+                                uint32_t x, u_int32_t y)
+{
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    return z_long + (uint64_t)x * (u_int64_t)y;
+}
+
+uint64_t DSPV2_HELPER(mula_s32)(uint32_t z, u_int32_t z1,
+                                uint32_t x, u_int32_t y)
+{
+    uint64_t z_long = ((uint64_t)z1 << 32) + z;
+    return z_long + (uint64_t)(int32_t)x * (u_int64_t)(int32_t)y;
+}
+
+uint32_t DSPV2_HELPER(mul_s32_h)(uint32_t x, u_int32_t y)
+{
+    return ((uint64_t)(int32_t)x * (u_int64_t)(int32_t)y) >> 32;
+}
+
+uint32_t DSPV2_HELPER(mul_s32_rh)(uint32_t x, u_int32_t y)
+{
+    return ((uint64_t)(int32_t)x * (u_int64_t)(int32_t)y + 0x80000000) >> 32;
+}
+
+uint32_t DSPV2_HELPER(mulll_s16)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x = x & 0xffff;
+    int16_t tmp_y = y & 0xffff;
+    return ((int32_t)tmp_x * (int32_t)tmp_y);
+}
+
+uint32_t DSPV2_HELPER(mulhh_s16)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y >> 16;
+    return ((int32_t)tmp_x * (int32_t)tmp_y);
+}
+
+uint32_t DSPV2_HELPER(mulhl_s16)(uint32_t x, uint32_t y)
+{
+    int16_t tmp_x = x >> 16;
+    int16_t tmp_y = y & 0xffff;
+    return ((int32_t)tmp_x * (int32_t)tmp_y);
+}
+
diff --git a/tests/qom-test.c b/tests/qom-test.c
index d48f890..681606b 100644
--- a/tests/qom-test.c
+++ b/tests/qom-test.c
@@ -18,12 +18,20 @@ static const char *blacklist_x86[] = {
     "xenfv", "xenpv", NULL
 };
 
+static const char *blacklist_csky[] = {
+    "dummyh", "dummyh", NULL
+};
+
 static const struct {
     const char *arch;
     const char **machine;
 } blacklists[] = {
     { "i386", blacklist_x86 },
     { "x86_64", blacklist_x86 },
+    { "cskyv2", blacklist_csky },
+    { "cskyv2eb", blacklist_csky },
+    { "cskyv1", blacklist_csky },
+    { "cskyv1eb", blacklist_csky },
 };
 
 static bool is_blacklisted(const char *arch, const char *mach)
diff --git a/util/log.c b/util/log.c
index e077340..c470cca 100644
--- a/util/log.c
+++ b/util/log.c
@@ -272,6 +272,8 @@ const QEMULogItem qemu_log_items[] = {
     { CPU_LOG_TB_NOCHAIN, "nochain",
       "do not chain compiled TBs so that \"exec\" and \"cpu\" show\n"
       "complete traces" },
+    { CPU_TB_TRACE, "tb_trace",
+      "log all beginning PC of TranslationBlock" },
     { 0, NULL, NULL },
 };
 
diff --git a/util/module.c b/util/module.c
index c909737..361d655 100644
--- a/util/module.c
+++ b/util/module.c
@@ -162,7 +162,7 @@ void module_load_one(const char *prefix, const char *lib_name)
 #ifdef CONFIG_MODULES
     char *fname = NULL;
     char *exec_dir;
-    char *dirs[3];
+    char *dirs[5];
     char *module_name;
     int i = 0;
     int ret;
@@ -189,13 +189,20 @@ void module_load_one(const char *prefix, const char *lib_name)
     dirs[i++] = g_strdup_printf("%s", CONFIG_QEMU_MODDIR);
     dirs[i++] = g_strdup_printf("%s/..", exec_dir ? : "");
     dirs[i++] = g_strdup_printf("%s", exec_dir ? : "");
+    dirs[i++] = g_strdup_printf("%s/../lib/qemu", exec_dir ? : "");
+    dirs[i++] = g_strdup_printf("%s/lib", exec_dir ? : "");
     assert(i == ARRAY_SIZE(dirs));
     g_free(exec_dir);
     exec_dir = NULL;
 
     for (i = 0; i < ARRAY_SIZE(dirs); i++) {
+#ifdef _WIN32
+        fname = g_strdup_printf("%s\\%s%s",
+                dirs[i], module_name, HOST_DSOSUF);
+#else
         fname = g_strdup_printf("%s/%s%s",
                 dirs[i], module_name, HOST_DSOSUF);
+#endif
         ret = module_load_file(fname);
         g_free(fname);
         fname = NULL;
diff --git a/util/path.c b/util/path.c
index 5479f76..6bca091 100644
--- a/util/path.c
+++ b/util/path.c
@@ -174,5 +174,9 @@ const char *path(const char *name)
     if (!base || !name || name[0] != '/')
         return name;
 
+    if (!strcmp(name, "/etc/ld.so.cache")) {
+        return base->pathname;
+    }
+
     return follow_path(base, name) ?: name;
 }
diff --git a/vl.c b/vl.c
index d77dd86..39823b5 100644
--- a/vl.c
+++ b/vl.c
@@ -124,6 +124,10 @@ int main(int argc, char **argv)
 #include "qapi/qmp/qerror.h"
 #include "sysemu/iothread.h"
 
+#ifdef CONFIG_MODULES
+#include "hw/csky/dynsoc.h"
+#endif
+
 #define MAX_VIRTIO_CONSOLES 1
 #define MAX_SCLP_CONSOLES 1
 
@@ -296,6 +300,43 @@ static QemuOptsList qemu_machine_opts = {
     },
 };
 
+static QemuOptsList qemu_cpu_prop_opts = {
+    .name = "cpu-prop",
+    .head = QTAILQ_HEAD_INITIALIZER(qemu_cpu_prop_opts.head),
+    .desc = {
+        {
+            .name = "vdsp",
+            .type = QEMU_OPT_NUMBER,
+            .help = "choose vdsp as 64 or 128",
+        },{
+            .name = "pctrace",
+            .type = QEMU_OPT_NUMBER,
+            .help = "number of pctrace records",
+        },{
+            .name = "elrw",
+            .type = QEMU_OPT_BOOL,
+            .help = "cpu use elrw or not",
+        },{
+            .name = "mem_prot",
+            .type = QEMU_OPT_STRING,
+            .help = "indicate memory protect, mmu/mgu/no",
+        },{
+            .name = "mmu_default",
+            .type = QEMU_OPT_BOOL,
+            .help = "MMU on or not before load kernel",
+        },{
+            .name = "tb_trace",
+            .type = QEMU_OPT_BOOL,
+            .help = "beginning of translation block's PC",
+        },{
+            .name = "unaligned_access",
+            .type = QEMU_OPT_BOOL,
+            .help = "cpu support unaligned data access",
+        },
+        { /* end of list */ }
+    },
+};
+
 static QemuOptsList qemu_boot_opts = {
     .name = "boot-opts",
     .implied_opt_name = "order",
@@ -3059,6 +3100,7 @@ int main(int argc, char **argv, char **envp)
     qemu_add_opts(&qemu_trace_opts);
     qemu_add_opts(&qemu_option_rom_opts);
     qemu_add_opts(&qemu_machine_opts);
+    qemu_add_opts(&qemu_cpu_prop_opts);
     qemu_add_opts(&qemu_mem_opts);
     qemu_add_opts(&qemu_smp_opts);
     qemu_add_opts(&qemu_boot_opts);
@@ -3154,6 +3196,21 @@ int main(int argc, char **argv, char **envp)
                 /* hw initialization will check this */
                 cpu_model = optarg;
                 break;
+            case QEMU_OPTION_cpu_prop:
+                opts = qemu_opts_parse_noisily(qemu_find_opts("cpu-prop"),
+                                               optarg, false);
+                if (!opts) {
+                    exit(1);
+                }
+                break;
+            case QEMU_OPTION_soc:
+#ifdef CONFIG_MODULES
+                dynsoc_load_modules();
+#else
+                error_report("dynsoc load support is disabled");
+                exit(1);
+#endif
+                break;
             case QEMU_OPTION_hda:
                 {
                     char buf[256];
